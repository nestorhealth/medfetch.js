import { RunInDatabase } from "./RunInDatabase";
import { Cards, Callout } from "nextra/components";

# Introduction

Welcome to the medfetch.js docs!

## What is Medfetch.js?
Medfetch.js is a JavaScript-based toolchain library for implementing the [SQL-on-FHIR v2]() specs. This means
it facilitates the *input* of [FHIR JSON]() data into your process(es) of interest so they can *output* SQL like tables.

```mermaid
flowchart LR
    subgraph MEDFETCH [Medfetch.js]
        direction LR
        A[FHIR JSON Fetcher] --> B[JSON Flattener<sup>1</sup>] --> C[Database]
    end
```
<Callout type="info">
    <sup>1</sup> Thanks to the JSON storage capabilities of modern SQL databases, Medfetch.js doesn't strictly *need* to
    output a scalar value for each column. You *could* dump entire [FHIR Resources]() or heavily nested child
    fields onto TEXT like columns with Medfetch.js, for example. In practice, however, the goal is
    to transform the JSON into scalar columns — or at the very least, to unnest and/or prune significant parts of the JSON tree.
</Callout>

## How does it work?
This library provides **you** the means to build and interact with this pipeline -- a so-called [View Runner](),
as found in the SQL on FHIR specifications. The term View Runner is the canonical label used in the spec, so
you'll see it referenced throughout the docs.

It's important to keep in mind that the View Runner is abstract. Where
this JSON 2 SQL pipeline fits into your system -- and how exactly it runs -- depends on 
architecture-specific factors and answers to questions such as:

1. ***Who*** is responsible for making the FHIR API requests for the JSONs?
2. ***Who*** is responsible for flattening / tabularizing that data?
3. ***How*** should said data be flattened / tabularized?
4. ***Where*** do these tables go ultimately?

This isn't an exhaustive list of architectural factors by any means, but it provides
a good overview of what factors should go into your pipeline design. 
Medfetch.js was built to support a wide range of these pipelines while staying practical — it’s not 
a single solution, but a toolchain for implementing a View Runner that fits your system.

## In Database vs In Memory runners
The [SQL on FHIR]() specs outline two general variants of a View Runner, an 
In Database Runner and an In Memory Runner. Medfetch.js provides you the tools
to implement both. No matter what type of runner you decide on, you will most likely
end up invoking the main JSON flattener function [`sof`](), whether that be indirectly
or directly. Here is a simplified overview of where Medfetch.js would be invoked from
based on which type of View Runner you decide on.

### Database Runner
A Database runner runs directly on top of an SQL database to perform the row projections.

```mermaid
flowchart LR
    subgraph MEDFETCH [Medfetch.js]
        direction LR
        A[FHIR JSON Fetcher] --> B[Medfetch.js Flattener] --> C[Database]
    end
    Z[FHIR API] --> A
```
Medfetch.js will hook into your database of choice<sup>2</sup> to provide an HTTP fetch
mechanism to it. After pulling, it inserts the data into a table, optionally using
any user provided FHIRPath transformations to run the projection prior to inserting, if 
such a mapping was provided.

In either case, you can now use your databases's native JSON capabilities to further transform the data.

Here's an example of how Medfetch.js can be used from a Web Assembly SQLite database
(this one will run on the actual [binary]()!).

<RunInDatabase>
```sql
SELECT 
    json ->> 'id' AS id,
    json ->> 'gender' AS gender,
    json -> 'given' ->> 0 AS first_name,
    json -> 'family' ->> 0 AS last_name,
    json ->> 'birthDate' AS birth_date,
    json -> 'city' ->> 0 AS city,
    json -> 'state' ->> 0 AS state
FROM medfetch('Patient', json_array(
    'id',
    'gender',
    'name.given.first()',
    'name.family.first()',
    'birthDate',
    'address.city.last()',
    'address.state.last()'
))
LIMIT 5;
```
</RunInDatabase>


### Memory Runner
An In Memory runner means your flattening process occurs on a process *separate* from your database.

```mermaid
flowchart LR
    subgraph MEDFETCH [Medfetch.js]
        direction LR
        A[FHIR JSON Fetcher] --> B[Medfetch.js Flattener]
    end
    Z[FHIR API] --> A
    B --> C[Database]
```
This involves less abstractions, since the transformations are done completely in JavaScript.
Here's an example that performs the exact same query as above, but in JS alone. Every
in-memory mapping relies on the [ViewDefinition]() struct, so we would first need to make one:

```ts
// view-definitions.ts
import { viewDefinition, column, columnPath } from "medfetch";

// to make a View Definition, use the viewDefinition() helper
export const patientsBasicView = viewDefinition({
    resource: "Patient",
    status: "active",
    name: "patients_basic",
    select: [
        column({
            column: [
                columnPath({
                    name: "id",
                    path: "getResourceKey()",
                    collection: false
                }),
                columnPath({
                    name: "gender",
                    path: "gender",
                    collection: false
                }),
                columnPath({
                    name: "first_name",
                    path: "name.given.first()",
                    collection: false
                }),
                columnPath({
                    name: "last_name",
                    path: "name.family.first()",
                    collection: false
                }),
                columnPath({
                    name: "city",
                    path: "address.city.last()",
                    collection: false
                }),
                columnPath({
                    name: "state",
                    path: "address.state.last()",
                    collection: false
                }),
            ]
        })
    ]
});
```

Then you invoke the flattener like so:
```ts
// main.ts
import { patientsBasicView } from "./view-definitions.js";
import { sof, pagen } from "medfetch";
import { ow } from "sqliteow";

// Fetch and flatten
const patients = await pagen("https://r4.smarthealthit.org", "Patient");
const rows = sof(patientsBasicView, patients);

/* Persistence steps. Optional, but this has the
 * same effect as a CREATE TABLE AS preprended to the
 * in-database example above */

// 1. Get Database handler
const handle = ow();

// 2. Create table using column names
const columnNames = patientsBasicView.select[0].column.map(col => col.name);
const createTableSQL = `
  CREATE TABLE IF NOT EXISTS patients (
    ${columnNames.map(name => `${name} TEXT`).join(", ")}
  );
`;
await handle("exec", {
    sql: createTableSQL
});

// 3. Prepare insert statement
const placeholders = columnNames.map(() => "?").join(", ");
const insertSQL = `INSERT INTO patients (${columnNames.join(", ")}) VALUES (${placeholders})`;
const insert = handle()

// 4. Insert each row
const insertMany = db.transaction((rows) => {
  for (const row of rows) {
    insert.run(columnNames.map(col => row[col] ?? null));
  }
});

insertMany(rows);

console.log(`Inserted ${rows.length} patient rows into patients.db`);
```

### Choosing
As you can see, the In Memory approach is much more involved in terms of usage, a classic case of
a double-edged sword. Since you have greater control over the JSON transformations before inserting,
you can `fhirpath` away at the data to your heart's content. At the same time, because you have greater control,
you are responsible for formatting the data to be inserted into any downstream database.

Which type is best depends, again, on your use case (I'm sorry!). Still, the following table
should hopefully give you a better idea on which option you would want to use.

| Feature / Concern           | In-Database Runner                          | In-Memory Runner                              |
|----------------------------|---------------------------------------------|-----------------------------------------------|
| **Performance**            | ✅ Typically faster due to reduced I/O, as you write the JSON data directly within the database. | ⚠️ Usually slower  *overall* due to additional I/O... but you get V8’s aggressive optimizations for the tree/object manipulation itself. |
| **Ease of Setup**          | ❌ More involved setup (e.g. compiling SQLite with WASM + extension). | ✅ Simple to get started — just import and call from JS. |
| **Ease of Use**            | ✅ Pure SQL — No FHIRPath knowledge required. | ❌ Requires familiarity with [FHIRPath]() and [ViewDefinition](), **along** with familiarity of SQL. |
| **Transformation Control** |⚠️  SQL for data transformations + a limited [`sof`]() port on the database. | ✅ Best control over transformations since you're directly calling the projector [`sof`]() function. This beats the in-database runner solely because of this. |
| **Integration Complexity** | ✅ Offloads data fetching to database: you inherently get one less process to worry about (in terms of data fetching) | ⚠️ You are in charge of setting up both the data fetches and the insertion of that data into the Database |

It's worth noting that while I can't definitively say the in-memory runner is slower than the in-database one, my best guess is 
that any performance gain from V8's aggressive JSON traversal optimizations is likely outweighed by the I/O overhead involved in 
inserting that data into a separate database — especially when that database lives on a different machine (as is common with PostgreSQL or hosted solutions).

For most real-world pipelines, the simpler option is often to run Medfetch.js directly inside the database. Since the library supports the 
full ViewDefinition transformation set in SQL, what the in-memory runner provides in practice is more control over the transformation process <sup>3</sup>.

<Callout type="info"> 
    <sup>3</sup> 
    Even if your pipeline involves heavy CPU-bound computations, that doesn't mean you need to use the in-memory runner. It’s often simpler (and faster) 
    to run Medfetch in-database, export the results, and hand off to Python (e.g. NumPy, pandas) for numeric processing (you could then write back to 
    the database, or write to a new one). V8 is fast at traversing JSON — you’ll absolutely benefit from that in the tree traversals.
    But if you're doing serious number crunching, the cost of using JS for computations will likely cancel that out. 
    Libraries like [NumPy]() are built for this kind of work, with raw CPU-level optimizations that JavaScript can’t match.
</Callout>

At the end of the day, the best way to know which runner is right for you is to try it out.
While Medfetch.js was designed to be as generic and portable as possible, certain pipeline setups — particularly SQL engines — 
may feel awkward to integrate with. You can explore the list of currently supported SQL environments to see where Medfetch fits best [here]().

## Why SQL On FHIR?
JSONs are great. You can compact rich data into (relatively) small data payloads
without needing to worry about a fixed schema. So it makes sense to use something like JSONs as the 
primary data format for data transfer for [clinical data exchange](https://build.fhir.org/exchange-module.html).
Combine JSON payloads with a tree-based navigation language like [FHIRPath](https://build.fhir.org/fhirpath.html)
and you have an incredibly powerful way to extract and manipulate FHIR JSONs!

Tables are also great. Rows and columns have been battle tested for centuries after all,
even before computers were around. Combine them with some relational algebra and you get SQL, 
which *excels* at representing relational data. And if there's any type of data that is relational, 
clinical data might just be the poster child for that.

Oversimplifying the 2 data formats:
> JSONs speak **across** systems. Tables think **within** them.

JSON has proven to be a strong web exchange module, and we don't expect them to go anywhere
anytime soon. And given how there are more [SQLite databases](https://sqlite.org/mostdeployed.html)
alone than [stars in the Milky Way](https://imagine.gsfc.nasa.gov/science/objects/milkyway1.html#:~:text=Our%20best%20estimates%20tell%20us,the%20suburbs%20of%20our%20galaxy.), we know SQL *definitely* isn't going anywhere.

Medfetch isn’t here to choose sides. It treats JSON as the ideal data-in, and SQL as the ideal data-out — transforming FHIR payloads into queryable tables, 
without losing what makes either format powerful. 

## Next Steps
Dive into the [quick start](/quick-start) section to get started within in minutes,
or head over to the [installation]() page for a comprehensive setup overview. 

Once you're up and running, feel free to check out the [philosophy](/philosophy) and [core concepts](/core-concepts) pages.
You don't need them to use Medfetch, but if you're curious about the *why* behind the *what*, they'll be well worth your time.
