import { Callout, Steps, Tabs } from 'nextra/components'
 
# sqlite-wasm
Spin up a sql-on-fhir View Runner directly on the browser with Medfetch.js
and [sqlite-wasm]()!

## Installation
[effect]() and [@sqlite.org/sqlite-wasm]() are peer dependencies.

<Tabs items={["pnpm", "npm"]}>
<Tabs.Tab>
```bash copy
pnpm add effect @sqlite.org/sqlite-wasm medfetch
```
</Tabs.Tab>

<Tabs.Tab>
```bash copy
npm install effect @sqlite.org/sqlite-wasm medfetch
```
</Tabs.Tab>
</Tabs>

Then transpile the virtual table extension into your `/public` folder as `/public/sqlite-ext/medfetch.mjs`.

```bash
npx medfetch bundle
```

> This is a very involved setup but I will be actively working on making this process smoother especially
once I get closer to version 1.0.0!

## Usage
If using as a new database:

```ts
// sof.ts
import { medfetch } from "medfetch/sqlite-wasm";

// Can name this whatever of course
export const sql = medfetch("https://your-fhir-server.here");

// Or if you want to open a file in the OPFS VFS with medfetch attached to the database
const sql2 = medfetch("...", {
  filename: "my-db"
});
```

Currently, if you want to mutate a SQLite database prior to
attaching Medfetch onto it, you must use the [`worker1`]()
from the package <sup>1</sup>.

```ts
import { medfetch, worker1 } from "medfetch/sqlite-wasm";


// Create a worker1 thread, or get an existing one
const w1 = worker1();
const { dbId } = await w1("open", {
    vfs: "opfs",
    filename: "my-db"
});

// Can name this whatever of course
export const sql = medfetch("https://your-fhir-server.here", { dbId });
```

<Callout type="info"> 
<sup>1</sup> 
This is meant to be a temporary requirement as I plan to make Medfetch.js compatible
with the base `@sqlite.org/sqlite-wasm` package. It's just that currently, I need
a way to load virtual tables from the main thread dynamically at runtime, which
is what that `worker1()` function handles.
</Callout>

`sql` here is a lazily executed template strings function.
Meaning it won't take effect until you call the `Effect.runPromise` function on it.

For example:

```ts
// queries.ts
import { Effect } from "effect";

const patients_clean = sql<{
  id: string;
  name: HumanName[];
}>`create table patients as 
   select json ->> 'id' as id,
   select json -> 'name' as name
   from medfetch('Patient');`;

// This will execute your query async when called
export const getPatients = async () => patients_clean.pipe(Effect.runPromise);
```

Then when a user does some action, say from React code,
you can wrap the query like you would with any stateful
async query e.g. react-query.

```ts
// some-component.ts
import { getPatients } from "./queries.js";
import { useMutation } from "@tanstack/react-query";

export function ExecuteOnClick() {
  // Just use react query for the love of god!!!
  const { mutate, isPending, data } = useMutation({
    mutationFn: getPatients
  });
  return <Button onClick={() => mutate()}></Button>;
}

```
