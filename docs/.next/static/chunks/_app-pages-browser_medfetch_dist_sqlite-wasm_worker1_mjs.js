/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "(app-pages-browser)/../medfetch/dist/Data-CYZAqtZB.mjs":
/*!******************************************!*\
  !*** ../medfetch/dist/Data-CYZAqtZB.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ E),\n/* harmony export */   _: () => (/* binding */ g),\n/* harmony export */   a: () => (/* binding */ l),\n/* harmony export */   t: () => (/* binding */ h)\n/* harmony export */ });\n/* harmony import */ var _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Effect-D4rBamoz.mjs */ \"(app-pages-browser)/../medfetch/dist/Effect-D4rBamoz.mjs\");\nvar o = Object.defineProperty;\nvar u = (t, n, e)=>n in t ? o(t, n, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: e\n    }) : t[n] = e;\nvar s = (t, n, e)=>u(t, typeof n != \"symbol\" ? n + \"\" : n, e);\n\nconst a = _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.s, g = ()=>(t)=>t === void 0 ? Object.create(_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.S) : a(t), l = (t)=>(n)=>{\n        const e = n === void 0 ? Object.create(_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.S) : a(n);\n        return e._tag = t, e;\n    }, h = ()=>new Proxy({}, {\n        get (t, n, e) {\n            return n === \"$is\" ? _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.i : n === \"$match\" ? m : l(n);\n        }\n    });\nfunction m() {\n    if (arguments.length === 1) {\n        const e = arguments[0];\n        return function(r) {\n            return e[r._tag](r);\n        };\n    }\n    const t = arguments[0];\n    return arguments[1][t._tag](t);\n}\nconst p = /* @__PURE__ */ function() {\n    const t = /* @__PURE__ */ Symbol.for(\"effect/Data/Error/plainArgs\");\n    return class extends _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.Y {\n        toJSON() {\n            return {\n                ...this[t],\n                ...this\n            };\n        }\n        constructor(e){\n            super(e == null ? void 0 : e.message, e != null && e.cause ? {\n                cause: e.cause\n            } : void 0), e && (Object.assign(this, e), Object.defineProperty(this, t, {\n                value: e,\n                enumerable: !1\n            }));\n        }\n    };\n}(), E = (t)=>{\n    class n extends p {\n        constructor(){\n            super(...arguments);\n            s(this, \"_tag\", t);\n        }\n    }\n    return n.prototype.name = t, n;\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9tZWRmZXRjaC9kaXN0L0RhdGEtQ1laQXF0WkIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsSUFBSUEsSUFBSUMsT0FBT0MsY0FBYztBQUM3QixJQUFJQyxJQUFJLENBQUNDLEdBQUdDLEdBQUdDLElBQU1ELEtBQUtELElBQUlKLEVBQUVJLEdBQUdDLEdBQUc7UUFBRUUsWUFBWSxDQUFDO1FBQUdDLGNBQWMsQ0FBQztRQUFHQyxVQUFVLENBQUM7UUFBR0MsT0FBT0o7SUFBRSxLQUFLRixDQUFDLENBQUNDLEVBQUUsR0FBR0M7QUFDN0csSUFBSUssSUFBSSxDQUFDUCxHQUFHQyxHQUFHQyxJQUFNSCxFQUFFQyxHQUFHLE9BQU9DLEtBQUssV0FBV0EsSUFBSSxLQUFLQSxHQUFHQztBQUNVO0FBQ3ZFLE1BQU1ZLElBQUlKLG1EQUFDQSxFQUFFSyxJQUFJLElBQU0sQ0FBQ2YsSUFBTUEsTUFBTSxLQUFLLElBQUlILE9BQU9tQixNQUFNLENBQUNKLG1EQUFDQSxJQUFJRSxFQUFFZCxJQUFJaUIsSUFBSSxDQUFDakIsSUFBTSxDQUFDQztRQUNoRixNQUFNQyxJQUFJRCxNQUFNLEtBQUssSUFBSUosT0FBT21CLE1BQU0sQ0FBQ0osbURBQUNBLElBQUlFLEVBQUViO1FBQzlDLE9BQU9DLEVBQUVnQixJQUFJLEdBQUdsQixHQUFHRTtJQUNyQixHQUFHaUIsSUFBSSxJQUFNLElBQUlDLE1BQU0sQ0FBQyxHQUFHO1FBQ3pCQyxLQUFJckIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7WUFDVCxPQUFPRCxNQUFNLFFBQVFZLG1EQUFDQSxHQUFHWixNQUFNLFdBQVdxQixJQUFJTCxFQUFFaEI7UUFDbEQ7SUFDRjtBQUNBLFNBQVNxQjtJQUNQLElBQUlDLFVBQVVDLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE1BQU10QixJQUFJcUIsU0FBUyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxTQUFTRSxDQUFDO1lBQ2YsT0FBT3ZCLENBQUMsQ0FBQ3VCLEVBQUVQLElBQUksQ0FBQyxDQUFDTztRQUNuQjtJQUNGO0lBQ0EsTUFBTXpCLElBQUl1QixTQUFTLENBQUMsRUFBRTtJQUN0QixPQUFPQSxTQUFTLENBQUMsRUFBRSxDQUFDdkIsRUFBRWtCLElBQUksQ0FBQyxDQUFDbEI7QUFDOUI7QUFDQSxNQUFNMEIsSUFBSSxhQUFhLEdBQUc7SUFDeEIsTUFBTTFCLElBQUksYUFBYSxHQUFHMkIsT0FBT0MsR0FBRyxDQUFDO0lBQ3JDLE9BQU8sY0FBY25CLG1EQUFDQTtRQVNwQm9CLFNBQVM7WUFDUCxPQUFPO2dCQUNMLEdBQUcsSUFBSSxDQUFDN0IsRUFBRTtnQkFDVixHQUFHLElBQUk7WUFDVDtRQUNGO1FBYkE4QixZQUFZNUIsQ0FBQyxDQUFFO1lBQ2IsS0FBSyxDQUFDQSxLQUFLLE9BQU8sS0FBSyxJQUFJQSxFQUFFNkIsT0FBTyxFQUFFN0IsS0FBSyxRQUFRQSxFQUFFOEIsS0FBSyxHQUFHO2dCQUMzREEsT0FBTzlCLEVBQUU4QixLQUFLO1lBQ2hCLElBQUksS0FBSyxJQUFJOUIsS0FBTUwsQ0FBQUEsT0FBT29DLE1BQU0sQ0FBQyxJQUFJLEVBQUUvQixJQUFJTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFRSxHQUFHO2dCQUN4RU0sT0FBT0o7Z0JBQ1BDLFlBQVksQ0FBQztZQUNmLEVBQUM7UUFDSDtJQU9GO0FBQ0YsS0FBSytCLElBQUksQ0FBQ2xDO0lBQ1IsTUFBTUMsVUFBVXlCO1FBQ2RJLGFBQWM7WUFDWixLQUFLLElBQUlQO1lBQ1RoQixFQUFFLElBQUksRUFBRSxRQUFRUDtRQUNsQjtJQUNGO0lBQ0EsT0FBT0MsRUFBRWtDLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHcEMsR0FBR0M7QUFDL0I7QUFNRSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9tZWRmZXRjaC9kaXN0L0RhdGEtQ1laQXF0WkIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIHUgPSAodCwgbiwgZSkgPT4gbiBpbiB0ID8gbyh0LCBuLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogdFtuXSA9IGU7XG52YXIgcyA9ICh0LCBuLCBlKSA9PiB1KHQsIHR5cGVvZiBuICE9IFwic3ltYm9sXCIgPyBuICsgXCJcIiA6IG4sIGUpO1xuaW1wb3J0IHsgWSBhcyBpLCBzIGFzIGYsIFMgYXMgYywgaSBhcyBkIH0gZnJvbSBcIi4vRWZmZWN0LUQ0ckJhbW96Lm1qc1wiO1xuY29uc3QgYSA9IGYsIGcgPSAoKSA9PiAodCkgPT4gdCA9PT0gdm9pZCAwID8gT2JqZWN0LmNyZWF0ZShjKSA6IGEodCksIGwgPSAodCkgPT4gKG4pID0+IHtcbiAgY29uc3QgZSA9IG4gPT09IHZvaWQgMCA/IE9iamVjdC5jcmVhdGUoYykgOiBhKG4pO1xuICByZXR1cm4gZS5fdGFnID0gdCwgZTtcbn0sIGggPSAoKSA9PiBuZXcgUHJveHkoe30sIHtcbiAgZ2V0KHQsIG4sIGUpIHtcbiAgICByZXR1cm4gbiA9PT0gXCIkaXNcIiA/IGQgOiBuID09PSBcIiRtYXRjaFwiID8gbSA6IGwobik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gbSgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBlID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gZVtyLl90YWddKHIpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgdCA9IGFyZ3VtZW50c1swXTtcbiAgcmV0dXJuIGFyZ3VtZW50c1sxXVt0Ll90YWddKHQpO1xufVxuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0RhdGEvRXJyb3IvcGxhaW5BcmdzXCIpO1xuICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBpIHtcbiAgICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgICBzdXBlcihlID09IG51bGwgPyB2b2lkIDAgOiBlLm1lc3NhZ2UsIGUgIT0gbnVsbCAmJiBlLmNhdXNlID8ge1xuICAgICAgICBjYXVzZTogZS5jYXVzZVxuICAgICAgfSA6IHZvaWQgMCksIGUgJiYgKE9iamVjdC5hc3NpZ24odGhpcywgZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCB0LCB7XG4gICAgICAgIHZhbHVlOiBlLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMVxuICAgICAgfSkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzW3RdLFxuICAgICAgICAuLi50aGlzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0oKSwgRSA9ICh0KSA9PiB7XG4gIGNsYXNzIG4gZXh0ZW5kcyBwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICBzKHRoaXMsIFwiX3RhZ1wiLCB0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4ucHJvdG90eXBlLm5hbWUgPSB0LCBuO1xufTtcbmV4cG9ydCB7XG4gIEUgYXMgVCxcbiAgZyBhcyBfLFxuICBsIGFzIGEsXG4gIGggYXMgdFxufTtcbiJdLCJuYW1lcyI6WyJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ1IiwidCIsIm4iLCJlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJzIiwiWSIsImkiLCJmIiwiUyIsImMiLCJkIiwiYSIsImciLCJjcmVhdGUiLCJsIiwiX3RhZyIsImgiLCJQcm94eSIsImdldCIsIm0iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwicCIsIlN5bWJvbCIsImZvciIsInRvSlNPTiIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNhdXNlIiwiYXNzaWduIiwiRSIsInByb3RvdHlwZSIsIm5hbWUiLCJUIiwiXyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../medfetch/dist/Data-CYZAqtZB.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../medfetch/dist/Effect-D4rBamoz.mjs":
/*!********************************************!*\
  !*** ../medfetch/dist/Effect-D4rBamoz.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ ME),\n/* harmony export */   A: () => (/* binding */ kc),\n/* harmony export */   B: () => (/* binding */ W$),\n/* harmony export */   C: () => (/* binding */ J$),\n/* harmony export */   D: () => (/* binding */ Bd),\n/* harmony export */   E: () => (/* binding */ tl),\n/* harmony export */   F: () => (/* binding */ ye),\n/* harmony export */   G: () => (/* binding */ de),\n/* harmony export */   H: () => (/* binding */ uE),\n/* harmony export */   I: () => (/* binding */ I),\n/* harmony export */   J: () => (/* binding */ v),\n/* harmony export */   K: () => (/* binding */ tt),\n/* harmony export */   L: () => (/* binding */ bl),\n/* harmony export */   M: () => (/* binding */ fE),\n/* harmony export */   N: () => (/* binding */ C),\n/* harmony export */   O: () => (/* binding */ Si),\n/* harmony export */   P: () => (/* binding */ Zg),\n/* harmony export */   Q: () => (/* binding */ Nr),\n/* harmony export */   R: () => (/* binding */ Wr),\n/* harmony export */   S: () => (/* binding */ Os),\n/* harmony export */   T: () => (/* binding */ SE),\n/* harmony export */   U: () => (/* binding */ _E),\n/* harmony export */   V: () => (/* binding */ pE),\n/* harmony export */   W: () => (/* binding */ $g),\n/* harmony export */   X: () => (/* binding */ xn),\n/* harmony export */   Y: () => (/* binding */ Hf),\n/* harmony export */   Z: () => (/* binding */ nm),\n/* harmony export */   _: () => (/* binding */ TE),\n/* harmony export */   a: () => (/* binding */ KI),\n/* harmony export */   a$: () => (/* binding */ Ab),\n/* harmony export */   a0: () => (/* binding */ Fn),\n/* harmony export */   a1: () => (/* binding */ to),\n/* harmony export */   a2: () => (/* binding */ NE),\n/* harmony export */   a3: () => (/* binding */ j),\n/* harmony export */   a4: () => (/* binding */ A),\n/* harmony export */   a5: () => (/* binding */ Nn),\n/* harmony export */   a6: () => (/* binding */ Ne),\n/* harmony export */   a7: () => (/* binding */ dc),\n/* harmony export */   a8: () => (/* binding */ CE),\n/* harmony export */   a9: () => (/* binding */ ha),\n/* harmony export */   aA: () => (/* binding */ zI),\n/* harmony export */   aB: () => (/* binding */ Tk),\n/* harmony export */   aC: () => (/* binding */ kg),\n/* harmony export */   aD: () => (/* binding */ tI),\n/* harmony export */   aE: () => (/* binding */ VE),\n/* harmony export */   aF: () => (/* binding */ Dg),\n/* harmony export */   aG: () => (/* binding */ sE),\n/* harmony export */   aH: () => (/* binding */ gI),\n/* harmony export */   aI: () => (/* binding */ dE),\n/* harmony export */   aJ: () => (/* binding */ zE),\n/* harmony export */   aK: () => (/* binding */ rE),\n/* harmony export */   aL: () => (/* binding */ dI),\n/* harmony export */   aM: () => (/* binding */ aE),\n/* harmony export */   aN: () => (/* binding */ tE),\n/* harmony export */   aO: () => (/* binding */ Yg),\n/* harmony export */   aP: () => (/* binding */ Z$),\n/* harmony export */   aQ: () => (/* binding */ Ss),\n/* harmony export */   aR: () => (/* binding */ Q$),\n/* harmony export */   aS: () => (/* binding */ H$),\n/* harmony export */   aT: () => (/* binding */ gE),\n/* harmony export */   aU: () => (/* binding */ Y$),\n/* harmony export */   aV: () => (/* binding */ G$),\n/* harmony export */   aW: () => (/* binding */ mE),\n/* harmony export */   aX: () => (/* binding */ oE),\n/* harmony export */   aY: () => (/* binding */ W),\n/* harmony export */   aZ: () => (/* binding */ Sl),\n/* harmony export */   a_: () => (/* binding */ bE),\n/* harmony export */   aa: () => (/* binding */ FE),\n/* harmony export */   ab: () => (/* binding */ ar),\n/* harmony export */   ac: () => (/* binding */ Bn),\n/* harmony export */   ad: () => (/* binding */ Cy),\n/* harmony export */   ae: () => (/* binding */ My),\n/* harmony export */   af: () => (/* binding */ Oe),\n/* harmony export */   ag: () => (/* binding */ $y),\n/* harmony export */   ah: () => (/* binding */ Iy),\n/* harmony export */   ai: () => (/* binding */ Te),\n/* harmony export */   aj: () => (/* binding */ RE),\n/* harmony export */   ak: () => (/* binding */ wg),\n/* harmony export */   al: () => (/* binding */ U),\n/* harmony export */   am: () => (/* binding */ iE),\n/* harmony export */   an: () => (/* binding */ cE),\n/* harmony export */   ao: () => (/* binding */ Qa),\n/* harmony export */   ap: () => (/* binding */ it),\n/* harmony export */   aq: () => (/* binding */ Xu),\n/* harmony export */   ar: () => (/* binding */ Pt),\n/* harmony export */   as: () => (/* binding */ ZE),\n/* harmony export */   at: () => (/* binding */ eE),\n/* harmony export */   au: () => (/* binding */ at),\n/* harmony export */   av: () => (/* binding */ RI),\n/* harmony export */   aw: () => (/* binding */ $I),\n/* harmony export */   ax: () => (/* binding */ eI),\n/* harmony export */   ay: () => (/* binding */ yE),\n/* harmony export */   az: () => (/* binding */ le),\n/* harmony export */   b: () => (/* binding */ YE),\n/* harmony export */   b$: () => (/* binding */ JI),\n/* harmony export */   b0: () => (/* binding */ PE),\n/* harmony export */   b1: () => (/* binding */ Lb),\n/* harmony export */   b2: () => (/* binding */ ro),\n/* harmony export */   b3: () => (/* binding */ jb),\n/* harmony export */   b4: () => (/* binding */ V),\n/* harmony export */   b5: () => (/* binding */ Q),\n/* harmony export */   b6: () => (/* binding */ be),\n/* harmony export */   b7: () => (/* binding */ Ae),\n/* harmony export */   b8: () => (/* binding */ yt),\n/* harmony export */   b9: () => (/* binding */ Jc),\n/* harmony export */   bA: () => (/* binding */ z),\n/* harmony export */   bB: () => (/* binding */ Bt),\n/* harmony export */   bC: () => (/* binding */ Hg),\n/* harmony export */   bD: () => (/* binding */ Tm),\n/* harmony export */   bE: () => (/* binding */ Yf),\n/* harmony export */   bF: () => (/* binding */ Df),\n/* harmony export */   bG: () => (/* binding */ Pl),\n/* harmony export */   bH: () => (/* binding */ Qf),\n/* harmony export */   bI: () => (/* binding */ vE),\n/* harmony export */   bJ: () => (/* binding */ ve),\n/* harmony export */   bK: () => (/* binding */ Mm),\n/* harmony export */   bL: () => (/* binding */ K),\n/* harmony export */   bM: () => (/* binding */ Wi),\n/* harmony export */   bN: () => (/* binding */ rI),\n/* harmony export */   bO: () => (/* binding */ GI),\n/* harmony export */   bP: () => (/* binding */ EI),\n/* harmony export */   bQ: () => (/* binding */ uI),\n/* harmony export */   bR: () => (/* binding */ BE),\n/* harmony export */   bS: () => (/* binding */ wO),\n/* harmony export */   bT: () => (/* binding */ Gc),\n/* harmony export */   bU: () => (/* binding */ pI),\n/* harmony export */   bV: () => (/* binding */ vI),\n/* harmony export */   bW: () => (/* binding */ HI),\n/* harmony export */   bX: () => (/* binding */ Zl),\n/* harmony export */   bY: () => (/* binding */ EE),\n/* harmony export */   bZ: () => (/* binding */ XE),\n/* harmony export */   b_: () => (/* binding */ II),\n/* harmony export */   ba: () => (/* binding */ mt),\n/* harmony export */   bb: () => (/* binding */ $a),\n/* harmony export */   bc: () => (/* binding */ y0),\n/* harmony export */   bd: () => (/* binding */ xE),\n/* harmony export */   be: () => (/* binding */ jE),\n/* harmony export */   bf: () => (/* binding */ es),\n/* harmony export */   bg: () => (/* binding */ zf),\n/* harmony export */   bh: () => (/* binding */ fs),\n/* harmony export */   bi: () => (/* binding */ m),\n/* harmony export */   bj: () => (/* binding */ y),\n/* harmony export */   bk: () => (/* binding */ T),\n/* harmony export */   bl: () => (/* binding */ Ps),\n/* harmony export */   bm: () => (/* binding */ ao),\n/* harmony export */   bn: () => (/* binding */ N),\n/* harmony export */   bo: () => (/* binding */ Zr),\n/* harmony export */   bp: () => (/* binding */ Qy),\n/* harmony export */   bq: () => (/* binding */ Ze),\n/* harmony export */   br: () => (/* binding */ Ks),\n/* harmony export */   bs: () => (/* binding */ L),\n/* harmony export */   bt: () => (/* binding */ xs),\n/* harmony export */   bu: () => (/* binding */ nt),\n/* harmony export */   bv: () => (/* binding */ rb),\n/* harmony export */   bw: () => (/* binding */ oe),\n/* harmony export */   bx: () => (/* binding */ pt),\n/* harmony export */   by: () => (/* binding */ AE),\n/* harmony export */   bz: () => (/* binding */ S),\n/* harmony export */   c: () => (/* binding */ MI),\n/* harmony export */   c0: () => (/* binding */ PI),\n/* harmony export */   c1: () => (/* binding */ LE),\n/* harmony export */   c2: () => (/* binding */ JE),\n/* harmony export */   c3: () => (/* binding */ wI),\n/* harmony export */   c4: () => (/* binding */ DI),\n/* harmony export */   c5: () => (/* binding */ kI),\n/* harmony export */   c6: () => (/* binding */ oI),\n/* harmony export */   c7: () => (/* binding */ _I),\n/* harmony export */   c8: () => (/* binding */ aI),\n/* harmony export */   c9: () => (/* binding */ WI),\n/* harmony export */   cA: () => (/* binding */ wE),\n/* harmony export */   cB: () => (/* binding */ ie),\n/* harmony export */   cC: () => (/* binding */ jI),\n/* harmony export */   cD: () => (/* binding */ OE),\n/* harmony export */   cE: () => (/* binding */ QI),\n/* harmony export */   cF: () => (/* binding */ hE),\n/* harmony export */   cG: () => (/* binding */ lE),\n/* harmony export */   cH: () => (/* binding */ Es),\n/* harmony export */   cI: () => (/* binding */ kE),\n/* harmony export */   ca: () => (/* binding */ HE),\n/* harmony export */   cb: () => (/* binding */ nI),\n/* harmony export */   cc: () => (/* binding */ TI),\n/* harmony export */   cd: () => (/* binding */ SI),\n/* harmony export */   ce: () => (/* binding */ iI),\n/* harmony export */   cf: () => (/* binding */ LI),\n/* harmony export */   cg: () => (/* binding */ bI),\n/* harmony export */   ch: () => (/* binding */ ht),\n/* harmony export */   ci: () => (/* binding */ O),\n/* harmony export */   cj: () => (/* binding */ UE),\n/* harmony export */   ck: () => (/* binding */ qE),\n/* harmony export */   cl: () => (/* binding */ vO),\n/* harmony export */   cm: () => (/* binding */ Sc),\n/* harmony export */   cn: () => (/* binding */ yI),\n/* harmony export */   co: () => (/* binding */ UI),\n/* harmony export */   cp: () => (/* binding */ NI),\n/* harmony export */   cq: () => (/* binding */ FI),\n/* harmony export */   cr: () => (/* binding */ CI),\n/* harmony export */   cs: () => (/* binding */ fI),\n/* harmony export */   ct: () => (/* binding */ xI),\n/* harmony export */   cu: () => (/* binding */ hI),\n/* harmony export */   cv: () => (/* binding */ KE),\n/* harmony export */   cw: () => (/* binding */ qI),\n/* harmony export */   cx: () => (/* binding */ DE),\n/* harmony export */   cy: () => (/* binding */ WE),\n/* harmony export */   cz: () => (/* binding */ mI),\n/* harmony export */   d: () => (/* binding */ l),\n/* harmony export */   e: () => (/* binding */ cI),\n/* harmony export */   f: () => (/* binding */ YI),\n/* harmony export */   g: () => (/* binding */ GE),\n/* harmony export */   h: () => (/* binding */ OI),\n/* harmony export */   i: () => (/* binding */ el),\n/* harmony export */   j: () => (/* binding */ VI),\n/* harmony export */   k: () => (/* binding */ sI),\n/* harmony export */   l: () => (/* binding */ lI),\n/* harmony export */   m: () => (/* binding */ QE),\n/* harmony export */   n: () => (/* binding */ $e),\n/* harmony export */   o: () => (/* binding */ nE),\n/* harmony export */   p: () => (/* binding */ f),\n/* harmony export */   q: () => (/* binding */ P),\n/* harmony export */   r: () => (/* binding */ BI),\n/* harmony export */   s: () => (/* binding */ IE),\n/* harmony export */   t: () => (/* binding */ AI),\n/* harmony export */   u: () => (/* binding */ ae),\n/* harmony export */   v: () => (/* binding */ w),\n/* harmony export */   w: () => (/* binding */ X$),\n/* harmony export */   x: () => (/* binding */ $),\n/* harmony export */   y: () => (/* binding */ Zn),\n/* harmony export */   z: () => (/* binding */ zd)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js\");\nvar Pd = Object.defineProperty;\nvar No = (e)=>{\n    throw TypeError(e);\n};\n_c1 = No;\nvar xd = (e, t, n)=>t in e ? Pd(e, t, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: n\n    }) : e[t] = n;\nvar u = (e, t, n)=>xd(e, typeof t != \"symbol\" ? t + \"\" : t, n), Ao = (e, t, n)=>t.has(e) || No(\"Cannot \" + n);\nvar Po = (e, t, n)=>(Ao(e, t, \"read from private field\"), n ? n.call(e) : t.get(e)), xo = (e, t, n)=>t.has(e) ? No(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(e) : t.set(e, n), jo = (e, t, n, r)=>(Ao(e, t, \"write to private field\"), r ? r.call(e, n) : t.set(e, n), n);\nconst jd = (e)=>typeof e == \"function\", l = function(e, t) {\n    if (typeof e == \"function\") return function() {\n        return e(arguments) ? t.apply(this, arguments) : (n)=>t(n, ...arguments);\n    };\n    switch(e){\n        case 0:\n        case 1:\n            throw new RangeError(\"Invalid arity \".concat(e));\n        case 2:\n            return function(n, r) {\n                return arguments.length >= 2 ? t(n, r) : function(s) {\n                    return t(s, n);\n                };\n            };\n        case 3:\n            return function(n, r, s) {\n                return arguments.length >= 3 ? t(n, r, s) : function(c) {\n                    return t(c, n, r);\n                };\n            };\n        case 4:\n            return function(n, r, s, c) {\n                return arguments.length >= 4 ? t(n, r, s, c) : function(i) {\n                    return t(i, n, r, s);\n                };\n            };\n        case 5:\n            return function(n, r, s, c, i) {\n                return arguments.length >= 5 ? t(n, r, s, c, i) : function(o) {\n                    return t(o, n, r, s, c);\n                };\n            };\n        default:\n            return function() {\n                if (arguments.length >= e) return t.apply(this, arguments);\n                const n = arguments;\n                return function(r) {\n                    return t(r, ...n);\n                };\n            };\n    }\n}, P = (e)=>e, Qn = (e)=>()=>e, Lo = /* @__PURE__ */ Qn(!0), bc = /* @__PURE__ */ Qn(!1), Ld = /* @__PURE__ */ Qn(null), Zu = /* @__PURE__ */ Qn(void 0), Sc = Zu;\nfunction f(e, t, n, r, s, c, i, o, a) {\n    switch(arguments.length){\n        case 1:\n            return e;\n        case 2:\n            return t(e);\n        case 3:\n            return n(t(e));\n        case 4:\n            return r(n(t(e)));\n        case 5:\n            return s(r(n(t(e))));\n        case 6:\n            return c(s(r(n(t(e)))));\n        case 7:\n            return i(c(s(r(n(t(e))))));\n        case 8:\n            return o(i(c(s(r(n(t(e)))))));\n        case 9:\n            return a(o(i(c(s(r(n(t(e))))))));\n        default:\n            {\n                let h = arguments[0];\n                for(let d = 1; d < arguments.length; d++)h = arguments[d](h);\n                return h;\n            }\n    }\n}\nconst ys = (e)=>(t, n)=>t === n || e(t, n), Dd = /* @__PURE__ */ l(2, (e, t)=>ys((n, r)=>e(t(n), t(r)))), qd = (e)=>ys((t, n)=>{\n        if (t.length !== n.length) return !1;\n        for(let r = 0; r < t.length; r++)if (!e(t[r], n[r])) return !1;\n        return !0;\n    });\nlet Ud = \"3.14.12\";\nconst bs = ()=>Ud, Or = \"effect/GlobalValue/globalStoreId/\".concat(bs());\nlet wn;\nconst C = (e, t)=>{\n    var _globalThis_Or;\n    return wn || ((_globalThis_Or = globalThis[Or]) !== null && _globalThis_Or !== void 0 ? _globalThis_Or : globalThis[Or] = /* @__PURE__ */ new Map(), wn = globalThis[Or]), wn.has(e) || wn.set(e, t()), wn.get(e);\n}, zd = (e)=>typeof e == \"string\", kc = (e)=>typeof e == \"number\", W$ = (e)=>typeof e == \"boolean\", Bd = (e)=>typeof e == \"bigint\", J$ = (e)=>typeof e == \"symbol\", Zn = jd, H$ = (e)=>e === void 0, G$ = (e)=>e !== void 0, Y$ = (e)=>e !== null, Q$ = (e)=>!1, Xu = (e)=>typeof e == \"object\" && e !== null, Ss = (e)=>Xu(e) || Zn(e), $ = /* @__PURE__ */ l(2, (e, t)=>Ss(e) && t in e), el = /* @__PURE__ */ l(2, (e, t)=>$(e, \"_tag\") && e._tag === t), Tt = (e)=>e == null, Z$ = (e)=>e != null, X$ = (e)=>e instanceof Date, tl = (e)=>$(e, Symbol.iterator), eE = (e)=>Xu(e) && !Array.isArray(e), nl = (e)=>$(e, \"then\") && Zn(e.then), ks = (e)=>\"BUG: \".concat(e, \" - please report an issue at https://github.com/Effect-TS/effect/issues\");\nlet rl = class sl {\n    /**\n   * @since 2.0.0\n   */ next(t) {\n        return this.called ? {\n            value: t,\n            done: !0\n        } : (this.called = !0, {\n            value: this.self,\n            done: !1\n        });\n    }\n    /**\n   * @since 2.0.0\n   */ return(t) {\n        return {\n            value: t,\n            done: !0\n        };\n    }\n    /**\n   * @since 2.0.0\n   */ throw(t) {\n        throw t;\n    }\n    /**\n   * @since 2.0.0\n   */ [Symbol.iterator]() {\n        return new sl(this.self);\n    }\n    constructor(t){\n        u(this, \"self\");\n        u(this, \"called\", !1);\n        this.self = t;\n    }\n};\nconst Vd = 335903614, Kd = 4150755663, Wd = 1481765933, Jd = 1284865837, Hd = 9007199254740992, Gd = 134217728;\nclass Yd {\n    /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */ getState() {\n        return [\n            this._state[0],\n            this._state[1],\n            this._state[2],\n            this._state[3]\n        ];\n    }\n    /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */ setState(t) {\n        this._state[0] = t[0], this._state[1] = t[1], this._state[2] = t[2], this._state[3] = t[3] | 1;\n    }\n    /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */ integer(t) {\n        return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % t;\n    }\n    /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */ number() {\n        const t = (this._next() & 67108863) * 1, n = (this._next() & 134217727) * 1;\n        return (t * Gd + n) / Hd;\n    }\n    /** @internal */ _next() {\n        const t = this._state[0] >>> 0, n = this._state[1] >>> 0;\n        Qd(this._state, t, n, Wd, Jd), Do(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n        let r = t >>> 18, s = (n >>> 18 | t << 14) >>> 0;\n        r = (r ^ t) >>> 0, s = (s ^ n) >>> 0;\n        const c = (s >>> 27 | r << 5) >>> 0, i = t >>> 27, o = (-i >>> 0 & 31) >>> 0;\n        return (c >>> i | c << o) >>> 0;\n    }\n    constructor(t, n, r, s){\n        u(this, \"_state\");\n        return Tt(n) && Tt(t) ? (n = Math.random() * 4294967295 >>> 0, t = 0) : Tt(n) && (n = t, t = 0), Tt(s) && Tt(r) ? (s = this._state ? this._state[3] : Kd, r = this._state ? this._state[2] : Vd) : Tt(s) && (s = r, r = 0), this._state = new Int32Array([\n            0,\n            0,\n            r >>> 0,\n            ((s || 0) | 1) >>> 0\n        ]), this._next(), Do(this._state, this._state[0], this._state[1], t >>> 0, n >>> 0), this._next(), this;\n    }\n}\nfunction Qd(e, t, n, r, s) {\n    let c = (n >>> 16) * (s & 65535) >>> 0, i = (n & 65535) * (s >>> 16) >>> 0, o = (n & 65535) * (s & 65535) >>> 0, a = (n >>> 16) * (s >>> 16) + ((i >>> 16) + (c >>> 16)) >>> 0;\n    i = i << 16 >>> 0, o = o + i >>> 0, o >>> 0 < i >>> 0 && (a = a + 1 >>> 0), c = c << 16 >>> 0, o = o + c >>> 0, o >>> 0 < c >>> 0 && (a = a + 1 >>> 0), a = a + Math.imul(n, r) >>> 0, a = a + Math.imul(t, s) >>> 0, e[0] = a, e[1] = o;\n}\n_c2 = Qd;\nfunction Do(e, t, n, r, s) {\n    let c = t + r >>> 0;\n    const i = n + s >>> 0;\n    i >>> 0 < n >>> 0 && (c = c + 1 | 0), e[0] = c, e[1] = i;\n}\n_c3 = Do;\nconst vc = /* @__PURE__ */ Symbol.for(\"effect/Utils/YieldWrap\");\nvar Yn;\nclass Xn {\n    /**\n   * @since 3.0.6\n   */ [vc]() {\n        return Po(this, Yn);\n    }\n    constructor(t){\n        /**\n     * @since 3.0.6\n     */ xo(this, Yn);\n        jo(this, Yn, t);\n    }\n}\nYn = new WeakMap();\nfunction Zd(e) {\n    if (typeof e == \"object\" && e !== null && vc in e) return e[vc]();\n    throw new Error(ks(\"yieldWrapGet\"));\n}\n_c4 = Zd;\nconst pe = /* @__PURE__ */ C(\"effect/Utils/isStructuralRegion\", ()=>({\n        enabled: !1,\n        tester: void 0\n    })), Xd = (e)=>{\n    const t = {\n        [e] (n) {\n            return n();\n        }\n    };\n    return function(n) {\n        return t[e](n);\n    };\n}, ee = /* @__PURE__ */ Xd(\"effect_internal_function\"), ic = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Hash/randomHashCache\"), ()=>/* @__PURE__ */ new WeakMap()), F = /* @__PURE__ */ Symbol.for(\"effect/Hash\"), k = (e)=>{\n    if (pe.enabled === !0) return 0;\n    switch(typeof e){\n        case \"number\":\n            return di(e);\n        case \"bigint\":\n            return B(e.toString(10));\n        case \"boolean\":\n            return B(String(e));\n        case \"symbol\":\n            return B(String(e));\n        case \"string\":\n            return B(e);\n        case \"undefined\":\n            return B(\"undefined\");\n        case \"function\":\n        case \"object\":\n            return e === null ? B(\"null\") : e instanceof Date ? k(e.toISOString()) : e instanceof URL ? k(e.href) : eg(e) ? e[F]() : hi(e);\n        default:\n            throw new Error(\"BUG: unhandled typeof \".concat(typeof e, \" - please report an issue at https://github.com/Effect-TS/effect/issues\"));\n    }\n}, hi = (e)=>(ic.has(e) || ic.set(e, di(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))), ic.get(e)), R = (e)=>(t)=>t * 53 ^ e, vs = (e)=>e & 3221225471 | e >>> 1 & 1073741824, eg = (e)=>$(e, F), di = (e)=>{\n    if (e !== e || e === 1 / 0) return 0;\n    let t = e | 0;\n    for(t !== e && (t ^= e * 4294967295); e > 4294967295;)t ^= e /= 4294967295;\n    return vs(t);\n}, B = (e)=>{\n    let t = 5381, n = e.length;\n    for(; n;)t = t * 33 ^ e.charCodeAt(--n);\n    return vs(t);\n}, tg = (e, t)=>{\n    let n = 12289;\n    for(let r = 0; r < t.length; r++)n ^= f(B(t[r]), R(k(e[t[r]])));\n    return vs(n);\n}, cl = (e)=>tg(e, Object.keys(e)), er = (e)=>{\n    let t = 6151;\n    for(let n = 0; n < e.length; n++)t = f(t, R(k(e[n])));\n    return vs(t);\n}, q = function() {\n    if (arguments.length === 1) {\n        const n = arguments[0];\n        return function(r) {\n            return Object.defineProperty(n, F, {\n                value () {\n                    return r;\n                },\n                enumerable: !1\n            }), r;\n        };\n    }\n    const e = arguments[0], t = arguments[1];\n    return Object.defineProperty(e, F, {\n        value () {\n            return t;\n        },\n        enumerable: !1\n    }), t;\n}, E = /* @__PURE__ */ Symbol.for(\"effect/Equal\");\nfunction O() {\n    return arguments.length === 1 ? (e)=>qr(e, arguments[0]) : qr(arguments[0], arguments[1]);\n}\n_c5 = O;\nfunction qr(e, t) {\n    if (e === t) return !0;\n    const n = typeof e;\n    if (n !== typeof t) return !1;\n    if (n === \"object\" || n === \"function\") {\n        if (e !== null && t !== null) {\n            if (Ur(e) && Ur(t)) return k(e) === k(t) && e[E](t) ? !0 : pe.enabled && pe.tester ? pe.tester(e, t) : !1;\n            if (e instanceof Date && t instanceof Date) return e.toISOString() === t.toISOString();\n            if (e instanceof URL && t instanceof URL) return e.href === t.href;\n        }\n        if (pe.enabled) {\n            if (Array.isArray(e) && Array.isArray(t)) return e.length === t.length && e.every((r, s)=>qr(r, t[s]));\n            if (Object.getPrototypeOf(e) === Object.prototype && Object.getPrototypeOf(e) === Object.prototype) {\n                const r = Object.keys(e), s = Object.keys(t);\n                if (r.length === s.length) {\n                    for (const c of r)if (!(c in t && qr(e[c], t[c]))) return pe.tester ? pe.tester(e, t) : !1;\n                    return !0;\n                }\n            }\n            return pe.tester ? pe.tester(e, t) : !1;\n        }\n    }\n    return pe.enabled && pe.tester ? pe.tester(e, t) : !1;\n}\nconst Ur = (e)=>$(e, E), gi = ()=>O, U = /* @__PURE__ */ Symbol.for(\"nodejs.util.inspect.custom\"), V = (e)=>{\n    try {\n        if ($(e, \"toJSON\") && Zn(e.toJSON) && e.toJSON.length === 0) return e.toJSON();\n        if (Array.isArray(e)) return e.map(V);\n    } catch (e) {\n        return {};\n    }\n    return rg(e);\n}, Q = (e)=>JSON.stringify(e, null, 2), Ut = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;\n    if (typeof e == \"string\") return e;\n    try {\n        return typeof e == \"object\" ? il(e, t) : String(e);\n    } catch (e1) {\n        return String(e);\n    }\n}, il = (e, t)=>{\n    let n = [];\n    const r = JSON.stringify(e, (s, c)=>typeof c == \"object\" && c !== null ? n.includes(c) ? void 0 : n.push(c) && (lt.fiberRefs !== void 0 && ol(c) ? c[mi](lt.fiberRefs) : c) : c, t);\n    return n = void 0, r;\n}, mi = /* @__PURE__ */ Symbol.for(\"effect/Inspectable/Redactable\"), ol = (e)=>typeof e == \"object\" && e !== null && mi in e, lt = /* @__PURE__ */ C(\"effect/Inspectable/redactableState\", ()=>({\n        fiberRefs: void 0\n    })), ng = (e, t)=>{\n    const n = lt.fiberRefs;\n    lt.fiberRefs = e;\n    try {\n        return t();\n    } finally{\n        lt.fiberRefs = n;\n    }\n}, rg = (e)=>ol(e) && lt.fiberRefs !== void 0 ? e[mi](lt.fiberRefs) : e, w = (e, t)=>{\n    switch(t.length){\n        case 0:\n            return e;\n        case 1:\n            return t[0](e);\n        case 2:\n            return t[1](t[0](e));\n        case 3:\n            return t[2](t[1](t[0](e)));\n        case 4:\n            return t[3](t[2](t[1](t[0](e))));\n        case 5:\n            return t[4](t[3](t[2](t[1](t[0](e)))));\n        case 6:\n            return t[5](t[4](t[3](t[2](t[1](t[0](e))))));\n        case 7:\n            return t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))));\n        case 8:\n            return t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e))))))));\n        case 9:\n            return t[8](t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))))));\n        default:\n            {\n                let n = e;\n                for(let r = 0, s = t.length; r < s; r++)n = t[r](n);\n                return n;\n            }\n    }\n}, Rn = \"Async\", ws = \"Commit\", te = \"Failure\", Tr = \"OnFailure\", zr = \"OnSuccess\", Br = \"OnSuccessAndFailure\", ne = \"Success\", al = \"Sync\", sg = \"Tag\", un = \"UpdateRuntimeFlags\", Vr = \"While\", Mn = \"Iterator\", ul = \"WithRuntime\", Cr = \"Yield\", pi = \"RevertFlags\", cg = /* @__PURE__ */ Symbol.for(\"effect/Effect\"), ig = /* @__PURE__ */ Symbol.for(\"effect/Stream\"), og = /* @__PURE__ */ Symbol.for(\"effect/Sink\"), ag = /* @__PURE__ */ Symbol.for(\"effect/Channel\"), zt = {\n    /* c8 ignore next */ _R: (e)=>e,\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _A: (e)=>e,\n    _V: /* @__PURE__ */ bs()\n}, ug = {\n    /* c8 ignore next */ _A: (e)=>e,\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _L: (e)=>e,\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _R: (e)=>e\n}, lg = {\n    /* c8 ignore next */ _Env: (e)=>e,\n    /* c8 ignore next */ _InErr: (e)=>e,\n    /* c8 ignore next */ _InElem: (e)=>e,\n    /* c8 ignore next */ _InDone: (e)=>e,\n    /* c8 ignore next */ _OutErr: (e)=>e,\n    /* c8 ignore next */ _OutElem: (e)=>e,\n    /* c8 ignore next */ _OutDone: (e)=>e\n}, tr = {\n    [cg]: zt,\n    [ig]: zt,\n    [og]: ug,\n    [ag]: lg,\n    [E] (e) {\n        return this === e;\n    },\n    [F] () {\n        return q(this, hi(this));\n    },\n    [Symbol.iterator] () {\n        return new rl(new Xn(this));\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, Os = {\n    [F] () {\n        return q(this, cl(this));\n    },\n    [E] (e) {\n        const t = Object.keys(this), n = Object.keys(e);\n        if (t.length !== n.length) return !1;\n        for (const r of t)if (!(r in e && O(this[r], e[r]))) return !1;\n        return !0;\n    }\n}, nr = {\n    ...tr,\n    _op: ws\n}, fg = {\n    ...nr,\n    ...Os\n}, hg = /* @__PURE__ */ function() {\n    function e() {}\n    return e.prototype = nr, e;\n}(), ll = /* @__PURE__ */ Symbol.for(\"effect/Option\"), fl = {\n    ...tr,\n    [ll]: {\n        _A: (e)=>e\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    toString () {\n        return Q(this.toJSON());\n    }\n}, dg = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(fl), {\n    _tag: \"Some\",\n    _op: \"Some\",\n    [E] (e) {\n        return _i(e) && dl(e) && O(this.value, e.value);\n    },\n    [F] () {\n        return q(this, R(k(this._tag))(k(this.value)));\n    },\n    toJSON () {\n        return {\n            _id: \"Option\",\n            _tag: this._tag,\n            value: V(this.value)\n        };\n    }\n}), gg = /* @__PURE__ */ k(\"None\"), mg = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(fl), {\n    _tag: \"None\",\n    _op: \"None\",\n    [E] (e) {\n        return _i(e) && hl(e);\n    },\n    [F] () {\n        return gg;\n    },\n    toJSON () {\n        return {\n            _id: \"Option\",\n            _tag: this._tag\n        };\n    }\n}), _i = (e)=>$(e, ll), hl = (e)=>e._tag === \"None\", dl = (e)=>e._tag === \"Some\", $s = /* @__PURE__ */ Object.create(mg), Pn = (e)=>{\n    const t = Object.create(dg);\n    return t.value = e, t;\n}, gl = /* @__PURE__ */ Symbol.for(\"effect/Either\"), ml = {\n    ...tr,\n    [gl]: {\n        _R: (e)=>e\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    toString () {\n        return Q(this.toJSON());\n    }\n}, pg = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ml), {\n    _tag: \"Right\",\n    _op: \"Right\",\n    [E] (e) {\n        return yi(e) && pl(e) && O(this.right, e.right);\n    },\n    [F] () {\n        return R(k(this._tag))(k(this.right));\n    },\n    toJSON () {\n        return {\n            _id: \"Either\",\n            _tag: this._tag,\n            right: V(this.right)\n        };\n    }\n}), _g = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ml), {\n    _tag: \"Left\",\n    _op: \"Left\",\n    [E] (e) {\n        return yi(e) && bi(e) && O(this.left, e.left);\n    },\n    [F] () {\n        return R(k(this._tag))(k(this.left));\n    },\n    toJSON () {\n        return {\n            _id: \"Either\",\n            _tag: this._tag,\n            left: V(this.left)\n        };\n    }\n}), yi = (e)=>$(e, gl), bi = (e)=>e._tag === \"Left\", pl = (e)=>e._tag === \"Right\", yg = (e)=>{\n    const t = Object.create(_g);\n    return t.left = e, t;\n}, bg = (e)=>{\n    const t = Object.create(pg);\n    return t.right = e, t;\n}, Sg = (e)=>bi(e) ? $s : Pn(e.right), ae = bg, $e = yg, tE = (e)=>{\n    if (Zn(e)) try {\n        return ae(e());\n    } catch (t) {\n        return $e(t);\n    }\n    else try {\n        return ae(e.try());\n    } catch (t) {\n        return $e(e.catch(t));\n    }\n}, nE = yi, at = bi, Pt = pl, rE = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onLeft: t, onRight: n } = param;\n    return at(e) ? $e(t(e.left)) : ae(n(e.right));\n}), sE = /* @__PURE__ */ l(2, (e, t)=>at(e) ? $e(t(e.left)) : ae(e.right)), cE = /* @__PURE__ */ l(2, (e, t)=>Pt(e) ? ae(t(e.right)) : $e(e.left)), kg = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onLeft: t, onRight: n } = param;\n    return at(e) ? t(e.left) : n(e.right);\n}), vg = /* @__PURE__ */ kg({\n    onLeft: P,\n    onRight: P\n}), wg = /* @__PURE__ */ l(2, (e, t)=>{\n    if (Pt(e)) return e.right;\n    throw t(e.left);\n}), iE = /* @__PURE__ */ wg(()=>new Error(\"getOrThrow called on a Left\")), _l = (e)=>e.length > 0, yl = (e)=>(t, n)=>t === n ? 0 : e(t, n), Og = /* @__PURE__ */ yl((e, t)=>e < t ? -1 : 1), $g = /* @__PURE__ */ l(2, (e, t)=>yl((n, r)=>e(t(n), t(r)))), Eg = (e)=>l(2, (t, n)=>e(t, n) === 1), v = ()=>$s, I = Pn, oE = _i, W = hl, ye = dl, tt = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onNone: t, onSome: n } = param;\n    return W(e) ? t() : n(e.value);\n}), aE = Sg, de = /* @__PURE__ */ l(2, (e, t)=>W(e) ? t() : e.value), uE = /* @__PURE__ */ l(2, (e, t)=>W(e) ? t() : e), Ig = /* @__PURE__ */ l(2, (e, t)=>W(e) ? I(t()) : e), Es = (e)=>e == null ? v() : I(e), lE = /* @__PURE__ */ de(Ld), it = /* @__PURE__ */ de(Zu), fE = (e)=>function() {\n        for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){\n            t[_key] = arguments[_key];\n        }\n        try {\n            return I(e(...t));\n        } catch (e) {\n            return v();\n        }\n    }, Fg = /* @__PURE__ */ l(2, (e, t)=>{\n    if (ye(e)) return e.value;\n    throw t();\n}), hE = /* @__PURE__ */ Fg(()=>new Error(\"getOrThrow called on a None\")), Nr = /* @__PURE__ */ l(2, (e, t)=>W(e) ? v() : I(t(e.value))), bl = /* @__PURE__ */ l(2, (e, t)=>W(e) ? v() : t(e.value)), dE = /* @__PURE__ */ l(2, (e, t)=>W(e) ? v() : Es(t(e.value))), Rg = bl, gE = /* @__PURE__ */ l(2, (e, t)=>Rg(e, (n)=>t(n) ? Pn(n) : $s)), mE = (e)=>ys((t, n)=>W(t) ? W(n) : W(n) ? !1 : e(t.value, n.value)), Mg = (e)=>l(2, (t, n)=>W(t) ? !1 : e(t.value, n)), Tg = /* @__PURE__ */ gi(), Cg = /* @__PURE__ */ Mg(Tg), pE = /* @__PURE__ */ l(2, (e, t)=>W(e) ? !1 : t(e.value)), Ng = function() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    return e;\n}, Si = (e)=>new Array(e), Ag = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Math.max(1, Math.floor(e)), r = new Array(n);\n    for(let s = 0; s < n; s++)r[s] = t(s);\n    return r;\n}), z = (e)=>Array.isArray(e) ? e : Array.from(e), Pg = (e)=>Array.isArray(e) ? e : [\n        e\n    ], _E = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onEmpty: t, onNonEmpty: n } = param;\n    return le(e) ? n(ue(e), _t(e)) : t();\n}), Kr = /* @__PURE__ */ l(2, (e, t)=>[\n        t,\n        ...e\n    ]), xg = /* @__PURE__ */ l(2, (e, t)=>[\n        ...e,\n        t\n    ]), Sl = /* @__PURE__ */ l(2, (e, t)=>z(e).concat(z(t))), yE = Array.isArray, jg = (e)=>e.length === 0, Lg = jg, Dg = _l, le = _l, kl = (e, t)=>e < 0 || e >= t.length, qg = (e, t)=>Math.floor(Math.min(Math.max(0, e), t.length)), Ug = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Math.floor(t);\n    return kl(n, e) ? v() : I(e[n]);\n}), vl = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Math.floor(t);\n    if (kl(n, e)) throw new Error(\"Index \".concat(n, \" out of bounds\"));\n    return e[n];\n}), Tn = /* @__PURE__ */ Ug(0), ue = /* @__PURE__ */ vl(0), zg = (e)=>le(e) ? I(wl(e)) : v(), wl = (e)=>e[e.length - 1], _t = (e)=>e.slice(1), Bg = (e, t)=>{\n    let n = 0;\n    for (const r of e){\n        if (!t(r, n)) break;\n        n++;\n    }\n    return n;\n}, Vg = /* @__PURE__ */ l(2, (e, t)=>Hg(e, Bg(e, t))), Kg = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = z(e);\n    return n.slice(qg(t, n), n.length);\n}), qo = (e)=>Array.from(e).reverse(), Wr = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Array.from(e);\n    return n.sort(t), n;\n}), Uo = /* @__PURE__ */ l(2, (e, t)=>Wg(e, t, Ng)), Wg = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = z(e), s = z(t);\n    if (le(r) && le(s)) {\n        const c = [\n            n(ue(r), ue(s))\n        ], i = Math.min(r.length, s.length);\n        for(let o = 1; o < i; o++)c[o] = n(r[o], s[o]);\n        return c;\n    }\n    return [];\n}), Jg = /* @__PURE__ */ gi(), Hg = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Array.from(e), r = Math.floor(t);\n    return le(n) ? r >= 1 ? Gg(n, r) : [\n        [],\n        n\n    ] : [\n        n,\n        []\n    ];\n}), Gg = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Math.max(1, Math.floor(t));\n    return n >= e.length ? [\n        Yg(e),\n        []\n    ] : [\n        Kr(e.slice(1, n), ue(e)),\n        e.slice(n)\n    ];\n}), Yg = (e)=>e.slice(), Qg = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = z(e), s = z(t);\n    return le(r) ? le(s) ? Ol(n)(Sl(r, s)) : r : s;\n}), Ar = /* @__PURE__ */ l(2, (e, t)=>Qg(e, t, Jg)), Bt = ()=>[], ke = (e)=>[\n        e\n    ], ft = /* @__PURE__ */ l(2, (e, t)=>e.map(t)), Zg = /* @__PURE__ */ l(2, (e, t)=>{\n    if (Lg(e)) return [];\n    const n = [];\n    for(let r = 0; r < e.length; r++){\n        const s = t(e[r], r);\n        for(let c = 0; c < s.length; c++)n.push(s[c]);\n    }\n    return n;\n}), Xg = /* @__PURE__ */ Zg(P), bE = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = z(e), r = [];\n    for(let s = 0; s < n.length; s++){\n        const c = t(n[s], s);\n        ye(c) && r.push(c.value);\n    }\n    return r;\n}), em = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = z(e), r = [];\n    for(let s = 0; s < n.length; s++)t(n[s], s) && r.push(n[s]);\n    return r;\n}), ki = /* @__PURE__ */ l(3, (e, t, n)=>z(e).reduce((r, s, c)=>n(r, s, c), t)), zo = (e, t)=>{\n    const n = [];\n    let r = e, s;\n    for(; ye(s = t(r));){\n        const [c, i] = s.value;\n        n.push(c), r = i;\n    }\n    return n;\n}, vi = qd, Ol = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = z(e);\n    if (le(n)) {\n        const r = [\n            ue(n)\n        ], s = _t(n);\n        for (const c of s)r.every((i)=>!t(c, i)) && r.push(c);\n        return r;\n    }\n    return [];\n}), tm = (e)=>Ol(e, gi()), ln = /* @__PURE__ */ l(2, (e, t)=>z(e).join(t)), xn = Og, nm = (e)=>e.replace(/[/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), $l = /* @__PURE__ */ Symbol.for(\"effect/Context/Tag\"), Jr = /* @__PURE__ */ Symbol.for(\"effect/Context/Reference\"), rm = \"effect/STM\", sm = /* @__PURE__ */ Symbol.for(rm), Is = {\n    ...tr,\n    _op: \"Tag\",\n    [sm]: zt,\n    [$l]: {\n        _Service: (e)=>e,\n        _Identifier: (e)=>e\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"Tag\",\n            key: this.key,\n            stack: this.stack\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    of (e) {\n        return e;\n    },\n    context (e) {\n        return Fl(this, e);\n    }\n}, cm = {\n    ...Is,\n    [Jr]: Jr\n}, im = (e)=>{\n    const t = Error.stackTraceLimit;\n    Error.stackTraceLimit = 2;\n    const n = new Error();\n    Error.stackTraceLimit = t;\n    const r = Object.create(Is);\n    return Object.defineProperty(r, \"stack\", {\n        get () {\n            return n.stack;\n        }\n    }), r.key = e, r;\n}, om = (e)=>()=>{\n        const t = Error.stackTraceLimit;\n        Error.stackTraceLimit = 2;\n        const n = new Error();\n        Error.stackTraceLimit = t;\n        function r() {}\n        return Object.setPrototypeOf(r, Is), r.key = e, Object.defineProperty(r, \"stack\", {\n            get () {\n                return n.stack;\n            }\n        }), r;\n    }, am = ()=>(e, t)=>{\n        const n = Error.stackTraceLimit;\n        Error.stackTraceLimit = 2;\n        const r = new Error();\n        Error.stackTraceLimit = n;\n        function s() {}\n        return Object.setPrototypeOf(s, cm), s.key = e, s.defaultValue = t.defaultValue, Object.defineProperty(s, \"stack\", {\n            get () {\n                return r.stack;\n            }\n        }), s;\n    }, El = /* @__PURE__ */ Symbol.for(\"effect/Context\"), um = {\n    [El]: {\n        _Services: (e)=>e\n    },\n    [E] (e) {\n        if (Il(e) && this.unsafeMap.size === e.unsafeMap.size) {\n            for (const t of this.unsafeMap.keys())if (!e.unsafeMap.has(t) || !O(this.unsafeMap.get(t), e.unsafeMap.get(t))) return !1;\n            return !0;\n        }\n        return !1;\n    },\n    [F] () {\n        return q(this, di(this.unsafeMap.size));\n    },\n    pipe () {\n        return w(this, arguments);\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"Context\",\n            services: Array.from(this.unsafeMap).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    }\n}, Vt = (e)=>{\n    const t = Object.create(um);\n    return t.unsafeMap = e, t;\n}, lm = (e)=>{\n    const t = new Error(\"Service not found\".concat(e.key ? \": \".concat(String(e.key)) : \"\"));\n    if (e.stack) {\n        const n = e.stack.split(\"\\n\");\n        if (n.length > 2) {\n            const r = n[2].match(/at (.*)/);\n            r && (t.message = t.message + \" (defined at \".concat(r[1], \")\"));\n        }\n    }\n    if (t.stack) {\n        const n = t.stack.split(\"\\n\");\n        n.splice(1, 3), t.stack = n.join(\"\\n\");\n    }\n    return t;\n}, Il = (e)=>$(e, El), fm = (e)=>$(e, $l), hm = (e)=>$(e, Jr), dm = /* @__PURE__ */ Vt(/* @__PURE__ */ new Map()), gm = ()=>dm, Fl = (e, t)=>Vt(/* @__PURE__ */ new Map([\n        [\n            e.key,\n            t\n        ]\n    ])), mm = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = new Map(e.unsafeMap);\n    return r.set(t.key, n), Vt(r);\n}), oc = /* @__PURE__ */ C(\"effect/Context/defaultValueCache\", ()=>/* @__PURE__ */ new Map()), wi = (e)=>{\n    if (oc.has(e.key)) return oc.get(e.key);\n    const t = e.defaultValue();\n    return oc.set(e.key, t), t;\n}, pm = (e, t)=>e.unsafeMap.has(t.key) ? e.unsafeMap.get(t.key) : wi(t), Rl = /* @__PURE__ */ l(2, (e, t)=>{\n    if (!e.unsafeMap.has(t.key)) {\n        if (Jr in t) return wi(t);\n        throw lm(t);\n    }\n    return e.unsafeMap.get(t.key);\n}), _m = Rl, ym = /* @__PURE__ */ l(2, (e, t)=>e.unsafeMap.has(t.key) ? Pn(e.unsafeMap.get(t.key)) : hm(t) ? Pn(wi(t)) : $s), bm = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new Map(e.unsafeMap);\n    for (const [r, s] of t.unsafeMap)n.set(r, s);\n    return Vt(n);\n}), It = im, Sm = Il, Fs = fm, Oi = gm, rr = Fl, At = mm, Ml = _m, Tl = Rl, sr = ym, fn = bm, SE = om, $i = am, Cl = /* @__PURE__ */ Symbol.for(\"effect/Chunk\");\nfunction km(e, t, n, r, s) {\n    for(let c = t; c < Math.min(e.length, t + s); c++)n[r + c - t] = e[c];\n    return n;\n}\nconst Nl = [], vm = (e)=>ys((t, n)=>t.length === n.length && We(t).every((r, s)=>e(r, ht(n, s)))), wm = /* @__PURE__ */ vm(O), Om = {\n    [Cl]: {\n        _A: (e)=>e\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"Chunk\",\n            values: We(this).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    [E] (e) {\n        return Al(e) && wm(this, e);\n    },\n    [F] () {\n        return q(this, er(We(this)));\n    },\n    [Symbol.iterator] () {\n        switch(this.backing._tag){\n            case \"IArray\":\n                return this.backing.array[Symbol.iterator]();\n            case \"IEmpty\":\n                return Nl[Symbol.iterator]();\n            default:\n                return We(this)[Symbol.iterator]();\n        }\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, G = (e)=>{\n    const t = Object.create(Om);\n    switch(t.backing = e, e._tag){\n        case \"IEmpty\":\n            {\n                t.length = 0, t.depth = 0, t.left = t, t.right = t;\n                break;\n            }\n        case \"IConcat\":\n            {\n                t.length = e.left.length + e.right.length, t.depth = 1 + Math.max(e.left.depth, e.right.depth), t.left = e.left, t.right = e.right;\n                break;\n            }\n        case \"IArray\":\n            {\n                t.length = e.array.length, t.depth = 0, t.left = Me, t.right = Me;\n                break;\n            }\n        case \"ISingleton\":\n            {\n                t.length = 1, t.depth = 0, t.left = Me, t.right = Me;\n                break;\n            }\n        case \"ISlice\":\n            {\n                t.length = e.length, t.depth = e.chunk.depth + 1, t.left = Me, t.right = Me;\n                break;\n            }\n    }\n    return t;\n}, Al = (e)=>$(e, Cl), Me = /* @__PURE__ */ G({\n    _tag: \"IEmpty\"\n}), Ae = ()=>Me, ac = function() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    return Rm(e);\n}, ie = (e)=>G({\n        _tag: \"ISingleton\",\n        a: e\n    }), Pl = (e)=>Al(e) ? e : hn(z(e)), wc = (e, t, n)=>{\n    switch(e.backing._tag){\n        case \"IArray\":\n            {\n                km(e.backing.array, 0, t, n, e.length);\n                break;\n            }\n        case \"IConcat\":\n            {\n                wc(e.left, t, n), wc(e.right, t, n + e.left.length);\n                break;\n            }\n        case \"ISingleton\":\n            {\n                t[n] = e.backing.a;\n                break;\n            }\n        case \"ISlice\":\n            {\n                let r = 0, s = n;\n                for(; r < e.length;)t[s] = ht(e, r), r += 1, s += 1;\n                break;\n            }\n    }\n}, $m = (e)=>We(e).slice(), kE = $m, Em = (e)=>{\n    switch(e.backing._tag){\n        case \"IEmpty\":\n            return Nl;\n        case \"IArray\":\n            return e.backing.array;\n        default:\n            {\n                const t = new Array(e.length);\n                return wc(e, t, 0), e.backing = {\n                    _tag: \"IArray\",\n                    array: t\n                }, e.left = Me, e.right = Me, e.depth = 0, t;\n            }\n    }\n}, We = Em, Im = (e)=>{\n    switch(e.backing._tag){\n        case \"IEmpty\":\n        case \"ISingleton\":\n            return e;\n        case \"IArray\":\n            return G({\n                _tag: \"IArray\",\n                array: qo(e.backing.array)\n            });\n        case \"IConcat\":\n            return G({\n                _tag: \"IConcat\",\n                left: yt(e.backing.right),\n                right: yt(e.backing.left)\n            });\n        case \"ISlice\":\n            return hn(qo(We(e)));\n    }\n}, yt = Im, Fm = /* @__PURE__ */ l(2, (e, t)=>t < 0 || t >= e.length ? v() : I(ht(e, t))), hn = (e)=>e.length === 0 ? Ae() : e.length === 1 ? ie(e[0]) : G({\n        _tag: \"IArray\",\n        array: e\n    }), Rm = (e)=>hn(e), ht = /* @__PURE__ */ l(2, (e, t)=>{\n    switch(e.backing._tag){\n        case \"IEmpty\":\n            throw new Error(\"Index out of bounds\");\n        case \"ISingleton\":\n            {\n                if (t !== 0) throw new Error(\"Index out of bounds\");\n                return e.backing.a;\n            }\n        case \"IArray\":\n            {\n                if (t >= e.length || t < 0) throw new Error(\"Index out of bounds\");\n                return e.backing.array[t];\n            }\n        case \"IConcat\":\n            return t < e.left.length ? ht(e.left, t) : ht(e.right, t - e.left.length);\n        case \"ISlice\":\n            return ht(e.backing.chunk, t + e.backing.offset);\n    }\n}), Mm = /* @__PURE__ */ l(2, (e, t)=>ve(e, ie(t))), be = /* @__PURE__ */ l(2, (e, t)=>ve(ie(t), e)), Oc = /* @__PURE__ */ l(2, (e, t)=>{\n    if (t <= 0) return e;\n    if (t >= e.length) return Me;\n    switch(e.backing._tag){\n        case \"ISlice\":\n            return G({\n                _tag: \"ISlice\",\n                chunk: e.backing.chunk,\n                offset: e.backing.offset + t,\n                length: e.backing.length - t\n            });\n        case \"IConcat\":\n            return t > e.left.length ? Oc(e.right, t - e.left.length) : G({\n                _tag: \"IConcat\",\n                left: Oc(e.left, t),\n                right: e.right\n            });\n        default:\n            return G({\n                _tag: \"ISlice\",\n                chunk: e,\n                offset: t,\n                length: e.length - t\n            });\n    }\n}), ve = /* @__PURE__ */ l(2, (e, t)=>{\n    if (e.backing._tag === \"IEmpty\") return t;\n    if (t.backing._tag === \"IEmpty\") return e;\n    const n = t.depth - e.depth;\n    if (Math.abs(n) <= 1) return G({\n        _tag: \"IConcat\",\n        left: e,\n        right: t\n    });\n    if (n < -1) if (e.left.depth >= e.right.depth) {\n        const r = ve(e.right, t);\n        return G({\n            _tag: \"IConcat\",\n            left: e.left,\n            right: r\n        });\n    } else {\n        const r = ve(e.right.right, t);\n        if (r.depth === e.depth - 3) {\n            const s = G({\n                _tag: \"IConcat\",\n                left: e.right.left,\n                right: r\n            });\n            return G({\n                _tag: \"IConcat\",\n                left: e.left,\n                right: s\n            });\n        } else {\n            const s = G({\n                _tag: \"IConcat\",\n                left: e.left,\n                right: e.right.left\n            });\n            return G({\n                _tag: \"IConcat\",\n                left: s,\n                right: r\n            });\n        }\n    }\n    else if (t.right.depth >= t.left.depth) {\n        const r = ve(e, t.left);\n        return G({\n            _tag: \"IConcat\",\n            left: r,\n            right: t.right\n        });\n    } else {\n        const r = ve(e, t.left.left);\n        if (r.depth === t.depth - 3) {\n            const s = G({\n                _tag: \"IConcat\",\n                left: r,\n                right: t.left.right\n            });\n            return G({\n                _tag: \"IConcat\",\n                left: s,\n                right: t.right\n            });\n        } else {\n            const s = G({\n                _tag: \"IConcat\",\n                left: t.left.right,\n                right: t.right\n            });\n            return G({\n                _tag: \"IConcat\",\n                left: r,\n                right: s\n            });\n        }\n    }\n}), vE = /* @__PURE__ */ l(2, (e, t)=>hn(em(e, t))), Tm = (e)=>e.length === 0, He = (e)=>e.length > 0, xl = /* @__PURE__ */ Fm(0), jl = (e)=>ht(e, 0), Ce = jl, wE = /* @__PURE__ */ l(2, (e, t)=>e.backing._tag === \"ISingleton\" ? ie(t(e.backing.a, 0)) : hn(f(We(e), ft((n, r)=>t(n, r))))), Ve = (e)=>Oc(e, 1), OE = ki, $c = /* @__PURE__ */ Symbol.for(\"effect/Duration\"), Ll = /* @__PURE__ */ BigInt(0), Bo = /* @__PURE__ */ BigInt(24), $r = /* @__PURE__ */ BigInt(60), Ec = /* @__PURE__ */ BigInt(1e3), Vo = /* @__PURE__ */ BigInt(1e6), Ko = /* @__PURE__ */ BigInt(1e9), Cm = /^(-?\\d+(?:\\.\\d+)?)\\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/, Pe = (e)=>{\n    if (Dl(e)) return e;\n    if (kc(e)) return Hr(e);\n    if (Bd(e)) return uc(e);\n    if (Array.isArray(e) && e.length === 2 && e.every(kc)) return e[0] === -1 / 0 || e[1] === -1 / 0 || Number.isNaN(e[0]) || Number.isNaN(e[1]) ? ql : e[0] === 1 / 0 || e[1] === 1 / 0 ? xm : uc(BigInt(Math.round(e[0] * 1e9)) + BigInt(Math.round(e[1])));\n    if (zd(e)) {\n        const t = Cm.exec(e);\n        if (t) {\n            const [n, r, s] = t, c = Number(r);\n            switch(s){\n                case \"nano\":\n                case \"nanos\":\n                    return uc(BigInt(r));\n                case \"micro\":\n                case \"micros\":\n                    return jm(BigInt(r));\n                case \"milli\":\n                case \"millis\":\n                    return Hr(c);\n                case \"second\":\n                case \"seconds\":\n                    return Lm(c);\n                case \"minute\":\n                case \"minutes\":\n                    return Dm(c);\n                case \"hour\":\n                case \"hours\":\n                    return qm(c);\n                case \"day\":\n                case \"days\":\n                    return Um(c);\n                case \"week\":\n                case \"weeks\":\n                    return zm(c);\n            }\n        }\n    }\n    throw new Error(\"Invalid DurationInput\");\n}, Wo = {\n    _tag: \"Millis\",\n    millis: 0\n}, Nm = {\n    _tag: \"Infinity\"\n}, Am = {\n    [$c]: $c,\n    [F] () {\n        return q(this, cl(this.value));\n    },\n    [E] (e) {\n        return Dl(e) && Gm(this, e);\n    },\n    toString () {\n        return \"Duration(\".concat(Qm(this), \")\");\n    },\n    toJSON () {\n        switch(this.value._tag){\n            case \"Millis\":\n                return {\n                    _id: \"Duration\",\n                    _tag: \"Millis\",\n                    millis: this.value.millis\n                };\n            case \"Nanos\":\n                return {\n                    _id: \"Duration\",\n                    _tag: \"Nanos\",\n                    hrtime: Vm(this)\n                };\n            case \"Infinity\":\n                return {\n                    _id: \"Duration\",\n                    _tag: \"Infinity\"\n                };\n        }\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, je = (e)=>{\n    const t = Object.create(Am);\n    return kc(e) ? isNaN(e) || e <= 0 ? t.value = Wo : Number.isFinite(e) ? Number.isInteger(e) ? t.value = {\n        _tag: \"Millis\",\n        millis: e\n    } : t.value = {\n        _tag: \"Nanos\",\n        nanos: BigInt(Math.round(e * 1e6))\n    } : t.value = Nm : e <= Ll ? t.value = Wo : t.value = {\n        _tag: \"Nanos\",\n        nanos: e\n    }, t;\n}, Dl = (e)=>$(e, $c), Pm = (e)=>{\n    switch(e.value._tag){\n        case \"Millis\":\n            return e.value.millis === 0;\n        case \"Nanos\":\n            return e.value.nanos === Ll;\n        case \"Infinity\":\n            return !1;\n    }\n}, ql = /* @__PURE__ */ je(0), xm = /* @__PURE__ */ je(1 / 0), uc = (e)=>je(e), jm = (e)=>je(e * Ec), Hr = (e)=>je(e), Lm = (e)=>je(e * 1e3), Dm = (e)=>je(e * 6e4), qm = (e)=>je(e * 36e5), Um = (e)=>je(e * 864e5), zm = (e)=>je(e * 6048e5), Ic = (e)=>Km(e, {\n        onMillis: (t)=>t,\n        onNanos: (t)=>Number(t) / 1e6\n    }), Bm = (e)=>{\n    const t = Pe(e);\n    switch(t.value._tag){\n        case \"Infinity\":\n            throw new Error(\"Cannot convert infinite duration to nanos\");\n        case \"Nanos\":\n            return t.value.nanos;\n        case \"Millis\":\n            return BigInt(Math.round(t.value.millis * 1e6));\n    }\n}, Vm = (e)=>{\n    const t = Pe(e);\n    switch(t.value._tag){\n        case \"Infinity\":\n            return [\n                1 / 0,\n                0\n            ];\n        case \"Nanos\":\n            return [\n                Number(t.value.nanos / Ko),\n                Number(t.value.nanos % Ko)\n            ];\n        case \"Millis\":\n            return [\n                Math.floor(t.value.millis / 1e3),\n                Math.round(t.value.millis % 1e3 * 1e6)\n            ];\n    }\n}, Km = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Pe(e);\n    switch(n.value._tag){\n        case \"Nanos\":\n            return t.onNanos(n.value.nanos);\n        case \"Infinity\":\n            return t.onMillis(1 / 0);\n        case \"Millis\":\n            return t.onMillis(n.value.millis);\n    }\n}), Ei = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = Pe(e), s = Pe(t);\n    if (r.value._tag === \"Infinity\" || s.value._tag === \"Infinity\") return n.onMillis(Ic(r), Ic(s));\n    if (r.value._tag === \"Nanos\" || s.value._tag === \"Nanos\") {\n        const c = r.value._tag === \"Nanos\" ? r.value.nanos : BigInt(Math.round(r.value.millis * 1e6)), i = s.value._tag === \"Nanos\" ? s.value.nanos : BigInt(Math.round(s.value.millis * 1e6));\n        return n.onNanos(c, i);\n    }\n    return n.onMillis(r.value.millis, s.value.millis);\n}), Wm = (e, t)=>Ei(e, t, {\n        onMillis: (n, r)=>n === r,\n        onNanos: (n, r)=>n === r\n    }), Jm = /* @__PURE__ */ l(2, (e, t)=>Ei(e, t, {\n        onMillis: (n, r)=>n <= r,\n        onNanos: (n, r)=>n <= r\n    })), Hm = /* @__PURE__ */ l(2, (e, t)=>Ei(e, t, {\n        onMillis: (n, r)=>n >= r,\n        onNanos: (n, r)=>n >= r\n    })), Gm = /* @__PURE__ */ l(2, (e, t)=>Wm(Pe(e), Pe(t))), Ym = (e)=>{\n    const t = Pe(e);\n    if (t.value._tag === \"Infinity\") return {\n        days: 1 / 0,\n        hours: 1 / 0,\n        minutes: 1 / 0,\n        seconds: 1 / 0,\n        millis: 1 / 0,\n        nanos: 1 / 0\n    };\n    const n = Bm(t), r = n / Vo, s = r / Ec, c = s / $r, i = c / $r, o = i / Bo;\n    return {\n        days: Number(o),\n        hours: Number(i % Bo),\n        minutes: Number(c % $r),\n        seconds: Number(s % $r),\n        millis: Number(r % Ec),\n        nanos: Number(n % Vo)\n    };\n}, Qm = (e)=>{\n    const t = Pe(e);\n    if (t.value._tag === \"Infinity\") return \"Infinity\";\n    if (Pm(t)) return \"0\";\n    const n = Ym(t), r = [];\n    return n.days !== 0 && r.push(\"\".concat(n.days, \"d\")), n.hours !== 0 && r.push(\"\".concat(n.hours, \"h\")), n.minutes !== 0 && r.push(\"\".concat(n.minutes, \"m\")), n.seconds !== 0 && r.push(\"\".concat(n.seconds, \"s\")), n.millis !== 0 && r.push(\"\".concat(n.millis, \"ms\")), n.nanos !== 0 && r.push(\"\".concat(n.nanos, \"ns\")), r.join(\" \");\n}, bt = 5, Ii = /* @__PURE__ */ Math.pow(2, bt), Zm = Ii - 1, Xm = Ii / 2, ep = Ii / 4;\nfunction tp(e) {\n    return e -= e >> 1 & 1431655765, e = (e & 858993459) + (e >> 2 & 858993459), e = e + (e >> 4) & 252645135, e += e >> 8, e += e >> 16, e & 127;\n}\nfunction Kt(e, t) {\n    return t >>> e & Zm;\n}\n_c6 = Kt;\nfunction xt(e) {\n    return 1 << e;\n}\nfunction Ul(e, t) {\n    return tp(e & t - 1);\n}\n_c7 = Ul;\nconst np = (e, t)=>({\n        value: e,\n        previous: t\n    });\nfunction Lt(e, t, n, r) {\n    let s = r;\n    if (!e) {\n        const c = r.length;\n        s = new Array(c);\n        for(let i = 0; i < c; ++i)s[i] = r[i];\n    }\n    return s[t] = n, s;\n}\n_c8 = Lt;\nfunction zl(e, t, n) {\n    const r = n.length - 1;\n    let s = 0, c = 0, i = n;\n    if (e) s = c = t;\n    else for(i = new Array(r); s < t;)i[c++] = n[s++];\n    for(++s; s <= r;)i[c++] = n[s++];\n    return e && (i.length = r), i;\n}\nfunction rp(e, t, n, r) {\n    const s = r.length;\n    if (e) {\n        let a = s;\n        for(; a >= t;)r[a--] = r[a];\n        return r[t] = n, r;\n    }\n    let c = 0, i = 0;\n    const o = new Array(s + 1);\n    for(; c < t;)o[i++] = r[c++];\n    for(o[t] = n; c < s;)o[++i] = r[c++];\n    return o;\n}\nclass Qe {\n    modify(t, n, r, s, c, i) {\n        const o = r(v());\n        return W(o) ? new Qe() : (++i.value, new dt(t, s, c, o));\n    }\n    constructor(){\n        u(this, \"_tag\", \"EmptyNode\");\n    }\n}\nfunction we(e) {\n    return el(e, \"EmptyNode\");\n}\nfunction sp(e) {\n    return we(e) || e._tag === \"LeafNode\" || e._tag === \"CollisionNode\";\n}\nfunction Rs(e, t) {\n    return we(e) ? !1 : t === e.edit;\n}\n_c9 = Rs;\nclass dt {\n    modify(t, n, r, s, c, i) {\n        if (O(c, this.key)) {\n            const a = r(this.value);\n            return a === this.value ? this : W(a) ? (--i.value, new Qe()) : Rs(this, t) ? (this.value = a, this) : new dt(t, s, c, a);\n        }\n        const o = r(v());\n        return W(o) ? this : (++i.value, Bl(t, n, this.hash, this, s, new dt(t, s, c, o)));\n    }\n    constructor(t, n, r, s){\n        u(this, \"edit\");\n        u(this, \"hash\");\n        u(this, \"key\");\n        u(this, \"value\");\n        u(this, \"_tag\", \"LeafNode\");\n        this.edit = t, this.hash = n, this.key = r, this.value = s;\n    }\n}\nclass Fi {\n    modify(t, n, r, s, c, i) {\n        if (s === this.hash) {\n            const a = Rs(this, t), h = this.updateCollisionList(a, t, this.hash, this.children, r, c, i);\n            return h === this.children ? this : h.length > 1 ? new Fi(t, this.hash, h) : h[0];\n        }\n        const o = r(v());\n        return W(o) ? this : (++i.value, Bl(t, n, this.hash, this, s, new dt(t, s, c, o)));\n    }\n    updateCollisionList(t, n, r, s, c, i, o) {\n        const a = s.length;\n        for(let d = 0; d < a; ++d){\n            const g = s[d];\n            if (\"key\" in g && O(i, g.key)) {\n                const p = g.value, _ = c(p);\n                return _ === p ? s : W(_) ? (--o.value, zl(t, d, s)) : Lt(t, d, new dt(n, r, i, _), s);\n            }\n        }\n        const h = c(v());\n        return W(h) ? s : (++o.value, Lt(t, a, new dt(n, r, i, h), s));\n    }\n    constructor(t, n, r){\n        u(this, \"edit\");\n        u(this, \"hash\");\n        u(this, \"children\");\n        u(this, \"_tag\", \"CollisionNode\");\n        this.edit = t, this.hash = n, this.children = r;\n    }\n}\nclass Wt {\n    modify(t, n, r, s, c, i) {\n        const o = this.mask, a = this.children, h = Kt(n, s), d = xt(h), g = Ul(o, d), p = o & d, _ = Rs(this, t);\n        if (!p) {\n            const H = new Qe().modify(t, n + bt, r, s, c, i);\n            return H ? a.length >= Xm ? ip(t, h, H, o, a) : new Wt(t, o | d, rp(_, g, H, a)) : this;\n        }\n        const b = a[g], M = b.modify(t, n + bt, r, s, c, i);\n        if (b === M) return this;\n        let D = o, X;\n        if (we(M)) {\n            if (D &= ~d, !D) return new Qe();\n            if (a.length <= 2 && sp(a[g ^ 1])) return a[g ^ 1];\n            X = zl(_, g, a);\n        } else X = Lt(_, g, M, a);\n        return _ ? (this.mask = D, this.children = X, this) : new Wt(t, D, X);\n    }\n    constructor(t, n, r){\n        u(this, \"edit\");\n        u(this, \"mask\");\n        u(this, \"children\");\n        u(this, \"_tag\", \"IndexedNode\");\n        this.edit = t, this.mask = n, this.children = r;\n    }\n}\nclass Ri {\n    modify(t, n, r, s, c, i) {\n        let o = this.size;\n        const a = this.children, h = Kt(n, s), d = a[h], g = (d || new Qe()).modify(t, n + bt, r, s, c, i);\n        if (d === g) return this;\n        const p = Rs(this, t);\n        let _;\n        if (we(d) && !we(g)) ++o, _ = Lt(p, h, g, a);\n        else if (!we(d) && we(g)) {\n            if (--o, o <= ep) return cp(t, o, h, a);\n            _ = Lt(p, h, new Qe(), a);\n        } else _ = Lt(p, h, g, a);\n        return p ? (this.size = o, this.children = _, this) : new Ri(t, o, _);\n    }\n    constructor(t, n, r){\n        u(this, \"edit\");\n        u(this, \"size\");\n        u(this, \"children\");\n        u(this, \"_tag\", \"ArrayNode\");\n        this.edit = t, this.size = n, this.children = r;\n    }\n}\nfunction cp(e, t, n, r) {\n    const s = new Array(t - 1);\n    let c = 0, i = 0;\n    for(let o = 0, a = r.length; o < a; ++o)if (o !== n) {\n        const h = r[o];\n        h && !we(h) && (s[c++] = h, i |= 1 << o);\n    }\n    return new Wt(e, i, s);\n}\nfunction ip(e, t, n, r, s) {\n    const c = [];\n    let i = r, o = 0;\n    for(let a = 0; i; ++a)i & 1 && (c[a] = s[o++]), i >>>= 1;\n    return c[t] = n, new Ri(e, o + 1, c);\n}\nfunction op(e, t, n, r, s, c) {\n    if (n === s) return new Fi(e, n, [\n        c,\n        r\n    ]);\n    const i = Kt(t, n), o = Kt(t, s);\n    if (i === o) return (a)=>new Wt(e, xt(i) | xt(o), [\n            a\n        ]);\n    {\n        const a = i < o ? [\n            r,\n            c\n        ] : [\n            c,\n            r\n        ];\n        return new Wt(e, xt(i) | xt(o), a);\n    }\n}\nfunction Bl(e, t, n, r, s, c) {\n    let i, o = t;\n    for(;;){\n        const a = op(e, o, n, r, s, c);\n        if (typeof a == \"function\") i = np(a, i), o = o + bt;\n        else {\n            let h = a;\n            for(; i != null;)h = i.value(h), i = i.previous;\n            return h;\n        }\n    }\n}\n_c10 = Bl;\nconst Vl = \"effect/HashMap\", Fc = /* @__PURE__ */ Symbol.for(Vl), ap = {\n    [Fc]: Fc,\n    [Symbol.iterator] () {\n        return new Ms(this, (e, t)=>[\n                e,\n                t\n            ]);\n    },\n    [F] () {\n        let e = k(Vl);\n        for (const t of this)e ^= f(k(t[0]), R(k(t[1])));\n        return q(this, e);\n    },\n    [E] (e) {\n        if (fp(e)) {\n            if (e._size !== this._size) return !1;\n            for (const t of this){\n                const n = f(e, Ti(t[0], k(t[0])));\n                if (W(n)) return !1;\n                if (!O(t[1], n.value)) return !1;\n            }\n            return !0;\n        }\n        return !1;\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"HashMap\",\n            values: Array.from(this).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, Mi = (e, t, n, r)=>{\n    const s = Object.create(ap);\n    return s._editable = e, s._edit = t, s._root = n, s._size = r, s;\n};\nclass Ms {\n    next() {\n        if (W(this.v)) return {\n            done: !0,\n            value: void 0\n        };\n        const t = this.v.value;\n        return this.v = Gr(t.cont), {\n            done: !1,\n            value: t.value\n        };\n    }\n    [Symbol.iterator]() {\n        return new Ms(this.map, this.f);\n    }\n    constructor(t, n){\n        u(this, \"map\");\n        u(this, \"f\");\n        u(this, \"v\");\n        this.map = t, this.f = n, this.v = Kl(this.map._root, this.f, void 0);\n    }\n}\nconst Gr = (e)=>e ? Wl(e[0], e[1], e[2], e[3], e[4]) : v(), Kl = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;\n    switch(e._tag){\n        case \"LeafNode\":\n            return ye(e.value) ? I({\n                value: t(e.key, e.value.value),\n                cont: n\n            }) : Gr(n);\n        case \"CollisionNode\":\n        case \"ArrayNode\":\n        case \"IndexedNode\":\n            {\n                const r = e.children;\n                return Wl(r.length, r, 0, t, n);\n            }\n        default:\n            return Gr(n);\n    }\n}, Wl = (e, t, n, r, s)=>{\n    for(; n < e;){\n        const c = t[n++];\n        if (c && !we(c)) return Kl(c, r, [\n            e,\n            t,\n            n,\n            r,\n            s\n        ]);\n    }\n    return Gr(s);\n}, up = /* @__PURE__ */ Mi(!1, 0, /* @__PURE__ */ new Qe(), 0), Ts = ()=>up, lp = (e)=>{\n    const t = Hl(Ts());\n    for (const n of e)jn(t, n[0], n[1]);\n    return pp(t);\n}, fp = (e)=>$(e, Fc), hp = (e)=>e && we(e._root), dp = /* @__PURE__ */ l(2, (e, t)=>Ti(e, t, k(t))), Ti = /* @__PURE__ */ l(3, (e, t, n)=>{\n    let r = e._root, s = 0;\n    for(;;)switch(r._tag){\n        case \"LeafNode\":\n            return O(t, r.key) ? r.value : v();\n        case \"CollisionNode\":\n            {\n                if (n === r.hash) {\n                    const c = r.children;\n                    for(let i = 0, o = c.length; i < o; ++i){\n                        const a = c[i];\n                        if (\"key\" in a && O(t, a.key)) return a.value;\n                    }\n                }\n                return v();\n            }\n        case \"IndexedNode\":\n            {\n                const c = Kt(s, n), i = xt(c);\n                if (r.mask & i) {\n                    r = r.children[Ul(r.mask, i)], s += bt;\n                    break;\n                }\n                return v();\n            }\n        case \"ArrayNode\":\n            {\n                if (r = r.children[Kt(s, n)], r) {\n                    s += bt;\n                    break;\n                }\n                return v();\n            }\n        default:\n            return v();\n    }\n}), gp = /* @__PURE__ */ l(2, (e, t)=>ye(Ti(e, t, k(t)))), jn = /* @__PURE__ */ l(3, (e, t, n)=>Ci(e, t, ()=>I(n))), mp = /* @__PURE__ */ l(3, (e, t, n)=>e._editable ? (e._root = t, e._size = n, e) : t === e._root ? e : Mi(e._editable, e._edit, t, n)), Jl = (e)=>new Ms(e, (t)=>t), Rc = (e)=>e._size, Hl = (e)=>Mi(!0, e._edit + 1, e._root, e._size), pp = (e)=>(e._editable = !1, e), Ci = /* @__PURE__ */ l(3, (e, t, n)=>_p(e, t, k(t), n)), _p = /* @__PURE__ */ l(4, (e, t, n, r)=>{\n    const s = {\n        value: e._size\n    }, c = e._root.modify(e._editable ? e._edit : NaN, 0, r, n, t, s);\n    return f(e, mp(c, s.value));\n}), Jo = /* @__PURE__ */ l(2, (e, t)=>Ci(e, t, v)), yp = /* @__PURE__ */ l(2, (e, t)=>Cs(e, Ts(), (n, r, s)=>jn(n, s, t(r, s)))), bp = /* @__PURE__ */ l(2, (e, t)=>Cs(e, void 0, (n, r, s)=>t(r, s))), Cs = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = e._root;\n    if (r._tag === \"LeafNode\") return ye(r.value) ? n(t, r.value.value, r.key) : t;\n    if (r._tag === \"EmptyNode\") return t;\n    const s = [\n        r.children\n    ];\n    let c;\n    for(; c = s.pop();)for(let i = 0, o = c.length; i < o;){\n        const a = c[i++];\n        a && !we(a) && (a._tag === \"LeafNode\" ? ye(a.value) && (t = n(t, a.value.value, a.key)) : s.push(a.children));\n    }\n    return t;\n}), Gl = \"effect/HashSet\", Mc = /* @__PURE__ */ Symbol.for(Gl), Sp = {\n    [Mc]: Mc,\n    [Symbol.iterator] () {\n        return Jl(this._keyMap);\n    },\n    [F] () {\n        return q(this, R(k(this._keyMap))(k(Gl)));\n    },\n    [E] (e) {\n        return kp(e) ? Rc(this._keyMap) === Rc(e._keyMap) && O(this._keyMap, e._keyMap) : !1;\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"HashSet\",\n            values: Array.from(this).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, Ns = (e)=>{\n    const t = Object.create(Sp);\n    return t._keyMap = e, t;\n}, kp = (e)=>$(e, Mc), vp = /* @__PURE__ */ Ns(/* @__PURE__ */ Ts()), As = ()=>vp, wp = (e)=>{\n    const t = Ni(As());\n    for (const n of e)Ln(t, n);\n    return Ai(t);\n}, Op = function() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    const t = Ni(As());\n    for (const n of e)Ln(t, n);\n    return Ai(t);\n}, $p = /* @__PURE__ */ l(2, (e, t)=>gp(e._keyMap, t)), Ep = (e)=>Rc(e._keyMap), Ni = (e)=>Ns(Hl(e._keyMap)), Ai = (e)=>(e._keyMap._editable = !1, e), Yl = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Ni(e);\n    return t(n), Ai(n);\n}), Ln = /* @__PURE__ */ l(2, (e, t)=>e._keyMap._editable ? (jn(t, !0)(e._keyMap), e) : Ns(jn(t, !0)(e._keyMap))), Ql = /* @__PURE__ */ l(2, (e, t)=>e._keyMap._editable ? (Jo(t)(e._keyMap), e) : Ns(Jo(t)(e._keyMap))), Ip = /* @__PURE__ */ l(2, (e, t)=>Yl(e, (n)=>{\n        for (const r of t)Ql(n, r);\n    })), Fp = /* @__PURE__ */ l(2, (e, t)=>Yl(As(), (n)=>{\n        Rp(e, (r)=>Ln(n, r));\n        for (const r of t)Ln(n, r);\n    })), Rp = /* @__PURE__ */ l(2, (e, t)=>bp(e._keyMap, (n, r)=>t(r))), Mp = /* @__PURE__ */ l(3, (e, t, n)=>Cs(e._keyMap, t, (r, s, c)=>n(r, c))), St = As, Tp = wp, Pi = Op, Cp = $p, Zl = Ep, Cn = Ln, Xl = Ql, Ho = Ip, Dn = Fp, qn = Mp, Go = /* @__PURE__ */ Symbol.for(\"effect/MutableRef\"), Np = {\n    [Go]: Go,\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"MutableRef\",\n            current: V(this.current)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, Ps = (e)=>{\n    const t = Object.create(Np);\n    return t.current = e, t;\n}, Ap = /* @__PURE__ */ l(3, (e, t, n)=>O(t, e.current) ? (e.current = n, !0) : !1), Ze = (e)=>e.current, xs = /* @__PURE__ */ l(2, (e, t)=>(e.current = t, e)), js = \"effect/FiberId\", kt = /* @__PURE__ */ Symbol.for(js), Jt = \"None\", Tc = \"Runtime\", Cc = \"Composite\", Pp = /* @__PURE__ */ B(\"\".concat(js, \"-\").concat(Jt));\nvar Za;\nlet xp = class {\n    [(Za = kt, F)]() {\n        return Pp;\n    }\n    [E](t) {\n        return xi(t) && t._tag === Jt;\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    toJSON() {\n        return {\n            _id: \"FiberId\",\n            _tag: this._tag\n        };\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    constructor(){\n        u(this, Za, kt);\n        u(this, \"_tag\", Jt);\n        u(this, \"id\", -1);\n        u(this, \"startTimeMillis\", -1);\n    }\n};\nvar Xa;\nclass jp {\n    [(Xa = kt, F)]() {\n        return q(this, B(\"\".concat(js, \"-\").concat(this._tag, \"-\").concat(this.id, \"-\").concat(this.startTimeMillis)));\n    }\n    [E](t) {\n        return xi(t) && t._tag === Tc && this.id === t.id && this.startTimeMillis === t.startTimeMillis;\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    toJSON() {\n        return {\n            _id: \"FiberId\",\n            _tag: this._tag,\n            id: this.id,\n            startTimeMillis: this.startTimeMillis\n        };\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    constructor(t, n){\n        u(this, \"id\");\n        u(this, \"startTimeMillis\");\n        u(this, Xa, kt);\n        u(this, \"_tag\", Tc);\n        this.id = t, this.startTimeMillis = n;\n    }\n}\nvar eu;\nclass Lp {\n    [(eu = kt, F)]() {\n        return f(B(\"\".concat(js, \"-\").concat(this._tag)), R(k(this.left)), R(k(this.right)), q(this));\n    }\n    [E](t) {\n        return xi(t) && t._tag === Cc && O(this.left, t.left) && O(this.right, t.right);\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    toJSON() {\n        return {\n            _id: \"FiberId\",\n            _tag: this._tag,\n            left: V(this.left),\n            right: V(this.right)\n        };\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    constructor(t, n){\n        u(this, \"left\");\n        u(this, \"right\");\n        u(this, eu, kt);\n        u(this, \"_tag\", Cc);\n        u(this, \"_hash\");\n        this.left = t, this.right = n;\n    }\n}\nconst ef = /* @__PURE__ */ new xp(), xi = (e)=>$(e, kt), tf = /* @__PURE__ */ l(2, (e, t)=>e._tag === Jt ? t : t._tag === Jt ? e : new Lp(e, t)), Dp = (e)=>f(e, qn(ef, (t, n)=>tf(n)(t))), Nc = (e)=>{\n    switch(e._tag){\n        case Jt:\n            return St();\n        case Tc:\n            return Pi(e.id);\n        case Cc:\n            return f(Nc(e.left), Dn(Nc(e.right)));\n    }\n}, Yo = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Fiber/Id/_fiberCounter\"), ()=>Ps(0)), nf = (e)=>Array.from(Nc(e)).map((n)=>\"#\".concat(n)).join(\",\"), qp = ()=>{\n    const e = Ze(Yo);\n    return f(Yo, xs(e + 1)), new jp(e, Date.now());\n}, Ht = ef, Up = tf, EE = Dp, zp = nf, rf = qp, ji = Ts, Bp = lp, Vp = hp, sf = dp, cf = jn, of = Jl, Kp = Ci, Wp = yp, af = Cs, Un = /* @__PURE__ */ Symbol.for(\"effect/List\"), Ac = (e)=>z(e), Jp = (e)=>Dd(vi(e), Ac), Hp = /* @__PURE__ */ Jp(O), Gp = {\n    [Un]: Un,\n    _tag: \"Cons\",\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"List\",\n            _tag: \"Cons\",\n            values: Ac(this).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    [E] (e) {\n        return lf(e) && this._tag === e._tag && Hp(this, e);\n    },\n    [F] () {\n        return q(this, er(Ac(this)));\n    },\n    [Symbol.iterator] () {\n        let e = !1, t = this;\n        return {\n            next () {\n                if (e) return this.return();\n                if (t._tag === \"Nil\") return e = !0, this.return();\n                const n = t.head;\n                return t = t.tail, {\n                    done: e,\n                    value: n\n                };\n            },\n            return (n) {\n                return e || (e = !0), {\n                    done: !0,\n                    value: n\n                };\n            }\n        };\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, Yr = (e, t)=>{\n    const n = Object.create(Gp);\n    return n.head = e, n.tail = t, n;\n}, Yp = /* @__PURE__ */ B(\"Nil\"), Qp = {\n    [Un]: Un,\n    _tag: \"Nil\",\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"List\",\n            _tag: \"Nil\"\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    [F] () {\n        return Yp;\n    },\n    [E] (e) {\n        return lf(e) && this._tag === e._tag;\n    },\n    [Symbol.iterator] () {\n        return {\n            next () {\n                return {\n                    done: !0,\n                    value: void 0\n                };\n            }\n        };\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, uf = /* @__PURE__ */ Object.create(Qp), lf = (e)=>$(e, Un), Je = (e)=>e._tag === \"Nil\", Zp = (e)=>e._tag === \"Cons\", Xp = ()=>uf, vt = (e, t)=>Yr(e, t), Gt = Xp, Li = (e)=>Yr(e, uf), e_ = /* @__PURE__ */ l(2, (e, t)=>n_(t, e)), t_ = /* @__PURE__ */ l(2, (e, t)=>vt(t, e)), n_ = /* @__PURE__ */ l(2, (e, t)=>{\n    if (Je(e)) return t;\n    if (Je(t)) return e;\n    {\n        const n = Yr(t.head, e);\n        let r = n, s = t.tail;\n        for(; !Je(s);){\n            const c = Yr(s.head, e);\n            r.tail = c, r = c, s = s.tail;\n        }\n        return n;\n    }\n}), r_ = /* @__PURE__ */ l(3, (e, t, n)=>{\n    let r = t, s = e;\n    for(; !Je(s);)r = n(r, s.head), s = s.tail;\n    return r;\n}), s_ = (e)=>{\n    let t = Gt(), n = e;\n    for(; !Je(n);)t = t_(t, n.head), n = n.tail;\n    return t;\n}, Di = /* @__PURE__ */ function() {\n    function e(t) {\n        t && Object.assign(this, t);\n    }\n    return e.prototype = Os, e;\n}(), IE = (e)=>Object.assign(Object.create(Os), e), c_ = /* @__PURE__ */ Symbol.for(\"effect/DifferContextPatch\");\nfunction Qo(e) {\n    return e;\n}\n_c11 = Qo;\nconst cr = {\n    ...Di.prototype,\n    [c_]: {\n        _Value: Qo,\n        _Patch: Qo\n    }\n}, i_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(cr), {\n    _tag: \"Empty\"\n}), o_ = /* @__PURE__ */ Object.create(i_), ff = ()=>o_, a_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(cr), {\n    _tag: \"AndThen\"\n}), u_ = (e, t)=>{\n    const n = Object.create(a_);\n    return n.first = e, n.second = t, n;\n}, l_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(cr), {\n    _tag: \"AddService\"\n}), f_ = (e, t)=>{\n    const n = Object.create(l_);\n    return n.key = e, n.service = t, n;\n}, h_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(cr), {\n    _tag: \"RemoveService\"\n}), d_ = (e)=>{\n    const t = Object.create(h_);\n    return t.key = e, t;\n}, g_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(cr), {\n    _tag: \"UpdateService\"\n}), m_ = (e, t)=>{\n    const n = Object.create(g_);\n    return n.key = e, n.update = t, n;\n}, p_ = (e, t)=>{\n    const n = new Map(e.unsafeMap);\n    let r = ff();\n    for (const [s, c] of t.unsafeMap.entries())if (n.has(s)) {\n        const i = n.get(s);\n        n.delete(s), O(i, c) || (r = Pr(m_(s, ()=>c))(r));\n    } else n.delete(s), r = Pr(f_(s, c))(r);\n    for (const [s] of n.entries())r = Pr(d_(s))(r);\n    return r;\n}, Pr = /* @__PURE__ */ l(2, (e, t)=>u_(e, t)), __ = /* @__PURE__ */ l(2, (e, t)=>{\n    if (e._tag === \"Empty\") return t;\n    let n = !1, r = ie(e);\n    const s = new Map(t.unsafeMap);\n    for(; He(r);){\n        const i = Ce(r), o = Ve(r);\n        switch(i._tag){\n            case \"Empty\":\n                {\n                    r = o;\n                    break;\n                }\n            case \"AddService\":\n                {\n                    s.set(i.key, i.service), r = o;\n                    break;\n                }\n            case \"AndThen\":\n                {\n                    r = be(be(o, i.second), i.first);\n                    break;\n                }\n            case \"RemoveService\":\n                {\n                    s.delete(i.key), r = o;\n                    break;\n                }\n            case \"UpdateService\":\n                {\n                    s.set(i.key, i.update(s.get(i.key))), n = !0, r = o;\n                    break;\n                }\n        }\n    }\n    if (!n) return Vt(s);\n    const c = /* @__PURE__ */ new Map();\n    for (const [i] of t.unsafeMap)s.has(i) && (c.set(i, s.get(i)), s.delete(i));\n    for (const [i, o] of s)c.set(i, o);\n    return Vt(c);\n}), y_ = /* @__PURE__ */ Symbol.for(\"effect/DifferHashSetPatch\");\nfunction lc(e) {\n    return e;\n}\nconst Ls = {\n    ...Di.prototype,\n    [y_]: {\n        _Value: lc,\n        _Key: lc,\n        _Patch: lc\n    }\n}, b_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Ls), {\n    _tag: \"Empty\"\n}), S_ = /* @__PURE__ */ Object.create(b_), hf = ()=>S_, k_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Ls), {\n    _tag: \"AndThen\"\n}), v_ = (e, t)=>{\n    const n = Object.create(k_);\n    return n.first = e, n.second = t, n;\n}, w_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Ls), {\n    _tag: \"Add\"\n}), O_ = (e)=>{\n    const t = Object.create(w_);\n    return t.value = e, t;\n}, $_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Ls), {\n    _tag: \"Remove\"\n}), E_ = (e)=>{\n    const t = Object.create($_);\n    return t.value = e, t;\n}, I_ = (e, t)=>{\n    const [n, r] = qn([\n        e,\n        hf()\n    ], (param, i)=>{\n        let [s, c] = param;\n        return Cp(i)(s) ? [\n            Xl(i)(s),\n            c\n        ] : [\n            s,\n            Pc(O_(i))(c)\n        ];\n    })(t);\n    return qn(r, (s, c)=>Pc(E_(c))(s))(n);\n}, Pc = /* @__PURE__ */ l(2, (e, t)=>v_(e, t)), F_ = /* @__PURE__ */ l(2, (e, t)=>{\n    if (e._tag === \"Empty\") return t;\n    let n = t, r = ie(e);\n    for(; He(r);){\n        const s = Ce(r), c = Ve(r);\n        switch(s._tag){\n            case \"Empty\":\n                {\n                    r = c;\n                    break;\n                }\n            case \"AndThen\":\n                {\n                    r = be(s.first)(be(s.second)(c));\n                    break;\n                }\n            case \"Add\":\n                {\n                    n = Cn(s.value)(n), r = c;\n                    break;\n                }\n            case \"Remove\":\n                n = Xl(s.value)(n), r = c;\n        }\n    }\n    return n;\n}), R_ = /* @__PURE__ */ Symbol.for(\"effect/DifferReadonlyArrayPatch\");\nfunction Zo(e) {\n    return e;\n}\n_c12 = Zo;\nconst ir = {\n    ...Di.prototype,\n    [R_]: {\n        _Value: Zo,\n        _Patch: Zo\n    }\n}, M_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ir), {\n    _tag: \"Empty\"\n}), T_ = /* @__PURE__ */ Object.create(M_), df = ()=>T_, C_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ir), {\n    _tag: \"AndThen\"\n}), N_ = (e, t)=>{\n    const n = Object.create(C_);\n    return n.first = e, n.second = t, n;\n}, A_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ir), {\n    _tag: \"Append\"\n}), P_ = (e)=>{\n    const t = Object.create(A_);\n    return t.values = e, t;\n}, x_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ir), {\n    _tag: \"Slice\"\n}), j_ = (e, t)=>{\n    const n = Object.create(x_);\n    return n.from = e, n.until = t, n;\n}, L_ = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(ir), {\n    _tag: \"Update\"\n}), D_ = (e, t)=>{\n    const n = Object.create(L_);\n    return n.index = e, n.patch = t, n;\n}, q_ = (e)=>{\n    let t = 0, n = df();\n    for(; t < e.oldValue.length && t < e.newValue.length;){\n        const r = e.oldValue[t], s = e.newValue[t], c = e.differ.diff(r, s);\n        O(c, e.differ.empty) || (n = xr(n, D_(t, c))), t = t + 1;\n    }\n    return t < e.oldValue.length && (n = xr(n, j_(0, t))), t < e.newValue.length && (n = xr(n, P_(Kg(t)(e.newValue)))), n;\n}, xr = /* @__PURE__ */ l(2, (e, t)=>N_(e, t)), U_ = /* @__PURE__ */ l(3, (e, t, n)=>{\n    if (e._tag === \"Empty\") return t;\n    let r = t.slice(), s = ke(e);\n    for(; Dg(s);){\n        const c = ue(s), i = _t(s);\n        switch(c._tag){\n            case \"Empty\":\n                {\n                    s = i;\n                    break;\n                }\n            case \"AndThen\":\n                {\n                    i.unshift(c.first, c.second), s = i;\n                    break;\n                }\n            case \"Append\":\n                {\n                    for (const o of c.values)r.push(o);\n                    s = i;\n                    break;\n                }\n            case \"Slice\":\n                {\n                    r = r.slice(c.from, c.until), s = i;\n                    break;\n                }\n            case \"Update\":\n                {\n                    r[c.index] = n.patch(c.patch, r[c.index]), s = i;\n                    break;\n                }\n        }\n    }\n    return r;\n}), z_ = /* @__PURE__ */ Symbol.for(\"effect/Differ\"), B_ = {\n    [z_]: {\n        _P: P,\n        _V: P\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n}, dn = (e)=>{\n    const t = Object.create(B_);\n    return t.empty = e.empty, t.diff = e.diff, t.combine = e.combine, t.patch = e.patch, t;\n}, V_ = ()=>dn({\n        empty: ff(),\n        combine: (e, t)=>Pr(t)(e),\n        diff: (e, t)=>p_(e, t),\n        patch: (e, t)=>__(t)(e)\n    }), K_ = ()=>dn({\n        empty: hf(),\n        combine: (e, t)=>Pc(t)(e),\n        diff: (e, t)=>I_(e, t),\n        patch: (e, t)=>F_(t)(e)\n    }), W_ = (e)=>dn({\n        empty: df(),\n        combine: (t, n)=>xr(t, n),\n        diff: (t, n)=>q_({\n                oldValue: t,\n                newValue: n,\n                differ: e\n            }),\n        patch: (t, n)=>U_(t, n, e)\n    }), gf = ()=>J_((e, t)=>t), J_ = (e)=>dn({\n        empty: P,\n        combine: (t, n)=>t === P ? n : n === P ? t : (r)=>n(t(r)),\n        diff: (t, n)=>O(t, n) ? P : Qn(n),\n        patch: (t, n)=>e(n, t(n))\n    }), zn = 255, mf = 8, xc = (e)=>e & zn, jc = (e)=>e >> mf & zn, or = (e, t)=>(e & zn) + ((t & e & zn) << mf), H_ = /* @__PURE__ */ or(0, 0), G_ = (e)=>or(e, e), Y_ = (e)=>or(e, 0), Q_ = /* @__PURE__ */ l(2, (e, t)=>or(xc(e) & ~t, jc(e))), Z_ = /* @__PURE__ */ l(2, (e, t)=>e | t), X_ = (e)=>~e >>> 0 & zn, ey = 0, gn = 1, ty = 2, pf = 4, Lc = 16, _f = 32, ny = (e)=>Ds(e, _f), ry = /* @__PURE__ */ l(2, (e, t)=>e | t), Ge = (e)=>yf(e) && !cy(e), yf = (e)=>Ds(e, gn), Ds = /* @__PURE__ */ l(2, (e, t)=>(e & t) !== 0), bf = function() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    return e.reduce((t, n)=>t | n, 0);\n}, sy = /* @__PURE__ */ bf(ey), Xo = (e)=>Ds(e, pf), cy = (e)=>Ds(e, Lc), gt = /* @__PURE__ */ l(2, (e, t)=>or(e ^ t, t)), Dt = /* @__PURE__ */ l(2, (e, t)=>e & (X_(xc(t)) | jc(t)) | xc(t) & jc(t)), ea = /* @__PURE__ */ dn({\n    empty: H_,\n    diff: (e, t)=>gt(e, t),\n    combine: (e, t)=>Z_(t)(e),\n    patch: (e, t)=>Dt(t, e)\n}), iy = G_, Sf = Y_, ta = Q_, kf = (e, t)=>({\n        _tag: \"Par\",\n        left: e,\n        right: t\n    }), Er = (e, t)=>({\n        _tag: \"Seq\",\n        left: e,\n        right: t\n    }), oy = (e)=>{\n    let t = Li(e), n = Gt();\n    for(;;){\n        const [r, s] = r_(t, [\n            vf(),\n            Gt()\n        ], (param, o)=>{\n            let [c, i] = param;\n            const [a, h] = ay(o);\n            return [\n                dy(c, a),\n                e_(i, h)\n            ];\n        });\n        if (n = uy(n, r), Je(s)) return s_(n);\n        t = s;\n    }\n    throw new Error(\"BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues\");\n}, ay = (e)=>{\n    let t = e, n = vf(), r = Gt(), s = Gt();\n    for(;;)switch(t._tag){\n        case \"Empty\":\n            {\n                if (Je(r)) return [\n                    n,\n                    s\n                ];\n                t = r.head, r = r.tail;\n                break;\n            }\n        case \"Par\":\n            {\n                r = vt(t.right, r), t = t.left;\n                break;\n            }\n        case \"Seq\":\n            {\n                const c = t.left, i = t.right;\n                switch(c._tag){\n                    case \"Empty\":\n                        {\n                            t = i;\n                            break;\n                        }\n                    case \"Par\":\n                        {\n                            const o = c.left, a = c.right;\n                            t = kf(Er(o, i), Er(a, i));\n                            break;\n                        }\n                    case \"Seq\":\n                        {\n                            const o = c.left, a = c.right;\n                            t = Er(o, Er(a, i));\n                            break;\n                        }\n                    case \"Single\":\n                        {\n                            t = c, s = vt(i, s);\n                            break;\n                        }\n                }\n                break;\n            }\n        case \"Single\":\n            {\n                if (n = hy(n, t), Je(r)) return [\n                    n,\n                    s\n                ];\n                t = r.head, r = r.tail;\n                break;\n            }\n    }\n    throw new Error(\"BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues\");\n}, uy = (e, t)=>{\n    if (Je(e)) return Li(fc(t));\n    if (gy(t)) return e;\n    const n = Sy(e.head), r = my(t);\n    return n.length === 1 && r.length === 1 && O(n[0], r[0]) ? vt(by(e.head, fc(t)), e.tail) : vt(fc(t), e);\n}, ly = /* @__PURE__ */ Symbol.for(\"effect/RequestBlock/RequestBlockParallel\"), fy = {\n    /* c8 ignore next */ _R: (e)=>e\n};\nvar tu;\ntu = ly;\nclass qi {\n    constructor(t){\n        u(this, \"map\");\n        u(this, tu, fy);\n        this.map = t;\n    }\n}\nconst vf = ()=>new qi(ji()), hy = (e, t)=>new qi(Kp(e.map, t.dataSource, (n)=>Ig(Nr(n, Mm(t.blockedRequest)), ()=>ie(t.blockedRequest)))), dy = (e, t)=>new qi(af(e.map, t.map, (n, r, s)=>cf(n, s, tt(sf(n, s), {\n            onNone: ()=>r,\n            onSome: (c)=>ve(r, c)\n        })))), gy = (e)=>Vp(e.map), my = (e)=>Array.from(of(e.map)), fc = (e)=>yy(Wp(e.map, (t)=>ie(t))), py = /* @__PURE__ */ Symbol.for(\"effect/RequestBlock/RequestBlockSequential\"), _y = {\n    /* c8 ignore next */ _R: (e)=>e\n};\nvar nu;\nnu = py;\nclass wf {\n    constructor(t){\n        u(this, \"map\");\n        u(this, nu, _y);\n        this.map = t;\n    }\n}\nconst yy = (e)=>new wf(e), by = (e, t)=>new wf(af(t.map, e.map, (n, r, s)=>cf(n, s, tt(sf(n, s), {\n            onNone: ()=>Ae(),\n            onSome: (c)=>ve(c, r)\n        })))), Sy = (e)=>Array.from(of(e.map)), ky = (e)=>Array.from(e.map), mn = \"Die\", wt = \"Empty\", Ft = \"Fail\", pn = \"Interrupt\", Yt = \"Parallel\", Qt = \"Sequential\", Of = \"effect/Cause\", $f = /* @__PURE__ */ Symbol.for(Of), vy = {\n    /* c8 ignore next */ _E: (e)=>e\n}, _n = {\n    [$f]: vy,\n    [F] () {\n        return f(k(Of), R(k(jy(this))), q(this));\n    },\n    [E] (e) {\n        return wy(e) && xy(this, e);\n    },\n    pipe () {\n        return w(this, arguments);\n    },\n    toJSON () {\n        switch(this._tag){\n            case \"Empty\":\n                return {\n                    _id: \"Cause\",\n                    _tag: this._tag\n                };\n            case \"Die\":\n                return {\n                    _id: \"Cause\",\n                    _tag: this._tag,\n                    defect: V(this.defect)\n                };\n            case \"Interrupt\":\n                return {\n                    _id: \"Cause\",\n                    _tag: this._tag,\n                    fiberId: this.fiberId.toJSON()\n                };\n            case \"Fail\":\n                return {\n                    _id: \"Cause\",\n                    _tag: this._tag,\n                    failure: V(this.error)\n                };\n            case \"Sequential\":\n            case \"Parallel\":\n                return {\n                    _id: \"Cause\",\n                    _tag: this._tag,\n                    left: V(this.left),\n                    right: V(this.right)\n                };\n        }\n    },\n    toString () {\n        return ar(this);\n    },\n    [U] () {\n        return this.toJSON();\n    }\n}, Zt = /* @__PURE__ */ (()=>{\n    const e = /* @__PURE__ */ Object.create(_n);\n    return e._tag = wt, e;\n})(), Bn = (e)=>{\n    const t = Object.create(_n);\n    return t._tag = Ft, t.error = e, t;\n}, Oe = (e)=>{\n    const t = Object.create(_n);\n    return t._tag = mn, t.defect = e, t;\n}, Te = (e)=>{\n    const t = Object.create(_n);\n    return t._tag = pn, t.fiberId = e, t;\n}, Ot = (e, t)=>{\n    const n = Object.create(_n);\n    return n._tag = Yt, n.left = e, n.right = t, n;\n}, se = (e, t)=>{\n    const n = Object.create(_n);\n    return n._tag = Qt, n.left = e, n.right = t, n;\n}, wy = (e)=>$(e, $f), Oy = (e)=>e._tag === wt, FE = (e)=>e._tag === Ft, $y = (e)=>e._tag === mn, Ey = (e)=>e._tag === wt ? !0 : Xt(e, !0, (t, n)=>{\n        switch(n._tag){\n            case wt:\n                return I(t);\n            case mn:\n            case Ft:\n            case pn:\n                return I(!1);\n            default:\n                return v();\n        }\n    }), Iy = (e)=>ye(Ny(e)), Ui = (e)=>Vi(void 0, Dy)(e), Fy = (e)=>yt(Xt(e, Ae(), (t, n)=>n._tag === Ft ? I(f(t, be(n.error))) : v())), Ry = (e)=>yt(Xt(e, Ae(), (t, n)=>n._tag === mn ? I(f(t, be(n.defect))) : v())), My = (e)=>Xt(e, St(), (t, n)=>n._tag === pn ? I(f(t, Cn(n.fiberId))) : v()), Ty = (e)=>zi(e, (t)=>t._tag === Ft ? I(t.error) : v()), Cy = (e)=>{\n    const t = Ty(e);\n    switch(t._tag){\n        case \"None\":\n            return ae(e);\n        case \"Some\":\n            return $e(t.value);\n    }\n}, Ny = (e)=>zi(e, (t)=>t._tag === pn ? I(t.fiberId) : v()), na = (e)=>Bi(e, {\n        onEmpty: Zt,\n        onFail: ()=>Zt,\n        onDie: Oe,\n        onInterrupt: Te,\n        onSequential: se,\n        onParallel: Ot\n    }), Ay = (e)=>Bi(e, {\n        onEmpty: Zt,\n        onFail: Oe,\n        onDie: Oe,\n        onInterrupt: Te,\n        onSequential: se,\n        onParallel: Ot\n    }), RE = /* @__PURE__ */ l(2, (e, t)=>Py(e, (n)=>Bn(t(n)))), Py = /* @__PURE__ */ l(2, (e, t)=>Bi(e, {\n        onEmpty: Zt,\n        onFail: (n)=>t(n),\n        onDie: (n)=>Oe(n),\n        onInterrupt: (n)=>Te(n),\n        onSequential: (n, r)=>se(n, r),\n        onParallel: (n, r)=>Ot(n, r)\n    })), xy = (e, t)=>{\n    let n = ie(e), r = ie(t);\n    for(; He(n) && He(r);){\n        const [s, c] = f(Ce(n), Xt([\n            St(),\n            Ae()\n        ], (param, d)=>{\n            let [a, h] = param;\n            const [g, p] = Dc(d);\n            return I([\n                f(a, Dn(g)),\n                f(h, ve(p))\n            ]);\n        })), [i, o] = f(Ce(r), Xt([\n            St(),\n            Ae()\n        ], (param, d)=>{\n            let [a, h] = param;\n            const [g, p] = Dc(d);\n            return I([\n                f(a, Dn(g)),\n                f(h, ve(p))\n            ]);\n        }));\n        if (!O(s, i)) return !1;\n        n = c, r = o;\n    }\n    return !0;\n}, jy = (e)=>Ly(ie(e), Ae()), Ly = (e, t)=>{\n    for(;;){\n        const [n, r] = f(e, ki([\n            St(),\n            Ae()\n        ], (param, o)=>{\n            let [c, i] = param;\n            const [a, h] = Dc(o);\n            return [\n                f(c, Dn(a)),\n                f(i, ve(h))\n            ];\n        })), s = Zl(n) > 0 ? f(t, be(n)) : t;\n        if (Tm(r)) return yt(s);\n        e = r, t = s;\n    }\n    throw new Error(ks(\"Cause.flattenCauseLoop\"));\n}, zi = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = [\n        e\n    ];\n    for(; n.length > 0;){\n        const r = n.pop(), s = t(r);\n        switch(s._tag){\n            case \"None\":\n                {\n                    switch(r._tag){\n                        case Qt:\n                        case Yt:\n                            {\n                                n.push(r.right), n.push(r.left);\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"Some\":\n                return s;\n        }\n    }\n    return v();\n}), Dc = (e)=>{\n    let t = e;\n    const n = [];\n    let r = St(), s = Ae();\n    for(; t !== void 0;)switch(t._tag){\n        case wt:\n            {\n                if (n.length === 0) return [\n                    r,\n                    s\n                ];\n                t = n.pop();\n                break;\n            }\n        case Ft:\n            {\n                if (r = Cn(r, ac(t._tag, t.error)), n.length === 0) return [\n                    r,\n                    s\n                ];\n                t = n.pop();\n                break;\n            }\n        case mn:\n            {\n                if (r = Cn(r, ac(t._tag, t.defect)), n.length === 0) return [\n                    r,\n                    s\n                ];\n                t = n.pop();\n                break;\n            }\n        case pn:\n            {\n                if (r = Cn(r, ac(t._tag, t.fiberId)), n.length === 0) return [\n                    r,\n                    s\n                ];\n                t = n.pop();\n                break;\n            }\n        case Qt:\n            {\n                switch(t.left._tag){\n                    case wt:\n                        {\n                            t = t.right;\n                            break;\n                        }\n                    case Qt:\n                        {\n                            t = se(t.left.left, se(t.left.right, t.right));\n                            break;\n                        }\n                    case Yt:\n                        {\n                            t = Ot(se(t.left.left, t.right), se(t.left.right, t.right));\n                            break;\n                        }\n                    default:\n                        {\n                            s = be(s, t.right), t = t.left;\n                            break;\n                        }\n                }\n                break;\n            }\n        case Yt:\n            {\n                n.push(t.right), t = t.left;\n                break;\n            }\n    }\n    throw new Error(ks(\"Cause.evaluateCauseLoop\"));\n}, Dy = {\n    emptyCase: Lo,\n    failCase: bc,\n    dieCase: bc,\n    interruptCase: Lo,\n    sequentialCase: (e, t, n)=>t && n,\n    parallelCase: (e, t, n)=>t && n\n}, ra = \"SequentialCase\", sa = \"ParallelCase\", Bi = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onDie: t, onEmpty: n, onFail: r, onInterrupt: s, onParallel: c, onSequential: i } = param;\n    return Vi(e, void 0, {\n        emptyCase: ()=>n,\n        failCase: (o, a)=>r(a),\n        dieCase: (o, a)=>t(a),\n        interruptCase: (o, a)=>s(a),\n        sequentialCase: (o, a, h)=>i(a, h),\n        parallelCase: (o, a, h)=>c(a, h)\n    });\n}), Xt = /* @__PURE__ */ l(3, (e, t, n)=>{\n    let r = t, s = e;\n    const c = [];\n    for(; s !== void 0;){\n        const i = n(r, s);\n        switch(r = ye(i) ? i.value : r, s._tag){\n            case Qt:\n                {\n                    c.push(s.right), s = s.left;\n                    break;\n                }\n            case Yt:\n                {\n                    c.push(s.right), s = s.left;\n                    break;\n                }\n            default:\n                {\n                    s = void 0;\n                    break;\n                }\n        }\n        s === void 0 && c.length > 0 && (s = c.pop());\n    }\n    return r;\n}), Vi = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = [\n        e\n    ], s = [];\n    for(; r.length > 0;){\n        const i = r.pop();\n        switch(i._tag){\n            case wt:\n                {\n                    s.push(ae(n.emptyCase(t)));\n                    break;\n                }\n            case Ft:\n                {\n                    s.push(ae(n.failCase(t, i.error)));\n                    break;\n                }\n            case mn:\n                {\n                    s.push(ae(n.dieCase(t, i.defect)));\n                    break;\n                }\n            case pn:\n                {\n                    s.push(ae(n.interruptCase(t, i.fiberId)));\n                    break;\n                }\n            case Qt:\n                {\n                    r.push(i.right), r.push(i.left), s.push($e({\n                        _tag: ra\n                    }));\n                    break;\n                }\n            case Yt:\n                {\n                    r.push(i.right), r.push(i.left), s.push($e({\n                        _tag: sa\n                    }));\n                    break;\n                }\n        }\n    }\n    const c = [];\n    for(; s.length > 0;){\n        const i = s.pop();\n        switch(i._tag){\n            case \"Left\":\n                {\n                    switch(i.left._tag){\n                        case ra:\n                            {\n                                const o = c.pop(), a = c.pop(), h = n.sequentialCase(t, o, a);\n                                c.push(h);\n                                break;\n                            }\n                        case sa:\n                            {\n                                const o = c.pop(), a = c.pop(), h = n.parallelCase(t, o, a);\n                                c.push(h);\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"Right\":\n                {\n                    c.push(i.right);\n                    break;\n                }\n        }\n    }\n    if (c.length === 0) throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\");\n    return c.pop();\n}), ar = (e, t)=>Ui(e) ? \"All fibers interrupted without errors.\" : If(e).map(function(n) {\n        return (t == null ? void 0 : t.renderErrorCause) !== !0 || n.cause === void 0 ? n.stack : \"\".concat(n.stack, \" {\\n\").concat(Ef(n.cause, \"  \"), \"\\n}\");\n    }).join(\"\\n\"), Ef = (e, t)=>{\n    const n = e.stack.split(\"\\n\");\n    let r = \"\".concat(t, \"[cause]: \").concat(n[0]);\n    for(let s = 1, c = n.length; s < c; s++)r += \"\\n\".concat(t).concat(n[s]);\n    return e.cause && (r += \" {\\n\".concat(Ef(e.cause, \"\".concat(t, \"  \")), \"\\n\").concat(t, \"}\")), r;\n};\nclass Qr extends globalThis.Error {\n    constructor(n){\n        const r = typeof n == \"object\" && n !== null, s = Error.stackTraceLimit;\n        Error.stackTraceLimit = 1;\n        super(qy(n), r && \"cause\" in n && typeof n.cause < \"u\" ? {\n            cause: new Qr(n.cause)\n        } : void 0);\n        u(this, \"span\");\n        this.message === \"\" && (this.message = \"An error has occurred\"), Error.stackTraceLimit = s, this.name = n instanceof Error ? n.name : \"Error\", r && (en in n && (this.span = n[en]), Object.keys(n).forEach((c)=>{\n            c in this || (this[c] = n[c]);\n        })), this.stack = By(\"\".concat(this.name, \": \").concat(this.message), n instanceof Error && n.stack ? n.stack : \"\", this.span);\n    }\n}\nconst qy = (e)=>{\n    if (typeof e == \"string\") return e;\n    if (typeof e == \"object\" && e !== null && e instanceof Error) return e.message;\n    try {\n        if ($(e, \"toString\") && Zn(e.toString) && e.toString !== Object.prototype.toString && e.toString !== globalThis.Array.prototype.toString) return e.toString();\n    } catch (e) {}\n    return il(e);\n}, Uy = /\\((.*)\\)/g, zy = /* @__PURE__ */ C(\"effect/Tracer/spanToTrace\", ()=>/* @__PURE__ */ new WeakMap()), By = (e, t, n)=>{\n    const r = [\n        e\n    ], s = t.startsWith(e) ? t.slice(e.length).split(\"\\n\") : t.split(\"\\n\");\n    for(let c = 1; c < s.length && !s[c].includes(\"Generator.next\"); c++){\n        if (s[c].includes(\"effect_internal_function\")) {\n            r.pop();\n            break;\n        }\n        r.push(s[c].replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\").replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\"));\n    }\n    if (n) {\n        let c = n, i = 0;\n        for(; c && c._tag === \"Span\" && i < 10;){\n            const o = zy.get(c);\n            if (typeof o == \"function\") {\n                const a = o();\n                if (typeof a == \"string\") {\n                    const h = a.matchAll(Uy);\n                    let d = !1;\n                    for (const [, g] of h)d = !0, r.push(\"    at \".concat(c.name, \" (\").concat(g, \")\"));\n                    d || r.push(\"    at \".concat(c.name, \" (\").concat(a.replace(/^at /, \"\"), \")\"));\n                } else r.push(\"    at \".concat(c.name));\n            } else r.push(\"    at \".concat(c.name));\n            c = it(c.parent), i++;\n        }\n    }\n    return r.join(\"\\n\");\n}, en = /* @__PURE__ */ Symbol.for(\"effect/SpanAnnotation\"), If = (e)=>Vi(e, void 0, {\n        emptyCase: ()=>[],\n        dieCase: (t, n)=>[\n                new Qr(n)\n            ],\n        failCase: (t, n)=>[\n                new Qr(n)\n            ],\n        interruptCase: ()=>[],\n        parallelCase: (t, n, r)=>[\n                ...n,\n                ...r\n            ],\n        sequentialCase: (t, n, r)=>[\n                ...n,\n                ...r\n            ]\n    }), ur = \"Pending\", qs = \"Done\", Vy = \"effect/Deferred\", Ky = /* @__PURE__ */ Symbol.for(Vy), Wy = {\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _A: (e)=>e\n}, Jy = (e)=>({\n        _tag: ur,\n        joiners: e\n    }), Ff = (e)=>({\n        _tag: qs,\n        effect: e\n    });\nclass lr {\n    next(t) {\n        return this.called ? {\n            value: t,\n            done: !0\n        } : (this.called = !0, {\n            value: this.self,\n            done: !1\n        });\n    }\n    return(t) {\n        return {\n            value: t,\n            done: !0\n        };\n    }\n    throw(t) {\n        throw t;\n    }\n    [Symbol.iterator]() {\n        return new lr(this.self);\n    }\n    constructor(t){\n        u(this, \"self\");\n        u(this, \"called\", !1);\n        this.self = t;\n    }\n}\nconst Rf = (e, t)=>{\n    const n = new J(\"Blocked\");\n    return n.effect_instruction_i0 = e, n.effect_instruction_i1 = t, n;\n}, Hy = (e)=>{\n    const t = new J(\"RunBlocked\");\n    return t.effect_instruction_i0 = e, t;\n}, tn = /* @__PURE__ */ Symbol.for(\"effect/Effect\");\nclass Gy {\n    constructor(t, n){\n        u(this, \"patch\");\n        u(this, \"op\");\n        u(this, \"_op\", pi);\n        this.patch = t, this.op = n;\n    }\n}\nvar ru;\nclass J {\n    [(ru = tn, E)](t) {\n        return this === t;\n    }\n    [F]() {\n        return q(this, hi(this));\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    toJSON() {\n        return {\n            _id: \"Effect\",\n            _op: this._op,\n            effect_instruction_i0: V(this.effect_instruction_i0),\n            effect_instruction_i1: V(this.effect_instruction_i1),\n            effect_instruction_i2: V(this.effect_instruction_i2)\n        };\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    [Symbol.iterator]() {\n        return new lr(new Xn(this));\n    }\n    constructor(t){\n        u(this, \"_op\");\n        u(this, \"effect_instruction_i0\");\n        u(this, \"effect_instruction_i1\");\n        u(this, \"effect_instruction_i2\");\n        u(this, \"trace\");\n        u(this, ru, zt);\n        this._op = t;\n    }\n}\nvar su;\nclass Mf {\n    [(su = tn, E)](t) {\n        return eo(t) && t._op === \"Failure\" && // @ts-expect-error\n        O(this.effect_instruction_i0, t.effect_instruction_i0);\n    }\n    [F]() {\n        return f(// @ts-expect-error\n        B(this._tag), // @ts-expect-error\n        R(k(this.effect_instruction_i0)), q(this));\n    }\n    get cause() {\n        return this.effect_instruction_i0;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    toJSON() {\n        return {\n            _id: \"Exit\",\n            _tag: this._op,\n            cause: this.cause.toJSON()\n        };\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    [Symbol.iterator]() {\n        return new lr(new Xn(this));\n    }\n    constructor(t){\n        u(this, \"_op\");\n        u(this, \"effect_instruction_i0\");\n        u(this, \"effect_instruction_i1\");\n        u(this, \"effect_instruction_i2\");\n        u(this, \"trace\");\n        u(this, su, zt);\n        this._op = t, this._tag = t;\n    }\n}\nvar cu;\nclass Tf {\n    [(cu = tn, E)](t) {\n        return eo(t) && t._op === \"Success\" && // @ts-expect-error\n        O(this.effect_instruction_i0, t.effect_instruction_i0);\n    }\n    [F]() {\n        return f(// @ts-expect-error\n        B(this._tag), // @ts-expect-error\n        R(k(this.effect_instruction_i0)), q(this));\n    }\n    get value() {\n        return this.effect_instruction_i0;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    toJSON() {\n        return {\n            _id: \"Exit\",\n            _tag: this._op,\n            value: V(this.value)\n        };\n    }\n    toString() {\n        return Q(this.toJSON());\n    }\n    [U]() {\n        return this.toJSON();\n    }\n    [Symbol.iterator]() {\n        return new lr(new Xn(this));\n    }\n    constructor(t){\n        u(this, \"_op\");\n        u(this, \"effect_instruction_i0\");\n        u(this, \"effect_instruction_i1\");\n        u(this, \"effect_instruction_i2\");\n        u(this, \"trace\");\n        u(this, cu, zt);\n        this._op = t, this._tag = t;\n    }\n}\nconst Le = (e)=>$(e, tn), L = (e)=>{\n    const t = new J(ul);\n    return t.effect_instruction_i0 = e, t;\n}, Cf = /* @__PURE__ */ l(3, (e, t, n)=>Ee((r)=>m(e, (s)=>m(Ye(N(()=>r(t(s)))), (c)=>N(()=>n(s, c)).pipe(Se({\n                    onFailure: (i)=>{\n                        switch(c._tag){\n                            case te:\n                                return Z(se(c.effect_instruction_i0, i));\n                            case ne:\n                                return Z(i);\n                        }\n                    },\n                    onSuccess: ()=>c\n                })))))), fe = /* @__PURE__ */ l(2, (e, t)=>m(e, ()=>S(t))), nt = (e)=>fe(e, void 0), Nf = function() {\n    const e = new J(ws);\n    switch(arguments.length){\n        case 2:\n            {\n                e.effect_instruction_i0 = arguments[0], e.commit = arguments[1];\n                break;\n            }\n        case 3:\n            {\n                e.effect_instruction_i0 = arguments[0], e.effect_instruction_i1 = arguments[1], e.commit = arguments[2];\n                break;\n            }\n        case 4:\n            {\n                e.effect_instruction_i0 = arguments[0], e.effect_instruction_i1 = arguments[1], e.effect_instruction_i2 = arguments[2], e.commit = arguments[3];\n                break;\n            }\n        default:\n            throw new Error(ks(\"you're not supposed to end up here\"));\n    }\n    return e;\n}, Vn = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ht;\n    const n = new J(Rn);\n    let r;\n    return n.effect_instruction_i0 = (s)=>{\n        r = e(s);\n    }, n.effect_instruction_i1 = t, Df(n, (s)=>Le(r) ? r : K);\n}, Af = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ht;\n    return N(()=>Vn(e, t));\n}, xe = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ht;\n    return Nf(e, function() {\n        let n, r;\n        function s(a) {\n            n ? n(a) : r === void 0 && (r = a);\n        }\n        const c = new J(Rn);\n        c.effect_instruction_i0 = (a)=>{\n            n = a, r && a(r);\n        }, c.effect_instruction_i1 = t;\n        let i, o;\n        return this.effect_instruction_i0.length !== 1 ? (o = new AbortController(), i = ee(()=>this.effect_instruction_i0(s, o.signal))) : i = ee(()=>this.effect_instruction_i0(s)), i || o ? Df(c, (a)=>(o && o.abort(), i !== null && i !== void 0 ? i : K)) : c;\n    });\n}, Pf = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new J(Tr);\n    return n.effect_instruction_i0 = e, n.effect_instruction_i1 = t, n;\n}), Zr = /* @__PURE__ */ l(2, (e, t)=>Xe(e, {\n        onFailure: t,\n        onSuccess: S\n    })), ca = /* @__PURE__ */ Symbol.for(\"effect/OriginalAnnotation\"), Ki = (e, t)=>ye(t) ? new Proxy(e, {\n        has (n, r) {\n            return r === en || r === ca || r in n;\n        },\n        get (n, r) {\n            return r === en ? t.value : r === ca ? e : n[r];\n        }\n    }) : e, Xr = (e)=>Ss(e) && !(en in e) ? L((t)=>Z(Oe(Ki(e, io(t))))) : Z(Oe(e)), qc = (e)=>xf(()=>Oe(new Fb(e))), nn = (e)=>Xe(e, {\n        onFailure: (t)=>S($e(t)),\n        onSuccess: (t)=>S(ae(t))\n    }), Ye = (e)=>jf(e, {\n        onFailure: A,\n        onSuccess: j\n    }), x = (e)=>Ss(e) && !(en in e) ? L((t)=>Z(Bn(Ki(e, io(t))))) : Z(Bn(e)), Us = (e)=>m(y(e), x), Z = (e)=>{\n    const t = new Mf(te);\n    return t.effect_instruction_i0 = e, t;\n}, xf = (e)=>m(y(e), Z), Wi = /* @__PURE__ */ L((e)=>S(e.id())), fr = (e)=>L((t)=>e(t.id())), m = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new J(zr);\n    return n.effect_instruction_i0 = e, n.effect_instruction_i1 = t, n;\n}), jt = /* @__PURE__ */ l(2, (e, t)=>m(e, (n)=>{\n        const r = typeof t == \"function\" ? t(n) : t;\n        return Le(r) ? r : nl(r) ? Vn((s)=>{\n            r.then((c)=>s(S(c)), (c)=>s(x(new Gs(c, \"An unknown error occurred in Effect.andThen\"))));\n        }) : S(r);\n    })), Yy = (e)=>{\n    const t = new J(\"OnStep\");\n    return t.effect_instruction_i0 = e, t;\n}, zs = (e)=>m(e, P), jf = /* @__PURE__ */ l(2, (e, t)=>Se(e, {\n        onFailure: (n)=>S(t.onFailure(n)),\n        onSuccess: (n)=>S(t.onSuccess(n))\n    })), Se = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new J(Br);\n    return n.effect_instruction_i0 = e, n.effect_instruction_i1 = t.onFailure, n.effect_instruction_i2 = t.onSuccess, n;\n}), Xe = /* @__PURE__ */ l(2, (e, t)=>Se(e, {\n        onFailure: (n)=>{\n            if (Ry(n).length > 0) return Z(Ay(n));\n            const s = Fy(n);\n            return s.length > 0 ? t.onFailure(jl(s)) : Z(n);\n        },\n        onSuccess: t.onSuccess\n    })), Ke = /* @__PURE__ */ l(2, (e, t)=>N(()=>{\n        const n = z(e), r = Si(n.length);\n        let s = 0;\n        return fe(Yi({\n            while: ()=>s < n.length,\n            body: ()=>t(n[s], s),\n            step: (c)=>{\n                r[s++] = c;\n            }\n        }), r);\n    })), Bs = /* @__PURE__ */ l(2, (e, t)=>N(()=>{\n        const n = z(e);\n        let r = 0;\n        return Yi({\n            while: ()=>r < n.length,\n            body: ()=>t(n[r], r),\n            step: ()=>{\n                r++;\n            }\n        });\n    })), Qy = /* @__PURE__ */ m(Wi, (e)=>Lf(e)), Lf = (e)=>Z(Te(e)), Ji = (e)=>{\n    const t = new J(un);\n    return t.effect_instruction_i0 = iy(gn), t.effect_instruction_i1 = ()=>e, t;\n}, Zy = /* @__PURE__ */ l(2, (e, t)=>Ee((n)=>m(Ye(n(e)), (r)=>xb(t, r)))), T = /* @__PURE__ */ l(2, (e, t)=>m(e, (n)=>y(()=>t(n)))), Hi = /* @__PURE__ */ l(2, (e, t)=>Xe(e, {\n        onFailure: (n)=>Us(()=>t.onFailure(n)),\n        onSuccess: (n)=>y(()=>t.onSuccess(n))\n    })), Vs = /* @__PURE__ */ l(2, (e, t)=>Se(e, {\n        onFailure: (n)=>{\n            const r = Cy(n);\n            switch(r._tag){\n                case \"Left\":\n                    return Us(()=>t(r.left));\n                case \"Right\":\n                    return Z(r.right);\n            }\n        },\n        onSuccess: S\n    })), rn = /* @__PURE__ */ l(2, (e, t)=>Ee((n)=>Se(n(e), {\n            onFailure: (r)=>{\n                const s = A(r);\n                return Se(t(s), {\n                    onFailure: (c)=>A(se(r, c)),\n                    onSuccess: ()=>s\n                });\n            },\n            onSuccess: (r)=>{\n                const s = j(r);\n                return oe(t(s), s);\n            }\n        }))), Df = /* @__PURE__ */ l(2, (e, t)=>rn(e, to({\n        onFailure: (n)=>Ui(n) ? nt(t(My(n))) : K,\n        onSuccess: ()=>K\n    }))), Xy = (e)=>eb(e, P), eb = /* @__PURE__ */ l(2, (e, t)=>Xe(e, {\n        onFailure: (n)=>Xr(t(n)),\n        onSuccess: S\n    })), S = (e)=>{\n    const t = new Tf(ne);\n    return t.effect_instruction_i0 = e, t;\n}, N = (e)=>{\n    const t = new J(ws);\n    return t.commit = e, t;\n}, y = (e)=>{\n    const t = new J(al);\n    return t.effect_instruction_i0 = e, t;\n}, Gi = /* @__PURE__ */ l((e)=>e.length === 3 || e.length === 2 && !(Ss(e[1]) && \"onlyEffect\" in e[1]), (e, t)=>m(e, (n)=>{\n        const r = typeof t == \"function\" ? t(n) : t;\n        return Le(r) ? fe(r, n) : nl(r) ? Vn((s)=>{\n            r.then((c)=>s(S(n)), (c)=>s(x(new Gs(c, \"An unknown error occurred in Effect.tap\"))));\n        }) : S(n);\n    })), tb = (e)=>L((t)=>{\n        const n = t.getFiberRef(zc), r = f(n, de(()=>t.scope()));\n        return e(hr(zc, I(r)));\n    }), Ks = (e)=>{\n    const t = new J(un);\n    return t.effect_instruction_i0 = Sf(gn), t.effect_instruction_i1 = ()=>e, t;\n}, Ee = (e)=>Nf(e, function() {\n        const t = new J(un);\n        return t.effect_instruction_i0 = Sf(gn), t.effect_instruction_i1 = (n)=>yf(n) ? ee(()=>this.effect_instruction_i0(Ji)) : ee(()=>this.effect_instruction_i0(Ks)), t;\n    }), K = /* @__PURE__ */ S(void 0), nb = (e)=>{\n    const t = new J(un);\n    return t.effect_instruction_i0 = e, t.effect_instruction_i1 = void 0, t;\n}, rb = /* @__PURE__ */ l(2, (e, t)=>m(t, (n)=>n ? f(e, T(I)) : S(v()))), Yi = (e)=>{\n    const t = new J(Vr);\n    return t.effect_instruction_i0 = e.while, t.effect_instruction_i1 = e.body, t.effect_instruction_i2 = e.step, t;\n}, sb = (e)=>N(()=>{\n        const t = new J(Mn);\n        return t.effect_instruction_i0 = e(), t;\n    }), cb = function() {\n    const e = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);\n    return sb(()=>e(f));\n}, ib = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new J(un);\n    return n.effect_instruction_i0 = t, n.effect_instruction_i1 = ()=>e, n;\n}), Qi = (e)=>{\n    const t = new J(Cr);\n    return typeof (e == null ? void 0 : e.priority) < \"u\" ? Ob(t, e.priority) : t;\n}, qf = /* @__PURE__ */ l(2, (e, t)=>m(e, (n)=>T(t, (r)=>[\n                n,\n                r\n            ]))), Zi = /* @__PURE__ */ l(2, (e, t)=>m(e, (n)=>fe(t, n))), oe = /* @__PURE__ */ l(2, (e, t)=>m(e, ()=>t)), Uf = /* @__PURE__ */ l(3, (e, t, n)=>m(e, (r)=>T(t, (s)=>n(r, s)))), zf = (e)=>m(Wi, (t)=>f(e, es(t))), es = /* @__PURE__ */ l(2, (e, t)=>m(e.interruptAsFork(t), ()=>e.await)), ob = {\n    _tag: \"All\",\n    syslog: 0,\n    label: \"ALL\",\n    ordinal: Number.MIN_SAFE_INTEGER,\n    pipe () {\n        return w(this, arguments);\n    }\n}, ab = {\n    _tag: \"Fatal\",\n    syslog: 2,\n    label: \"FATAL\",\n    ordinal: 5e4,\n    pipe () {\n        return w(this, arguments);\n    }\n}, ub = {\n    _tag: \"Error\",\n    syslog: 3,\n    label: \"ERROR\",\n    ordinal: 4e4,\n    pipe () {\n        return w(this, arguments);\n    }\n}, lb = {\n    _tag: \"Warning\",\n    syslog: 4,\n    label: \"WARN\",\n    ordinal: 3e4,\n    pipe () {\n        return w(this, arguments);\n    }\n}, Bf = {\n    _tag: \"Info\",\n    syslog: 6,\n    label: \"INFO\",\n    ordinal: 2e4,\n    pipe () {\n        return w(this, arguments);\n    }\n}, Vf = {\n    _tag: \"Debug\",\n    syslog: 7,\n    label: \"DEBUG\",\n    ordinal: 1e4,\n    pipe () {\n        return w(this, arguments);\n    }\n}, fb = {\n    _tag: \"Trace\",\n    syslog: 7,\n    label: \"TRACE\",\n    ordinal: 0,\n    pipe () {\n        return w(this, arguments);\n    }\n}, hb = {\n    _tag: \"None\",\n    syslog: 7,\n    label: \"OFF\",\n    ordinal: Number.MAX_SAFE_INTEGER,\n    pipe () {\n        return w(this, arguments);\n    }\n}, db = \"effect/FiberRef\", gb = /* @__PURE__ */ Symbol.for(db), mb = {\n    /* c8 ignore next */ _A: (e)=>e\n}, Xi = (e)=>L((t)=>j(t.getFiberRef(e))), Ws = /* @__PURE__ */ l(2, (e, t)=>m(Xi(e), t)), ia = /* @__PURE__ */ l(2, (e, t)=>pb(e, ()=>[\n            void 0,\n            t\n        ])), pb = /* @__PURE__ */ l(2, (e, t)=>L((n)=>{\n        const [r, s] = t(n.getFiberRef(e));\n        return n.setFiberRef(e, s), S(r);\n    })), hr = /* @__PURE__ */ l(3, (e, t, n)=>Cf(Zi(Xi(t), ia(t, n)), ()=>e, (r)=>ia(t, r))), _b = /* @__PURE__ */ l(3, (e, t, n)=>Ws(t, (r)=>hr(e, t, n(r)))), ge = (e, t)=>{\n    var _ref;\n    return yn(e, {\n        differ: gf(),\n        fork: (_ref = t == null ? void 0 : t.fork) !== null && _ref !== void 0 ? _ref : P,\n        join: t == null ? void 0 : t.join\n    });\n}, yb = (e)=>{\n    const t = K_();\n    return yn(e, {\n        differ: t,\n        fork: t.empty\n    });\n}, bb = (e)=>{\n    const t = W_(gf());\n    return yn(e, {\n        differ: t,\n        fork: t.empty\n    });\n}, Kf = (e)=>{\n    const t = V_();\n    return yn(e, {\n        differ: t,\n        fork: t.empty\n    });\n}, yn = (e, t)=>{\n    var _t_join;\n    return {\n        ...nr,\n        [gb]: mb,\n        initial: e,\n        commit () {\n            return Xi(this);\n        },\n        diff: (r, s)=>t.differ.diff(r, s),\n        combine: (r, s)=>t.differ.combine(r, s),\n        patch: (r)=>(s)=>t.differ.patch(r, s),\n        fork: t.fork,\n        join: (_t_join = t.join) !== null && _t_join !== void 0 ? _t_join : (r, s)=>s\n    };\n}, Sb = (e)=>yn(e, {\n        differ: ea,\n        fork: ea.empty\n    }), rt = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentContext\"), ()=>Kf(Oi())), dr = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"), ()=>ge(0)), Wf = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"), ()=>ge(2048)), kb = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentLogAnnotation\"), ()=>ge(ji())), vb = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentLogLevel\"), ()=>ge(Bf)), wb = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentLogSpan\"), ()=>ge(Gt())), Ob = /* @__PURE__ */ l(2, (e, t)=>hr(e, dr, t)), $b = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentConcurrency\"), ()=>ge(\"unbounded\")), Eb = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentRequestBatching\"), ()=>ge(!0)), Ib = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"), ()=>ge(I(Vf))), Uc = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentMetricLabels\"), ()=>bb(Bt())), zc = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"), ()=>ge(v(), {\n        fork: ()=>v(),\n        join: (e, t)=>e\n    })), Ir = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentInterruptedCause\"), ()=>ge(Zt, {\n        fork: ()=>Zt,\n        join: (e, t)=>e\n    })), oa = /* @__PURE__ */ Symbol.for(\"effect/Scope\"), aa = /* @__PURE__ */ Symbol.for(\"effect/CloseableScope\"), Jf = (e, t)=>e.addFinalizer(()=>nt(t)), ts = (e, t)=>e.addFinalizer(t), Bc = (e, t)=>e.close(t), Js = (e, t)=>e.fork(t), Hf = /* @__PURE__ */ function() {\n    class e extends globalThis.Error {\n        commit() {\n            return x(this);\n        }\n        toJSON() {\n            const n = {\n                ...this\n            };\n            return this.message && (n.message = this.message), this.cause && (n.cause = this.cause), n;\n        }\n        [U]() {\n            return this.toString !== globalThis.Error.prototype.toString ? this.stack ? \"\".concat(this.toString(), \"\\n\").concat(this.stack.split(\"\\n\").slice(1).join(\"\\n\")) : this.toString() : \"Bun\" in globalThis ? ar(Bn(this), {\n                renderErrorCause: !0\n            }) : this;\n        }\n    }\n    return Object.assign(e.prototype, fg), e;\n}(), Gf = (e, t)=>{\n    class n extends Hf {\n        constructor(){\n            super(...arguments);\n            u(this, \"_tag\", t);\n        }\n    }\n    return Object.assign(n.prototype, e), n.prototype.name = t, n;\n}, ua = /* @__PURE__ */ Symbol.for(\"effect/Cause/errors/RuntimeException\"), Fb = /* @__PURE__ */ Gf({\n    [ua]: ua\n}, \"RuntimeException\"), Rb = /* @__PURE__ */ Symbol.for(\"effect/Cause/errors/InterruptedException\"), Mb = (e)=>$(e, Rb), la = /* @__PURE__ */ Symbol.for(\"effect/Cause/errors/NoSuchElement\"), Hs = /* @__PURE__ */ Gf({\n    [la]: la\n}, \"NoSuchElementException\"), fa = /* @__PURE__ */ Symbol.for(\"effect/Cause/errors/UnknownException\"), Gs = /* @__PURE__ */ function() {\n    class e extends Hf {\n        constructor(r, s){\n            super(s !== null && s !== void 0 ? s : \"An unknown error occurred\", {\n                cause: r\n            });\n            u(this, \"_tag\", \"UnknownException\");\n            u(this, \"error\");\n            this.error = r;\n        }\n    }\n    return Object.assign(e.prototype, {\n        [fa]: fa,\n        name: \"UnknownException\"\n    }), e;\n}(), eo = (e)=>Le(e) && \"_tag\" in e && (e._tag === \"Success\" || e._tag === \"Failure\"), ME = (e)=>e._tag === \"Failure\", TE = (e)=>e._tag === \"Success\", Tb = /* @__PURE__ */ l(2, (e, t)=>{\n    switch(e._tag){\n        case te:\n            return A(e.effect_instruction_i0);\n        case ne:\n            return j(t);\n    }\n}), hc = (e)=>Tb(e, void 0), Nn = (e, t)=>Nb(e, t != null && t.parallel ? Ot : se), Fn = (e)=>A(Oe(e)), ha = (e)=>A(Bn(e)), A = (e)=>{\n    const t = new Mf(te);\n    return t.effect_instruction_i0 = e, t;\n}, Cb = (e)=>A(Te(e)), dc = /* @__PURE__ */ l(2, (e, t)=>{\n    switch(e._tag){\n        case te:\n            return A(e.effect_instruction_i0);\n        case ne:\n            return j(t(e.effect_instruction_i0));\n    }\n}), to = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onFailure: t, onSuccess: n } = param;\n    switch(e._tag){\n        case te:\n            return t(e.effect_instruction_i0);\n        case ne:\n            return n(e.effect_instruction_i0);\n    }\n}), Vc = /* @__PURE__ */ l(2, (e, param)=>{\n    let { onFailure: t, onSuccess: n } = param;\n    switch(e._tag){\n        case te:\n            return t(e.effect_instruction_i0);\n        case ne:\n            return n(e.effect_instruction_i0);\n    }\n}), j = (e)=>{\n    const t = new Tf(ne);\n    return t.effect_instruction_i0 = e, t;\n}, Ne = /* @__PURE__ */ j(void 0), CE = /* @__PURE__ */ l(2, (e, t)=>no(e, t, {\n        onSuccess: (n, r)=>[\n                n,\n                r\n            ],\n        onFailure: se\n    })), NE = /* @__PURE__ */ l(2, (e, t)=>no(e, t, {\n        onSuccess: (n, r)=>r,\n        onFailure: se\n    })), no = /* @__PURE__ */ l(3, (e, t, param)=>{\n    let { onFailure: n, onSuccess: r } = param;\n    switch(e._tag){\n        case te:\n            switch(t._tag){\n                case ne:\n                    return A(e.effect_instruction_i0);\n                case te:\n                    return A(n(e.effect_instruction_i0, t.effect_instruction_i0));\n            }\n        case ne:\n            switch(t._tag){\n                case ne:\n                    return j(r(e.effect_instruction_i0, t.effect_instruction_i0));\n                case te:\n                    return A(t.effect_instruction_i0);\n            }\n    }\n}), Nb = (e, t)=>{\n    const n = Pl(e);\n    return He(n) ? f(Ve(n), ki(f(Ce(n), dc(ie)), (r, s)=>f(r, no(s, {\n            onSuccess: (c, i)=>f(c, be(i)),\n            onFailure: t\n        }))), dc(yt), dc((r)=>We(r)), I) : v();\n}, Yf = (e)=>({\n        ...nr,\n        [Ky]: Wy,\n        state: Ps(Jy([])),\n        commit () {\n            return ro(this);\n        },\n        blockingOn: e\n    }), Ab = ()=>m(Wi, (e)=>Pb(e)), Pb = (e)=>y(()=>Yf(e)), ro = (e)=>Af((t)=>{\n        const n = Ze(e.state);\n        switch(n._tag){\n            case qs:\n                return t(n.effect);\n            case ur:\n                return n.joiners.push(t), Db(e, t);\n        }\n    }, e.blockingOn), Ys = /* @__PURE__ */ l(2, (e, t)=>y(()=>{\n        const n = Ze(e.state);\n        switch(n._tag){\n            case qs:\n                return !1;\n            case ur:\n                {\n                    xs(e.state, Ff(t));\n                    for(let r = 0, s = n.joiners.length; r < s; r++)n.joiners[r](t);\n                    return !0;\n                }\n        }\n    })), xb = /* @__PURE__ */ l(2, (e, t)=>Ys(e, t)), jb = /* @__PURE__ */ l(2, (e, t)=>Ys(e, Z(t))), AE = /* @__PURE__ */ l(2, (e, t)=>Ys(e, Lf(t))), PE = (e)=>y(()=>Ze(e.state)._tag === qs), Lb = /* @__PURE__ */ l(2, (e, t)=>Ys(e, S(t))), Qf = (e, t)=>{\n    const n = Ze(e.state);\n    if (n._tag === ur) {\n        xs(e.state, Ff(t));\n        for(let r = 0, s = n.joiners.length; r < s; r++)n.joiners[r](t);\n    }\n}, Db = (e, t)=>y(()=>{\n        const n = Ze(e.state);\n        if (n._tag === ur) {\n            const r = n.joiners.indexOf(t);\n            r >= 0 && n.joiners.splice(r, 1);\n        }\n    }), qb = /* @__PURE__ */ L((e)=>j(e.currentContext)), Zf = ()=>qb, bn = (e)=>m(Zf(), e), so = /* @__PURE__ */ l(2, (e, t)=>hr(rt, t)(e)), co = /* @__PURE__ */ l(2, (e, t)=>_b(rt, (n)=>fn(n, t))(e)), Ub = /* @__PURE__ */ l(2, (e, t)=>bn((n)=>so(e, t(n)))), io = (e)=>{\n    const t = e.currentSpan;\n    return t !== void 0 && t._tag === \"Span\" ? I(t) : v();\n}, da = /* @__PURE__ */ Symbol.for(\"effect/MutableHashMap\"), zb = {\n    [da]: da,\n    [Symbol.iterator] () {\n        return new oo(this);\n    },\n    toString () {\n        return Q(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"MutableHashMap\",\n            values: Array.from(this).map(V)\n        };\n    },\n    [U] () {\n        return this.toJSON();\n    },\n    pipe () {\n        return w(this, arguments);\n    }\n};\nclass oo {\n    next() {\n        if (this.bucketIterator !== void 0) return this.bucketIterator.next();\n        const t = this.referentialIterator.next();\n        return t.done ? (this.bucketIterator = new Bb(this.self.buckets.values()), this.next()) : t;\n    }\n    [Symbol.iterator]() {\n        return new oo(this.self);\n    }\n    constructor(t){\n        u(this, \"self\");\n        u(this, \"referentialIterator\");\n        u(this, \"bucketIterator\");\n        this.self = t, this.referentialIterator = t.referential[Symbol.iterator]();\n    }\n}\nclass Bb {\n    next() {\n        if (this.currentBucket === void 0) {\n            const n = this.backing.next();\n            if (n.done) return n;\n            this.currentBucket = n.value[Symbol.iterator]();\n        }\n        const t = this.currentBucket.next();\n        return t.done ? (this.currentBucket = void 0, this.next()) : t;\n    }\n    constructor(t){\n        u(this, \"backing\");\n        u(this, \"currentBucket\");\n        this.backing = t;\n    }\n}\nconst Vb = ()=>{\n    const e = Object.create(zb);\n    return e.referential = /* @__PURE__ */ new Map(), e.buckets = /* @__PURE__ */ new Map(), e.bucketsSize = 0, e;\n}, ot = /* @__PURE__ */ l(2, (e, t)=>{\n    if (Ur(t) === !1) return e.referential.has(t) ? I(e.referential.get(t)) : v();\n    const n = t[F](), r = e.buckets.get(n);\n    return r === void 0 ? v() : Kb(e, r, t);\n}), Kb = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n    for(let s = 0, c = t.length; s < c; s++)if (n[E](t[s][0])) {\n        const i = t[s][1];\n        return r && (t.splice(s, 1), e.bucketsSize--), I(i);\n    }\n    return v();\n}, On = /* @__PURE__ */ l(2, (e, t)=>ye(ot(e, t))), $n = /* @__PURE__ */ l(3, (e, t, n)=>{\n    if (Ur(t) === !1) return e.referential.set(t, n), e;\n    const r = t[F](), s = e.buckets.get(r);\n    return s === void 0 ? (e.buckets.set(r, [\n        [\n            t,\n            n\n        ]\n    ]), e.bucketsSize++, e) : (Wb(e, s, t), s.push([\n        t,\n        n\n    ]), e.bucketsSize++, e);\n}), Wb = (e, t, n)=>{\n    for(let r = 0, s = t.length; r < s; r++)if (n[E](t[r][0])) {\n        t.splice(r, 1), e.bucketsSize--;\n        return;\n    }\n}, Jb = \"effect/Clock\", ga = /* @__PURE__ */ Symbol.for(Jb), Qs = /* @__PURE__ */ It(\"effect/Clock\"), Hb = 2 ** 31 - 1, ma = {\n    unsafeSchedule (e, t) {\n        const n = Ic(t);\n        if (n > Hb) return bc;\n        let r = !1;\n        const s = setTimeout(()=>{\n            r = !0, e();\n        }, n);\n        return ()=>(clearTimeout(s), !r);\n    }\n}, pa = /* @__PURE__ */ function() {\n    const e = /* @__PURE__ */ BigInt(1e6);\n    if (typeof performance > \"u\") return ()=>BigInt(Date.now()) * e;\n    if (typeof performance.timeOrigin == \"number\" && performance.timeOrigin === 0) return ()=>BigInt(Math.round(performance.now() * 1e6));\n    const t = /* @__PURE__ */ BigInt(/* @__PURE__ */ Date.now()) * e - /* @__PURE__ */ BigInt(/* @__PURE__ */ Math.round(/* @__PURE__ */ performance.now() * 1e6));\n    return ()=>t + BigInt(Math.round(performance.now() * 1e6));\n}(), Gb = /* @__PURE__ */ function() {\n    const e = typeof process == \"object\" && \"hrtime\" in process && typeof process.hrtime.bigint == \"function\" ? process.hrtime : void 0;\n    if (!e) return pa;\n    const t = /* @__PURE__ */ pa() - /* @__PURE__ */ e.bigint();\n    return ()=>t + e.bigint();\n}();\nvar iu;\niu = ga;\nclass Yb {\n    unsafeCurrentTimeMillis() {\n        return Date.now();\n    }\n    unsafeCurrentTimeNanos() {\n        return Gb();\n    }\n    scheduler() {\n        return S(ma);\n    }\n    sleep(t) {\n        return xe((n)=>{\n            const r = ma.unsafeSchedule(()=>n(K), t);\n            return nt(y(r));\n        });\n    }\n    constructor(){\n        u(this, iu, ga);\n        u(this, \"currentTimeMillis\", /* @__PURE__ */ y(()=>this.unsafeCurrentTimeMillis()));\n        u(this, \"currentTimeNanos\", /* @__PURE__ */ y(()=>this.unsafeCurrentTimeNanos()));\n    }\n}\nconst Qb = ()=>new Yb(), Xf = \"And\", eh = \"Or\", th = \"InvalidData\", nh = \"MissingData\", rh = \"SourceUnavailable\", sh = \"Unsupported\", Zb = \"effect/ConfigError\", _a = /* @__PURE__ */ Symbol.for(Zb), Sn = {\n    _tag: \"ConfigError\",\n    [_a]: _a\n}, ch = (e, t)=>{\n    const n = Object.create(Sn);\n    return n._op = Xf, n.left = e, n.right = t, Object.defineProperty(n, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"\".concat(this.left, \" and \").concat(this.right);\n        }\n    }), n;\n}, ih = (e, t)=>{\n    const n = Object.create(Sn);\n    return n._op = eh, n.left = e, n.right = t, Object.defineProperty(n, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"\".concat(this.left, \" or \").concat(this.right);\n        }\n    }), n;\n}, Xb = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n        pathDelim: \".\"\n    };\n    const r = Object.create(Sn);\n    return r._op = th, r.path = e, r.message = t, Object.defineProperty(r, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"(Invalid data at \".concat(f(this.path, ln(n.pathDelim)), ': \"').concat(this.message, '\")');\n        }\n    }), r;\n}, $t = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n        pathDelim: \".\"\n    };\n    const r = Object.create(Sn);\n    return r._op = nh, r.path = e, r.message = t, Object.defineProperty(r, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"(Missing data at \".concat(f(this.path, ln(n.pathDelim)), ': \"').concat(this.message, '\")');\n        }\n    }), r;\n}, eS = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n        pathDelim: \".\"\n    };\n    const s = Object.create(Sn);\n    return s._op = rh, s.path = e, s.message = t, s.cause = n, Object.defineProperty(s, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"(Source unavailable at \".concat(f(this.path, ln(r.pathDelim)), ': \"').concat(this.message, '\")');\n        }\n    }), s;\n}, tS = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n        pathDelim: \".\"\n    };\n    const r = Object.create(Sn);\n    return r._op = sh, r.path = e, r.message = t, Object.defineProperty(r, \"toString\", {\n        enumerable: !1,\n        value () {\n            return \"(Unsupported operation at \".concat(f(this.path, ln(n.pathDelim)), ': \"').concat(this.message, '\")');\n        }\n    }), r;\n}, ut = /* @__PURE__ */ l(2, (e, t)=>{\n    switch(e._op){\n        case Xf:\n            return ch(ut(e.left, t), ut(e.right, t));\n        case eh:\n            return ih(ut(e.left, t), ut(e.right, t));\n        case th:\n            return Xb([\n                ...t,\n                ...e.path\n            ], e.message);\n        case nh:\n            return $t([\n                ...t,\n                ...e.path\n            ], e.message);\n        case rh:\n            return eS([\n                ...t,\n                ...e.path\n            ], e.message, e.cause);\n        case sh:\n            return tS([\n                ...t,\n                ...e.path\n            ], e.message);\n    }\n}), nS = {\n    _tag: \"Empty\"\n}, gc = /* @__PURE__ */ l(2, (e, t)=>{\n    let n = Li(t), r = e;\n    for(; Zp(n);){\n        const s = n.head;\n        switch(s._tag){\n            case \"Empty\":\n                {\n                    n = n.tail;\n                    break;\n                }\n            case \"AndThen\":\n                {\n                    n = vt(s.first, vt(s.second, n.tail));\n                    break;\n                }\n            case \"MapName\":\n                {\n                    r = ft(r, s.f), n = n.tail;\n                    break;\n                }\n            case \"Nested\":\n                {\n                    r = Kr(r, s.name), n = n.tail;\n                    break;\n                }\n            case \"Unnested\":\n                {\n                    if (f(Tn(r), Cg(s.name))) r = _t(r), n = n.tail;\n                    else return $e($t(r, \"Expected \".concat(s.name, \" to be in path in ConfigProvider#unnested\")));\n                    break;\n                }\n        }\n    }\n    return ae(r);\n}), rS = \"Constant\", sS = \"Fail\", cS = \"Fallback\", iS = \"Described\", oS = \"Lazy\", aS = \"MapOrFail\", uS = \"Nested\", lS = \"Primitive\", fS = \"Sequence\", hS = \"HashMap\", dS = \"ZipWith\", ns = (e, t)=>[\n        ...e,\n        ...t\n    ], gS = \"effect/ConfigProvider\", ya = /* @__PURE__ */ Symbol.for(gS), mS = /* @__PURE__ */ It(\"effect/ConfigProvider\"), pS = \"effect/ConfigProviderFlat\", ba = /* @__PURE__ */ Symbol.for(pS), _S = (e)=>({\n        [ya]: ya,\n        pipe () {\n            return w(this, arguments);\n        },\n        ...e\n    }), yS = (e)=>({\n        [ba]: ba,\n        patch: e.patch,\n        load: function(t, n) {\n            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n            return e.load(t, n, r);\n        },\n        enumerateChildren: e.enumerateChildren\n    }), bS = (e)=>_S({\n        load: (t)=>m(_e(e, Bt(), t, !1), (n)=>tt(Tn(n), {\n                    onNone: ()=>x($t(Bt(), \"Expected a single value having structure: \".concat(t))),\n                    onSome: S\n                })),\n        flattened: e\n    }), SS = (e)=>{\n    const { pathDelim: t, seqDelim: n } = Object.assign({}, {\n        pathDelim: \"_\",\n        seqDelim: \",\"\n    }, e), r = (a)=>f(a, ln(t)), s = (a)=>a.split(t), c = ()=>typeof process < \"u\" && \"env\" in process && typeof process.env == \"object\" ? process.env : {};\n    return bS(yS({\n        load: function(a, h) {\n            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n            const g = r(a), p = c(), _ = g in p ? I(p[g]) : v();\n            return f(_, Vs(()=>$t(a, \"Expected \".concat(g, \" to exist in the process context\"))), m((b)=>$S(b, a, h, n, d)));\n        },\n        enumerateChildren: (a)=>y(()=>{\n                const h = c(), p = Object.keys(h).map((_)=>s(_.toUpperCase())).filter((_)=>{\n                    for(let b = 0; b < a.length; b++){\n                        const M = f(a, vl(b)), D = _[b];\n                        if (D === void 0 || M !== D) return !1;\n                    }\n                    return !0;\n                }).flatMap((_)=>_.slice(a.length, a.length + 1));\n                return Tp(p);\n            }),\n        patch: nS\n    }));\n}, kS = (e, t, n, r)=>{\n    const s = zo(n.length, (a)=>a >= r.length ? v() : I([\n            e(a),\n            a + 1\n        ])), c = zo(r.length, (a)=>a >= n.length ? v() : I([\n            t(a),\n            a + 1\n        ])), i = ns(n, s), o = ns(r, c);\n    return [\n        i,\n        o\n    ];\n}, vS = (e, t)=>{\n    let n = t;\n    if (n._tag === \"Nested\") {\n        const r = e.slice();\n        for(; n._tag === \"Nested\";)r.push(n.name), n = n.config;\n        return r;\n    }\n    return e;\n}, _e = (e, t, n, r)=>{\n    const s = n;\n    switch(s._tag){\n        case rS:\n            return S(ke(s.value));\n        case iS:\n            return N(()=>_e(e, t, s.config, r));\n        case sS:\n            return x($t(t, s.message));\n        case cS:\n            return f(N(()=>_e(e, t, s.first, r)), Zr((c)=>s.condition(c) ? f(_e(e, t, s.second, r), Zr((i)=>x(ih(c, i)))) : x(c)));\n        case oS:\n            return N(()=>_e(e, t, s.config(), r));\n        case aS:\n            return N(()=>f(_e(e, t, s.original, r), m(Ke((c)=>f(s.mapOrFail(c), Vs(ut(vS(t, s.original))))))));\n        case uS:\n            return N(()=>_e(e, ns(t, ke(s.name)), s.config, r));\n        case lS:\n            return f(gc(t, e.patch), m((c)=>f(e.load(c, s, r), m((i)=>{\n                    if (i.length === 0) {\n                        const o = f(zg(c), de(()=>\"<n/a>\"));\n                        return x($t([], \"Expected \".concat(s.description, \" with name \").concat(o)));\n                    }\n                    return S(i);\n                }))));\n        case fS:\n            return f(gc(t, e.patch), m((c)=>f(e.enumerateChildren(c), m(IS), m((i)=>i.length === 0 ? N(()=>T(_e(e, t, s.config, !0), ke)) : f(Ke(i, (o)=>_e(e, xg(t, \"[\".concat(o, \"]\")), s.config, !0)), T((o)=>{\n                        const a = Xg(o);\n                        return a.length === 0 ? ke(Bt()) : ke(a);\n                    }))))));\n        case hS:\n            return N(()=>f(gc(t, e.patch), m((c)=>f(e.enumerateChildren(c), m((i)=>f(i, Ke((o)=>_e(e, ns(c, ke(o)), s.valueConfig, r)), T((o)=>o.length === 0 ? ke(ji()) : f(ES(o), ft((a)=>Bp(Uo(z(i), a)))))))))));\n        case dS:\n            return N(()=>f(_e(e, t, s.left, r), nn, m((c)=>f(_e(e, t, s.right, r), nn, m((i)=>{\n                        if (at(c) && at(i)) return x(ch(c.left, i.left));\n                        if (at(c) && Pt(i)) return x(c.left);\n                        if (Pt(c) && at(i)) return x(i.left);\n                        if (Pt(c) && Pt(i)) {\n                            const o = f(t, ln(\".\")), a = wS(t, o), [h, d] = kS(a, a, f(c.right, ft(ae)), f(i.right, ft(ae)));\n                            return f(h, Uo(d), Ke((param)=>{\n                                let [g, p] = param;\n                                return f(qf(g, p), T((param)=>{\n                                    let [_, b] = param;\n                                    return s.zip(_, b);\n                                }));\n                            }));\n                        }\n                        throw new Error(\"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues\");\n                    })))));\n    }\n}, wS = (e, t)=>(n)=>$e($t(e, \"The element at index \".concat(n, ' in a sequence at path \"').concat(t, '\" was missing'))), OS = (e, t)=>e.split(new RegExp(\"\\\\s*\".concat(nm(t), \"\\\\s*\"))), $S = (e, t, n, r, s)=>s ? f(OS(e, r), Ke((c)=>n.parse(c.trim())), Vs(ut(t))) : f(n.parse(e), Hi({\n        onFailure: ut(t),\n        onSuccess: ke\n    })), ES = (e)=>Object.keys(e[0]).map((t)=>e.map((n)=>n[t])), IS = (e)=>f(Ke(e, RS), Hi({\n        onFailure: ()=>Bt(),\n        onSuccess: Wr(xn)\n    }), nn, T(vg)), FS = /^(\\[(\\d+)\\])$/, RS = (e)=>{\n    const t = e.match(FS);\n    if (t !== null) {\n        const n = t[2];\n        return f(n !== void 0 && n.length > 0 ? I(n) : v(), bl(MS));\n    }\n    return v();\n}, MS = (e)=>{\n    const t = Number.parseInt(e);\n    return Number.isNaN(t) ? v() : I(t);\n}, Sa = /* @__PURE__ */ Symbol.for(\"effect/Console\"), oh = /* @__PURE__ */ It(\"effect/Console\"), TS = {\n    [Sa]: Sa,\n    assert (e) {\n        for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            t[_key - 1] = arguments[_key];\n        }\n        return y(()=>{\n            console.assert(e, ...t);\n        });\n    },\n    clear: /* @__PURE__ */ y(()=>{\n        console.clear();\n    }),\n    count (e) {\n        return y(()=>{\n            console.count(e);\n        });\n    },\n    countReset (e) {\n        return y(()=>{\n            console.countReset(e);\n        });\n    },\n    debug () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.debug(...e);\n        });\n    },\n    dir (e, t) {\n        return y(()=>{\n            console.dir(e, t);\n        });\n    },\n    dirxml () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.dirxml(...e);\n        });\n    },\n    error () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.error(...e);\n        });\n    },\n    group (e) {\n        return e != null && e.collapsed ? y(()=>console.groupCollapsed(e == null ? void 0 : e.label)) : y(()=>console.group(e == null ? void 0 : e.label));\n    },\n    groupEnd: /* @__PURE__ */ y(()=>{\n        console.groupEnd();\n    }),\n    info () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.info(...e);\n        });\n    },\n    log () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.log(...e);\n        });\n    },\n    table (e, t) {\n        return y(()=>{\n            console.table(e, t);\n        });\n    },\n    time (e) {\n        return y(()=>console.time(e));\n    },\n    timeEnd (e) {\n        return y(()=>console.timeEnd(e));\n    },\n    timeLog (e) {\n        for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            t[_key - 1] = arguments[_key];\n        }\n        return y(()=>{\n            console.timeLog(e, ...t);\n        });\n    },\n    trace () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.trace(...e);\n        });\n    },\n    warn () {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return y(()=>{\n            console.warn(...e);\n        });\n    },\n    unsafe: console\n}, CS = \"effect/Random\", ka = /* @__PURE__ */ Symbol.for(CS), NS = /* @__PURE__ */ It(\"effect/Random\");\nvar ou;\nou = ka;\nclass AS {\n    get next() {\n        return y(()=>this.PRNG.number());\n    }\n    get nextBoolean() {\n        return T(this.next, (t)=>t > 0.5);\n    }\n    get nextInt() {\n        return y(()=>this.PRNG.integer(Number.MAX_SAFE_INTEGER));\n    }\n    nextRange(t, n) {\n        return T(this.next, (r)=>(n - t) * r + t);\n    }\n    nextIntBetween(t, n) {\n        return y(()=>this.PRNG.integer(n - t) + t);\n    }\n    shuffle(t) {\n        return PS(t, (n)=>this.nextIntBetween(0, n));\n    }\n    constructor(t){\n        u(this, \"seed\");\n        u(this, ou, ka);\n        u(this, \"PRNG\");\n        this.seed = t, this.PRNG = new Yd(t);\n    }\n}\nconst PS = (e, t)=>N(()=>f(y(()=>Array.from(e)), m((n)=>{\n            const r = [];\n            for(let s = n.length; s >= 2; s = s - 1)r.push(s);\n            return f(r, Bs((s)=>f(t(s), T((c)=>xS(n, s - 1, c)))), fe(Pl(n)));\n        }))), xS = (e, t, n)=>{\n    const r = e[t];\n    return e[t] = e[n], e[n] = r, e;\n}, jS = (e)=>new AS(k(e)), va = /* @__PURE__ */ Symbol.for(\"effect/Tracer\"), LS = (e)=>({\n        [va]: va,\n        ...e\n    }), ah = /* @__PURE__ */ It(\"effect/Tracer\"), uh = /* @__PURE__ */ It(\"effect/ParentSpan\"), wa = /* @__PURE__ */ function() {\n    const e = \"abcdef0123456789\", t = e.length;\n    return function(n) {\n        let r = \"\";\n        for(let s = 0; s < n; s++)r += e.charAt(Math.floor(Math.random() * t));\n        return r;\n    };\n}();\nclass DS {\n    end(t, n) {\n        this.status = {\n            _tag: \"Ended\",\n            endTime: t,\n            exit: n,\n            startTime: this.status.startTime\n        };\n    }\n    attribute(t, n) {\n        this.attributes.set(t, n);\n    }\n    event(t, n, r) {\n        this.events.push([\n            t,\n            n,\n            r !== null && r !== void 0 ? r : {}\n        ]);\n    }\n    addLinks(t) {\n        this.links.push(...t);\n    }\n    constructor(t, n, r, s, c, i){\n        u(this, \"name\");\n        u(this, \"parent\");\n        u(this, \"context\");\n        u(this, \"startTime\");\n        u(this, \"kind\");\n        u(this, \"_tag\", \"Span\");\n        u(this, \"spanId\");\n        u(this, \"traceId\", \"native\");\n        u(this, \"sampled\", !0);\n        u(this, \"status\");\n        u(this, \"attributes\");\n        u(this, \"events\", []);\n        u(this, \"links\");\n        this.name = t, this.parent = n, this.context = r, this.startTime = c, this.kind = i, this.status = {\n            _tag: \"Started\",\n            startTime: c\n        }, this.attributes = /* @__PURE__ */ new Map(), this.traceId = n._tag === \"Some\" ? n.value.traceId : wa(32), this.spanId = wa(16), this.links = Array.from(s);\n    }\n}\nconst qS = /* @__PURE__ */ LS({\n    span: (e, t, n, r, s, c)=>new DS(e, t, n, r, s, c),\n    context: (e)=>e()\n}), US = /* @__PURE__ */ f(/* @__PURE__ */ Oi(), /* @__PURE__ */ At(Qs, /* @__PURE__ */ Qb()), /* @__PURE__ */ At(oh, TS), /* @__PURE__ */ At(NS, /* @__PURE__ */ jS(/* @__PURE__ */ Math.random())), /* @__PURE__ */ At(mS, /* @__PURE__ */ SS()), /* @__PURE__ */ At(ah, qS)), rs = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/DefaultServices/currentServices\"), ()=>Kf(US)), zS = (e)=>{\n    const t = Pe(e);\n    return lh((n)=>n.sleep(t));\n}, BS = (e)=>L((t)=>e(t.currentDefaultServices)), lh = (e)=>BS((t)=>e(t.unsafeMap.get(Qs.key))), VS = /* @__PURE__ */ lh((e)=>e.currentTimeMillis), KS = zS, WS = VS;\nfunction JS(e) {\n    return new et(e);\n}\n_c13 = JS;\nfunction HS() {\n    return JS(/* @__PURE__ */ new Map());\n}\n_c14 = HS;\nconst Oa = /* @__PURE__ */ Symbol.for(\"effect/FiberRefs\");\nvar au;\nau = Oa;\nclass et {\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"locals\");\n        u(this, au, Oa);\n        this.locals = t;\n    }\n}\nconst GS = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n    const s = e;\n    let c = t, i = n, o = r, a;\n    for(; a === void 0;)if (le(c) && le(i)) {\n        const h = ue(c)[0], d = _t(c), g = ue(i)[0], p = ue(i)[1], _ = _t(i);\n        h.startTimeMillis < g.startTimeMillis ? (i = _, o = !0) : h.startTimeMillis > g.startTimeMillis ? c = d : h.id < g.id ? (i = _, o = !0) : h.id > g.id ? c = d : a = [\n            p,\n            o\n        ];\n    } else a = [\n        s.initial,\n        !0\n    ];\n    return a;\n}, YS = /* @__PURE__ */ l(3, (e, t, n)=>{\n    const r = new Map(e.locals);\n    return n.locals.forEach((s, c)=>{\n        const i = s[0][1];\n        if (!s[0][0][E](t)) {\n            if (!r.has(c)) {\n                if (O(i, c.initial)) return;\n                r.set(c, [\n                    [\n                        t,\n                        c.join(c.initial, i)\n                    ]\n                ]);\n                return;\n            }\n            const o = r.get(c), [a, h] = GS(c, o, s);\n            if (h) {\n                const d = c.diff(a, i), g = o[0][1], p = c.join(g, c.patch(d)(g));\n                if (!O(g, p)) {\n                    let _;\n                    const b = o[0][0];\n                    b[E](t) ? _ = [\n                        [\n                            b,\n                            p\n                        ],\n                        ...o.slice(1)\n                    ] : _ = [\n                        [\n                            t,\n                            p\n                        ],\n                        ...o\n                    ], r.set(c, _);\n                }\n            }\n        }\n    }), new et(r);\n}), QS = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = /* @__PURE__ */ new Map();\n    return fh(e, n, t), new et(n);\n}), fh = (e, t, n)=>{\n    e.locals.forEach((r, s)=>{\n        const c = r[0][1], i = s.patch(s.fork)(c);\n        O(c, i) ? t.set(s, r) : t.set(s, [\n            [\n                n,\n                i\n            ],\n            ...r\n        ]);\n    });\n}, hh = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = new Map(e.locals);\n    return n.delete(t), new et(n);\n}), ZS = /* @__PURE__ */ l(2, (e, t)=>e.locals.has(t) ? I(ue(e.locals.get(t))[1]) : v()), Kn = /* @__PURE__ */ l(2, (e, t)=>f(ZS(e, t), de(()=>t.initial))), Kc = /* @__PURE__ */ l(2, (e, param)=>{\n    let { fiberId: t, fiberRef: n, value: r } = param;\n    if (e.locals.size === 0) return new et(/* @__PURE__ */ new Map([\n        [\n            n,\n            [\n                [\n                    t,\n                    r\n                ]\n            ]\n        ]\n    ]));\n    const s = new Map(e.locals);\n    return Wc(s, t, n, r), new et(s);\n}), Wc = (e, t, n, r)=>{\n    var _e_get;\n    const s = (_e_get = e.get(n)) !== null && _e_get !== void 0 ? _e_get : [];\n    let c;\n    if (le(s)) {\n        const [i, o] = ue(s);\n        if (i[E](t)) {\n            if (O(o, r)) return;\n            c = [\n                [\n                    t,\n                    r\n                ],\n                ...s.slice(1)\n            ];\n        } else c = [\n            [\n                t,\n                r\n            ],\n            ...s\n        ];\n    } else c = [\n        [\n            t,\n            r\n        ]\n    ];\n    e.set(n, c);\n}, XS = /* @__PURE__ */ l(2, (e, param)=>{\n    let { entries: t, forkAs: n } = param;\n    if (e.locals.size === 0) return new et(new Map(t));\n    const r = new Map(e.locals);\n    return n !== void 0 && fh(e, r, n), t.forEach((param)=>{\n        let [s, c] = param;\n        c.length === 1 ? Wc(r, c[0][0], s, c[0][1]) : c.forEach((param)=>{\n            let [i, o] = param;\n            Wc(r, i, s, o);\n        });\n    }), new et(r);\n}), e0 = Kn, t0 = XS, n0 = HS, r0 = ob, s0 = ab, c0 = ub, i0 = lb, o0 = Bf, a0 = Vf, u0 = fb, l0 = hb, f0 = /* @__PURE__ */ f(xn, /* @__PURE__ */ $g((e)=>e.ordinal)), h0 = /* @__PURE__ */ Eg(f0), d0 = (e)=>{\n    switch(e){\n        case \"All\":\n            return r0;\n        case \"Debug\":\n            return a0;\n        case \"Error\":\n            return c0;\n        case \"Fatal\":\n            return s0;\n        case \"Info\":\n            return o0;\n        case \"Trace\":\n            return u0;\n        case \"None\":\n            return l0;\n        case \"Warning\":\n            return i0;\n    }\n}, dh = (e)=>e.replace(/[\\s=\"]/g, \"_\"), g0 = (e)=>(t)=>\"\".concat(dh(t.label), \"=\").concat(e - t.startTime, \"ms\"), m0 = tr, p0 = hg;\nclass ao extends p0 {\n}\nconst ss = /* @__PURE__ */ Symbol.for(\"effect/Readable\"), gh = /* @__PURE__ */ Symbol.for(\"effect/Ref\"), mh = {\n    /* c8 ignore next */ _A: (e)=>e\n};\nvar uu, lu, fu;\nclass _0 extends (fu = ao, lu = gh, uu = ss, fu) {\n    commit() {\n        return this.get;\n    }\n    modify(n) {\n        return y(()=>{\n            const r = Ze(this.ref), [s, c] = n(r);\n            return r !== c && xs(c)(this.ref), s;\n        });\n    }\n    constructor(n){\n        super();\n        u(this, \"ref\");\n        u(this, lu, mh);\n        u(this, uu, ss);\n        u(this, \"get\");\n        this.ref = n, this.get = y(()=>Ze(this.ref));\n    }\n}\nconst ph = (e)=>new _0(Ps(e)), Jc = (e)=>y(()=>ph(e)), mt = (e)=>e.get, cs = /* @__PURE__ */ l(2, (e, t)=>e.modify(()=>[\n            void 0,\n            t\n        ])), y0 = /* @__PURE__ */ l(2, (e, t)=>e.modify(t)), $a = /* @__PURE__ */ l(2, (e, t)=>e.modify((n)=>[\n            void 0,\n            t(n)\n        ])), _h = \"Empty\", yh = \"Add\", bh = \"Remove\", Sh = \"Update\", kh = \"AndThen\", b0 = {\n    _tag: _h\n}, vh = (e, t)=>{\n    const n = new Map(e.locals);\n    let r = b0;\n    for (const [s, c] of t.locals.entries()){\n        const i = ue(c)[1], o = n.get(s);\n        if (o !== void 0) {\n            const a = ue(o)[1];\n            O(a, i) || (r = mc({\n                _tag: Sh,\n                fiberRef: s,\n                patch: s.diff(a, i)\n            })(r));\n        } else r = mc({\n            _tag: yh,\n            fiberRef: s,\n            value: i\n        })(r);\n        n.delete(s);\n    }\n    for (const [s] of n.entries())r = mc({\n        _tag: bh,\n        fiberRef: s\n    })(r);\n    return r;\n}, mc = /* @__PURE__ */ l(2, (e, t)=>({\n        _tag: kh,\n        first: e,\n        second: t\n    })), wh = /* @__PURE__ */ l(3, (e, t, n)=>{\n    let r = n, s = ke(e);\n    for(; le(s);){\n        const c = ue(s), i = _t(s);\n        switch(c._tag){\n            case _h:\n                {\n                    s = i;\n                    break;\n                }\n            case yh:\n                {\n                    r = Kc(r, {\n                        fiberId: t,\n                        fiberRef: c.fiberRef,\n                        value: c.value\n                    }), s = i;\n                    break;\n                }\n            case bh:\n                {\n                    r = hh(r, c.fiberRef), s = i;\n                    break;\n                }\n            case Sh:\n                {\n                    const o = Kn(r, c.fiberRef);\n                    r = Kc(r, {\n                        fiberId: t,\n                        fiberRef: c.fiberRef,\n                        value: c.fiberRef.patch(c.patch)(o)\n                    }), s = i;\n                    break;\n                }\n            case kh:\n                {\n                    s = Kr(c.first)(Kr(c.second)(i));\n                    break;\n                }\n        }\n    }\n    return r;\n}), Oh = \"effect/MetricLabel\", Hc = /* @__PURE__ */ Symbol.for(Oh);\nvar hu;\nclass S0 {\n    [(hu = Hc, F)]() {\n        return this._hash;\n    }\n    [E](t) {\n        return v0(t) && this.key === t.key && this.value === t.value;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n){\n        u(this, \"key\");\n        u(this, \"value\");\n        u(this, hu, Hc);\n        u(this, \"_hash\");\n        this.key = t, this.value = n, this._hash = B(Oh + this.key + this.value);\n    }\n}\nconst k0 = (e, t)=>new S0(e, t), v0 = (e)=>$(e, Hc), w0 = (e)=>T(e, I), O0 = (e)=>{\n    let t, n;\n    return typeof e == \"function\" ? t = e : (t = e.try, n = e.catch), N(()=>{\n        try {\n            return S(ee(t));\n        } catch (r) {\n            return x(n ? ee(()=>n(r)) : new Gs(r, \"An unknown error occurred in Effect.try\"));\n        }\n    });\n}, $0 = (e)=>A0(e, I0, vh), E0 = /* @__PURE__ */ l(3, (e, t, n)=>N(()=>t(e) ? S(e) : x(n(e)))), $h = /* @__PURE__ */ l(2, (e, t)=>Xe(e, {\n        onFailure: (n)=>S(t.onFailure(n)),\n        onSuccess: (n)=>S(t.onSuccess(n))\n    })), I0 = /* @__PURE__ */ L((e)=>S(e.getFiberRefs())), F0 = (e)=>$h(e, {\n        onFailure: Sc,\n        onSuccess: Sc\n    }), Ea = /* @__PURE__ */ l(2, (e, t)=>Se(e, {\n        onFailure: (n)=>xf(()=>t(n)),\n        onSuccess: S\n    })), R0 = (e)=>T(e, (t)=>!t), M0 = (e)=>j0((t, n)=>f(e, wh(t, n))), T0 = (e)=>e.length >= 1 ? xe((t, n)=>{\n        try {\n            e(n).then((r)=>t(j(r)), (r)=>t(Fn(r)));\n        } catch (r) {\n            t(Fn(r));\n        }\n    }) : xe((t)=>{\n        try {\n            e().then((n)=>t(j(n)), (n)=>t(Fn(n)));\n        } catch (n) {\n            t(Fn(n));\n        }\n    }), Eh = /* @__PURE__ */ l(3, (e, t, n)=>bn((r)=>so(e, At(r, t, n)))), C0 = KS, N0 = /* @__PURE__ */ S(/* @__PURE__ */ v()), A0 = /* @__PURE__ */ l(3, (e, t, n)=>m(t, (r)=>m(e, (s)=>T(t, (c)=>[\n                    n(r, c),\n                    s\n                ])))), P0 = /* @__PURE__ */ l(2, (e, t)=>Se(e, {\n        onFailure: (n)=>oe(t(n), Z(n)),\n        onSuccess: S\n    })), x0 = (e)=>{\n    let t, n;\n    typeof e == \"function\" ? t = e : (t = e.try, n = e.catch);\n    const r = (s)=>n ? Us(()=>n(s)) : x(new Gs(s, \"An unknown error occurred in Effect.tryPromise\"));\n    return t.length >= 1 ? xe((s, c)=>{\n        try {\n            t(c).then((i)=>s(j(i)), (i)=>s(r(i)));\n        } catch (i) {\n            s(r(i));\n        }\n    }) : xe((s)=>{\n        try {\n            t().then((c)=>s(j(c)), (c)=>s(r(c)));\n        } catch (c) {\n            s(r(c));\n        }\n    });\n}, j0 = (e)=>L((t)=>(t.setFiberRefs(e(t.id(), t.getFiberRefs())), K)), L0 = /* @__PURE__ */ l(2, (e, t)=>N(()=>t() ? T(e, I) : S(v()))), D0 = (e)=>e == null ? x(new Hs()) : S(e), Ih = \"Sequential\", Fh = \"Parallel\", q0 = \"ParallelN\", Zs = {\n    _tag: Ih\n}, U0 = {\n    _tag: Fh\n}, z0 = (e)=>({\n        _tag: q0,\n        parallelism: e\n    }), B0 = (e)=>e._tag === Ih, V0 = (e)=>e._tag === Fh, Gc = Zs, Yc = U0, Qc = z0, Wn = vh, Jn = wh, Xs = \"effect/FiberStatus\", Et = /* @__PURE__ */ Symbol.for(Xs), is = \"Done\", Ia = \"Running\", Fa = \"Suspended\", K0 = /* @__PURE__ */ B(\"\".concat(Xs, \"-\").concat(is));\nvar du;\nclass W0 {\n    [(du = Et, F)]() {\n        return K0;\n    }\n    [E](t) {\n        return uo(t) && t._tag === is;\n    }\n    constructor(){\n        u(this, du, Et);\n        u(this, \"_tag\", is);\n    }\n}\nvar gu;\nclass J0 {\n    [(gu = Et, F)]() {\n        return f(k(Xs), R(k(this._tag)), R(k(this.runtimeFlags)), q(this));\n    }\n    [E](t) {\n        return uo(t) && t._tag === Ia && this.runtimeFlags === t.runtimeFlags;\n    }\n    constructor(t){\n        u(this, \"runtimeFlags\");\n        u(this, gu, Et);\n        u(this, \"_tag\", Ia);\n        this.runtimeFlags = t;\n    }\n}\nvar mu;\nclass H0 {\n    [(mu = Et, F)]() {\n        return f(k(Xs), R(k(this._tag)), R(k(this.runtimeFlags)), R(k(this.blockingOn)), q(this));\n    }\n    [E](t) {\n        return uo(t) && t._tag === Fa && this.runtimeFlags === t.runtimeFlags && O(this.blockingOn, t.blockingOn);\n    }\n    constructor(t, n){\n        u(this, \"runtimeFlags\");\n        u(this, \"blockingOn\");\n        u(this, mu, Et);\n        u(this, \"_tag\", Fa);\n        this.runtimeFlags = t, this.blockingOn = n;\n    }\n}\nconst G0 = /* @__PURE__ */ new W0(), Y0 = (e)=>new J0(e), Q0 = (e, t)=>new H0(e, t), uo = (e)=>$(e, Et), Z0 = (e)=>e._tag === is, X0 = G0, Rh = Y0, ek = Q0, tk = Z0, nk = /* @__PURE__ */ Symbol.for(\"effect/Micro\"), os = /* @__PURE__ */ Symbol.for(\"effect/Micro/MicroExit\"), Ra = /* @__PURE__ */ Symbol.for(\"effect/Micro/MicroCause\"), rk = {\n    _E: P\n};\nvar pu;\nclass Mh extends globalThis.Error {\n    pipe() {\n        return w(this, arguments);\n    }\n    toString() {\n        return this.stack;\n    }\n    [(pu = Ra, U)]() {\n        return this.stack;\n    }\n    constructor(n, r, s){\n        const c = \"MicroCause.\".concat(n);\n        let i, o, a;\n        if (r instanceof globalThis.Error) {\n            i = \"(\".concat(c, \") \").concat(r.name), o = r.message;\n            const h = o.split(\"\\n\").length;\n            a = r.stack ? \"(\".concat(c, \") \").concat(r.stack.split(\"\\n\").slice(0, h + 3).join(\"\\n\")) : \"\".concat(i, \": \").concat(o);\n        } else i = c, o = Ut(r, 0), a = \"\".concat(i, \": \").concat(o);\n        s.length > 0 && (a += \"\\n    \".concat(s.join(\"\\n    \")));\n        super(o);\n        u(this, \"_tag\");\n        u(this, \"traces\");\n        u(this, pu);\n        this._tag = n, this.traces = s, this[Ra] = rk, this.name = i, this.stack = a;\n    }\n}\nclass sk extends Mh {\n    constructor(n, r = []){\n        super(\"Die\", n, r);\n        u(this, \"defect\");\n        this.defect = n;\n    }\n}\nconst ck = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    return new sk(e, t);\n};\nclass ik extends Mh {\n    constructor(t = []){\n        super(\"Interrupt\", \"interrupted\", t);\n    }\n}\nconst ok = function() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return new ik(e);\n}, ak = (e)=>e._tag === \"Interrupt\", Ma = /* @__PURE__ */ Symbol.for(\"effect/Micro/MicroFiber\"), uk = {\n    _A: P,\n    _E: P\n};\nvar _u;\n_u = Ma;\nclass lk {\n    getRef(t) {\n        return pm(this.context, t);\n    }\n    addObserver(t) {\n        return this._exit ? (t(this._exit), Sc) : (this._observers.push(t), ()=>{\n            const n = this._observers.indexOf(t);\n            n >= 0 && this._observers.splice(n, 1);\n        });\n    }\n    unsafeInterrupt() {\n        this._exit || (this._interrupted = !0, this.interruptible && this.evaluate(mo));\n    }\n    unsafePoll() {\n        return this._exit;\n    }\n    evaluate(t) {\n        if (this._exit) return;\n        if (this._yielded !== void 0) {\n            const s = this._yielded;\n            this._yielded = void 0, s();\n        }\n        const n = this.runLoop(t);\n        if (n === Fr) return;\n        const r = Ta.interruptChildren && Ta.interruptChildren(this);\n        if (r !== void 0) return this.evaluate(us(r, ()=>n));\n        this._exit = n;\n        for(let s = 0; s < this._observers.length; s++)this._observers[s](n);\n        this._observers.length = 0;\n    }\n    runLoop(t) {\n        let n = !1, r = t;\n        this.currentOpCount = 0;\n        try {\n            for(;;){\n                if (this.currentOpCount++, !n && this.getRef(po).shouldYield(this)) {\n                    n = !0;\n                    const s = r;\n                    r = us(mk, ()=>s);\n                }\n                if (r = r[Zc](this), r === Fr) {\n                    const s = this._yielded;\n                    return os in s ? (this._yielded = void 0, s) : Fr;\n                }\n            }\n        } catch (s) {\n            return $(r, Zc) ? Xc(s) : Xc(\"MicroFiber.runLoop: Not a valid effect: \".concat(String(r)));\n        }\n    }\n    getCont(t) {\n        for(;;){\n            const n = this._stack.pop();\n            if (!n) return;\n            const r = n[as] && n[as](this);\n            if (r) return {\n                [t]: r\n            };\n            if (n[t]) return n;\n        }\n    }\n    yieldWith(t) {\n        return this._yielded = t, Fr;\n    }\n    children() {\n        var _this__children;\n        return (_this__children = this._children) !== null && _this__children !== void 0 ? _this__children : this._children = /* @__PURE__ */ new Set();\n    }\n    constructor(t, n = !0){\n        u(this, \"context\");\n        u(this, \"interruptible\");\n        u(this, _u);\n        u(this, \"_stack\", []);\n        u(this, \"_observers\", []);\n        u(this, \"_exit\");\n        u(this, \"_children\");\n        u(this, \"currentOpCount\", 0);\n        u(this, \"_interrupted\", !1);\n        // cancel the yielded operation, or for the yielded exit value\n        u(this, \"_yielded\");\n        this.context = t, this.interruptible = n, this[Ma] = uk;\n    }\n}\nconst Ta = /* @__PURE__ */ C(\"effect/Micro/fiberMiddleware\", ()=>({\n        interruptChildren: void 0\n    })), Th = /* @__PURE__ */ Symbol.for(\"effect/Micro/identifier\"), Y = /* @__PURE__ */ Symbol.for(\"effect/Micro/args\"), Zc = /* @__PURE__ */ Symbol.for(\"effect/Micro/evaluate\"), sn = /* @__PURE__ */ Symbol.for(\"effect/Micro/successCont\"), qt = /* @__PURE__ */ Symbol.for(\"effect/Micro/failureCont\"), as = /* @__PURE__ */ Symbol.for(\"effect/Micro/ensureCont\"), Fr = /* @__PURE__ */ Symbol.for(\"effect/Micro/Yield\"), fk = {\n    _A: P,\n    _E: P,\n    _R: P\n}, hk = {\n    ...m0,\n    _op: \"Micro\",\n    [nk]: fk,\n    pipe () {\n        return w(this, arguments);\n    },\n    [Symbol.iterator] () {\n        return new rl(new Xn(this));\n    },\n    toJSON () {\n        return {\n            _id: \"Micro\",\n            op: this[Th],\n            ...Y in this ? {\n                args: this[Y]\n            } : void 0\n        };\n    },\n    toString () {\n        return Q(this);\n    },\n    [U] () {\n        return Q(this);\n    }\n};\nfunction dk(e) {\n    return Xc(\"Micro.evaluate: Not implemented\");\n}\nconst ec = (e)=>{\n    var _e_eval;\n    return {\n        ...hk,\n        [Th]: e.op,\n        [Zc]: (_e_eval = e.eval) !== null && _e_eval !== void 0 ? _e_eval : dk,\n        [sn]: e.contA,\n        [qt]: e.contE,\n        [as]: e.ensure\n    };\n}, lo = (e)=>{\n    const t = ec(e);\n    return function() {\n        const n = Object.create(t);\n        return n[Y] = e.single === !1 ? arguments : arguments[0], n;\n    };\n}, Ch = (e)=>{\n    const t = {\n        ...ec(e),\n        [os]: os,\n        _tag: e.op,\n        get [e.prop] () {\n            return this[Y];\n        },\n        toJSON () {\n            return {\n                _id: \"MicroExit\",\n                _tag: e.op,\n                [e.prop]: this[Y]\n            };\n        },\n        [E] (n) {\n            return yk(n) && n._tag === e.op && O(this[Y], n[Y]);\n        },\n        [F] () {\n            return q(this, R(B(e.op))(k(this[Y])));\n        }\n    };\n    return function(n) {\n        const r = Object.create(t);\n        return r[Y] = n, r[sn] = void 0, r[qt] = void 0, r[as] = void 0, r;\n    };\n}, fo = /* @__PURE__ */ Ch({\n    op: \"Success\",\n    prop: \"value\",\n    eval (e) {\n        const t = e.getCont(sn);\n        return t ? t[sn](this[Y], e) : e.yieldWith(this);\n    }\n}), Nh = /* @__PURE__ */ Ch({\n    op: \"Failure\",\n    prop: \"cause\",\n    eval (e) {\n        let t = e.getCont(qt);\n        for(; ak(this[Y]) && t && e.interruptible;)t = e.getCont(qt);\n        return t ? t[qt](this[Y], e) : e.yieldWith(this);\n    }\n}), gk = /* @__PURE__ */ lo({\n    op: \"Yield\",\n    eval (e) {\n        let t = !1;\n        var _this_Y;\n        return e.getRef(po).scheduleTask(()=>{\n            t || e.evaluate(bk);\n        }, (_this_Y = this[Y]) !== null && _this_Y !== void 0 ? _this_Y : 0), e.yieldWith(()=>{\n            t = !0;\n        });\n    }\n}), mk = /* @__PURE__ */ gk(0), pk = /* @__PURE__ */ fo(void 0), ho = /* @__PURE__ */ lo({\n    op: \"WithMicroFiber\",\n    eval (e) {\n        return this[Y](e);\n    }\n}), us = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Object.create(_k);\n    return n[Y] = e, n[sn] = t, n;\n}), _k = /* @__PURE__ */ ec({\n    op: \"OnSuccess\",\n    eval (e) {\n        return e._stack.push(this), this[Y];\n    }\n}), yk = (e)=>$(e, os), Ah = fo, go = Nh, mo = /* @__PURE__ */ go(/* @__PURE__ */ ok()), Xc = (e)=>go(ck(e)), bk = /* @__PURE__ */ Ah(void 0), Sk = \"setImmediate\" in globalThis ? globalThis.setImmediate : (e)=>setTimeout(e, 0);\nclass Ph {\n    /**\n   * @since 3.5.9\n   */ scheduleTask(t, n) {\n        this.tasks.push(t), this.running || (this.running = !0, Sk(this.afterScheduled));\n    }\n    /**\n   * @since 3.5.9\n   */ runTasks() {\n        const t = this.tasks;\n        this.tasks = [];\n        for(let n = 0, r = t.length; n < r; n++)t[n]();\n    }\n    /**\n   * @since 3.5.9\n   */ shouldYield(t) {\n        return t.currentOpCount >= t.getRef(wk);\n    }\n    /**\n   * @since 3.5.9\n   */ flush() {\n        for(; this.tasks.length > 0;)this.runTasks();\n    }\n    constructor(){\n        u(this, \"tasks\", []);\n        u(this, \"running\", !1);\n        /**\n     * @since 3.5.9\n     */ u(this, \"afterScheduled\", ()=>{\n            this.running = !1, this.runTasks();\n        });\n    }\n}\nconst kk = /* @__PURE__ */ l(2, (e, t)=>ho((n)=>{\n        const r = n.context;\n        return n.context = t(r), Ek(e, ()=>(n.context = r, pk));\n    })), vk = /* @__PURE__ */ l(2, (e, t)=>kk(e, fn(t)));\nclass wk extends /* @__PURE__ */ $i()(\"effect/Micro/currentMaxOpsBeforeYield\", {\n    defaultValue: ()=>2048\n}) {\n}\nclass po extends /* @__PURE__ */ $i()(\"effect/Micro/currentScheduler\", {\n    defaultValue: ()=>new Ph()\n}) {\n}\nconst Ok = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Object.create($k);\n    return n[Y] = e, n[sn] = t.onSuccess, n[qt] = t.onFailure, n;\n}), $k = /* @__PURE__ */ ec({\n    op: \"OnSuccessAndFailure\",\n    eval (e) {\n        return e._stack.push(this), this[Y];\n    }\n}), Ek = /* @__PURE__ */ l(2, (e, t)=>Fk((n)=>Ok(n(e), {\n            onFailure: (r)=>us(t(go(r)), ()=>Nh(r)),\n            onSuccess: (r)=>us(t(Ah(r)), ()=>fo(r))\n        }))), xh = /* @__PURE__ */ lo({\n    op: \"SetInterruptible\",\n    ensure (e) {\n        if (e.interruptible = this[Y], e._interrupted && e.interruptible) return ()=>mo;\n    }\n}), Ik = (e)=>ho((t)=>t.interruptible ? e : (t.interruptible = !0, t._stack.push(xh(!1)), t._interrupted ? mo : e)), Fk = (e)=>ho((t)=>t.interruptible ? (t.interruptible = !1, t._stack.push(xh(!0)), e(Ik)) : e(P)), Rk = (e, t)=>{\n    const n = new lk(po.context(new Ph()));\n    return n.evaluate(e), n;\n};\nclass jh {\n    /**\n   * @since 2.0.0\n   */ scheduleTask(t, n) {\n        const r = this.buckets.length;\n        let s, c = 0;\n        for(; c < r && this.buckets[c][0] <= n; c++)s = this.buckets[c];\n        s && s[0] === n ? s[1].push(t) : c === r ? this.buckets.push([\n            n,\n            [\n                t\n            ]\n        ]) : this.buckets.splice(c, 0, [\n            n,\n            [\n                t\n            ]\n        ]);\n    }\n    constructor(){\n        /**\n     * @since 2.0.0\n     */ u(this, \"buckets\", []);\n    }\n}\nclass Mk {\n    /**\n   * @since 2.0.0\n   */ starveInternal(t) {\n        const n = this.tasks.buckets;\n        this.tasks.buckets = [];\n        for (const [r, s] of n)for(let c = 0; c < s.length; c++)s[c]();\n        this.tasks.buckets.length === 0 ? this.running = !1 : this.starve(t);\n    }\n    /**\n   * @since 2.0.0\n   */ starve() {\n        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        t >= this.maxNextTickBeforeTimer ? setTimeout(()=>this.starveInternal(0), 0) : Promise.resolve(void 0).then(()=>this.starveInternal(t + 1));\n    }\n    /**\n   * @since 2.0.0\n   */ shouldYield(t) {\n        return t.currentOpCount > t.getFiberRef(Wf) ? t.getFiberRef(dr) : !1;\n    }\n    /**\n   * @since 2.0.0\n   */ scheduleTask(t, n) {\n        this.tasks.scheduleTask(t, n), this.running || (this.running = !0, this.starve());\n    }\n    constructor(t){\n        u(this, \"maxNextTickBeforeTimer\");\n        /**\n     * @since 2.0.0\n     */ u(this, \"running\", !1);\n        /**\n     * @since 2.0.0\n     */ u(this, \"tasks\", /* @__PURE__ */ new jh());\n        this.maxNextTickBeforeTimer = t;\n    }\n}\nconst Lh = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Scheduler/defaultScheduler\"), ()=>new Mk(2048));\nclass Tk {\n    /**\n   * @since 2.0.0\n   */ scheduleTask(t, n) {\n        this.deferred ? Lh.scheduleTask(t, n) : this.tasks.scheduleTask(t, n);\n    }\n    /**\n   * @since 2.0.0\n   */ shouldYield(t) {\n        return t.currentOpCount > t.getFiberRef(Wf) ? t.getFiberRef(dr) : !1;\n    }\n    /**\n   * @since 2.0.0\n   */ flush() {\n        for(; this.tasks.buckets.length > 0;){\n            const t = this.tasks.buckets;\n            this.tasks.buckets = [];\n            for (const [n, r] of t)for(let s = 0; s < r.length; s++)r[s]();\n        }\n        this.deferred = !0;\n    }\n    constructor(){\n        /**\n     * @since 2.0.0\n     */ u(this, \"tasks\", /* @__PURE__ */ new jh());\n        /**\n     * @since 2.0.0\n     */ u(this, \"deferred\", !1);\n    }\n}\nconst _o = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentScheduler\"), ()=>ge(Lh)), Dh = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentRequestMap\"), ()=>ge(/* @__PURE__ */ new Map())), Ca = (e, t, n, r)=>{\n    switch(e){\n        case void 0:\n            return t();\n        case \"unbounded\":\n            return n();\n        case \"inherit\":\n            return Ws($b, (s)=>s === \"unbounded\" ? n() : s > 1 ? r(s) : t());\n        default:\n            return e > 1 ? r(e) : t();\n    }\n}, yo = \"InterruptSignal\", bo = \"Stateful\", So = \"Resume\", ko = \"YieldNow\", pc = (e)=>({\n        _tag: yo,\n        cause: e\n    }), jr = (e)=>({\n        _tag: bo,\n        onFiber: e\n    }), Ct = (e)=>({\n        _tag: So,\n        effect: e\n    }), Ck = ()=>({\n        _tag: ko\n    }), Nk = \"effect/FiberScope\", ls = /* @__PURE__ */ Symbol.for(Nk);\nvar yu;\nyu = ls;\nclass Ak {\n    add(t, n) {\n        this.roots.add(n), n.addObserver(()=>{\n            this.roots.delete(n);\n        });\n    }\n    constructor(){\n        u(this, yu, ls);\n        u(this, \"fiberId\", Ht);\n        u(this, \"roots\", /* @__PURE__ */ new Set());\n    }\n}\nvar bu;\nbu = ls;\nclass Pk {\n    add(t, n) {\n        this.parent.tell(jr((r)=>{\n            r.addChild(n), n.addObserver(()=>{\n                r.removeChild(n);\n            });\n        }));\n    }\n    constructor(t, n){\n        u(this, \"fiberId\");\n        u(this, \"parent\");\n        u(this, bu, ls);\n        this.fiberId = t, this.parent = n;\n    }\n}\nconst xk = (e)=>new Pk(e.id(), e), tc = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberScope/Global\"), ()=>new Ak()), jk = \"effect/Fiber\", Lk = /* @__PURE__ */ Symbol.for(jk), Dk = {\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _A: (e)=>e\n}, qk = \"effect/Fiber\", Uk = /* @__PURE__ */ Symbol.for(qk), xE = (e)=>e.await, jE = (e)=>e.inheritAll, fs = (e)=>Zi(zs(e.await), e.inheritAll);\n({\n    ...nr\n});\nconst ct = \"effect/FiberCurrent\", zk = \"effect/Logger\", Bk = /* @__PURE__ */ Symbol.for(zk), Vk = {\n    /* c8 ignore next */ _Message: (e)=>e,\n    /* c8 ignore next */ _Output: (e)=>e\n}, vo = (e)=>({\n        [Bk]: Vk,\n        log: e,\n        pipe () {\n            return w(this, arguments);\n        }\n    }), Kk = /^[^\\s\"=]*$/, Wk = (e, t)=>(param)=>{\n        let { annotations: n, cause: r, date: s, fiberId: c, logLevel: i, message: o, spans: a } = param;\n        const h = (b)=>b.match(Kk) ? b : e(b), d = (b, M)=>\"\".concat(dh(b), \"=\").concat(h(M)), g = (b, M)=>\" \" + d(b, M);\n        let p = d(\"timestamp\", s.toISOString());\n        p += g(\"level\", i.label), p += g(\"fiber\", nf(c));\n        const _ = Pg(o);\n        for(let b = 0; b < _.length; b++)p += g(\"message\", Ut(_[b], t));\n        Oy(r) || (p += g(\"cause\", ar(r, {\n            renderErrorCause: !0\n        })));\n        for (const b of a)p += \" \" + g0(s.getTime())(b);\n        for (const [b, M] of n)p += g(b, Ut(M, t));\n        return p;\n    }, Jk = (e)=>'\"'.concat(e.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\"), '\"'), Hk = /* @__PURE__ */ vo(/* @__PURE__ */ Wk(Jk)), Gk = typeof process == \"object\" && process !== null && typeof process.stdout == \"object\" && process.stdout !== null;\nGk && process.stdout.isTTY;\nconst qh = \"effect/MetricBoundaries\", ei = /* @__PURE__ */ Symbol.for(qh);\nvar Su;\nclass Yk {\n    [(Su = ei, F)]() {\n        return this._hash;\n    }\n    [E](t) {\n        return Qk(t) && O(this.values, t.values);\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"values\");\n        u(this, Su, ei);\n        u(this, \"_hash\");\n        this.values = t, this._hash = f(B(qh), R(er(this.values)));\n    }\n}\nconst Qk = (e)=>$(e, ei), Zk = (e)=>{\n    const t = f(e, Sl(ie(Number.POSITIVE_INFINITY)), tm);\n    return new Yk(t);\n}, Xk = (e)=>f(Ag(e.count - 1, (t)=>e.start * Math.pow(e.factor, t)), hn, Zk), ev = \"effect/MetricKeyType\", Uh = /* @__PURE__ */ Symbol.for(ev), zh = \"effect/MetricKeyType/Counter\", ti = /* @__PURE__ */ Symbol.for(zh), tv = \"effect/MetricKeyType/Frequency\", nv = /* @__PURE__ */ Symbol.for(tv), rv = \"effect/MetricKeyType/Gauge\", sv = /* @__PURE__ */ Symbol.for(rv), Bh = \"effect/MetricKeyType/Histogram\", ni = /* @__PURE__ */ Symbol.for(Bh), cv = \"effect/MetricKeyType/Summary\", iv = /* @__PURE__ */ Symbol.for(cv), Vh = {\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _Out: (e)=>e\n};\nvar ku, vu;\nclass ov {\n    [(vu = Uh, ku = ti, F)]() {\n        return this._hash;\n    }\n    [E](t) {\n        return Kh(t);\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n){\n        u(this, \"incremental\");\n        u(this, \"bigint\");\n        u(this, vu, Vh);\n        u(this, ku, ti);\n        u(this, \"_hash\");\n        this.incremental = t, this.bigint = n, this._hash = B(zh);\n    }\n}\nvar wu, Ou;\nclass av {\n    [(Ou = Uh, wu = ni, F)]() {\n        return this._hash;\n    }\n    [E](t) {\n        return Wh(t) && O(this.boundaries, t.boundaries);\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"boundaries\");\n        u(this, Ou, Vh);\n        u(this, wu, ni);\n        u(this, \"_hash\");\n        this.boundaries = t, this._hash = f(B(Bh), R(k(this.boundaries)));\n    }\n}\nconst uv = (e)=>{\n    var _ref, _ref1;\n    return new ov((_ref = e == null ? void 0 : e.incremental) !== null && _ref !== void 0 ? _ref : !1, (_ref1 = e == null ? void 0 : e.bigint) !== null && _ref1 !== void 0 ? _ref1 : !1);\n}, lv = (e)=>new av(e), Kh = (e)=>$(e, ti), fv = (e)=>$(e, nv), hv = (e)=>$(e, sv), Wh = (e)=>$(e, ni), dv = (e)=>$(e, iv), gv = \"effect/MetricKey\", Jh = /* @__PURE__ */ Symbol.for(gv), mv = {\n    /* c8 ignore next */ _Type: (e)=>e\n}, pv = /* @__PURE__ */ vi(O);\nvar $u;\nclass wo {\n    [($u = Jh, F)]() {\n        return this._hash;\n    }\n    [E](t) {\n        return _v(t) && this.name === t.name && O(this.keyType, t.keyType) && O(this.description, t.description) && pv(this.tags, t.tags);\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n, r, s = []){\n        u(this, \"name\");\n        u(this, \"keyType\");\n        u(this, \"description\");\n        u(this, \"tags\");\n        u(this, $u, mv);\n        u(this, \"_hash\");\n        this.name = t, this.keyType = n, this.description = r, this.tags = s, this._hash = f(B(this.name + this.description), R(k(this.keyType)), R(er(this.tags)));\n    }\n}\nconst _v = (e)=>$(e, Jh), yv = (e, t)=>new wo(e, uv(t), Es(t == null ? void 0 : t.description)), bv = (e, t, n)=>new wo(e, lv(t), Es(n)), Sv = /* @__PURE__ */ l(2, (e, t)=>t.length === 0 ? e : new wo(e.name, e.keyType, e.description, Ar(e.tags, t))), kv = \"effect/MetricState\", gr = /* @__PURE__ */ Symbol.for(kv), Hh = \"effect/MetricState/Counter\", ri = /* @__PURE__ */ Symbol.for(Hh), Gh = \"effect/MetricState/Frequency\", si = /* @__PURE__ */ Symbol.for(Gh), Yh = \"effect/MetricState/Gauge\", ci = /* @__PURE__ */ Symbol.for(Yh), Qh = \"effect/MetricState/Histogram\", ii = /* @__PURE__ */ Symbol.for(Qh), Zh = \"effect/MetricState/Summary\", oi = /* @__PURE__ */ Symbol.for(Zh), mr = {\n    /* c8 ignore next */ _A: (e)=>e\n};\nvar Eu, Iu;\nclass vv {\n    [(Iu = gr, Eu = ri, F)]() {\n        return f(k(Hh), R(k(this.count)), q(this));\n    }\n    [E](t) {\n        return Nv(t) && this.count === t.count;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"count\");\n        u(this, Iu, mr);\n        u(this, Eu, ri);\n        this.count = t;\n    }\n}\nconst wv = /* @__PURE__ */ vi(O);\nvar Fu, Ru;\nclass Ov {\n    [(Ru = gr, Fu = si, F)]() {\n        return f(B(Gh), R(er(z(this.occurrences.entries()))), q(this));\n    }\n    [E](t) {\n        return Av(t) && wv(z(this.occurrences.entries()), z(t.occurrences.entries()));\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"occurrences\");\n        u(this, Ru, mr);\n        u(this, Fu, si);\n        u(this, \"_hash\");\n        this.occurrences = t;\n    }\n}\nvar Mu, Tu;\nclass $v {\n    [(Tu = gr, Mu = ci, F)]() {\n        return f(k(Yh), R(k(this.value)), q(this));\n    }\n    [E](t) {\n        return Pv(t) && this.value === t.value;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t){\n        u(this, \"value\");\n        u(this, Tu, mr);\n        u(this, Mu, ci);\n        this.value = t;\n    }\n}\nvar Cu, Nu;\nclass Ev {\n    [(Nu = gr, Cu = ii, F)]() {\n        return f(k(Qh), R(k(this.buckets)), R(k(this.count)), R(k(this.min)), R(k(this.max)), R(k(this.sum)), q(this));\n    }\n    [E](t) {\n        return xv(t) && O(this.buckets, t.buckets) && this.count === t.count && this.min === t.min && this.max === t.max && this.sum === t.sum;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n, r, s, c){\n        u(this, \"buckets\");\n        u(this, \"count\");\n        u(this, \"min\");\n        u(this, \"max\");\n        u(this, \"sum\");\n        u(this, Nu, mr);\n        u(this, Cu, ii);\n        this.buckets = t, this.count = n, this.min = r, this.max = s, this.sum = c;\n    }\n}\nvar Au, Pu;\nclass Iv {\n    [(Pu = gr, Au = oi, F)]() {\n        return f(k(Zh), R(k(this.error)), R(k(this.quantiles)), R(k(this.count)), R(k(this.min)), R(k(this.max)), R(k(this.sum)), q(this));\n    }\n    [E](t) {\n        return jv(t) && this.error === t.error && O(this.quantiles, t.quantiles) && this.count === t.count && this.min === t.min && this.max === t.max && this.sum === t.sum;\n    }\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n, r, s, c, i){\n        u(this, \"error\");\n        u(this, \"quantiles\");\n        u(this, \"count\");\n        u(this, \"min\");\n        u(this, \"max\");\n        u(this, \"sum\");\n        u(this, Pu, mr);\n        u(this, Au, oi);\n        this.error = t, this.quantiles = n, this.count = r, this.min = s, this.max = c, this.sum = i;\n    }\n}\nconst Fv = (e)=>new vv(e), Rv = (e)=>new Ov(e), Mv = (e)=>new $v(e), Tv = (e)=>new Ev(e.buckets, e.count, e.min, e.max, e.sum), Cv = (e)=>new Iv(e.error, e.quantiles, e.count, e.min, e.max, e.sum), Nv = (e)=>$(e, ri), Av = (e)=>$(e, si), Pv = (e)=>$(e, ci), xv = (e)=>$(e, ii), jv = (e)=>$(e, oi), Lv = \"effect/MetricHook\", Dv = /* @__PURE__ */ Symbol.for(Lv), qv = {\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _Out: (e)=>e\n}, pr = (e)=>({\n        [Dv]: qv,\n        pipe () {\n            return w(this, arguments);\n        },\n        ...e\n    }), Na = /* @__PURE__ */ BigInt(0), Uv = (e)=>{\n    let t = e.keyType.bigint ? Na : 0;\n    const n = e.keyType.incremental ? e.keyType.bigint ? (s)=>s >= Na : (s)=>s >= 0 : (s)=>!0, r = (s)=>{\n        n(s) && (t = t + s);\n    };\n    return pr({\n        get: ()=>Fv(t),\n        update: r,\n        modify: r\n    });\n}, zv = (e)=>{\n    const t = /* @__PURE__ */ new Map();\n    for (const r of e.keyType.preregisteredWords)t.set(r, 0);\n    const n = (r)=>{\n        var _t_get;\n        const s = (_t_get = t.get(r)) !== null && _t_get !== void 0 ? _t_get : 0;\n        t.set(r, s + 1);\n    };\n    return pr({\n        get: ()=>Rv(t),\n        update: n,\n        modify: n\n    });\n}, Bv = (e, t)=>{\n    let n = t;\n    return pr({\n        get: ()=>Mv(n),\n        update: (r)=>{\n            n = r;\n        },\n        modify: (r)=>{\n            n = n + r;\n        }\n    });\n}, Vv = (e)=>{\n    const t = e.keyType.boundaries.values, n = t.length, r = new Uint32Array(n + 1), s = new Float32Array(n);\n    let c = 0, i = 0, o = Number.MAX_VALUE, a = Number.MIN_VALUE;\n    f(t, Wr(xn), ft((g, p)=>{\n        s[p] = g;\n    }));\n    const h = (g)=>{\n        let p = 0, _ = n;\n        for(; p !== _;){\n            const b = Math.floor(p + (_ - p) / 2), M = s[b];\n            g <= M ? _ = b : p = b, _ === p + 1 && (g <= s[p] ? _ = p : p = _);\n        }\n        r[p] = r[p] + 1, c = c + 1, i = i + g, g < o && (o = g), g > a && (a = g);\n    }, d = ()=>{\n        const g = Si(n);\n        let p = 0;\n        for(let _ = 0; _ < n; _++){\n            const b = s[_], M = r[_];\n            p = p + M, g[_] = [\n                b,\n                p\n            ];\n        }\n        return g;\n    };\n    return pr({\n        get: ()=>Tv({\n                buckets: d(),\n                count: c,\n                min: o,\n                max: a,\n                sum: i\n            }),\n        update: h,\n        modify: h\n    });\n}, Kv = (e)=>{\n    const { error: t, maxAge: n, maxSize: r, quantiles: s } = e.keyType, c = f(s, Wr(xn)), i = Si(r);\n    let o = 0, a = 0, h = 0, d = Number.MAX_VALUE, g = Number.MIN_VALUE;\n    const p = (b)=>{\n        const M = [];\n        let D = 0;\n        for(; D !== r - 1;){\n            const X = i[D];\n            if (X != null) {\n                const [H, Ie] = X, De = Hr(b - H);\n                Hm(De, ql) && Jm(De, n) && M.push(Ie);\n            }\n            D = D + 1;\n        }\n        return Wv(t, c, Wr(M, xn));\n    }, _ = (b, M)=>{\n        if (r > 0) {\n            o = o + 1;\n            const D = o % r;\n            i[D] = [\n                M,\n                b\n            ];\n        }\n        a = a + 1, h = h + b, b < d && (d = b), b > g && (g = b);\n    };\n    return pr({\n        get: ()=>Cv({\n                error: t,\n                quantiles: p(Date.now()),\n                count: a,\n                min: d,\n                max: g,\n                sum: h\n            }),\n        update: (param)=>{\n            let [b, M] = param;\n            return _(b, M);\n        },\n        modify: (param)=>{\n            let [b, M] = param;\n            return _(b, M);\n        }\n    });\n}, Wv = (e, t, n)=>{\n    const r = n.length;\n    if (!le(t)) return Bt();\n    const s = t[0], c = t.slice(1), i = Aa(e, r, v(), 0, s, n), o = ke(i);\n    return c.forEach((a)=>{\n        o.push(Aa(e, r, i.value, i.consumed, a, i.rest));\n    }), ft(o, (a)=>[\n            a.quantile,\n            a.value\n        ]);\n}, Aa = (e, t, n, r, s, c)=>{\n    let i = e, o = t, a = n, h = r, d = s, g = c, p = e, _ = t, b = n, M = r, D = s, X = c;\n    for(;;){\n        if (!le(g)) return {\n            quantile: d,\n            value: v(),\n            consumed: h,\n            rest: []\n        };\n        if (d === 1) return {\n            quantile: d,\n            value: I(wl(g)),\n            consumed: h + g.length,\n            rest: []\n        };\n        const H = Vg(g, (Mt)=>Mt <= g[0]), Ie = d * o, De = i / 2 * Ie, qe = h + H[0].length, kr = Math.abs(qe - Ie);\n        if (qe < Ie - De) {\n            p = i, _ = o, b = Tn(g), M = qe, D = d, X = H[1], i = p, o = _, a = b, h = M, d = D, g = X;\n            continue;\n        }\n        if (qe > Ie + De) return {\n            quantile: d,\n            value: a,\n            consumed: h,\n            rest: g\n        };\n        switch(a._tag){\n            case \"None\":\n                {\n                    p = i, _ = o, b = Tn(g), M = qe, D = d, X = H[1], i = p, o = _, a = b, h = M, d = D, g = X;\n                    continue;\n                }\n            case \"Some\":\n                {\n                    const Mt = Math.abs(Ie - a.value);\n                    if (kr < Mt) {\n                        p = i, _ = o, b = Tn(g), M = qe, D = d, X = H[1], i = p, o = _, a = b, h = M, d = D, g = X;\n                        continue;\n                    }\n                    return {\n                        quantile: d,\n                        value: I(a.value),\n                        consumed: h,\n                        rest: g\n                    };\n                }\n        }\n    }\n    throw new Error(\"BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues\");\n}, Jv = \"effect/MetricPair\", Hv = /* @__PURE__ */ Symbol.for(Jv), Gv = {\n    /* c8 ignore next */ _Type: (e)=>e\n}, Yv = (e, t)=>({\n        [Hv]: Gv,\n        metricKey: e,\n        metricState: t,\n        pipe () {\n            return w(this, arguments);\n        }\n    }), Qv = \"effect/MetricRegistry\", Pa = /* @__PURE__ */ Symbol.for(Qv);\nvar xu;\nxu = Pa;\nclass Zv {\n    snapshot() {\n        const t = [];\n        for (const [n, r] of this.map)t.push(Yv(n, r.get()));\n        return t;\n    }\n    get(t) {\n        const n = f(this.map, ot(t), it);\n        if (n == null) {\n            if (Kh(t.keyType)) return this.getCounter(t);\n            if (hv(t.keyType)) return this.getGauge(t);\n            if (fv(t.keyType)) return this.getFrequency(t);\n            if (Wh(t.keyType)) return this.getHistogram(t);\n            if (dv(t.keyType)) return this.getSummary(t);\n            throw new Error(\"BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues\");\n        } else return n;\n    }\n    getCounter(t) {\n        let n = f(this.map, ot(t), it);\n        if (n == null) {\n            const r = Uv(t);\n            f(this.map, On(t)) || f(this.map, $n(t, r)), n = r;\n        }\n        return n;\n    }\n    getFrequency(t) {\n        let n = f(this.map, ot(t), it);\n        if (n == null) {\n            const r = zv(t);\n            f(this.map, On(t)) || f(this.map, $n(t, r)), n = r;\n        }\n        return n;\n    }\n    getGauge(t) {\n        let n = f(this.map, ot(t), it);\n        if (n == null) {\n            const r = Bv(t, t.keyType.bigint ? BigInt(0) : 0);\n            f(this.map, On(t)) || f(this.map, $n(t, r)), n = r;\n        }\n        return n;\n    }\n    getHistogram(t) {\n        let n = f(this.map, ot(t), it);\n        if (n == null) {\n            const r = Vv(t);\n            f(this.map, On(t)) || f(this.map, $n(t, r)), n = r;\n        }\n        return n;\n    }\n    getSummary(t) {\n        let n = f(this.map, ot(t), it);\n        if (n == null) {\n            const r = Kv(t);\n            f(this.map, On(t)) || f(this.map, $n(t, r)), n = r;\n        }\n        return n;\n    }\n    constructor(){\n        u(this, xu, Pa);\n        u(this, \"map\", /* @__PURE__ */ Vb());\n    }\n}\nconst Xv = ()=>new Zv(), ew = \"effect/Metric\", tw = /* @__PURE__ */ Symbol.for(ew), nw = {\n    /* c8 ignore next */ _Type: (e)=>e,\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _Out: (e)=>e\n}, xa = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Metric/globalMetricRegistry\"), ()=>Xv()), Xh = function(e, t, n, r) {\n    const s = Object.assign((c)=>Gi(c, (i)=>iw(s, i)), {\n        [tw]: nw,\n        keyType: e,\n        unsafeUpdate: t,\n        unsafeValue: n,\n        unsafeModify: r,\n        register () {\n            return this.unsafeValue([]), this;\n        },\n        pipe () {\n            return w(this, arguments);\n        }\n    });\n    return s;\n}, nc = (e, t)=>ed(yv(e, t)), ed = (e)=>{\n    let t;\n    const n = /* @__PURE__ */ new WeakMap(), r = (s)=>{\n        if (s.length === 0) return t !== void 0 || (t = xa.get(e)), t;\n        let c = n.get(s);\n        return c !== void 0 || (c = xa.get(Sv(e, s)), n.set(s, c)), c;\n    };\n    return Xh(e.keyType, (s, c)=>r(c).update(s), (s)=>r(s).get(), (s, c)=>r(c).modify(s));\n}, rw = (e, t, n)=>ed(bv(e, t, n)), sw = /* @__PURE__ */ l(3, (e, t, n)=>cw(e, [\n        k0(t, n)\n    ])), cw = /* @__PURE__ */ l(2, (e, t)=>Xh(e.keyType, (n, r)=>e.unsafeUpdate(n, Ar(t, r)), (n)=>e.unsafeValue(Ar(t, n)), (n, r)=>e.unsafeModify(n, Ar(t, r)))), iw = /* @__PURE__ */ l(2, (e, t)=>Ws(Uc, (n)=>y(()=>e.unsafeUpdate(t, n))));\n({\n    ...Os\n});\nconst ow = /* @__PURE__ */ l(2, (e, t)=>Ws(Dh, (n)=>y(()=>{\n            if (n.has(e)) {\n                const r = n.get(e);\n                r.state.completed || (r.state.completed = !0, Qf(r.result, t));\n            }\n        }))), aw = \"effect/Supervisor\", rc = /* @__PURE__ */ Symbol.for(aw), Oo = {\n    /* c8 ignore next */ _T: (e)=>e\n};\nvar ju;\nju = rc;\nconst Mo = class Mo {\n    get value() {\n        return this.value0;\n    }\n    onStart(t, n, r, s) {\n        this.underlying.onStart(t, n, r, s);\n    }\n    onEnd(t, n) {\n        this.underlying.onEnd(t, n);\n    }\n    onEffect(t, n) {\n        this.underlying.onEffect(t, n);\n    }\n    onSuspend(t) {\n        this.underlying.onSuspend(t);\n    }\n    onResume(t) {\n        this.underlying.onResume(t);\n    }\n    map(t) {\n        return new Mo(this, f(this.value, T(t)));\n    }\n    zip(t) {\n        return new ds(this, t);\n    }\n    constructor(t, n){\n        u(this, \"underlying\");\n        u(this, \"value0\");\n        u(this, ju, Oo);\n        this.underlying = t, this.value0 = n;\n    }\n};\nlet hs = Mo;\nvar Lu;\nLu = rc;\nconst To = class To {\n    get value() {\n        return qf(this.left.value, this.right.value);\n    }\n    onStart(t, n, r, s) {\n        this.left.onStart(t, n, r, s), this.right.onStart(t, n, r, s);\n    }\n    onEnd(t, n) {\n        this.left.onEnd(t, n), this.right.onEnd(t, n);\n    }\n    onEffect(t, n) {\n        this.left.onEffect(t, n), this.right.onEffect(t, n);\n    }\n    onSuspend(t) {\n        this.left.onSuspend(t), this.right.onSuspend(t);\n    }\n    onResume(t) {\n        this.left.onResume(t), this.right.onResume(t);\n    }\n    map(t) {\n        return new hs(this, f(this.value, T(t)));\n    }\n    zip(t) {\n        return new To(this, t);\n    }\n    constructor(t, n){\n        u(this, \"left\");\n        u(this, \"right\");\n        u(this, \"_tag\", \"Zip\");\n        u(this, Lu, Oo);\n        this.left = t, this.right = n;\n    }\n};\nlet ds = To;\nconst td = (e)=>$(e, rc) && el(e, \"Zip\");\nvar Du;\nDu = rc;\nclass uw {\n    get value() {\n        return this.effect;\n    }\n    onStart(t, n, r, s) {}\n    onEnd(t, n) {}\n    onEffect(t, n) {}\n    onSuspend(t) {}\n    onResume(t) {}\n    map(t) {\n        return new hs(this, f(this.value, T(t)));\n    }\n    zip(t) {\n        return new ds(this, t);\n    }\n    onRun(t, n) {\n        return t();\n    }\n    constructor(t){\n        u(this, \"effect\");\n        u(this, Du, Oo);\n        this.effect = t;\n    }\n}\nconst lw = (e)=>new uw(e), sc = /* @__PURE__ */ C(\"effect/Supervisor/none\", ()=>lw(K)), fw = dn, nd = \"Empty\", rd = \"AddSupervisor\", sd = \"RemoveSupervisor\", cd = \"AndThen\", An = {\n    _tag: nd\n}, Lr = (e, t)=>({\n        _tag: cd,\n        first: e,\n        second: t\n    }), hw = (e, t)=>dw(t, ie(e)), dw = (e, t)=>{\n    let n = e, r = t;\n    for(; He(r);){\n        const s = Ce(r);\n        switch(s._tag){\n            case nd:\n                {\n                    r = Ve(r);\n                    break;\n                }\n            case rd:\n                {\n                    n = n.zip(s.supervisor), r = Ve(r);\n                    break;\n                }\n            case sd:\n                {\n                    n = ai(n, s.supervisor), r = Ve(r);\n                    break;\n                }\n            case cd:\n                {\n                    r = be(s.first)(be(s.second)(Ve(r)));\n                    break;\n                }\n        }\n    }\n    return n;\n}, ai = (e, t)=>O(e, t) ? sc : td(e) ? ai(e.left, t).zip(ai(e.right, t)) : e, gs = (e)=>O(e, sc) ? St() : td(e) ? f(gs(e.left), Dn(gs(e.right))) : Pi(e), gw = (e, t)=>{\n    if (O(e, t)) return An;\n    const n = gs(e), r = gs(t), s = f(r, Ho(n), qn(An, (i, o)=>Lr(i, {\n            _tag: rd,\n            supervisor: o\n        }))), c = f(n, Ho(r), qn(An, (i, o)=>Lr(i, {\n            _tag: sd,\n            supervisor: o\n        })));\n    return Lr(s, c);\n}, mw = /* @__PURE__ */ fw({\n    empty: An,\n    patch: hw,\n    combine: Lr,\n    diff: gw\n}), pw = /* @__PURE__ */ nc(\"effect_fiber_started\", {\n    incremental: !0\n}), ja = /* @__PURE__ */ nc(\"effect_fiber_active\"), _w = /* @__PURE__ */ nc(\"effect_fiber_successes\", {\n    incremental: !0\n}), yw = /* @__PURE__ */ nc(\"effect_fiber_failures\", {\n    incremental: !0\n}), bw = /* @__PURE__ */ sw(/* @__PURE__ */ rw(\"effect_fiber_lifetimes\", /* @__PURE__ */ Xk({\n    start: 0.5,\n    factor: 2,\n    count: 35\n})), \"time_unit\", \"milliseconds\"), En = \"Continue\", Sw = \"Done\", La = \"Yield\", kw = {\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _A: (e)=>e\n}, Rr = (e)=>{\n    throw new Error(\"BUG: FiberRuntime - \".concat(Ut(e), \" - please report an issue at https://github.com/Effect-TS/effect/issues\"));\n}, ze = /* @__PURE__ */ Symbol.for(\"effect/internal/fiberRuntime/YieldedOp\"), Be = /* @__PURE__ */ C(\"effect/internal/fiberRuntime/yieldedOpChannel\", ()=>({\n        currentOp: null\n    })), In = {\n    [zr]: (e, t, n)=>ee(()=>t.effect_instruction_i1(n)),\n    OnStep: (e, t, n)=>j(j(n)),\n    [Br]: (e, t, n)=>ee(()=>t.effect_instruction_i2(n)),\n    [pi]: (e, t, n)=>(e.patchRuntimeFlags(e.currentRuntimeFlags, t.patch), Ge(e.currentRuntimeFlags) && e.isInterrupted() ? A(e.getInterruptedCause()) : j(n)),\n    [Vr]: (e, t, n)=>(ee(()=>t.effect_instruction_i2(n)), ee(()=>t.effect_instruction_i0()) ? (e.pushStack(t), ee(()=>t.effect_instruction_i1())) : K),\n    [Mn]: (e, t, n)=>{\n        const r = ee(()=>t.effect_instruction_i0.next(n));\n        return r.done ? j(r.value) : (e.pushStack(t), Zd(r.value));\n    }\n}, vw = {\n    [yo]: (e, t, n, r)=>(e.processNewInterruptSignal(r.cause), Ge(t) ? A(r.cause) : n),\n    [So]: (e, t, n, r)=>{\n        throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\");\n    },\n    [bo]: (e, t, n, r)=>(r.onFiber(e, Rh(t)), n),\n    [ko]: (e, t, n, r)=>m(Qi(), ()=>n)\n}, ww = (e)=>Bs(oy(e), (t)=>pt(ky(t), (param)=>{\n            let [n, r] = param;\n            const s = /* @__PURE__ */ new Map(), c = [];\n            for (const o of r){\n                c.push(We(o));\n                for (const a of o)s.set(a.request, a);\n            }\n            const i = c.flat();\n            return hr(Jw(n.runAll(c), i, ()=>i.forEach((o)=>{\n                    o.listeners.interrupted = !0;\n                })), Dh, s);\n        }, !1, !1)), Ow = /* @__PURE__ */ bs();\nvar qu, Uu;\nclass id extends ao {\n    commit() {\n        return fs(this);\n    }\n    /**\n   * The identity of the fiber.\n   */ id() {\n        return this._fiberId;\n    }\n    /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */ resume(n) {\n        this.tell(Ct(n));\n    }\n    /**\n   * The status of the fiber.\n   */ get status() {\n        return this.ask((n, r)=>r);\n    }\n    /**\n   * Gets the fiber runtime flags.\n   */ get runtimeFlags() {\n        return this.ask((n, r)=>tk(r) ? n.currentRuntimeFlags : r.runtimeFlags);\n    }\n    /**\n   * Returns the current `FiberScope` for the fiber.\n   */ scope() {\n        return xk(this);\n    }\n    /**\n   * Retrieves the immediate children of the fiber.\n   */ get children() {\n        return this.ask((n)=>Array.from(n.getChildren()));\n    }\n    /**\n   * Gets the fiber's set of children.\n   */ getChildren() {\n        return this._children === null && (this._children = /* @__PURE__ */ new Set()), this._children;\n    }\n    /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */ getInterruptedCause() {\n        return this.getFiberRef(Ir);\n    }\n    /**\n   * Retrieves the whole set of fiber refs.\n   */ fiberRefs() {\n        return this.ask((n)=>n.getFiberRefs());\n    }\n    /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */ ask(n) {\n        return N(()=>{\n            const r = Yf(this._fiberId);\n            return this.tell(jr((s, c)=>{\n                Qf(r, y(()=>n(s, c)));\n            })), ro(r);\n        });\n    }\n    /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */ tell(n) {\n        this._queue.push(n), this._running || (this._running = !0, this.drainQueueLaterOnExecutor());\n    }\n    get await() {\n        return xe((n)=>{\n            const r = (s)=>n(S(s));\n            return this.tell(jr((s, c)=>{\n                s._exitValue !== null ? r(this._exitValue) : s.addObserver(r);\n            })), y(()=>this.tell(jr((s, c)=>{\n                    s.removeObserver(r);\n                })));\n        }, this.id());\n    }\n    get inheritAll() {\n        return L((n, r)=>{\n            const s = n.id(), c = n.getFiberRefs(), i = r.runtimeFlags, o = this.getFiberRefs(), a = YS(c, s, o);\n            n.setFiberRefs(a);\n            const h = n.getFiberRef(za), d = f(gt(i, h), // Do not inherit WindDown or Interruption!\n            ta(gn), ta(Lc));\n            return nb(d);\n        });\n    }\n    /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */ get poll() {\n        return y(()=>Es(this._exitValue));\n    }\n    /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */ unsafePoll() {\n        return this._exitValue;\n    }\n    /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */ interruptAsFork(n) {\n        return y(()=>this.tell(pc(Te(n))));\n    }\n    /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */ unsafeInterruptAsFork(n) {\n        this.tell(pc(Te(n)));\n    }\n    /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ addObserver(n) {\n        this._exitValue !== null ? n(this._exitValue) : this._observers.push(n);\n    }\n    /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ removeObserver(n) {\n        this._observers = this._observers.filter((r)=>r !== n);\n    }\n    /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */ getFiberRefs() {\n        return this.setFiberRef(za, this.currentRuntimeFlags), this._fiberRefs;\n    }\n    /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ unsafeDeleteFiberRef(n) {\n        this._fiberRefs = hh(this._fiberRefs, n);\n    }\n    /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */ getFiberRef(n) {\n        return this._fiberRefs.locals.has(n) ? this._fiberRefs.locals.get(n)[0][1] : n.initial;\n    }\n    /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ setFiberRef(n, r) {\n        this._fiberRefs = Kc(this._fiberRefs, {\n            fiberId: this._fiberId,\n            fiberRef: n,\n            value: r\n        }), this.refreshRefCache();\n    }\n    refreshRefCache() {\n        this.currentDefaultServices = this.getFiberRef(rs), this.currentTracer = this.currentDefaultServices.unsafeMap.get(ah.key), this.currentSupervisor = this.getFiberRef(Vw), this.currentScheduler = this.getFiberRef(_o), this.currentContext = this.getFiberRef(rt), this.currentSpan = this.currentContext.unsafeMap.get(uh.key);\n    }\n    /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ setFiberRefs(n) {\n        this._fiberRefs = n, this.refreshRefCache();\n    }\n    /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ addChild(n) {\n        this.getChildren().add(n);\n    }\n    /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ removeChild(n) {\n        this.getChildren().delete(n);\n    }\n    /**\n   * Transfers all children of this fiber that are currently running to the\n   * specified fiber scope.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself after it has\n   * evaluated the effects but prior to exiting.\n   */ transferChildren(n) {\n        const r = this._children;\n        if (this._children = null, r !== null && r.size > 0) for (const s of r)s._exitValue === null && n.add(this.currentRuntimeFlags, s);\n    }\n    /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ drainQueueOnCurrentThread() {\n        let n = !0;\n        for(; n;){\n            let r = En;\n            const s = globalThis[ct];\n            globalThis[ct] = this;\n            try {\n                for(; r === En;)r = this._queue.length === 0 ? Sw : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);\n            } finally{\n                this._running = !1, globalThis[ct] = s;\n            }\n            this._queue.length > 0 && !this._running ? (this._running = !0, r === La ? (this.drainQueueLaterOnExecutor(), n = !1) : n = !0) : n = !1;\n        }\n    }\n    /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ drainQueueLaterOnExecutor() {\n        this.currentScheduler.scheduleTask(this.run, this.getFiberRef(dr));\n    }\n    /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ drainQueueWhileRunning(n, r) {\n        let s = r;\n        for(; this._queue.length > 0;){\n            const c = this._queue.splice(0, 1)[0];\n            s = vw[c._tag](this, n, s, c);\n        }\n        return s;\n    }\n    /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */ isInterrupted() {\n        return !Ey(this.getFiberRef(Ir));\n    }\n    /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ addInterruptedCause(n) {\n        const r = this.getFiberRef(Ir);\n        this.setFiberRef(Ir, se(r, n));\n    }\n    /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ processNewInterruptSignal(n) {\n        this.addInterruptedCause(n), this.sendInterruptSignalToAllChildren();\n    }\n    /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ sendInterruptSignalToAllChildren() {\n        if (this._children === null || this._children.size === 0) return !1;\n        let n = !1;\n        for (const r of this._children)r.tell(pc(Te(this.id()))), n = !0;\n        return n;\n    }\n    /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ interruptAllChildren() {\n        if (this.sendInterruptSignalToAllChildren()) {\n            const n = this._children.values();\n            this._children = null;\n            let r = !1;\n            return Yi({\n                while: ()=>!r,\n                body: ()=>{\n                    const c = n.next();\n                    return c.done ? y(()=>{\n                        r = !0;\n                    }) : nt(c.value.await);\n                },\n                step: ()=>{}\n            });\n        }\n        return null;\n    }\n    reportExitValue(n) {\n        if (Xo(this.currentRuntimeFlags)) {\n            const r = this.getFiberRef(Uc), s = this.id().startTimeMillis, c = Date.now();\n            switch(bw.unsafeUpdate(c - s, r), ja.unsafeUpdate(-1, r), n._tag){\n                case ne:\n                    {\n                        _w.unsafeUpdate(1, r);\n                        break;\n                    }\n                case te:\n                    {\n                        yw.unsafeUpdate(1, r);\n                        break;\n                    }\n            }\n        }\n        if (n._tag === \"Failure\") {\n            const r = this.getFiberRef(Ib);\n            !Ui(n.cause) && r._tag === \"Some\" && this.log(\"Fiber terminated with an unhandled error\", n.cause, r);\n        }\n    }\n    setExitValue(n) {\n        this._exitValue = n, this.reportExitValue(n);\n        for(let r = this._observers.length - 1; r >= 0; r--)this._observers[r](n);\n        this._observers = [];\n    }\n    getLoggers() {\n        return this.getFiberRef(Rw);\n    }\n    log(n, r, s) {\n        const c = ye(s) ? s.value : this.getFiberRef(vb), i = this.getFiberRef($w);\n        if (h0(i, c)) return;\n        const o = this.getFiberRef(wb), a = this.getFiberRef(kb), h = this.getLoggers(), d = this.getFiberRefs();\n        if (Zl(h) > 0) {\n            const g = Ml(this.getFiberRef(rs), Qs), p = new Date(g.unsafeCurrentTimeMillis());\n            ng(d, ()=>{\n                for (const _ of h)_.log({\n                    fiberId: this.id(),\n                    logLevel: c,\n                    message: n,\n                    cause: r,\n                    context: d,\n                    spans: o,\n                    annotations: a,\n                    date: p\n                });\n            });\n        }\n    }\n    /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ evaluateMessageWhileSuspended(n) {\n        switch(n._tag){\n            case ko:\n                return La;\n            case yo:\n                return this.processNewInterruptSignal(n.cause), this._asyncInterruptor !== null && (this._asyncInterruptor(A(n.cause)), this._asyncInterruptor = null), En;\n            case So:\n                return this._asyncInterruptor = null, this._asyncBlockingOn = null, this.evaluateEffect(n.effect), En;\n            case bo:\n                return n.onFiber(this, this._exitValue !== null ? X0 : ek(this.currentRuntimeFlags, this._asyncBlockingOn)), En;\n            default:\n                return Rr(n);\n        }\n    }\n    /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ evaluateEffect(n) {\n        this.currentSupervisor.onResume(this);\n        try {\n            let r = Ge(this.currentRuntimeFlags) && this.isInterrupted() ? A(this.getInterruptedCause()) : n;\n            for(; r !== null;){\n                const s = r, c = this.runLoop(s);\n                if (c === ze) {\n                    const i = Be.currentOp;\n                    Be.currentOp = null, i._op === Cr ? ny(this.currentRuntimeFlags) ? (this.tell(Ck()), this.tell(Ct(Ne)), r = null) : r = Ne : i._op === Rn && (r = null);\n                } else {\n                    this.currentRuntimeFlags = f(this.currentRuntimeFlags, ry(Lc));\n                    const i = this.interruptAllChildren();\n                    i !== null ? r = m(i, ()=>c) : (this._queue.length === 0 ? this.setExitValue(c) : this.tell(Ct(c)), r = null);\n                }\n            }\n        } finally{\n            this.currentSupervisor.onSuspend(this);\n        }\n    }\n    /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */ start(n) {\n        if (this._running) this.tell(Ct(n));\n        else {\n            this._running = !0;\n            const r = globalThis[ct];\n            globalThis[ct] = this;\n            try {\n                this.evaluateEffect(n);\n            } finally{\n                this._running = !1, globalThis[ct] = r, this._queue.length > 0 && this.drainQueueLaterOnExecutor();\n            }\n        }\n    }\n    /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */ startFork(n) {\n        this.tell(Ct(n));\n    }\n    /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ patchRuntimeFlags(n, r) {\n        const s = Dt(n, r);\n        return globalThis[ct] = this, this.currentRuntimeFlags = s, s;\n    }\n    /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ initiateAsync(n, r) {\n        let s = !1;\n        const c = (i)=>{\n            s || (s = !0, this.tell(Ct(i)));\n        };\n        Ge(n) && (this._asyncInterruptor = c);\n        try {\n            r(c);\n        } catch (i) {\n            c(Z(Oe(i)));\n        }\n    }\n    pushStack(n) {\n        this._stack.push(n), n._op === \"OnStep\" && this._steps.push({\n            refs: this.getFiberRefs(),\n            flags: this.currentRuntimeFlags\n        });\n    }\n    popStack() {\n        const n = this._stack.pop();\n        if (n) return n._op === \"OnStep\" && this._steps.pop(), n;\n    }\n    getNextSuccessCont() {\n        let n = this.popStack();\n        for(; n;){\n            if (n._op !== Tr) return n;\n            n = this.popStack();\n        }\n    }\n    getNextFailCont() {\n        let n = this.popStack();\n        for(; n;){\n            if (n._op !== zr && n._op !== Vr && n._op !== Mn) return n;\n            n = this.popStack();\n        }\n    }\n    [(Uu = Lk, qu = Uk, sg)](n) {\n        return y(()=>Tl(this.currentContext, n));\n    }\n    Left(n) {\n        return x(n.left);\n    }\n    None(n) {\n        return x(new Hs());\n    }\n    Right(n) {\n        return j(n.right);\n    }\n    Some(n) {\n        return j(n.value);\n    }\n    Micro(n) {\n        return Vn((r)=>{\n            let s = r;\n            const c = Rk(vk(n, this.currentContext));\n            return c.addObserver((i)=>{\n                if (i._tag === \"Success\") return s(j(i.value));\n                switch(i.cause._tag){\n                    case \"Interrupt\":\n                        return s(A(Te(Ht)));\n                    case \"Fail\":\n                        return s(x(i.cause.error));\n                    case \"Die\":\n                        return s(Xr(i.cause.defect));\n                }\n            }), Vn((i)=>{\n                s = (o)=>{\n                    i(K);\n                }, c.unsafeInterrupt();\n            });\n        });\n    }\n    [al](n) {\n        const r = ee(()=>n.effect_instruction_i0()), s = this.getNextSuccessCont();\n        return s !== void 0 ? (s._op in In || Rr(s), In[s._op](this, s, r)) : (Be.currentOp = j(r), ze);\n    }\n    [ne](n) {\n        const r = n, s = this.getNextSuccessCont();\n        return s !== void 0 ? (s._op in In || Rr(s), In[s._op](this, s, r.effect_instruction_i0)) : (Be.currentOp = r, ze);\n    }\n    [te](n) {\n        const r = n.effect_instruction_i0, s = this.getNextFailCont();\n        if (s !== void 0) switch(s._op){\n            case Tr:\n            case Br:\n                return Ge(this.currentRuntimeFlags) && this.isInterrupted() ? A(na(r)) : ee(()=>s.effect_instruction_i1(r));\n            case \"OnStep\":\n                return Ge(this.currentRuntimeFlags) && this.isInterrupted() ? A(na(r)) : j(A(r));\n            case pi:\n                return this.patchRuntimeFlags(this.currentRuntimeFlags, s.patch), Ge(this.currentRuntimeFlags) && this.isInterrupted() ? A(se(r, this.getInterruptedCause())) : A(r);\n            default:\n                Rr(s);\n        }\n        else return Be.currentOp = A(r), ze;\n    }\n    [ul](n) {\n        return ee(()=>n.effect_instruction_i0(this, Rh(this.currentRuntimeFlags)));\n    }\n    Blocked(n) {\n        const r = this.getFiberRefs(), s = this.currentRuntimeFlags;\n        if (this._steps.length > 0) {\n            const c = [], i = this._steps[this._steps.length - 1];\n            let o = this.popStack();\n            for(; o && o._op !== \"OnStep\";)c.push(o), o = this.popStack();\n            this.setFiberRefs(i.refs), this.currentRuntimeFlags = i.flags;\n            const a = Wn(i.refs, r), h = gt(i.flags, s);\n            return j(Rf(n.effect_instruction_i0, L((d)=>{\n                for(; c.length > 0;)d.pushStack(c.pop());\n                return d.setFiberRefs(Jn(d.id(), d.getFiberRefs())(a)), d.currentRuntimeFlags = Dt(h)(d.currentRuntimeFlags), n.effect_instruction_i1;\n            })));\n        }\n        return Ee((c)=>m($o(Hy(n.effect_instruction_i0)), ()=>c(n.effect_instruction_i1)));\n    }\n    RunBlocked(n) {\n        return ww(n.effect_instruction_i0);\n    }\n    [un](n) {\n        const r = n.effect_instruction_i0, s = this.currentRuntimeFlags, c = Dt(s, r);\n        if (Ge(c) && this.isInterrupted()) return A(this.getInterruptedCause());\n        if (this.patchRuntimeFlags(this.currentRuntimeFlags, r), n.effect_instruction_i1) {\n            const i = gt(c, s);\n            return this.pushStack(new Gy(i, n)), ee(()=>n.effect_instruction_i1(s));\n        } else return Ne;\n    }\n    [zr](n) {\n        return this.pushStack(n), n.effect_instruction_i0;\n    }\n    OnStep(n) {\n        return this.pushStack(n), n.effect_instruction_i0;\n    }\n    [Tr](n) {\n        return this.pushStack(n), n.effect_instruction_i0;\n    }\n    [Br](n) {\n        return this.pushStack(n), n.effect_instruction_i0;\n    }\n    [Rn](n) {\n        return this._asyncBlockingOn = n.effect_instruction_i1, this.initiateAsync(this.currentRuntimeFlags, n.effect_instruction_i0), Be.currentOp = n, ze;\n    }\n    [Cr](n) {\n        return this._isYielding = !1, Be.currentOp = n, ze;\n    }\n    [Vr](n) {\n        const r = n.effect_instruction_i0, s = n.effect_instruction_i1;\n        return r() ? (this.pushStack(n), s()) : Ne;\n    }\n    [Mn](n) {\n        return In[Mn](this, n, void 0);\n    }\n    [ws](n) {\n        return ee(()=>n.commit());\n    }\n    /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */ runLoop(n) {\n        let r = n;\n        for(this.currentOpCount = 0;;){\n            if ((this.currentRuntimeFlags & ty) !== 0 && this.currentSupervisor.onEffect(this, r), this._queue.length > 0 && (r = this.drainQueueWhileRunning(this.currentRuntimeFlags, r)), !this._isYielding) {\n                this.currentOpCount += 1;\n                const s = this.currentScheduler.shouldYield(this);\n                if (s !== !1) {\n                    this._isYielding = !0, this.currentOpCount = 0;\n                    const c = r;\n                    r = m(Qi({\n                        priority: s\n                    }), ()=>c);\n                }\n            }\n            try {\n                if (r = this.currentTracer.context(()=>Ow !== r[tn]._V ? qc(\"Cannot execute an Effect versioned \".concat(r[tn]._V, \" with a Runtime of version \").concat(bs())) : this[r._op](r), this), r === ze) {\n                    const s = Be.currentOp;\n                    return s._op === Cr || s._op === Rn ? ze : (Be.currentOp = null, s._op === ne || s._op === te ? s : A(Oe(s)));\n                }\n            } catch (s) {\n                r !== ze && !$(r, \"_op\") || !(r._op in this) ? r = qc(\"Not a valid effect: \".concat(Ut(r))) : Mb(s) ? r = A(se(Oe(s), Te(Ht))) : r = Xr(s);\n            }\n        }\n    }\n    constructor(n, r, s){\n        super();\n        u(this, Uu, Dk);\n        u(this, qu, kw);\n        u(this, \"_fiberRefs\");\n        u(this, \"_fiberId\");\n        u(this, \"_queue\", /* @__PURE__ */ new Array());\n        u(this, \"_children\", null);\n        u(this, \"_observers\", /* @__PURE__ */ new Array());\n        u(this, \"_running\", !1);\n        u(this, \"_stack\", []);\n        u(this, \"_asyncInterruptor\", null);\n        u(this, \"_asyncBlockingOn\", null);\n        u(this, \"_exitValue\", null);\n        u(this, \"_steps\", []);\n        u(this, \"_isYielding\", !1);\n        u(this, \"currentRuntimeFlags\");\n        u(this, \"currentOpCount\", 0);\n        u(this, \"currentSupervisor\");\n        u(this, \"currentScheduler\");\n        u(this, \"currentTracer\");\n        u(this, \"currentSpan\");\n        u(this, \"currentContext\");\n        u(this, \"currentDefaultServices\");\n        u(this, \"run\", ()=>{\n            this.drainQueueOnCurrentThread();\n        });\n        if (this.currentRuntimeFlags = s, this._fiberId = n, this._fiberRefs = r, Xo(s)) {\n            const c = this.getFiberRef(Uc);\n            pw.unsafeUpdate(1, c), ja.unsafeUpdate(1, c);\n        }\n        this.refreshRefCache();\n    }\n}\nconst $w = /* @__PURE__ */ C(\"effect/FiberRef/currentMinimumLogLevel\", ()=>ge(d0(\"Info\"))), Ew = (e)=>vo((t)=>{\n        const n = e0(t.context, rs);\n        Ml(n, oh).unsafe.log(e.log(t));\n    }), Iw = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Logger/defaultLogger\"), ()=>Ew(Hk)), Fw = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/Logger/tracerLogger\"), ()=>vo((param)=>{\n        let { annotations: e, cause: t, context: n, fiberId: r, logLevel: s, message: c } = param;\n        const i = sr(Kn(n, rt), uh);\n        if (i._tag === \"None\" || i.value._tag === \"ExternalSpan\") return;\n        const o = Tl(Kn(n, rs), Qs), a = {};\n        for (const [h, d] of e)a[h] = d;\n        a[\"effect.fiberId\"] = zp(r), a[\"effect.logLevel\"] = s.label, t !== null && t._tag !== \"Empty\" && (a[\"effect.cause\"] = ar(t, {\n            renderErrorCause: !0\n        })), i.value.event(Ut(Array.isArray(c) ? c[0] : c), o.unsafeCurrentTimeNanos(), a);\n    })), Rw = /* @__PURE__ */ C(/* @__PURE__ */ Symbol.for(\"effect/FiberRef/currentLoggers\"), ()=>yb(Pi(Iw, Fw))), Mw = /* @__PURE__ */ l((e)=>Le(e[0]), (e, t)=>Ks(Gi(e, (n)=>Tw((r)=>t(n, r))))), Tw = (e)=>L((t)=>{\n        const n = t.getFiberRefs(), r = t.currentRuntimeFlags;\n        return m(fd, (s)=>ts(s, (c)=>L((i)=>{\n                    const o = i.getFiberRefs(), a = i.currentRuntimeFlags, h = Wn(o, n), d = gt(a, r), g = Wn(n, o);\n                    return i.setFiberRefs(Jn(h, i.id(), n)), Hn(ib(e(c), d), y(()=>{\n                        i.setFiberRefs(Jn(g, i.id(), i.getFiberRefs()));\n                    }));\n                })));\n    }), Cw = (e)=>{\n    if (Array.isArray(e) || tl(e)) return [\n        e,\n        v()\n    ];\n    const t = Object.keys(e), n = t.length;\n    return [\n        t.map((r)=>e[r]),\n        I((r)=>{\n            const s = {};\n            for(let c = 0; c < n; c++)s[t[c]] = r[c];\n            return s;\n        })\n    ];\n}, Nw = (e, t, n)=>{\n    const r = [];\n    for (const s of e)r.push(nn(s));\n    return m(cn(r, P, {\n        concurrency: n == null ? void 0 : n.concurrency,\n        batching: n == null ? void 0 : n.batching,\n        concurrentFinalizers: n == null ? void 0 : n.concurrentFinalizers\n    }), (s)=>{\n        const c = v(), i = s.length, o = new Array(i), a = new Array(i);\n        let h = !1;\n        for(let d = 0; d < i; d++){\n            const g = s[d];\n            g._tag === \"Left\" ? (o[d] = I(g.left), h = !0) : (a[d] = g.right, o[d] = c);\n        }\n        return h ? t._tag === \"Some\" ? x(t.value(o)) : x(o) : n != null && n.discard ? K : t._tag === \"Some\" ? S(t.value(a)) : S(a);\n    });\n}, Aw = (e, t, n)=>{\n    const r = [];\n    for (const s of e)r.push(nn(s));\n    return n != null && n.discard ? cn(r, P, {\n        concurrency: n == null ? void 0 : n.concurrency,\n        batching: n == null ? void 0 : n.batching,\n        discard: !0,\n        concurrentFinalizers: n == null ? void 0 : n.concurrentFinalizers\n    }) : T(cn(r, P, {\n        concurrency: n == null ? void 0 : n.concurrency,\n        batching: n == null ? void 0 : n.batching,\n        concurrentFinalizers: n == null ? void 0 : n.concurrentFinalizers\n    }), (s)=>t._tag === \"Some\" ? t.value(s) : s);\n}, od = (e, t)=>{\n    const [n, r] = Cw(e);\n    return (t == null ? void 0 : t.mode) === \"validate\" ? Nw(n, r, t) : (t == null ? void 0 : t.mode) === \"either\" ? Aw(n, r, t) : (t == null ? void 0 : t.discard) !== !0 && r._tag === \"Some\" ? T(cn(n, P, t), r.value) : cn(n, P, t);\n}, cn = /* @__PURE__ */ l((e)=>tl(e[0]), (e, t, n)=>L((r)=>{\n        const s = (n == null ? void 0 : n.batching) === !0 || (n == null ? void 0 : n.batching) === \"inherit\" && r.getFiberRef(Eb);\n        return n != null && n.discard ? Ca(n.concurrency, ()=>Nt(Gc, n == null ? void 0 : n.concurrentFinalizers)((c)=>s ? pt(e, (i, o)=>c(t(i, o)), !0, !1, 1) : Bs(e, (i, o)=>c(t(i, o)))), ()=>Nt(Yc, n == null ? void 0 : n.concurrentFinalizers)((c)=>pt(e, (i, o)=>c(t(i, o)), s, !1)), (c)=>Nt(Qc(c), n == null ? void 0 : n.concurrentFinalizers)((i)=>pt(e, (o, a)=>i(t(o, a)), s, !1, c))) : Ca(n == null ? void 0 : n.concurrency, ()=>Nt(Gc, n == null ? void 0 : n.concurrentFinalizers)((c)=>s ? ui(e, 1, (i, o)=>c(t(i, o)), !0) : Ke(e, (i, o)=>c(t(i, o)))), ()=>Nt(Yc, n == null ? void 0 : n.concurrentFinalizers)((c)=>ad(e, (i, o)=>c(t(i, o)), s)), (c)=>Nt(Qc(c), n == null ? void 0 : n.concurrentFinalizers)((i)=>ui(e, c, (o, a)=>i(t(o, a)), s)));\n    })), ad = (e, t, n)=>N(()=>{\n        const r = z(e), s = new Array(r.length);\n        return oe(pt(r, (i, o)=>m(t(i, o), (a)=>y(()=>s[o] = a)), n, !1), S(s));\n    }), pt = (e, t, n, r, s)=>Ee((c)=>tb((i)=>L((o)=>{\n                let a = Array.from(e).reverse(), h = a.length;\n                if (h === 0) return K;\n                let d = 0, g = !1;\n                const p = s ? Math.min(a.length, s) : a.length, _ = /* @__PURE__ */ new Set(), b = new Array(), M = ()=>_.forEach((ce)=>{\n                        ce.currentScheduler.scheduleTask(()=>{\n                            ce.unsafeInterruptAsFork(o.id());\n                        }, 0);\n                    }), D = new Array(), X = new Array(), H = new Array(), Ie = ()=>{\n                    const ce = b.filter((param)=>{\n                        let { exit: he } = param;\n                        return he._tag === \"Failure\";\n                    }).sort((he, Fe)=>he.index < Fe.index ? -1 : he.index === Fe.index ? 0 : 1).map((param)=>{\n                        let { exit: he } = param;\n                        return he;\n                    });\n                    return ce.length === 0 && ce.push(Ne), ce;\n                }, De = function(ce) {\n                    let he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n                    const Fe = Ks(i(ce)), re = Pw(Fe, o, o.currentRuntimeFlags, tc);\n                    return o.currentScheduler.scheduleTask(()=>{\n                        he && re.unsafeInterruptAsFork(o.id()), re.resume(Fe);\n                    }, 0), re;\n                }, qe = ()=>{\n                    r || (h -= a.length, a = []), g = !0, M();\n                }, kr = n ? Yy : Ye, Mt = De(xe((ce)=>{\n                    const he = (re, Ue)=>{\n                        re._op === \"Blocked\" ? H.push(re) : (b.push({\n                            index: Ue,\n                            exit: re\n                        }), re._op === \"Failure\" && !g && qe());\n                    }, Fe = ()=>{\n                        if (a.length > 0) {\n                            const re = a.pop();\n                            let Ue = d++;\n                            const vr = ()=>{\n                                const me = a.pop();\n                                return Ue = d++, m(Qi(), ()=>m(kr(c(t(me, Ue))), st));\n                            }, st = (me)=>a.length > 0 && (he(me, Ue), a.length > 0) ? vr() : S(me), wr = m(kr(c(t(re, Ue))), st), Re = De(wr);\n                            D.push(Re), _.add(Re), g && Re.currentScheduler.scheduleTask(()=>{\n                                Re.unsafeInterruptAsFork(o.id());\n                            }, 0), Re.addObserver((me)=>{\n                                let kn;\n                                if (me._op === \"Failure\" ? kn = me : kn = me.effect_instruction_i0, X.push(Re), _.delete(Re), he(kn, Ue), b.length === h) ce(S(de(Nn(Ie(), {\n                                    parallel: !0\n                                }), ()=>Ne)));\n                                else if (H.length + b.length === h) {\n                                    const Co = Ie(), Ad = H.map((vn)=>vn.effect_instruction_i0).reduce(kf);\n                                    ce(S(Rf(Ad, pt([\n                                        de(Nn(Co, {\n                                            parallel: !0\n                                        }), ()=>Ne),\n                                        ...H.map((vn)=>vn.effect_instruction_i1)\n                                    ], (vn)=>vn, n, !0, s))));\n                                } else Fe();\n                            });\n                        }\n                    };\n                    for(let re = 0; re < p; re++)Fe();\n                }));\n                return nt(rn(zs(c(fs(Mt))), to({\n                    onFailure: (ce)=>{\n                        qe();\n                        const he = H.length + 1, Fe = Math.min(typeof s == \"number\" ? s : H.length, H.length), re = Array.from(H);\n                        return xe((Ue)=>{\n                            let vr = 0, st = 0;\n                            const wr = (me, kn)=>(Co)=>{\n                                    vr++, vr === he && Ue(j(A(ce))), re.length > 0 && kn && Re();\n                                }, Re = ()=>{\n                                De(re.pop(), !0).addObserver(wr(st, !0)), st++;\n                            };\n                            Mt.addObserver(wr(st, !1)), st++;\n                            for(let me = 0; me < Fe; me++)Re();\n                        });\n                    },\n                    onSuccess: ()=>Ke(X, (ce)=>ce.inheritAll)\n                })));\n            }))), ui = (e, t, n, r)=>N(()=>{\n        const s = z(e), c = new Array(s.length);\n        return oe(pt(s, (o, a)=>T(n(o, a), (h)=>c[a] = h), r, !1, t), S(c));\n    }), $o = (e)=>xw(e, tc), ud = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    const s = ms(e, t, n, r);\n    return s.resume(e), s;\n}, Pw = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    return ms(e, t, n, r);\n}, ms = function(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    const s = rf(), c = t.getFiberRefs(), i = QS(c, s), o = new id(s, i, n), a = Kn(i, rt), h = o.currentSupervisor;\n    return h.onStart(a, e, I(t), o), o.addObserver((g)=>h.onEnd(g, o)), (r !== null ? r : f(t.getFiberRef(zc), de(()=>t.scope()))).add(n, o), o;\n}, xw = (e, t)=>L((n, r)=>S(ud(e, n, r.runtimeFlags, t))), Da = (e)=>bn((t)=>tt(sr(t, Rt), {\n            onNone: ()=>e,\n            onSome: (n)=>{\n                switch(n.strategy._tag){\n                    case \"Parallel\":\n                        return e;\n                    case \"Sequential\":\n                    case \"ParallelN\":\n                        return m(Js(n, Yc), (r)=>yr(e, r));\n                }\n            }\n        })), qa = (e)=>(t)=>bn((n)=>tt(sr(n, Rt), {\n                onNone: ()=>t,\n                onSome: (r)=>r.strategy._tag === \"ParallelN\" && r.strategy.parallelism === e ? t : m(Js(r, Qc(e)), (s)=>yr(t, s))\n            })), Nt = (e, t)=>(n)=>bn((r)=>tt(sr(r, Rt), {\n                onNone: ()=>n(P),\n                onSome: (s)=>{\n                    if (t === !0) {\n                        const c = e._tag === \"Parallel\" ? Da : e._tag === \"Sequential\" ? Ua : qa(e.parallelism);\n                        switch(s.strategy._tag){\n                            case \"Parallel\":\n                                return c(n(Da));\n                            case \"Sequential\":\n                                return c(n(Ua));\n                            case \"ParallelN\":\n                                return c(n(qa(s.strategy.parallelism)));\n                        }\n                    } else return n(P);\n                }\n            })), jw = (e)=>m(Rt, e), ld = (e)=>m(Eo(), (t)=>rn(e(t), (n)=>t.close(n))), Ua = (e)=>bn((t)=>tt(sr(t, Rt), {\n            onNone: ()=>e,\n            onSome: (n)=>{\n                switch(n.strategy._tag){\n                    case \"Sequential\":\n                        return e;\n                    case \"Parallel\":\n                    case \"ParallelN\":\n                        return m(Js(n, Gc), (r)=>yr(e, r));\n                }\n            }\n        })), Lw = /* @__PURE__ */ l((e)=>Le(e[1]), (e, t, n)=>_r(e, t, (r, s)=>[\n            r,\n            s\n        ], n)), Dw = /* @__PURE__ */ l((e)=>Le(e[1]), (e, t, n)=>(n == null ? void 0 : n.concurrent) !== !0 && ((n == null ? void 0 : n.batching) === void 0 || n.batching === !1) ? Zi(e, t) : _r(e, t, (r, s)=>r, n)), qw = /* @__PURE__ */ l((e)=>Le(e[1]), (e, t, n)=>(n == null ? void 0 : n.concurrent) !== !0 && ((n == null ? void 0 : n.batching) === void 0 || n.batching === !1) ? oe(e, t) : _r(e, t, (r, s)=>s, n)), _r = /* @__PURE__ */ l((e)=>Le(e[1]), (e, t, n, r)=>T(od([\n        e,\n        t\n    ], {\n        concurrency: r != null && r.concurrent ? 2 : 1,\n        batching: r == null ? void 0 : r.batching,\n        concurrentFinalizers: r == null ? void 0 : r.concurrentFinalizers\n    }), (param)=>{\n        let [s, c] = param;\n        return n(s, c);\n    })), Rt = /* @__PURE__ */ It(\"effect/Scope\"), fd = Rt, Uw = (e, t)=>{\n    e.state._tag === \"Open\" && e.state.finalizers.set({}, t);\n}, zw = {\n    [oa]: oa,\n    [aa]: aa,\n    pipe () {\n        return w(this, arguments);\n    },\n    fork (e) {\n        return y(()=>{\n            const t = hd(e);\n            if (this.state._tag === \"Closed\") return t.state = this.state, t;\n            const n = {}, r = (s)=>t.close(s);\n            return this.state.finalizers.set(n, r), Uw(t, (s)=>y(()=>{\n                    this.state._tag === \"Open\" && this.state.finalizers.delete(n);\n                })), t;\n        });\n    },\n    close (e) {\n        return N(()=>{\n            if (this.state._tag === \"Closed\") return K;\n            const t = Array.from(this.state.finalizers.values()).reverse();\n            return this.state = {\n                _tag: \"Closed\",\n                exit: e\n            }, t.length === 0 ? K : B0(this.strategy) ? f(Ke(t, (n)=>Ye(n(e))), m((n)=>f(Nn(n), Nr(hc), de(()=>Ne)))) : V0(this.strategy) ? f(ad(t, (n)=>Ye(n(e)), !1), m((n)=>f(Nn(n, {\n                    parallel: !0\n                }), Nr(hc), de(()=>Ne)))) : f(ui(t, this.strategy.parallelism, (n)=>Ye(n(e)), !1), m((n)=>f(Nn(n, {\n                    parallel: !0\n                }), Nr(hc), de(()=>Ne))));\n        });\n    },\n    addFinalizer (e) {\n        return N(()=>this.state._tag === \"Closed\" ? e(this.state.exit) : (this.state.finalizers.set({}, e), K));\n    }\n}, hd = function() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zs;\n    const t = Object.create(zw);\n    return t.strategy = e, t.state = {\n        _tag: \"Open\",\n        finalizers: /* @__PURE__ */ new Map()\n    }, t;\n}, Eo = function() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zs;\n    return y(()=>hd(e));\n}, yr = /* @__PURE__ */ l(2, (e, t)=>Ub(e, // @ts-expect-error\n    fn(rr(Rt, t)))), Bw = (e)=>yn(e, {\n        differ: mw,\n        fork: An\n    }), za = /* @__PURE__ */ Sb(sy), Vw = /* @__PURE__ */ Bw(sc), dd = /* @__PURE__ */ l(3, (e, t, n)=>Ww(e, t, {\n        onSelfWin: (r, s)=>m(r.await, (c)=>{\n                switch(c._tag){\n                    case ne:\n                        return m(r.inheritAll, ()=>n.onSelfDone(c, s));\n                    case te:\n                        return n.onSelfDone(c, s);\n                }\n            }),\n        onOtherWin: (r, s)=>m(r.await, (c)=>{\n                switch(c._tag){\n                    case ne:\n                        return m(r.inheritAll, ()=>n.onOtherDone(c, s));\n                    case te:\n                        return n.onOtherDone(c, s);\n                }\n            })\n    })), Kw = /* @__PURE__ */ l(2, (e, t)=>fr((n)=>dd(e, t, {\n            onSelfDone: (r, s)=>Vc(r, {\n                    onFailure: (c)=>f(fs(s), Ea((i)=>Ot(c, i))),\n                    onSuccess: (c)=>f(s, es(n), fe(c))\n                }),\n            onOtherDone: (r, s)=>Vc(r, {\n                    onFailure: (c)=>f(fs(s), Ea((i)=>Ot(i, c))),\n                    onSuccess: (c)=>f(s, es(n), fe(c))\n                })\n        }))), Ww = /* @__PURE__ */ l(3, (e, t, n)=>L((r, s)=>{\n        const c = s.runtimeFlags, i = Ps(!0), o = ms(e, r, c, n.selfScope), a = ms(t, r, c, n.otherScope);\n        return xe((h)=>{\n            o.addObserver(()=>Ba(o, a, n.onSelfWin, i, h)), a.addObserver(()=>Ba(a, o, n.onOtherWin, i, h)), o.startFork(e), a.startFork(t);\n        }, Up(o.id(), a.id()));\n    })), Ba = (e, t, n, r, s)=>{\n    Ap(!0, !1)(r) && s(n(e, t));\n}, Hn = /* @__PURE__ */ l(2, (e, t)=>Ee((n)=>Se(n(e), {\n            onFailure: (r)=>Se(t, {\n                    onFailure: (s)=>Z(se(r, s)),\n                    onSuccess: ()=>Z(r)\n                }),\n            onSuccess: (r)=>fe(t, r)\n        }))), Jw = (e, t, n)=>fr((r)=>m(m($o(Ji(e)), (s)=>xe((c)=>{\n                const i = t.map((h)=>h.listeners.count), o = ()=>{\n                    i.every((h)=>h === 0) && t.every((h)=>h.result.state.current._tag === \"Pending\" ? !0 : !!(h.result.state.current._tag === \"Done\" && eo(h.result.state.current.effect) && h.result.state.current.effect._tag === \"Failure\" && Iy(h.result.state.current.effect.cause))) && (a.forEach((h)=>h()), n == null || n(), c(zf(s)));\n                };\n                s.addObserver((h)=>{\n                    a.forEach((d)=>d()), c(h);\n                });\n                const a = t.map((h, d)=>{\n                    const g = (p)=>{\n                        i[d] = p, o();\n                    };\n                    return h.listeners.addObserver(g), ()=>h.listeners.removeObserver(g);\n                });\n                return o(), y(()=>{\n                    a.forEach((h)=>h());\n                });\n            })), ()=>N(()=>{\n                const s = t.flatMap((c)=>c.state.completed ? [] : [\n                        c\n                    ]);\n                return Bs(s, (c)=>ow(c.request, Cb(r)));\n            }))), Hw = \"effect/ScheduleInterval\", ps = /* @__PURE__ */ Symbol.for(Hw), gd = {\n    [ps]: ps,\n    startMillis: 0,\n    endMillis: 0\n}, md = (e, t)=>e > t ? gd : {\n        [ps]: ps,\n        startMillis: e,\n        endMillis: t\n    }, Gw = /* @__PURE__ */ l(2, (e, t)=>Yw(e, t) === e), Yw = /* @__PURE__ */ l(2, (e, t)=>e.endMillis <= t.startMillis ? e : t.endMillis <= e.startMillis ? t : e.startMillis < t.startMillis ? e : t.startMillis < e.startMillis ? t : e.endMillis <= t.endMillis ? e : t), Qw = (e)=>e.startMillis >= e.endMillis, Zw = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Math.max(e.startMillis, t.startMillis), r = Math.min(e.endMillis, t.endMillis);\n    return md(n, r);\n}), Xw = (e)=>md(e, Number.POSITIVE_INFINITY), pd = gd, eO = Gw, tO = Qw, nO = Zw, rO = Xw, sO = \"effect/ScheduleIntervals\", Va = /* @__PURE__ */ Symbol.for(sO), _d = (e)=>({\n        [Va]: Va,\n        intervals: e\n    }), cO = /* @__PURE__ */ l(2, (e, t)=>iO(e.intervals, t.intervals, Ae())), iO = (e, t, n)=>{\n    let r = e, s = t, c = n;\n    for(; He(r) && He(s);){\n        const i = f(Ce(r), nO(Ce(s))), o = tO(i) ? c : f(c, be(i));\n        f(Ce(r), eO(Ce(s))) ? r = Ve(r) : s = Ve(s), c = o;\n    }\n    return _d(yt(c));\n}, li = (e)=>f(e.intervals, xl, de(()=>pd)).startMillis, oO = (e)=>f(e.intervals, xl, de(()=>pd)).endMillis, aO = /* @__PURE__ */ l(2, (e, t)=>li(e) < li(t)), uO = (e)=>He(e.intervals), lO = _d, fO = cO, hO = li, Ka = oO, dO = aO, gO = uO, Io = \"Continue\", yd = \"Done\", mO = (e)=>({\n        _tag: Io,\n        intervals: e\n    }), pO = (e)=>({\n        _tag: Io,\n        intervals: lO(ie(e))\n    }), _O = {\n    _tag: yd\n}, yO = (e)=>e._tag === Io, bO = (e)=>e._tag === yd, SO = mO, kO = pO, Gn = _O, Wa = yO, _s = bO, LE = Jf, DE = ts, vO = Bc, qE = yr, wO = Js, UE = Eo, OO = \"effect/Schedule\", bd = /* @__PURE__ */ Symbol.for(OO), $O = (e)=>$(e, bd), EO = \"effect/ScheduleDriver\", IO = /* @__PURE__ */ Symbol.for(EO), FO = {\n    /* c8 ignore next */ _Out: (e)=>e,\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _R: (e)=>e\n}, RO = {\n    /* c8 ignore next */ _Out: (e)=>e,\n    /* c8 ignore next */ _In: (e)=>e,\n    /* c8 ignore next */ _R: (e)=>e\n};\nvar zu;\nzu = bd;\nclass MO {\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n){\n        u(this, \"initial\");\n        u(this, \"step\");\n        u(this, zu, FO);\n        this.initial = t, this.step = n;\n    }\n}\nvar Bu;\nBu = IO;\nclass TO {\n    get state() {\n        return T(mt(this.ref), (t)=>t[1]);\n    }\n    get last() {\n        return m(mt(this.ref), (param)=>{\n            let [t, n] = param;\n            switch(t._tag){\n                case \"None\":\n                    return Us(()=>new Hs());\n                case \"Some\":\n                    return S(t.value);\n            }\n        });\n    }\n    get reset() {\n        return cs(this.ref, [\n            v(),\n            this.schedule.initial\n        ]);\n    }\n    next(t) {\n        return f(T(mt(this.ref), (n)=>n[1]), m((n)=>f(WS, m((r)=>f(N(()=>this.schedule.step(r, t, n)), m((param)=>{\n                    let [s, c, i] = param;\n                    const o = cs(this.ref, [\n                        I(c),\n                        s\n                    ]);\n                    if (_s(i)) return oe(o, x(v()));\n                    const a = hO(i.intervals) - r;\n                    return a <= 0 ? fe(o, c) : f(o, oe(C0(Hr(a))), fe(c));\n                }))))));\n    }\n    constructor(t, n){\n        u(this, \"schedule\");\n        u(this, \"ref\");\n        u(this, Bu, RO);\n        this.schedule = t, this.ref = n;\n    }\n}\nconst br = (e, t)=>new MO(e, t), CO = /* @__PURE__ */ l(2, (e, t)=>Fo(e, (n, r)=>y(()=>t(n, r)))), Fo = /* @__PURE__ */ l(2, (e, t)=>br(e.initial, (n, r, s)=>m(e.step(n, r, s), (param)=>{\n            let [c, i, o] = param;\n            return _s(o) ? S([\n                c,\n                i,\n                Gn\n            ]) : T(t(r, i), (a)=>a ? [\n                    c,\n                    i,\n                    o\n                ] : [\n                    c,\n                    i,\n                    Gn\n                ]);\n        }))), NO = (e)=>f(Jc([\n        v(),\n        e.initial\n    ]), T((t)=>new TO(e, t))), AO = /* @__PURE__ */ l(2, (e, t)=>PO(e, t, fO)), PO = /* @__PURE__ */ l(3, (e, t, n)=>br([\n        e.initial,\n        t.initial\n    ], (r, s, c)=>f(Uf(e.step(r, s, c[0]), t.step(r, s, c[1]), (i, o)=>[\n                i,\n                o\n            ]), m((param)=>{\n            let [[i, o, a], [h, d, g]] = param;\n            return Wa(a) && Wa(g) ? fi(e, t, s, i, o, a.intervals, h, d, g.intervals, n) : S([\n                [\n                    i,\n                    h\n                ],\n                [\n                    o,\n                    d\n                ],\n                Gn\n            ]);\n        })))), fi = (e, t, n, r, s, c, i, o, a, h)=>{\n    const d = h(c, a);\n    return gO(d) ? S([\n        [\n            r,\n            i\n        ],\n        [\n            s,\n            o\n        ],\n        SO(d)\n    ]) : f(c, dO(a)) ? m(e.step(Ka(c), n, r), (param)=>{\n        let [g, p, _] = param;\n        return _s(_) ? S([\n            [\n                g,\n                i\n            ],\n            [\n                p,\n                o\n            ],\n            Gn\n        ]) : fi(e, t, n, g, p, _.intervals, i, o, a, h);\n    }) : m(t.step(Ka(a), n, i), (param)=>{\n        let [g, p, _] = param;\n        return _s(_) ? S([\n            [\n                r,\n                g\n            ],\n            [\n                s,\n                p\n            ],\n            Gn\n        ]) : fi(e, t, n, r, s, c, g, p, _.intervals, h);\n    });\n}, xO = /* @__PURE__ */ l(2, (e, t)=>jO(e, (n)=>y(()=>t(n)))), jO = /* @__PURE__ */ l(2, (e, t)=>br(e.initial, (n, r, s)=>m(e.step(n, r, s), (param)=>{\n            let [c, i, o] = param;\n            return T(t(i), (a)=>[\n                    c,\n                    a,\n                    o\n                ]);\n        }))), LO = (e)=>br(e.initial, (t, n, r)=>f(e.step(t, n, r), T((param)=>{\n            let [s, c, i] = param;\n            return [\n                s,\n                n,\n                i\n            ];\n        }))), DO = (e)=>BO(kd, (t)=>t < e), qO = (e, t)=>br(e, (n, r, s)=>y(()=>[\n                t(s),\n                s,\n                kO(rO(n))\n            ])), UO = /* @__PURE__ */ l(2, (e, t)=>Fo(e, (n, r)=>R0(t(n)))), zO = /* @__PURE__ */ l(2, (e, t)=>Fo(e, (n, r)=>t(n))), BO = /* @__PURE__ */ l(2, (e, t)=>CO(e, (n, r)=>t(r))), Dr = /* @__PURE__ */ Symbol.for(\"effect/Schedule/ScheduleDefect\");\nvar Vu;\nVu = Dr;\nclass VO {\n    constructor(t){\n        u(this, \"error\");\n        u(this, Vu);\n        this.error = t, this[Dr] = Dr;\n    }\n}\nconst KO = (e)=>$(e, Dr), Ja = (e)=>Zr(e, (t)=>Xr(new VO(t))), WO = (e)=>Pf(e, (t)=>tt(zi(t, (n)=>$y(n) && KO(n.defect) ? I(n.defect) : v()), {\n            onNone: ()=>Z(t),\n            onSome: (n)=>x(n.error)\n        })), Ha = /* @__PURE__ */ l(2, (e, t)=>HO(e, t, (n, r)=>x(n))), JO = /* @__PURE__ */ l(2, (e, t)=>{\n    if ($O(t)) return Ha(e, t);\n    var _t_schedule;\n    const n = (_t_schedule = t.schedule) !== null && _t_schedule !== void 0 ? _t_schedule : LO(kd), r = t.while ? zO(n, (i)=>{\n        const o = t.while(i);\n        return typeof o == \"boolean\" ? S(o) : Ja(o);\n    }) : n, s = t.until ? UO(r, (i)=>{\n        const o = t.until(i);\n        return typeof o == \"boolean\" ? S(o) : Ja(o);\n    }) : r, c = t.times ? AO(s, DO(t.times)).pipe(xO((i)=>i[0])) : s;\n    return WO(Ha(e, c));\n}), HO = /* @__PURE__ */ l(3, (e, t, n)=>m(NO(t), (r)=>Xe(e, {\n            onFailure: (s)=>n(s, v()),\n            onSuccess: (s)=>Sd(e, r, n, s)\n        }))), Sd = (e, t, n, r)=>Xe(t.next(r), {\n        onFailure: ()=>Xy(t.last),\n        onSuccess: (s)=>Xe(e, {\n                onFailure: (c)=>n(c, I(s)),\n                onSuccess: (c)=>Sd(e, t, n, c)\n            })\n    }), kd = /* @__PURE__ */ qO(0, (e)=>e + 1);\nclass GO {\n    get free() {\n        return this.permits - this.taken;\n    }\n    constructor(t){\n        u(this, \"permits\");\n        u(this, \"waiters\", /* @__PURE__ */ new Set());\n        u(this, \"taken\", 0);\n        u(this, \"take\", (t)=>Af((n)=>{\n                if (this.free < t) {\n                    const r = ()=>{\n                        this.free < t || (this.waiters.delete(r), this.taken += t, n(S(t)));\n                    };\n                    return this.waiters.add(r), y(()=>{\n                        this.waiters.delete(r);\n                    });\n                }\n                return this.taken += t, n(S(t));\n            }));\n        u(this, \"updateTaken\", (t)=>L((n)=>(this.taken = t(this.taken), this.waiters.size > 0 && n.getFiberRef(_o).scheduleTask(()=>{\n                    const r = this.waiters.values();\n                    let s = r.next();\n                    for(; s.done === !1 && this.free > 0;)s.value(), s = r.next();\n                }, n.getFiberRef(dr)), S(this.free))));\n        u(this, \"release\", (t)=>this.updateTaken((n)=>n - t));\n        u(this, \"releaseAll\", /* @__PURE__ */ this.updateTaken((t)=>0));\n        u(this, \"withPermits\", (t)=>(n)=>Ee((r)=>m(r(this.take(t)), (s)=>Hn(r(n), this.release(s)))));\n        u(this, \"withPermitsIfAvailable\", (t)=>(n)=>Ee((r)=>N(()=>this.free < t ? N0 : (this.taken += t, Hn(r(w0(n)), this.release(t))))));\n        this.permits = t;\n    }\n}\nconst vd = (e)=>new GO(e), YO = (e)=>y(()=>vd(e)), QO = /* @__PURE__ */ l(2, (e, t)=>L((n, r)=>{\n        const s = t, c = ud(e, n, r.runtimeFlags, tc);\n        if (s.state._tag === \"Open\") {\n            const i = ()=>fr((a)=>O(a, c.id()) ? K : nt(zf(c))), o = {};\n            s.state.finalizers.set(o, i), c.addObserver(()=>{\n                s.state._tag !== \"Closed\" && s.state.finalizers.delete(o);\n            });\n        } else c.unsafeInterruptAsFork(n.id());\n        return S(c);\n    })), ZO = \"effect/Ref/SynchronizedRef\", XO = /* @__PURE__ */ Symbol.for(ZO), e$ = {\n    /* c8 ignore next */ _A: (e)=>e\n};\nvar Ku, Wu, Ju, Hu;\nclass t$ extends (Hu = ao, Ju = XO, Wu = gh, Ku = ss, Hu) {\n    commit() {\n        return this.get;\n    }\n    modify(n) {\n        return this.modifyEffect((r)=>S(n(r)));\n    }\n    modifyEffect(n) {\n        return this.withLock(f(m(mt(this.ref), n), m((param)=>{\n            let [r, s] = param;\n            return fe(cs(this.ref, s), r);\n        })));\n    }\n    constructor(n, r){\n        super();\n        u(this, \"ref\");\n        u(this, \"withLock\");\n        u(this, Ju, e$);\n        u(this, Wu, mh);\n        u(this, Ku, ss);\n        u(this, \"get\");\n        this.ref = n, this.withLock = r, this.get = mt(this.ref);\n    }\n}\nconst n$ = (e)=>y(()=>wd(e)), wd = (e)=>{\n    const t = ph(e), n = vd(1);\n    return new t$(t, n.withPermits(1));\n}, r$ = /* @__PURE__ */ Symbol.for(\"effect/ManagedRuntime\"), s$ = \"Fresh\", c$ = \"FromEffect\", i$ = \"Scoped\", o$ = \"Suspend\", a$ = \"Provide\", u$ = \"ProvideMerge\", l$ = \"ZipWith\", Sr = (e)=>function() {\n        if (arguments.length === 1) {\n            const t = arguments[0];\n            return function(n) {\n                for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    r[_key - 1] = arguments[_key];\n                }\n                return e(t, n, ...r);\n            };\n        }\n        return e.apply(this, arguments);\n    }, Ro = /* @__PURE__ */ Sr((e, t, n)=>{\n    const r = rf(), s = [\n        [\n            rt,\n            [\n                [\n                    r,\n                    e.context\n                ]\n            ]\n        ]\n    ];\n    n != null && n.scheduler && s.push([\n        _o,\n        [\n            [\n                r,\n                n.scheduler\n            ]\n        ]\n    ]);\n    let c = t0(e.fiberRefs, {\n        entries: s,\n        forkAs: r\n    });\n    n != null && n.updateRefs && (c = n.updateRefs(c, r));\n    const i = new id(r, c, e.runtimeFlags);\n    let o = t;\n    n != null && n.scope && (o = m(wO(n.scope, Zs), (h)=>oe(Jf(h, fr((d)=>O(d, i.id()) ? K : es(i, d))), rn(t, (d)=>vO(h, d)))));\n    const a = i.currentSupervisor;\n    return a !== sc && (a.onStart(e.context, o, v(), i), i.addObserver((h)=>a.onEnd(h, i))), tc.add(e.runtimeFlags, i), (n == null ? void 0 : n.immediate) === !1 ? i.resume(o) : i.start(o), i;\n}), f$ = /* @__PURE__ */ Sr((e, t)=>{\n    const n = m$(e)(t);\n    if (n._tag === \"Failure\") throw Od(n.effect_instruction_i0);\n    return n.effect_instruction_i0;\n});\nclass h$ extends Error {\n    constructor(n){\n        super(\"Fiber #\".concat(n.id().id, \" cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\"));\n        u(this, \"fiber\");\n        u(this, \"_tag\", \"AsyncFiberException\");\n        this.fiber = n, this.name = this._tag, this.stack = this.message;\n    }\n}\nconst d$ = (e)=>{\n    const t = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    const n = new h$(e);\n    return Error.stackTraceLimit = t, n;\n}, _c = /* @__PURE__ */ Symbol.for(\"effect/Runtime/FiberFailure\"), Mr = /* @__PURE__ */ Symbol.for(\"effect/Runtime/FiberFailure/Cause\");\nvar Gu, Yu;\nclass g$ extends Error {\n    toJSON() {\n        return {\n            _id: \"FiberFailure\",\n            cause: this[Mr].toJSON()\n        };\n    }\n    toString() {\n        return \"(FiberFailure) \" + ar(this[Mr], {\n            renderErrorCause: !0\n        });\n    }\n    [(Yu = _c, Gu = Mr, U)]() {\n        return this.toString();\n    }\n    constructor(n){\n        const r = If(n)[0];\n        super((r == null ? void 0 : r.message) || \"An error has occurred\");\n        u(this, Yu);\n        u(this, Gu);\n        this[_c] = _c, this[Mr] = n, this.name = r ? \"(FiberFailure) \".concat(r.name) : \"FiberFailure\", r != null && r.stack && (this.stack = r.stack);\n    }\n}\nconst Od = (e)=>{\n    const t = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    const n = new g$(e);\n    return Error.stackTraceLimit = t, n;\n}, $d = (e)=>{\n    const t = e;\n    switch(t._op){\n        case \"Failure\":\n        case \"Success\":\n            return t;\n        case \"Left\":\n            return ha(t.left);\n        case \"Right\":\n            return j(t.right);\n        case \"Some\":\n            return j(t.value);\n        case \"None\":\n            return ha(Hs());\n    }\n}, m$ = /* @__PURE__ */ Sr((e, t)=>{\n    const n = $d(t);\n    if (n) return n;\n    const r = new Tk(), s = Ro(e)(t, {\n        scheduler: r\n    });\n    r.flush();\n    const c = s.unsafePoll();\n    return c || Fn(Ki(d$(s), io(s)));\n}), p$ = /* @__PURE__ */ Sr((e, t, n)=>Ed(e, t, n).then((r)=>{\n        switch(r._tag){\n            case ne:\n                return r.effect_instruction_i0;\n            case te:\n                throw Od(r.effect_instruction_i0);\n        }\n    })), Ed = /* @__PURE__ */ Sr((e, t, n)=>new Promise((r)=>{\n        const s = $d(t);\n        s && r(s);\n        const c = Ro(e)(t);\n        c.addObserver((i)=>{\n            r(i);\n        }), (n == null ? void 0 : n.signal) !== void 0 && (n.signal.aborted ? c.unsafeInterruptAsFork(c.id()) : n.signal.addEventListener(\"abort\", ()=>{\n            c.unsafeInterruptAsFork(c.id());\n        }, {\n            once: !0\n        }));\n    }));\nclass Id {\n    pipe() {\n        return w(this, arguments);\n    }\n    constructor(t, n, r){\n        u(this, \"context\");\n        u(this, \"runtimeFlags\");\n        u(this, \"fiberRefs\");\n        this.context = t, this.runtimeFlags = n, this.fiberRefs = r;\n    }\n}\nconst _$ = (e)=>new Id(e.context, e.runtimeFlags, e.fiberRefs), y$ = ()=>L((e, t)=>S(new Id(e.getFiberRef(rt), t.runtimeFlags, e.getFiberRefs()))), b$ = /* @__PURE__ */ bf(gn, _f, pf), on = /* @__PURE__ */ _$({\n    context: /* @__PURE__ */ Oi(),\n    runtimeFlags: b$,\n    fiberRefs: /* @__PURE__ */ n0()\n}), S$ = /* @__PURE__ */ Ro(on), k$ = /* @__PURE__ */ p$(on), v$ = /* @__PURE__ */ Ed(on), w$ = /* @__PURE__ */ f$(on), O$ = /* @__PURE__ */ l(2, (e, t)=>e.modifyEffect(t)), $$ = \"effect/Layer\", Fd = /* @__PURE__ */ Symbol.for($$), E$ = {\n    /* c8 ignore next */ _RIn: (e)=>e,\n    /* c8 ignore next */ _E: (e)=>e,\n    /* c8 ignore next */ _ROut: (e)=>e\n}, an = {\n    [Fd]: E$,\n    pipe () {\n        return w(this, arguments);\n    }\n}, I$ = \"effect/Layer/MemoMap\", yc = /* @__PURE__ */ Symbol.for(I$), F$ = /* @__PURE__ */ $i()(\"effect/Layer/CurrentMemoMap\", {\n    defaultValue: ()=>C$()\n}), R$ = (e)=>$(e, Fd), M$ = (e)=>e._op_layer === s$;\nvar Qu;\nQu = yc;\nclass Rd {\n    /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */ getOrElseMemoize(t, n) {\n        return f(O$(this.ref, (r)=>{\n            const s = r.get(t);\n            if (s !== void 0) {\n                const [c, i] = s, o = f(c, m((param)=>{\n                    let [a, h] = param;\n                    return f(M0(a), fe(h));\n                }), rn(to({\n                    onFailure: ()=>K,\n                    onSuccess: ()=>ts(n, i)\n                })));\n                return S([\n                    o,\n                    r\n                ]);\n            }\n            return f(Jc(0), m((c)=>f(Ab(), m((i)=>f(Jc(()=>K), T((o)=>{\n                        const a = Ee((d)=>f(Eo(), m((g)=>f(d(m(Td(t, g, !0), (p)=>$0(p(this)))), Ye, m((p)=>{\n                                    switch(p._tag){\n                                        case te:\n                                            return f(jb(i, p.effect_instruction_i0), oe(Bc(g, p)), oe(Z(p.effect_instruction_i0)));\n                                        case ne:\n                                            return f(cs(o, (_)=>f(Bc(g, _), rb(y0(c, (b)=>[\n                                                        b === 1,\n                                                        b - 1\n                                                    ])), nt)), oe($a(c, (_)=>_ + 1)), oe(ts(n, (_)=>f(y(()=>r.delete(t)), oe(mt(o)), m((b)=>b(_))))), oe(Lb(i, p.effect_instruction_i0)), fe(p.effect_instruction_i0[1]));\n                                    }\n                                }))))), h = [\n                            f(ro(i), rn(Vc({\n                                onFailure: ()=>K,\n                                onSuccess: ()=>$a(c, (d)=>d + 1)\n                            }))),\n                            (d)=>f(mt(o), m((g)=>g(d)))\n                        ];\n                        return [\n                            a,\n                            M$(t) ? r : r.set(t, h)\n                        ];\n                    }))))));\n        }), zs);\n    }\n    constructor(t){\n        u(this, \"ref\");\n        u(this, Qu);\n        this.ref = t, this[yc] = yc;\n    }\n}\nconst T$ = /* @__PURE__ */ N(()=>T(n$(/* @__PURE__ */ new Map()), (e)=>new Rd(e))), C$ = ()=>new Rd(wd(/* @__PURE__ */ new Map())), Md = /* @__PURE__ */ l(2, (e, t)=>m(T$, (n)=>N$(e, n, t))), N$ = /* @__PURE__ */ l(3, (e, t, n)=>m(Td(e, n), (r)=>Eh(r(t), F$, t))), Td = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    const r = e;\n    switch(r._op_layer){\n        case \"Locally\":\n            return y(()=>(s)=>r.f(s.getOrElseMemoize(r.self, t)));\n        case \"ExtendScope\":\n            return y(()=>(s)=>jw((c)=>s.getOrElseMemoize(r.layer, c)));\n        case \"Fold\":\n            return y(()=>(s)=>f(s.getOrElseMemoize(r.layer, t), Se({\n                        onFailure: (c)=>s.getOrElseMemoize(r.failureK(c), t),\n                        onSuccess: (c)=>s.getOrElseMemoize(r.successK(c), t)\n                    })));\n        case \"Fresh\":\n            return y(()=>(s)=>f(r.layer, Md(t)));\n        case \"FromEffect\":\n            return y(n ? ()=>(s)=>r.effect : ()=>(s)=>s.getOrElseMemoize(e, t));\n        case \"Provide\":\n            return y(()=>(s)=>f(s.getOrElseMemoize(r.first, t), m((c)=>f(s.getOrElseMemoize(r.second, t), so(c)))));\n        case \"Scoped\":\n            return y(n ? ()=>(s)=>yr(r.effect, t) : ()=>(s)=>s.getOrElseMemoize(e, t));\n        case \"Suspend\":\n            return y(()=>(s)=>s.getOrElseMemoize(r.evaluate(), t));\n        case \"ProvideMerge\":\n            return y(()=>(s)=>f(s.getOrElseMemoize(r.first, t), Uf(s.getOrElseMemoize(r.second, t), r.zipK)));\n        case \"ZipWith\":\n            return y(()=>(s)=>f(s.getOrElseMemoize(r.first, t), _r(s.getOrElseMemoize(r.second, t), r.zipK, {\n                        concurrent: !0\n                    })));\n    }\n}, A$ = ()=>cc(Zf()), P$ = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Fs(e), r = n ? e : t;\n    return cc(T(n ? t : e, (c)=>rr(r, c)));\n});\nfunction cc(e) {\n    const t = Object.create(an);\n    return t._op_layer = c$, t.effect = e, t;\n}\nconst x$ = /* @__PURE__ */ l(2, (e, t)=>z$(e, t, (n, r)=>fn(n, r))), Cd = function() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    let t = e[0];\n    for(let n = 1; n < e.length; n++)t = x$(t, e[n]);\n    return t;\n}, j$ = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Fs(e), r = n ? e : t;\n    return L$(T(n ? t : e, (c)=>rr(r, c)));\n}), L$ = (e)=>{\n    const t = Object.create(an);\n    return t._op_layer = i$, t.effect = e, t;\n}, D$ = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Fs(e);\n    return cc(S(rr(n ? e : t, n ? t : e)));\n}), Nd = (e)=>{\n    const t = Object.create(an);\n    return t._op_layer = o$, t.evaluate = e, t;\n}, q$ = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Fs(e), r = n ? e : t, s = n ? t : e;\n    return cc(y(()=>rr(r, s())));\n}), U$ = /* @__PURE__ */ l(2, (e, t)=>Nd(()=>{\n        const n = Object.create(an);\n        return n._op_layer = a$, n.first = Object.create(an, {\n            _op_layer: {\n                value: u$,\n                enumerable: !0\n            },\n            first: {\n                value: A$(),\n                enumerable: !0\n            },\n            second: {\n                value: Array.isArray(t) ? Cd(...t) : t\n            },\n            zipK: {\n                value: (r, s)=>f(r, fn(s))\n            }\n        }), n.second = e, n;\n    })), z$ = /* @__PURE__ */ l(3, (e, t, n)=>Nd(()=>{\n        const r = Object.create(an);\n        return r._op_layer = l$, r.first = e, r.second = t, r.zipK = n, r;\n    })), Ga = /* @__PURE__ */ l(2, (e, t)=>ld((n)=>m(Md(t, n), (r)=>co(e, r)))), Ya = /* @__PURE__ */ l(2, (e, t)=>{\n    const n = Wn(on.fiberRefs, t.fiberRefs), r = gt(on.runtimeFlags, t.runtimeFlags);\n    return Ee((s)=>L((c)=>{\n            const i = c.getFiberRef(rt), o = c.getFiberRefs(), a = Jn(c.id(), o)(n), h = c.currentRuntimeFlags, d = Dt(r)(h), g = Wn(a, o), p = gt(d, h);\n            return c.setFiberRefs(a), c.currentRuntimeFlags = d, Hn(co(s(e), fn(i, t.context)), L((_)=>(_.setFiberRefs(Jn(_.id(), _.getFiberRefs())(g)), _.currentRuntimeFlags = Dt(p)(_.currentRuntimeFlags), K)));\n        }));\n}), B$ = /* @__PURE__ */ l(2, (e, t)=>Array.isArray(t) ? Ga(e, Cd(...t)) : R$(t) ? Ga(e, t) : Sm(t) ? co(e, t) : r$ in t ? m(t.runtimeEffect, (n)=>Ya(e, n)) : Ya(e, t)), zE = Le, BE = od, VE = cn, KE = L, WE = x, JE = Z, HE = qc, GE = cb, YE = T0, QE = S, ZE = N, XE = y, eI = K, tI = Zr, nI = Pf, rI = F0, sI = O0, cI = x0, iI = Qy, oI = Ji, aI = Ks, uI = Ee, lI = E0, fI = fe, hI = nt, Qa = T, dI = Hi, gI = Vs, mI = Mw, pI = Cf, _I = Hn, yI = fd, bI = ld, SI = fr, kI = $o, vI = QO, wI = B$, OI = Eh, $I = nn, EI = Ye, II = Zy, FI = L0, RI = m, MI = jt, TI = zs, CI = Kw, NI = dd, AI = Gi, PI = P0, xI = JO, jI = $h, LI = jf, DI = Se, qI = y$, UI = YO, zI = S$, BI = k$, VI = v$, KI = w$, WI = Lw, JI = Dw, HI = qw, GI = _r, YI = D0, V$ = (e)=>{\n    const t = /* @__PURE__ */ new Map();\n    return new Proxy(e, {\n        get (n, r, s) {\n            if (r in n) return Reflect.get(n, r, s);\n            if (t.has(r)) return t.get(r);\n            const c = function() {\n                for(var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++){\n                    o[_key] = arguments[_key];\n                }\n                return jt(n, (a)=>typeof a[r] == \"function\" ? (t.set(r, function() {\n                        for(var _len = arguments.length, h = new Array(_len), _key = 0; _key < _len; _key++){\n                            h[_key] = arguments[_key];\n                        }\n                        return jt(n, (d)=>d[r](...h));\n                    }), a[r](...o)) : (t.set(r, jt(n, (h)=>h[r])), a[r]));\n            }, i = jt(n, (o)=>o[r]);\n            return Object.assign(c, i), Object.setPrototypeOf(c, Object.getPrototypeOf(i)), t.set(r, c), c;\n        }\n    });\n}, QI = function() {\n    return function() {\n        const [e, t] = arguments, n = \"accessors\" in t ? t.accessors : !1, r = Error.stackTraceLimit;\n        Error.stackTraceLimit = 2;\n        const s = new Error();\n        Error.stackTraceLimit = r;\n        let c = \"unchecked\";\n        const i = function(d) {\n            if (c === \"unchecked\") {\n                const g = Object.getPrototypeOf(d);\n                if (g === Object.prototype || g === null) c = \"plain\";\n                else {\n                    const p = Object.getPrototypeOf(this);\n                    Object.setPrototypeOf(p, g), c = \"patched\";\n                }\n            }\n            if (c === \"plain\") Object.assign(this, d);\n            else if (c === \"patched\") return Object.setPrototypeOf(d, Object.getPrototypeOf(this)), d;\n        };\n        i.prototype._tag = e, Object.defineProperty(i, \"make\", {\n            get () {\n                return (d)=>new this(d);\n            }\n        }), Object.defineProperty(i, \"use\", {\n            get () {\n                return (d)=>jt(this, d);\n            }\n        }), i.key = e, Object.assign(i, Is), Object.defineProperty(i, \"stack\", {\n            get () {\n                return s.stack;\n            }\n        });\n        const o = \"dependencies\" in t && t.dependencies.length > 0, a = o ? \"DefaultWithoutDependencies\" : \"Default\";\n        let h;\n        if (\"effect\" in t ? Object.defineProperty(i, a, {\n            get () {\n                return h !== null && h !== void 0 ? h : h = P$(i, Qa(t.effect, (d)=>new this(d)));\n            }\n        }) : \"scoped\" in t ? Object.defineProperty(i, a, {\n            get () {\n                return h !== null && h !== void 0 ? h : h = j$(i, Qa(t.scoped, (d)=>new this(d)));\n            }\n        }) : \"sync\" in t ? Object.defineProperty(i, a, {\n            get () {\n                return h !== null && h !== void 0 ? h : h = q$(i, ()=>new this(t.sync()));\n            }\n        }) : Object.defineProperty(i, a, {\n            get () {\n                return h !== null && h !== void 0 ? h : h = D$(i, new this(t.succeed));\n            }\n        }), o) {\n            let d;\n            Object.defineProperty(i, \"Default\", {\n                get () {\n                    return d !== null && d !== void 0 ? d : d = U$(this.DefaultWithoutDependencies, t.dependencies);\n                }\n            });\n        }\n        return n === !0 ? V$(i) : i;\n    };\n};\n\nvar _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14;\n$RefreshReg$(_c1, \"No\");\n$RefreshReg$(_c2, \"Qd\");\n$RefreshReg$(_c3, \"Do\");\n$RefreshReg$(_c4, \"Zd\");\n$RefreshReg$(_c5, \"O\");\n$RefreshReg$(_c6, \"Kt\");\n$RefreshReg$(_c7, \"Ul\");\n$RefreshReg$(_c8, \"Lt\");\n$RefreshReg$(_c9, \"Rs\");\n$RefreshReg$(_c10, \"Bl\");\n$RefreshReg$(_c11, \"Qo\");\n$RefreshReg$(_c12, \"Zo\");\n$RefreshReg$(_c13, \"JS\");\n$RefreshReg$(_c14, \"HS\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9tZWRmZXRjaC9kaXN0L0VmZmVjdC1ENHJCYW1vei5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsS0FBS0MsT0FBT0MsY0FBYztBQUM5QixJQUFJQyxLQUFLLENBQUNDO0lBQ1IsTUFBTUMsVUFBVUQ7QUFDbEI7TUFGSUQ7QUFHSixJQUFJRyxLQUFLLENBQUNGLEdBQUdHLEdBQUdDLElBQU1ELEtBQUtILElBQUlKLEdBQUdJLEdBQUdHLEdBQUc7UUFBRUUsWUFBWSxDQUFDO1FBQUdDLGNBQWMsQ0FBQztRQUFHQyxVQUFVLENBQUM7UUFBR0MsT0FBT0o7SUFBRSxLQUFLSixDQUFDLENBQUNHLEVBQUUsR0FBR0M7QUFDL0csSUFBSUssSUFBSSxDQUFDVCxHQUFHRyxHQUFHQyxJQUFNRixHQUFHRixHQUFHLE9BQU9HLEtBQUssV0FBV0EsSUFBSSxLQUFLQSxHQUFHQyxJQUFJTSxLQUFLLENBQUNWLEdBQUdHLEdBQUdDLElBQU1ELEVBQUVRLEdBQUcsQ0FBQ1gsTUFBTUQsR0FBRyxZQUFZSztBQUMvRyxJQUFJUSxLQUFLLENBQUNaLEdBQUdHLEdBQUdDLElBQU9NLENBQUFBLEdBQUdWLEdBQUdHLEdBQUcsNEJBQTRCQyxJQUFJQSxFQUFFUyxJQUFJLENBQUNiLEtBQUtHLEVBQUVXLEdBQUcsQ0FBQ2QsRUFBQyxHQUFJZSxLQUFLLENBQUNmLEdBQUdHLEdBQUdDLElBQU1ELEVBQUVRLEdBQUcsQ0FBQ1gsS0FBS0Qs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QUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDSDtRQUM3QixLQUFLO1lBQ0gsT0FBT0csQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0g7UUFDbEMsS0FBSztZQUNILE9BQU9HLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNIO1FBQ3ZDLEtBQUs7WUFDSCxPQUFPRyxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDSDtRQUM1QyxLQUFLO1lBQ0gsT0FBT0csQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0g7UUFDakQsS0FBSztZQUNILE9BQU9HLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUNBLENBQUMsQ0FB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LENBQUNBO1lBQ3REO1FBQ0YsS0FBSyxZQUFZdEMsSUFBSU4sT0FBT0MsY0FBYyxDQUFDK0IsR0FBR1UsR0FBRztZQUMvQ3pCO2dCQUNFLE9BQU8wQixjQUFBQSxlQUFBQSxJQUFNQSxJQUFJcS9ELEdBQUdoZ0UsR0FBR21pRSxHQUFHN2pFLEVBQUV5bUUsTUFBTSxFQUFFLENBQUNua0UsSUFBTSxJQUFJLElBQUksQ0FBQ0E7WUFDdEQ7UUFDRixLQUFLLFVBQVV0QyxJQUFJTixPQUFPQyxjQUFjLENBQUMrQixHQUFHVSxHQUFHO1lBQzdDekI7Z0JBQ0UsT0FBTzBCLGNBQUFBLGVBQUFBLElBQU1BLElBQUl5L0QsR0FBR3BnRSxHQUFHLElBQU0sSUFBSSxJQUFJLENBQUMxQixFQUFFMG1FLElBQUk7WUFDOUM7UUFDRixLQUFLaG5FLE9BQU9DLGNBQWMsQ0FBQytCLEdBQUdVLEdBQUc7WUFDL0J6QjtnQkFDRSxPQUFPMEIsY0FBQUEsZUFBQUEsSUFBTUEsSUFBSXUvRCxHQUFHbGdFLEdBQUcsSUFBSSxJQUFJLENBQUMxQixFQUFFMm1FLE9BQU87WUFDM0M7UUFDRixJQUFJaGxFLEdBQUc7WUFDTCxJQUFJVztZQUNKNUMsT0FBT0MsY0FBYyxDQUFDK0IsR0FBRyxXQUFXO2dCQUNsQ2Y7b0JBQ0UsT0FBTzJCLGNBQUFBLGVBQUFBLElBQU1BLElBQUl5L0QsR0FBRyxJQUFJLENBQUM2RSwwQkFBMEIsRUFBRTVtRSxFQUFFd21FLFlBQVk7Z0JBQ3JFO1lBQ0Y7UUFDRjtRQUNBLE9BQU92bUUsTUFBTSxDQUFDLElBQUltbUUsR0FBRzFrRSxLQUFLQTtJQUM1QjtBQUNGO0FBcU9FIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL21lZGZldGNoL2Rpc3QvRWZmZWN0LUQ0ckJhbW96Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgTm8gPSAoZSkgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IoZSk7XG59O1xudmFyIHhkID0gKGUsIHQsIG4pID0+IHQgaW4gZSA/IFBkKGUsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IG4gfSkgOiBlW3RdID0gbjtcbnZhciB1ID0gKGUsIHQsIG4pID0+IHhkKGUsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIG4pLCBBbyA9IChlLCB0LCBuKSA9PiB0LmhhcyhlKSB8fCBObyhcIkNhbm5vdCBcIiArIG4pO1xudmFyIFBvID0gKGUsIHQsIG4pID0+IChBbyhlLCB0LCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBuID8gbi5jYWxsKGUpIDogdC5nZXQoZSkpLCB4byA9IChlLCB0LCBuKSA9PiB0LmhhcyhlKSA/IE5vKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IHQgaW5zdGFuY2VvZiBXZWFrU2V0ID8gdC5hZGQoZSkgOiB0LnNldChlLCBuKSwgam8gPSAoZSwgdCwgbiwgcikgPT4gKEFvKGUsIHQsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgciA/IHIuY2FsbChlLCBuKSA6IHQuc2V0KGUsIG4pLCBuKTtcbmNvbnN0IGpkID0gKGUpID0+IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiwgbCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZShhcmd1bWVudHMpID8gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogKG4pID0+IHQobiwgLi4uYXJndW1lbnRzKTtcbiAgICB9O1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxOlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgYXJpdHkgJHtlfWApO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID49IDIgPyB0KG4sIHIpIDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiB0KHMsIG4pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24obiwgciwgcykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+PSAzID8gdChuLCByLCBzKSA6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gdChjLCBuLCByKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4sIHIsIHMsIGMpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPj0gNCA/IHQobiwgciwgcywgYykgOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHQoaSwgbiwgciwgcyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihuLCByLCBzLCBjLCBpKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID49IDUgPyB0KG4sIHIsIHMsIGMsIGkpIDogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0KG8sIG4sIHIsIHMsIGMpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSBlKVxuICAgICAgICAgIHJldHVybiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IG4gPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHQociwgLi4ubik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICB9XG59LCBQID0gKGUpID0+IGUsIFFuID0gKGUpID0+ICgpID0+IGUsIExvID0gLyogQF9fUFVSRV9fICovIFFuKCEwKSwgYmMgPSAvKiBAX19QVVJFX18gKi8gUW4oITEpLCBMZCA9IC8qIEBfX1BVUkVfXyAqLyBRbihudWxsKSwgWnUgPSAvKiBAX19QVVJFX18gKi8gUW4odm9pZCAwKSwgU2MgPSBadTtcbmZ1bmN0aW9uIGYoZSwgdCwgbiwgciwgcywgYywgaSwgbywgYSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gdChlKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gbih0KGUpKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcihuKHQoZSkpKTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gcyhyKG4odChlKSkpKTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gYyhzKHIobih0KGUpKSkpKTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gaShjKHMocihuKHQoZSkpKSkpKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gbyhpKGMocyhyKG4odChlKSkpKSkpKTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gYShvKGkoYyhzKHIobih0KGUpKSkpKSkpKTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgaCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAobGV0IGQgPSAxOyBkIDwgYXJndW1lbnRzLmxlbmd0aDsgZCsrKVxuICAgICAgICBoID0gYXJndW1lbnRzW2RdKGgpO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICB9XG59XG5jb25zdCB5cyA9IChlKSA9PiAodCwgbikgPT4gdCA9PT0gbiB8fCBlKHQsIG4pLCBEZCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB5cygobiwgcikgPT4gZSh0KG4pLCB0KHIpKSkpLCBxZCA9IChlKSA9PiB5cygodCwgbikgPT4ge1xuICBpZiAodC5sZW5ndGggIT09IG4ubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGlmICghZSh0W3JdLCBuW3JdKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufSk7XG5sZXQgVWQgPSBcIjMuMTQuMTJcIjtcbmNvbnN0IGJzID0gKCkgPT4gVWQsIE9yID0gYGVmZmVjdC9HbG9iYWxWYWx1ZS9nbG9iYWxTdG9yZUlkLyR7LyogQF9fUFVSRV9fICovIGJzKCl9YDtcbmxldCB3bjtcbmNvbnN0IEMgPSAoZSwgdCkgPT4gKHduIHx8IChnbG9iYWxUaGlzW09yXSA/PyAoZ2xvYmFsVGhpc1tPcl0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgd24gPSBnbG9iYWxUaGlzW09yXSksIHduLmhhcyhlKSB8fCB3bi5zZXQoZSwgdCgpKSwgd24uZ2V0KGUpKSwgemQgPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiwga2MgPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJudW1iZXJcIiwgVyQgPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJib29sZWFuXCIsIEJkID0gKGUpID0+IHR5cGVvZiBlID09IFwiYmlnaW50XCIsIEokID0gKGUpID0+IHR5cGVvZiBlID09IFwic3ltYm9sXCIsIFpuID0gamQsIEgkID0gKGUpID0+IGUgPT09IHZvaWQgMCwgRyQgPSAoZSkgPT4gZSAhPT0gdm9pZCAwLCBZJCA9IChlKSA9PiBlICE9PSBudWxsLCBRJCA9IChlKSA9PiAhMSwgWHUgPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsLCBTcyA9IChlKSA9PiBYdShlKSB8fCBabihlKSwgJCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBTcyhlKSAmJiB0IGluIGUpLCBlbCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiAkKGUsIFwiX3RhZ1wiKSAmJiBlLl90YWcgPT09IHQpLCBUdCA9IChlKSA9PiBlID09IG51bGwsIFokID0gKGUpID0+IGUgIT0gbnVsbCwgWCQgPSAoZSkgPT4gZSBpbnN0YW5jZW9mIERhdGUsIHRsID0gKGUpID0+ICQoZSwgU3ltYm9sLml0ZXJhdG9yKSwgZUUgPSAoZSkgPT4gWHUoZSkgJiYgIUFycmF5LmlzQXJyYXkoZSksIG5sID0gKGUpID0+ICQoZSwgXCJ0aGVuXCIpICYmIFpuKGUudGhlbiksIGtzID0gKGUpID0+IGBCVUc6ICR7ZX0gLSBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9FZmZlY3QtVFMvZWZmZWN0L2lzc3Vlc2A7XG5sZXQgcmwgPSBjbGFzcyBzbCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwic2VsZlwiKTtcbiAgICB1KHRoaXMsIFwiY2FsbGVkXCIsICExKTtcbiAgICB0aGlzLnNlbGYgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIG5leHQodCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxlZCA/IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZG9uZTogITBcbiAgICB9IDogKHRoaXMuY2FsbGVkID0gITAsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnNlbGYsXG4gICAgICBkb25lOiAhMVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHJldHVybih0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHRocm93KHQpIHtcbiAgICB0aHJvdyB0O1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgc2wodGhpcy5zZWxmKTtcbiAgfVxufTtcbmNvbnN0IFZkID0gMzM1OTAzNjE0LCBLZCA9IDQxNTA3NTU2NjMsIFdkID0gMTQ4MTc2NTkzMywgSmQgPSAxMjg0ODY1ODM3LCBIZCA9IDkwMDcxOTkyNTQ3NDA5OTIsIEdkID0gMTM0MjE3NzI4O1xuY2xhc3MgWWQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByLCBzKSB7XG4gICAgdSh0aGlzLCBcIl9zdGF0ZVwiKTtcbiAgICByZXR1cm4gVHQobikgJiYgVHQodCkgPyAobiA9IE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1ID4+PiAwLCB0ID0gMCkgOiBUdChuKSAmJiAobiA9IHQsIHQgPSAwKSwgVHQocykgJiYgVHQocikgPyAocyA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbM10gOiBLZCwgciA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbMl0gOiBWZCkgOiBUdChzKSAmJiAocyA9IHIsIHIgPSAwKSwgdGhpcy5fc3RhdGUgPSBuZXcgSW50MzJBcnJheShbMCwgMCwgciA+Pj4gMCwgKChzIHx8IDApIHwgMSkgPj4+IDBdKSwgdGhpcy5fbmV4dCgpLCBEbyh0aGlzLl9zdGF0ZSwgdGhpcy5fc3RhdGVbMF0sIHRoaXMuX3N0YXRlWzFdLCB0ID4+PiAwLCBuID4+PiAwKSwgdGhpcy5fbmV4dCgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhcyBhXG4gICAqIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9zdGF0ZVswXSwgdGhpcy5fc3RhdGVbMV0sIHRoaXMuX3N0YXRlWzJdLCB0aGlzLl9zdGF0ZVszXV07XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmUgc3RhdGUgcHJldmlvdXNseSByZXRyaWV2ZWQgdXNpbmcgYGdldFN0YXRlKClgLlxuICAgKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNldFN0YXRlKHQpIHtcbiAgICB0aGlzLl9zdGF0ZVswXSA9IHRbMF0sIHRoaXMuX3N0YXRlWzFdID0gdFsxXSwgdGhpcy5fc3RhdGVbMl0gPSB0WzJdLCB0aGlzLl9zdGF0ZVszXSA9IHRbM10gfCAxO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgMzIgYml0IGludGVnZXIgYmV0d2VlbiBbMCwgbWF4KS5cbiAgICpcbiAgICogQGNhdGVnb3J5IGdldHRlclxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGludGVnZXIodCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMubnVtYmVyKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgJSB0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgSUVFRS03NTQgZG91YmxlIGJldHdlZW4gMC4wIGFuZCAxLjAsIHdpdGhcbiAgICogNTMgYml0cyBvZiBwcmVjaXNpb24gKGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2EgaXMgcmFuZG9taXplZCkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgbnVtYmVyKCkge1xuICAgIGNvbnN0IHQgPSAodGhpcy5fbmV4dCgpICYgNjcxMDg4NjMpICogMSwgbiA9ICh0aGlzLl9uZXh0KCkgJiAxMzQyMTc3MjcpICogMTtcbiAgICByZXR1cm4gKHQgKiBHZCArIG4pIC8gSGQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbmV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc3RhdGVbMF0gPj4+IDAsIG4gPSB0aGlzLl9zdGF0ZVsxXSA+Pj4gMDtcbiAgICBRZCh0aGlzLl9zdGF0ZSwgdCwgbiwgV2QsIEpkKSwgRG8odGhpcy5fc3RhdGUsIHRoaXMuX3N0YXRlWzBdLCB0aGlzLl9zdGF0ZVsxXSwgdGhpcy5fc3RhdGVbMl0sIHRoaXMuX3N0YXRlWzNdKTtcbiAgICBsZXQgciA9IHQgPj4+IDE4LCBzID0gKG4gPj4+IDE4IHwgdCA8PCAxNCkgPj4+IDA7XG4gICAgciA9IChyIF4gdCkgPj4+IDAsIHMgPSAocyBeIG4pID4+PiAwO1xuICAgIGNvbnN0IGMgPSAocyA+Pj4gMjcgfCByIDw8IDUpID4+PiAwLCBpID0gdCA+Pj4gMjcsIG8gPSAoLWkgPj4+IDAgJiAzMSkgPj4+IDA7XG4gICAgcmV0dXJuIChjID4+PiBpIHwgYyA8PCBvKSA+Pj4gMDtcbiAgfVxufVxuZnVuY3Rpb24gUWQoZSwgdCwgbiwgciwgcykge1xuICBsZXQgYyA9IChuID4+PiAxNikgKiAocyAmIDY1NTM1KSA+Pj4gMCwgaSA9IChuICYgNjU1MzUpICogKHMgPj4+IDE2KSA+Pj4gMCwgbyA9IChuICYgNjU1MzUpICogKHMgJiA2NTUzNSkgPj4+IDAsIGEgPSAobiA+Pj4gMTYpICogKHMgPj4+IDE2KSArICgoaSA+Pj4gMTYpICsgKGMgPj4+IDE2KSkgPj4+IDA7XG4gIGkgPSBpIDw8IDE2ID4+PiAwLCBvID0gbyArIGkgPj4+IDAsIG8gPj4+IDAgPCBpID4+PiAwICYmIChhID0gYSArIDEgPj4+IDApLCBjID0gYyA8PCAxNiA+Pj4gMCwgbyA9IG8gKyBjID4+PiAwLCBvID4+PiAwIDwgYyA+Pj4gMCAmJiAoYSA9IGEgKyAxID4+PiAwKSwgYSA9IGEgKyBNYXRoLmltdWwobiwgcikgPj4+IDAsIGEgPSBhICsgTWF0aC5pbXVsKHQsIHMpID4+PiAwLCBlWzBdID0gYSwgZVsxXSA9IG87XG59XG5mdW5jdGlvbiBEbyhlLCB0LCBuLCByLCBzKSB7XG4gIGxldCBjID0gdCArIHIgPj4+IDA7XG4gIGNvbnN0IGkgPSBuICsgcyA+Pj4gMDtcbiAgaSA+Pj4gMCA8IG4gPj4+IDAgJiYgKGMgPSBjICsgMSB8IDApLCBlWzBdID0gYywgZVsxXSA9IGk7XG59XG5jb25zdCB2YyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1V0aWxzL1lpZWxkV3JhcFwiKTtcbnZhciBZbjtcbmNsYXNzIFhuIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjAuNlxuICAgICAqL1xuICAgIHhvKHRoaXMsIFluKTtcbiAgICBqbyh0aGlzLCBZbiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAzLjAuNlxuICAgKi9cbiAgW3ZjXSgpIHtcbiAgICByZXR1cm4gUG8odGhpcywgWW4pO1xuICB9XG59XG5ZbiA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBaZChlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgdmMgaW4gZSlcbiAgICByZXR1cm4gZVt2Y10oKTtcbiAgdGhyb3cgbmV3IEVycm9yKGtzKFwieWllbGRXcmFwR2V0XCIpKTtcbn1cbmNvbnN0IHBlID0gLyogQF9fUFVSRV9fICovIEMoXCJlZmZlY3QvVXRpbHMvaXNTdHJ1Y3R1cmFsUmVnaW9uXCIsICgpID0+ICh7XG4gIGVuYWJsZWQ6ICExLFxuICB0ZXN0ZXI6IHZvaWQgMFxufSkpLCBYZCA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSB7XG4gICAgW2VdKG4pIHtcbiAgICAgIHJldHVybiBuKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0W2VdKG4pO1xuICB9O1xufSwgZWUgPSAvKiBAX19QVVJFX18gKi8gWGQoXCJlZmZlY3RfaW50ZXJuYWxfZnVuY3Rpb25cIiksIGljID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvSGFzaC9yYW5kb21IYXNoQ2FjaGVcIiksICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKSwgRiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0hhc2hcIiksIGsgPSAoZSkgPT4ge1xuICBpZiAocGUuZW5hYmxlZCA9PT0gITApXG4gICAgcmV0dXJuIDA7XG4gIHN3aXRjaCAodHlwZW9mIGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gZGkoZSk7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIEIoZS50b1N0cmluZygxMCkpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gQihTdHJpbmcoZSkpO1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBCKFN0cmluZyhlKSk7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIEIoZSk7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIEIoXCJ1bmRlZmluZWRcIik7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIGUgPT09IG51bGwgPyBCKFwibnVsbFwiKSA6IGUgaW5zdGFuY2VvZiBEYXRlID8gayhlLnRvSVNPU3RyaW5nKCkpIDogZSBpbnN0YW5jZW9mIFVSTCA/IGsoZS5ocmVmKSA6IGVnKGUpID8gZVtGXSgpIDogaGkoZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiB1bmhhbmRsZWQgdHlwZW9mICR7dHlwZW9mIGV9IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNgKTtcbiAgfVxufSwgaGkgPSAoZSkgPT4gKGljLmhhcyhlKSB8fCBpYy5zZXQoZSwgZGkoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSksIGljLmdldChlKSksIFIgPSAoZSkgPT4gKHQpID0+IHQgKiA1MyBeIGUsIHZzID0gKGUpID0+IGUgJiAzMjIxMjI1NDcxIHwgZSA+Pj4gMSAmIDEwNzM3NDE4MjQsIGVnID0gKGUpID0+ICQoZSwgRiksIGRpID0gKGUpID0+IHtcbiAgaWYgKGUgIT09IGUgfHwgZSA9PT0gMSAvIDApXG4gICAgcmV0dXJuIDA7XG4gIGxldCB0ID0gZSB8IDA7XG4gIGZvciAodCAhPT0gZSAmJiAodCBePSBlICogNDI5NDk2NzI5NSk7IGUgPiA0Mjk0OTY3Mjk1OyApXG4gICAgdCBePSBlIC89IDQyOTQ5NjcyOTU7XG4gIHJldHVybiB2cyh0KTtcbn0sIEIgPSAoZSkgPT4ge1xuICBsZXQgdCA9IDUzODEsIG4gPSBlLmxlbmd0aDtcbiAgZm9yICg7IG47IClcbiAgICB0ID0gdCAqIDMzIF4gZS5jaGFyQ29kZUF0KC0tbik7XG4gIHJldHVybiB2cyh0KTtcbn0sIHRnID0gKGUsIHQpID0+IHtcbiAgbGV0IG4gPSAxMjI4OTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIG4gXj0gZihCKHRbcl0pLCBSKGsoZVt0W3JdXSkpKTtcbiAgcmV0dXJuIHZzKG4pO1xufSwgY2wgPSAoZSkgPT4gdGcoZSwgT2JqZWN0LmtleXMoZSkpLCBlciA9IChlKSA9PiB7XG4gIGxldCB0ID0gNjE1MTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKVxuICAgIHQgPSBmKHQsIFIoayhlW25dKSkpO1xuICByZXR1cm4gdnModCk7XG59LCBxID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgbiA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBGLCB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMVxuICAgICAgfSksIHI7XG4gICAgfTtcbiAgfVxuICBjb25zdCBlID0gYXJndW1lbnRzWzBdLCB0ID0gYXJndW1lbnRzWzFdO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIEYsIHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogITFcbiAgfSksIHQ7XG59LCBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRXF1YWxcIik7XG5mdW5jdGlvbiBPKCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IChlKSA9PiBxcihlLCBhcmd1bWVudHNbMF0pIDogcXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xufVxuZnVuY3Rpb24gcXIoZSwgdCkge1xuICBpZiAoZSA9PT0gdClcbiAgICByZXR1cm4gITA7XG4gIGNvbnN0IG4gPSB0eXBlb2YgZTtcbiAgaWYgKG4gIT09IHR5cGVvZiB0KVxuICAgIHJldHVybiAhMTtcbiAgaWYgKG4gPT09IFwib2JqZWN0XCIgfHwgbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKGUgIT09IG51bGwgJiYgdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKFVyKGUpICYmIFVyKHQpKVxuICAgICAgICByZXR1cm4gayhlKSA9PT0gayh0KSAmJiBlW0VdKHQpID8gITAgOiBwZS5lbmFibGVkICYmIHBlLnRlc3RlciA/IHBlLnRlc3RlcihlLCB0KSA6ICExO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBEYXRlICYmIHQgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4gZS50b0lTT1N0cmluZygpID09PSB0LnRvSVNPU3RyaW5nKCk7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFVSTCAmJiB0IGluc3RhbmNlb2YgVVJMKVxuICAgICAgICByZXR1cm4gZS5ocmVmID09PSB0LmhyZWY7XG4gICAgfVxuICAgIGlmIChwZS5lbmFibGVkKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSAmJiBBcnJheS5pc0FycmF5KHQpKVxuICAgICAgICByZXR1cm4gZS5sZW5ndGggPT09IHQubGVuZ3RoICYmIGUuZXZlcnkoKHIsIHMpID0+IHFyKHIsIHRbc10pKTtcbiAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGNvbnN0IHIgPSBPYmplY3Qua2V5cyhlKSwgcyA9IE9iamVjdC5rZXlzKHQpO1xuICAgICAgICBpZiAoci5sZW5ndGggPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjIG9mIHIpXG4gICAgICAgICAgICBpZiAoIShjIGluIHQgJiYgcXIoZVtjXSwgdFtjXSkpKVxuICAgICAgICAgICAgICByZXR1cm4gcGUudGVzdGVyID8gcGUudGVzdGVyKGUsIHQpIDogITE7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGUudGVzdGVyID8gcGUudGVzdGVyKGUsIHQpIDogITE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwZS5lbmFibGVkICYmIHBlLnRlc3RlciA/IHBlLnRlc3RlcihlLCB0KSA6ICExO1xufVxuY29uc3QgVXIgPSAoZSkgPT4gJChlLCBFKSwgZ2kgPSAoKSA9PiBPLCBVID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKSwgViA9IChlKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCQoZSwgXCJ0b0pTT05cIikgJiYgWm4oZS50b0pTT04pICYmIGUudG9KU09OLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBlLnRvSlNPTigpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgICAgcmV0dXJuIGUubWFwKFYpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIHJnKGUpO1xufSwgUSA9IChlKSA9PiBKU09OLnN0cmluZ2lmeShlLCBudWxsLCAyKSwgVXQgPSAoZSwgdCA9IDIpID0+IHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBpbChlLCB0KSA6IFN0cmluZyhlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFN0cmluZyhlKTtcbiAgfVxufSwgaWwgPSAoZSwgdCkgPT4ge1xuICBsZXQgbiA9IFtdO1xuICBjb25zdCByID0gSlNPTi5zdHJpbmdpZnkoZSwgKHMsIGMpID0+IHR5cGVvZiBjID09IFwib2JqZWN0XCIgJiYgYyAhPT0gbnVsbCA/IG4uaW5jbHVkZXMoYykgPyB2b2lkIDAgOiBuLnB1c2goYykgJiYgKGx0LmZpYmVyUmVmcyAhPT0gdm9pZCAwICYmIG9sKGMpID8gY1ttaV0obHQuZmliZXJSZWZzKSA6IGMpIDogYywgdCk7XG4gIHJldHVybiBuID0gdm9pZCAwLCByO1xufSwgbWkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9JbnNwZWN0YWJsZS9SZWRhY3RhYmxlXCIpLCBvbCA9IChlKSA9PiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgbWkgaW4gZSwgbHQgPSAvKiBAX19QVVJFX18gKi8gQyhcImVmZmVjdC9JbnNwZWN0YWJsZS9yZWRhY3RhYmxlU3RhdGVcIiwgKCkgPT4gKHtcbiAgZmliZXJSZWZzOiB2b2lkIDBcbn0pKSwgbmcgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gbHQuZmliZXJSZWZzO1xuICBsdC5maWJlclJlZnMgPSBlO1xuICB0cnkge1xuICAgIHJldHVybiB0KCk7XG4gIH0gZmluYWxseSB7XG4gICAgbHQuZmliZXJSZWZzID0gbjtcbiAgfVxufSwgcmcgPSAoZSkgPT4gb2woZSkgJiYgbHQuZmliZXJSZWZzICE9PSB2b2lkIDAgPyBlW21pXShsdC5maWJlclJlZnMpIDogZSwgdyA9IChlLCB0KSA9PiB7XG4gIHN3aXRjaCAodC5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gdFswXShlKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gdFsxXSh0WzBdKGUpKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gdFsyXSh0WzFdKHRbMF0oZSkpKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gdFszXSh0WzJdKHRbMV0odFswXShlKSkpKTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gdFs0XSh0WzNdKHRbMl0odFsxXSh0WzBdKGUpKSkpKTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gdFs1XSh0WzRdKHRbM10odFsyXSh0WzFdKHRbMF0oZSkpKSkpKTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gdFs2XSh0WzVdKHRbNF0odFszXSh0WzJdKHRbMV0odFswXShlKSkpKSkpKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gdFs3XSh0WzZdKHRbNV0odFs0XSh0WzNdKHRbMl0odFsxXSh0WzBdKGUpKSkpKSkpKTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gdFs4XSh0WzddKHRbNl0odFs1XSh0WzRdKHRbM10odFsyXSh0WzFdKHRbMF0oZSkpKSkpKSkpKTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbiA9IGU7XG4gICAgICBmb3IgKGxldCByID0gMCwgcyA9IHQubGVuZ3RoOyByIDwgczsgcisrKVxuICAgICAgICBuID0gdFtyXShuKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfVxufSwgUm4gPSBcIkFzeW5jXCIsIHdzID0gXCJDb21taXRcIiwgdGUgPSBcIkZhaWx1cmVcIiwgVHIgPSBcIk9uRmFpbHVyZVwiLCB6ciA9IFwiT25TdWNjZXNzXCIsIEJyID0gXCJPblN1Y2Nlc3NBbmRGYWlsdXJlXCIsIG5lID0gXCJTdWNjZXNzXCIsIGFsID0gXCJTeW5jXCIsIHNnID0gXCJUYWdcIiwgdW4gPSBcIlVwZGF0ZVJ1bnRpbWVGbGFnc1wiLCBWciA9IFwiV2hpbGVcIiwgTW4gPSBcIkl0ZXJhdG9yXCIsIHVsID0gXCJXaXRoUnVudGltZVwiLCBDciA9IFwiWWllbGRcIiwgcGkgPSBcIlJldmVydEZsYWdzXCIsIGNnID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRWZmZWN0XCIpLCBpZyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1N0cmVhbVwiKSwgb2cgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9TaW5rXCIpLCBhZyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0NoYW5uZWxcIiksIHp0ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9FOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0E6IChlKSA9PiBlLFxuICBfVjogLyogQF9fUFVSRV9fICovIGJzKClcbn0sIHVnID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfQTogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbjogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9MOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0U6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogKGUpID0+IGVcbn0sIGxnID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfRW52OiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0luRXJyOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0luRWxlbTogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbkRvbmU6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0RXJyOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX091dEVsZW06IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0RG9uZTogKGUpID0+IGVcbn0sIHRyID0ge1xuICBbY2ddOiB6dCxcbiAgW2lnXTogenQsXG4gIFtvZ106IHVnLFxuICBbYWddOiBsZyxcbiAgW0VdKGUpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gZTtcbiAgfSxcbiAgW0ZdKCkge1xuICAgIHJldHVybiBxKHRoaXMsIGhpKHRoaXMpKTtcbiAgfSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBybChuZXcgWG4odGhpcykpO1xuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn0sIE9zID0ge1xuICBbRl0oKSB7XG4gICAgcmV0dXJuIHEodGhpcywgY2wodGhpcykpO1xuICB9LFxuICBbRV0oZSkge1xuICAgIGNvbnN0IHQgPSBPYmplY3Qua2V5cyh0aGlzKSwgbiA9IE9iamVjdC5rZXlzKGUpO1xuICAgIGlmICh0Lmxlbmd0aCAhPT0gbi5sZW5ndGgpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCByIG9mIHQpXG4gICAgICBpZiAoIShyIGluIGUgJiYgTyh0aGlzW3JdLCBlW3JdKSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH1cbn0sIG5yID0ge1xuICAuLi50cixcbiAgX29wOiB3c1xufSwgZmcgPSB7XG4gIC4uLm5yLFxuICAuLi5Pc1xufSwgaGcgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUoKSB7XG4gIH1cbiAgcmV0dXJuIGUucHJvdG90eXBlID0gbnIsIGU7XG59KCksIGxsID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvT3B0aW9uXCIpLCBmbCA9IHtcbiAgLi4udHIsXG4gIFtsbF06IHtcbiAgICBfQTogKGUpID0+IGVcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfVxufSwgZGcgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShmbCksIHtcbiAgX3RhZzogXCJTb21lXCIsXG4gIF9vcDogXCJTb21lXCIsXG4gIFtFXShlKSB7XG4gICAgcmV0dXJuIF9pKGUpICYmIGRsKGUpICYmIE8odGhpcy52YWx1ZSwgZS52YWx1ZSk7XG4gIH0sXG4gIFtGXSgpIHtcbiAgICByZXR1cm4gcSh0aGlzLCBSKGsodGhpcy5fdGFnKSkoayh0aGlzLnZhbHVlKSkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJPcHRpb25cIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIHZhbHVlOiBWKHRoaXMudmFsdWUpXG4gICAgfTtcbiAgfVxufSksIGdnID0gLyogQF9fUFVSRV9fICovIGsoXCJOb25lXCIpLCBtZyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKGZsKSwge1xuICBfdGFnOiBcIk5vbmVcIixcbiAgX29wOiBcIk5vbmVcIixcbiAgW0VdKGUpIHtcbiAgICByZXR1cm4gX2koZSkgJiYgaGwoZSk7XG4gIH0sXG4gIFtGXSgpIHtcbiAgICByZXR1cm4gZ2c7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIk9wdGlvblwiLFxuICAgICAgX3RhZzogdGhpcy5fdGFnXG4gICAgfTtcbiAgfVxufSksIF9pID0gKGUpID0+ICQoZSwgbGwpLCBobCA9IChlKSA9PiBlLl90YWcgPT09IFwiTm9uZVwiLCBkbCA9IChlKSA9PiBlLl90YWcgPT09IFwiU29tZVwiLCAkcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG1nKSwgUG4gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShkZyk7XG4gIHJldHVybiB0LnZhbHVlID0gZSwgdDtcbn0sIGdsID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRWl0aGVyXCIpLCBtbCA9IHtcbiAgLi4udHIsXG4gIFtnbF06IHtcbiAgICBfUjogKGUpID0+IGVcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfVxufSwgcGcgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShtbCksIHtcbiAgX3RhZzogXCJSaWdodFwiLFxuICBfb3A6IFwiUmlnaHRcIixcbiAgW0VdKGUpIHtcbiAgICByZXR1cm4geWkoZSkgJiYgcGwoZSkgJiYgTyh0aGlzLnJpZ2h0LCBlLnJpZ2h0KTtcbiAgfSxcbiAgW0ZdKCkge1xuICAgIHJldHVybiBSKGsodGhpcy5fdGFnKSkoayh0aGlzLnJpZ2h0KSk7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkVpdGhlclwiLFxuICAgICAgX3RhZzogdGhpcy5fdGFnLFxuICAgICAgcmlnaHQ6IFYodGhpcy5yaWdodClcbiAgICB9O1xuICB9XG59KSwgX2cgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShtbCksIHtcbiAgX3RhZzogXCJMZWZ0XCIsXG4gIF9vcDogXCJMZWZ0XCIsXG4gIFtFXShlKSB7XG4gICAgcmV0dXJuIHlpKGUpICYmIGJpKGUpICYmIE8odGhpcy5sZWZ0LCBlLmxlZnQpO1xuICB9LFxuICBbRl0oKSB7XG4gICAgcmV0dXJuIFIoayh0aGlzLl90YWcpKShrKHRoaXMubGVmdCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJFaXRoZXJcIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIGxlZnQ6IFYodGhpcy5sZWZ0KVxuICAgIH07XG4gIH1cbn0pLCB5aSA9IChlKSA9PiAkKGUsIGdsKSwgYmkgPSAoZSkgPT4gZS5fdGFnID09PSBcIkxlZnRcIiwgcGwgPSAoZSkgPT4gZS5fdGFnID09PSBcIlJpZ2h0XCIsIHlnID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUoX2cpO1xuICByZXR1cm4gdC5sZWZ0ID0gZSwgdDtcbn0sIGJnID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUocGcpO1xuICByZXR1cm4gdC5yaWdodCA9IGUsIHQ7XG59LCBTZyA9IChlKSA9PiBiaShlKSA/ICRzIDogUG4oZS5yaWdodCksIGFlID0gYmcsICRlID0geWcsIHRFID0gKGUpID0+IHtcbiAgaWYgKFpuKGUpKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYWUoZSgpKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICByZXR1cm4gJGUodCk7XG4gICAgfVxuICBlbHNlXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhZShlLnRyeSgpKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICByZXR1cm4gJGUoZS5jYXRjaCh0KSk7XG4gICAgfVxufSwgbkUgPSB5aSwgYXQgPSBiaSwgUHQgPSBwbCwgckUgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwge1xuICBvbkxlZnQ6IHQsXG4gIG9uUmlnaHQ6IG5cbn0pID0+IGF0KGUpID8gJGUodChlLmxlZnQpKSA6IGFlKG4oZS5yaWdodCkpKSwgc0UgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gYXQoZSkgPyAkZSh0KGUubGVmdCkpIDogYWUoZS5yaWdodCkpLCBjRSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBQdChlKSA/IGFlKHQoZS5yaWdodCkpIDogJGUoZS5sZWZ0KSksIGtnID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHtcbiAgb25MZWZ0OiB0LFxuICBvblJpZ2h0OiBuXG59KSA9PiBhdChlKSA/IHQoZS5sZWZ0KSA6IG4oZS5yaWdodCkpLCB2ZyA9IC8qIEBfX1BVUkVfXyAqLyBrZyh7XG4gIG9uTGVmdDogUCxcbiAgb25SaWdodDogUFxufSksIHdnID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgaWYgKFB0KGUpKVxuICAgIHJldHVybiBlLnJpZ2h0O1xuICB0aHJvdyB0KGUubGVmdCk7XG59KSwgaUUgPSAvKiBAX19QVVJFX18gKi8gd2coKCkgPT4gbmV3IEVycm9yKFwiZ2V0T3JUaHJvdyBjYWxsZWQgb24gYSBMZWZ0XCIpKSwgX2wgPSAoZSkgPT4gZS5sZW5ndGggPiAwLCB5bCA9IChlKSA9PiAodCwgbikgPT4gdCA9PT0gbiA/IDAgOiBlKHQsIG4pLCBPZyA9IC8qIEBfX1BVUkVfXyAqLyB5bCgoZSwgdCkgPT4gZSA8IHQgPyAtMSA6IDEpLCAkZyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB5bCgobiwgcikgPT4gZSh0KG4pLCB0KHIpKSkpLCBFZyA9IChlKSA9PiBsKDIsICh0LCBuKSA9PiBlKHQsIG4pID09PSAxKSwgdiA9ICgpID0+ICRzLCBJID0gUG4sIG9FID0gX2ksIFcgPSBobCwgeWUgPSBkbCwgdHQgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwge1xuICBvbk5vbmU6IHQsXG4gIG9uU29tZTogblxufSkgPT4gVyhlKSA/IHQoKSA6IG4oZS52YWx1ZSkpLCBhRSA9IFNnLCBkZSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBXKGUpID8gdCgpIDogZS52YWx1ZSksIHVFID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFcoZSkgPyB0KCkgOiBlKSwgSWcgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gVyhlKSA/IEkodCgpKSA6IGUpLCBFcyA9IChlKSA9PiBlID09IG51bGwgPyB2KCkgOiBJKGUpLCBsRSA9IC8qIEBfX1BVUkVfXyAqLyBkZShMZCksIGl0ID0gLyogQF9fUFVSRV9fICovIGRlKFp1KSwgZkUgPSAoZSkgPT4gKC4uLnQpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSShlKC4uLnQpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHYoKTtcbiAgfVxufSwgRmcgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBpZiAoeWUoZSkpXG4gICAgcmV0dXJuIGUudmFsdWU7XG4gIHRocm93IHQoKTtcbn0pLCBoRSA9IC8qIEBfX1BVUkVfXyAqLyBGZygoKSA9PiBuZXcgRXJyb3IoXCJnZXRPclRocm93IGNhbGxlZCBvbiBhIE5vbmVcIikpLCBOciA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBXKGUpID8gdigpIDogSSh0KGUudmFsdWUpKSksIGJsID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFcoZSkgPyB2KCkgOiB0KGUudmFsdWUpKSwgZEUgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gVyhlKSA/IHYoKSA6IEVzKHQoZS52YWx1ZSkpKSwgUmcgPSBibCwgZ0UgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gUmcoZSwgKG4pID0+IHQobikgPyBQbihuKSA6ICRzKSksIG1FID0gKGUpID0+IHlzKCh0LCBuKSA9PiBXKHQpID8gVyhuKSA6IFcobikgPyAhMSA6IGUodC52YWx1ZSwgbi52YWx1ZSkpLCBNZyA9IChlKSA9PiBsKDIsICh0LCBuKSA9PiBXKHQpID8gITEgOiBlKHQudmFsdWUsIG4pKSwgVGcgPSAvKiBAX19QVVJFX18gKi8gZ2koKSwgQ2cgPSAvKiBAX19QVVJFX18gKi8gTWcoVGcpLCBwRSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBXKGUpID8gITEgOiB0KGUudmFsdWUpKSwgTmcgPSAoLi4uZSkgPT4gZSwgU2kgPSAoZSkgPT4gbmV3IEFycmF5KGUpLCBBZyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGUpKSwgciA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBuOyBzKyspXG4gICAgcltzXSA9IHQocyk7XG4gIHJldHVybiByO1xufSksIHogPSAoZSkgPT4gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBBcnJheS5mcm9tKGUpLCBQZyA9IChlKSA9PiBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtlXSwgX0UgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwge1xuICBvbkVtcHR5OiB0LFxuICBvbk5vbkVtcHR5OiBuXG59KSA9PiBsZShlKSA/IG4odWUoZSksIF90KGUpKSA6IHQoKSksIEtyID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFt0LCAuLi5lXSksIHhnID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFsuLi5lLCB0XSksIFNsID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHooZSkuY29uY2F0KHoodCkpKSwgeUUgPSBBcnJheS5pc0FycmF5LCBqZyA9IChlKSA9PiBlLmxlbmd0aCA9PT0gMCwgTGcgPSBqZywgRGcgPSBfbCwgbGUgPSBfbCwga2wgPSAoZSwgdCkgPT4gZSA8IDAgfHwgZSA+PSB0Lmxlbmd0aCwgcWcgPSAoZSwgdCkgPT4gTWF0aC5mbG9vcihNYXRoLm1pbihNYXRoLm1heCgwLCBlKSwgdC5sZW5ndGgpKSwgVWcgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gTWF0aC5mbG9vcih0KTtcbiAgcmV0dXJuIGtsKG4sIGUpID8gdigpIDogSShlW25dKTtcbn0pLCB2bCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBNYXRoLmZsb29yKHQpO1xuICBpZiAoa2wobiwgZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCAke259IG91dCBvZiBib3VuZHNgKTtcbiAgcmV0dXJuIGVbbl07XG59KSwgVG4gPSAvKiBAX19QVVJFX18gKi8gVWcoMCksIHVlID0gLyogQF9fUFVSRV9fICovIHZsKDApLCB6ZyA9IChlKSA9PiBsZShlKSA/IEkod2woZSkpIDogdigpLCB3bCA9IChlKSA9PiBlW2UubGVuZ3RoIC0gMV0sIF90ID0gKGUpID0+IGUuc2xpY2UoMSksIEJnID0gKGUsIHQpID0+IHtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGNvbnN0IHIgb2YgZSkge1xuICAgIGlmICghdChyLCBuKSlcbiAgICAgIGJyZWFrO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn0sIFZnID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEhnKGUsIEJnKGUsIHQpKSksIEtnID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IHooZSk7XG4gIHJldHVybiBuLnNsaWNlKHFnKHQsIG4pLCBuLmxlbmd0aCk7XG59KSwgcW8gPSAoZSkgPT4gQXJyYXkuZnJvbShlKS5yZXZlcnNlKCksIFdyID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IEFycmF5LmZyb20oZSk7XG4gIHJldHVybiBuLnNvcnQodCksIG47XG59KSwgVW8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gV2coZSwgdCwgTmcpKSwgV2cgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0geihlKSwgcyA9IHoodCk7XG4gIGlmIChsZShyKSAmJiBsZShzKSkge1xuICAgIGNvbnN0IGMgPSBbbih1ZShyKSwgdWUocykpXSwgaSA9IE1hdGgubWluKHIubGVuZ3RoLCBzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgbyA9IDE7IG8gPCBpOyBvKyspXG4gICAgICBjW29dID0gbihyW29dLCBzW29dKTtcbiAgICByZXR1cm4gYztcbiAgfVxuICByZXR1cm4gW107XG59KSwgSmcgPSAvKiBAX19QVVJFX18gKi8gZ2koKSwgSGcgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gQXJyYXkuZnJvbShlKSwgciA9IE1hdGguZmxvb3IodCk7XG4gIHJldHVybiBsZShuKSA/IHIgPj0gMSA/IEdnKG4sIHIpIDogW1tdLCBuXSA6IFtuLCBbXV07XG59KSwgR2cgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0KSk7XG4gIHJldHVybiBuID49IGUubGVuZ3RoID8gW1lnKGUpLCBbXV0gOiBbS3IoZS5zbGljZSgxLCBuKSwgdWUoZSkpLCBlLnNsaWNlKG4pXTtcbn0pLCBZZyA9IChlKSA9PiBlLnNsaWNlKCksIFFnID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IHooZSksIHMgPSB6KHQpO1xuICByZXR1cm4gbGUocikgPyBsZShzKSA/IE9sKG4pKFNsKHIsIHMpKSA6IHIgOiBzO1xufSksIEFyID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFFnKGUsIHQsIEpnKSksIEJ0ID0gKCkgPT4gW10sIGtlID0gKGUpID0+IFtlXSwgZnQgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZS5tYXAodCkpLCBaZyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGlmIChMZyhlKSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IG4gPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgcyA9IHQoZVtyXSwgcik7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBzLmxlbmd0aDsgYysrKVxuICAgICAgbi5wdXNoKHNbY10pO1xuICB9XG4gIHJldHVybiBuO1xufSksIFhnID0gLyogQF9fUFVSRV9fICovIFpnKFApLCBiRSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSB6KGUpLCByID0gW107XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKykge1xuICAgIGNvbnN0IGMgPSB0KG5bc10sIHMpO1xuICAgIHllKGMpICYmIHIucHVzaChjLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gcjtcbn0pLCBlbSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSB6KGUpLCByID0gW107XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKylcbiAgICB0KG5bc10sIHMpICYmIHIucHVzaChuW3NdKTtcbiAgcmV0dXJuIHI7XG59KSwga2kgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4geihlKS5yZWR1Y2UoKHIsIHMsIGMpID0+IG4ociwgcywgYyksIHQpKSwgem8gPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gW107XG4gIGxldCByID0gZSwgcztcbiAgZm9yICg7IHllKHMgPSB0KHIpKTsgKSB7XG4gICAgY29uc3QgW2MsIGldID0gcy52YWx1ZTtcbiAgICBuLnB1c2goYyksIHIgPSBpO1xuICB9XG4gIHJldHVybiBuO1xufSwgdmkgPSBxZCwgT2wgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0geihlKTtcbiAgaWYgKGxlKG4pKSB7XG4gICAgY29uc3QgciA9IFt1ZShuKV0sIHMgPSBfdChuKTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgcylcbiAgICAgIHIuZXZlcnkoKGkpID0+ICF0KGMsIGkpKSAmJiByLnB1c2goYyk7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIFtdO1xufSksIHRtID0gKGUpID0+IE9sKGUsIGdpKCkpLCBsbiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB6KGUpLmpvaW4odCkpLCB4biA9IE9nLCBubSA9IChlKSA9PiBlLnJlcGxhY2UoL1svXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIiksICRsID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvQ29udGV4dC9UYWdcIiksIEpyID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvQ29udGV4dC9SZWZlcmVuY2VcIiksIHJtID0gXCJlZmZlY3QvU1RNXCIsIHNtID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3Iocm0pLCBJcyA9IHtcbiAgLi4udHIsXG4gIF9vcDogXCJUYWdcIixcbiAgW3NtXTogenQsXG4gIFskbF06IHtcbiAgICBfU2VydmljZTogKGUpID0+IGUsXG4gICAgX0lkZW50aWZpZXI6IChlKSA9PiBlXG4gIH0sXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJUYWdcIixcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH0sXG4gIFtVXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgb2YoZSkge1xuICAgIHJldHVybiBlO1xuICB9LFxuICBjb250ZXh0KGUpIHtcbiAgICByZXR1cm4gRmwodGhpcywgZSk7XG4gIH1cbn0sIGNtID0ge1xuICAuLi5JcyxcbiAgW0pyXTogSnJcbn0sIGltID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMjtcbiAgY29uc3QgbiA9IG5ldyBFcnJvcigpO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSB0O1xuICBjb25zdCByID0gT2JqZWN0LmNyZWF0ZShJcyk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJzdGFja1wiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG4uc3RhY2s7XG4gICAgfVxuICB9KSwgci5rZXkgPSBlLCByO1xufSwgb20gPSAoZSkgPT4gKCkgPT4ge1xuICBjb25zdCB0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAyO1xuICBjb25zdCBuID0gbmV3IEVycm9yKCk7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHQ7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLCBJcyksIHIua2V5ID0gZSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwic3RhY2tcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBuLnN0YWNrO1xuICAgIH1cbiAgfSksIHI7XG59LCBhbSA9ICgpID0+IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDI7XG4gIGNvbnN0IHIgPSBuZXcgRXJyb3IoKTtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbjtcbiAgZnVuY3Rpb24gcygpIHtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHMsIGNtKSwgcy5rZXkgPSBlLCBzLmRlZmF1bHRWYWx1ZSA9IHQuZGVmYXVsdFZhbHVlLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJzdGFja1wiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHIuc3RhY2s7XG4gICAgfVxuICB9KSwgcztcbn0sIEVsID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvQ29udGV4dFwiKSwgdW0gPSB7XG4gIFtFbF06IHtcbiAgICBfU2VydmljZXM6IChlKSA9PiBlXG4gIH0sXG4gIFtFXShlKSB7XG4gICAgaWYgKElsKGUpICYmIHRoaXMudW5zYWZlTWFwLnNpemUgPT09IGUudW5zYWZlTWFwLnNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLnVuc2FmZU1hcC5rZXlzKCkpXG4gICAgICAgIGlmICghZS51bnNhZmVNYXAuaGFzKHQpIHx8ICFPKHRoaXMudW5zYWZlTWFwLmdldCh0KSwgZS51bnNhZmVNYXAuZ2V0KHQpKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSxcbiAgW0ZdKCkge1xuICAgIHJldHVybiBxKHRoaXMsIGRpKHRoaXMudW5zYWZlTWFwLnNpemUpKTtcbiAgfSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiQ29udGV4dFwiLFxuICAgICAgc2VydmljZXM6IEFycmF5LmZyb20odGhpcy51bnNhZmVNYXApLm1hcChWKVxuICAgIH07XG4gIH0sXG4gIFtVXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfVxufSwgVnQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZSh1bSk7XG4gIHJldHVybiB0LnVuc2FmZU1hcCA9IGUsIHQ7XG59LCBsbSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgRXJyb3IoYFNlcnZpY2Ugbm90IGZvdW5kJHtlLmtleSA/IGA6ICR7U3RyaW5nKGUua2V5KX1gIDogXCJcIn1gKTtcbiAgaWYgKGUuc3RhY2spIHtcbiAgICBjb25zdCBuID0gZS5zdGFjay5zcGxpdChgXG5gKTtcbiAgICBpZiAobi5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zdCByID0gblsyXS5tYXRjaCgvYXQgKC4qKS8pO1xuICAgICAgciAmJiAodC5tZXNzYWdlID0gdC5tZXNzYWdlICsgYCAoZGVmaW5lZCBhdCAke3JbMV19KWApO1xuICAgIH1cbiAgfVxuICBpZiAodC5zdGFjaykge1xuICAgIGNvbnN0IG4gPSB0LnN0YWNrLnNwbGl0KGBcbmApO1xuICAgIG4uc3BsaWNlKDEsIDMpLCB0LnN0YWNrID0gbi5qb2luKGBcbmApO1xuICB9XG4gIHJldHVybiB0O1xufSwgSWwgPSAoZSkgPT4gJChlLCBFbCksIGZtID0gKGUpID0+ICQoZSwgJGwpLCBobSA9IChlKSA9PiAkKGUsIEpyKSwgZG0gPSAvKiBAX19QVVJFX18gKi8gVnQoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIGdtID0gKCkgPT4gZG0sIEZsID0gKGUsIHQpID0+IFZ0KC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbZS5rZXksIHRdXSkpLCBtbSA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiB7XG4gIGNvbnN0IHIgPSBuZXcgTWFwKGUudW5zYWZlTWFwKTtcbiAgcmV0dXJuIHIuc2V0KHQua2V5LCBuKSwgVnQocik7XG59KSwgb2MgPSAvKiBAX19QVVJFX18gKi8gQyhcImVmZmVjdC9Db250ZXh0L2RlZmF1bHRWYWx1ZUNhY2hlXCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCB3aSA9IChlKSA9PiB7XG4gIGlmIChvYy5oYXMoZS5rZXkpKVxuICAgIHJldHVybiBvYy5nZXQoZS5rZXkpO1xuICBjb25zdCB0ID0gZS5kZWZhdWx0VmFsdWUoKTtcbiAgcmV0dXJuIG9jLnNldChlLmtleSwgdCksIHQ7XG59LCBwbSA9IChlLCB0KSA9PiBlLnVuc2FmZU1hcC5oYXModC5rZXkpID8gZS51bnNhZmVNYXAuZ2V0KHQua2V5KSA6IHdpKHQpLCBSbCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGlmICghZS51bnNhZmVNYXAuaGFzKHQua2V5KSkge1xuICAgIGlmIChKciBpbiB0KSByZXR1cm4gd2kodCk7XG4gICAgdGhyb3cgbG0odCk7XG4gIH1cbiAgcmV0dXJuIGUudW5zYWZlTWFwLmdldCh0LmtleSk7XG59KSwgX20gPSBSbCwgeW0gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZS51bnNhZmVNYXAuaGFzKHQua2V5KSA/IFBuKGUudW5zYWZlTWFwLmdldCh0LmtleSkpIDogaG0odCkgPyBQbih3aSh0KSkgOiAkcyksIGJtID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IG5ldyBNYXAoZS51bnNhZmVNYXApO1xuICBmb3IgKGNvbnN0IFtyLCBzXSBvZiB0LnVuc2FmZU1hcClcbiAgICBuLnNldChyLCBzKTtcbiAgcmV0dXJuIFZ0KG4pO1xufSksIEl0ID0gaW0sIFNtID0gSWwsIEZzID0gZm0sIE9pID0gZ20sIHJyID0gRmwsIEF0ID0gbW0sIE1sID0gX20sIFRsID0gUmwsIHNyID0geW0sIGZuID0gYm0sIFNFID0gb20sICRpID0gYW0sIENsID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvQ2h1bmtcIik7XG5mdW5jdGlvbiBrbShlLCB0LCBuLCByLCBzKSB7XG4gIGZvciAobGV0IGMgPSB0OyBjIDwgTWF0aC5taW4oZS5sZW5ndGgsIHQgKyBzKTsgYysrKVxuICAgIG5bciArIGMgLSB0XSA9IGVbY107XG4gIHJldHVybiBuO1xufVxuY29uc3QgTmwgPSBbXSwgdm0gPSAoZSkgPT4geXMoKHQsIG4pID0+IHQubGVuZ3RoID09PSBuLmxlbmd0aCAmJiBXZSh0KS5ldmVyeSgociwgcykgPT4gZShyLCBodChuLCBzKSkpKSwgd20gPSAvKiBAX19QVVJFX18gKi8gdm0oTyksIE9tID0ge1xuICBbQ2xdOiB7XG4gICAgX0E6IChlKSA9PiBlXG4gIH0sXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJDaHVua1wiLFxuICAgICAgdmFsdWVzOiBXZSh0aGlzKS5tYXAoVilcbiAgICB9O1xuICB9LFxuICBbVV0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH0sXG4gIFtFXShlKSB7XG4gICAgcmV0dXJuIEFsKGUpICYmIHdtKHRoaXMsIGUpO1xuICB9LFxuICBbRl0oKSB7XG4gICAgcmV0dXJuIHEodGhpcywgZXIoV2UodGhpcykpKTtcbiAgfSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgc3dpdGNoICh0aGlzLmJhY2tpbmcuX3RhZykge1xuICAgICAgY2FzZSBcIklBcnJheVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nLmFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIGNhc2UgXCJJRW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIE5sW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBXZSh0aGlzKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn0sIEcgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShPbSk7XG4gIHN3aXRjaCAodC5iYWNraW5nID0gZSwgZS5fdGFnKSB7XG4gICAgY2FzZSBcIklFbXB0eVwiOiB7XG4gICAgICB0Lmxlbmd0aCA9IDAsIHQuZGVwdGggPSAwLCB0LmxlZnQgPSB0LCB0LnJpZ2h0ID0gdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiSUNvbmNhdFwiOiB7XG4gICAgICB0Lmxlbmd0aCA9IGUubGVmdC5sZW5ndGggKyBlLnJpZ2h0Lmxlbmd0aCwgdC5kZXB0aCA9IDEgKyBNYXRoLm1heChlLmxlZnQuZGVwdGgsIGUucmlnaHQuZGVwdGgpLCB0LmxlZnQgPSBlLmxlZnQsIHQucmlnaHQgPSBlLnJpZ2h0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJJQXJyYXlcIjoge1xuICAgICAgdC5sZW5ndGggPSBlLmFycmF5Lmxlbmd0aCwgdC5kZXB0aCA9IDAsIHQubGVmdCA9IE1lLCB0LnJpZ2h0ID0gTWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIklTaW5nbGV0b25cIjoge1xuICAgICAgdC5sZW5ndGggPSAxLCB0LmRlcHRoID0gMCwgdC5sZWZ0ID0gTWUsIHQucmlnaHQgPSBNZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiSVNsaWNlXCI6IHtcbiAgICAgIHQubGVuZ3RoID0gZS5sZW5ndGgsIHQuZGVwdGggPSBlLmNodW5rLmRlcHRoICsgMSwgdC5sZWZ0ID0gTWUsIHQucmlnaHQgPSBNZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn0sIEFsID0gKGUpID0+ICQoZSwgQ2wpLCBNZSA9IC8qIEBfX1BVUkVfXyAqLyBHKHtcbiAgX3RhZzogXCJJRW1wdHlcIlxufSksIEFlID0gKCkgPT4gTWUsIGFjID0gKC4uLmUpID0+IFJtKGUpLCBpZSA9IChlKSA9PiBHKHtcbiAgX3RhZzogXCJJU2luZ2xldG9uXCIsXG4gIGE6IGVcbn0pLCBQbCA9IChlKSA9PiBBbChlKSA/IGUgOiBobih6KGUpKSwgd2MgPSAoZSwgdCwgbikgPT4ge1xuICBzd2l0Y2ggKGUuYmFja2luZy5fdGFnKSB7XG4gICAgY2FzZSBcIklBcnJheVwiOiB7XG4gICAgICBrbShlLmJhY2tpbmcuYXJyYXksIDAsIHQsIG4sIGUubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiSUNvbmNhdFwiOiB7XG4gICAgICB3YyhlLmxlZnQsIHQsIG4pLCB3YyhlLnJpZ2h0LCB0LCBuICsgZS5sZWZ0Lmxlbmd0aCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIklTaW5nbGV0b25cIjoge1xuICAgICAgdFtuXSA9IGUuYmFja2luZy5hO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJJU2xpY2VcIjoge1xuICAgICAgbGV0IHIgPSAwLCBzID0gbjtcbiAgICAgIGZvciAoOyByIDwgZS5sZW5ndGg7IClcbiAgICAgICAgdFtzXSA9IGh0KGUsIHIpLCByICs9IDEsIHMgKz0gMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufSwgJG0gPSAoZSkgPT4gV2UoZSkuc2xpY2UoKSwga0UgPSAkbSwgRW0gPSAoZSkgPT4ge1xuICBzd2l0Y2ggKGUuYmFja2luZy5fdGFnKSB7XG4gICAgY2FzZSBcIklFbXB0eVwiOlxuICAgICAgcmV0dXJuIE5sO1xuICAgIGNhc2UgXCJJQXJyYXlcIjpcbiAgICAgIHJldHVybiBlLmJhY2tpbmcuYXJyYXk7XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgdCA9IG5ldyBBcnJheShlLmxlbmd0aCk7XG4gICAgICByZXR1cm4gd2MoZSwgdCwgMCksIGUuYmFja2luZyA9IHtcbiAgICAgICAgX3RhZzogXCJJQXJyYXlcIixcbiAgICAgICAgYXJyYXk6IHRcbiAgICAgIH0sIGUubGVmdCA9IE1lLCBlLnJpZ2h0ID0gTWUsIGUuZGVwdGggPSAwLCB0O1xuICAgIH1cbiAgfVxufSwgV2UgPSBFbSwgSW0gPSAoZSkgPT4ge1xuICBzd2l0Y2ggKGUuYmFja2luZy5fdGFnKSB7XG4gICAgY2FzZSBcIklFbXB0eVwiOlxuICAgIGNhc2UgXCJJU2luZ2xldG9uXCI6XG4gICAgICByZXR1cm4gZTtcbiAgICBjYXNlIFwiSUFycmF5XCI6XG4gICAgICByZXR1cm4gRyh7XG4gICAgICAgIF90YWc6IFwiSUFycmF5XCIsXG4gICAgICAgIGFycmF5OiBxbyhlLmJhY2tpbmcuYXJyYXkpXG4gICAgICB9KTtcbiAgICBjYXNlIFwiSUNvbmNhdFwiOlxuICAgICAgcmV0dXJuIEcoe1xuICAgICAgICBfdGFnOiBcIklDb25jYXRcIixcbiAgICAgICAgbGVmdDogeXQoZS5iYWNraW5nLnJpZ2h0KSxcbiAgICAgICAgcmlnaHQ6IHl0KGUuYmFja2luZy5sZWZ0KVxuICAgICAgfSk7XG4gICAgY2FzZSBcIklTbGljZVwiOlxuICAgICAgcmV0dXJuIGhuKHFvKFdlKGUpKSk7XG4gIH1cbn0sIHl0ID0gSW0sIEZtID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHQgPCAwIHx8IHQgPj0gZS5sZW5ndGggPyB2KCkgOiBJKGh0KGUsIHQpKSksIGhuID0gKGUpID0+IGUubGVuZ3RoID09PSAwID8gQWUoKSA6IGUubGVuZ3RoID09PSAxID8gaWUoZVswXSkgOiBHKHtcbiAgX3RhZzogXCJJQXJyYXlcIixcbiAgYXJyYXk6IGVcbn0pLCBSbSA9IChlKSA9PiBobihlKSwgaHQgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBzd2l0Y2ggKGUuYmFja2luZy5fdGFnKSB7XG4gICAgY2FzZSBcIklFbXB0eVwiOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICBjYXNlIFwiSVNpbmdsZXRvblwiOiB7XG4gICAgICBpZiAodCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIHJldHVybiBlLmJhY2tpbmcuYTtcbiAgICB9XG4gICAgY2FzZSBcIklBcnJheVwiOiB7XG4gICAgICBpZiAodCA+PSBlLmxlbmd0aCB8fCB0IDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIHJldHVybiBlLmJhY2tpbmcuYXJyYXlbdF07XG4gICAgfVxuICAgIGNhc2UgXCJJQ29uY2F0XCI6XG4gICAgICByZXR1cm4gdCA8IGUubGVmdC5sZW5ndGggPyBodChlLmxlZnQsIHQpIDogaHQoZS5yaWdodCwgdCAtIGUubGVmdC5sZW5ndGgpO1xuICAgIGNhc2UgXCJJU2xpY2VcIjpcbiAgICAgIHJldHVybiBodChlLmJhY2tpbmcuY2h1bmssIHQgKyBlLmJhY2tpbmcub2Zmc2V0KTtcbiAgfVxufSksIE1tID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHZlKGUsIGllKHQpKSksIGJlID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHZlKGllKHQpLCBlKSksIE9jID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgaWYgKHQgPD0gMClcbiAgICByZXR1cm4gZTtcbiAgaWYgKHQgPj0gZS5sZW5ndGgpXG4gICAgcmV0dXJuIE1lO1xuICBzd2l0Y2ggKGUuYmFja2luZy5fdGFnKSB7XG4gICAgY2FzZSBcIklTbGljZVwiOlxuICAgICAgcmV0dXJuIEcoe1xuICAgICAgICBfdGFnOiBcIklTbGljZVwiLFxuICAgICAgICBjaHVuazogZS5iYWNraW5nLmNodW5rLFxuICAgICAgICBvZmZzZXQ6IGUuYmFja2luZy5vZmZzZXQgKyB0LFxuICAgICAgICBsZW5ndGg6IGUuYmFja2luZy5sZW5ndGggLSB0XG4gICAgICB9KTtcbiAgICBjYXNlIFwiSUNvbmNhdFwiOlxuICAgICAgcmV0dXJuIHQgPiBlLmxlZnQubGVuZ3RoID8gT2MoZS5yaWdodCwgdCAtIGUubGVmdC5sZW5ndGgpIDogRyh7XG4gICAgICAgIF90YWc6IFwiSUNvbmNhdFwiLFxuICAgICAgICBsZWZ0OiBPYyhlLmxlZnQsIHQpLFxuICAgICAgICByaWdodDogZS5yaWdodFxuICAgICAgfSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBHKHtcbiAgICAgICAgX3RhZzogXCJJU2xpY2VcIixcbiAgICAgICAgY2h1bms6IGUsXG4gICAgICAgIG9mZnNldDogdCxcbiAgICAgICAgbGVuZ3RoOiBlLmxlbmd0aCAtIHRcbiAgICAgIH0pO1xuICB9XG59KSwgdmUgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBpZiAoZS5iYWNraW5nLl90YWcgPT09IFwiSUVtcHR5XCIpXG4gICAgcmV0dXJuIHQ7XG4gIGlmICh0LmJhY2tpbmcuX3RhZyA9PT0gXCJJRW1wdHlcIilcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgbiA9IHQuZGVwdGggLSBlLmRlcHRoO1xuICBpZiAoTWF0aC5hYnMobikgPD0gMSlcbiAgICByZXR1cm4gRyh7XG4gICAgICBfdGFnOiBcIklDb25jYXRcIixcbiAgICAgIGxlZnQ6IGUsXG4gICAgICByaWdodDogdFxuICAgIH0pO1xuICBpZiAobiA8IC0xKVxuICAgIGlmIChlLmxlZnQuZGVwdGggPj0gZS5yaWdodC5kZXB0aCkge1xuICAgICAgY29uc3QgciA9IHZlKGUucmlnaHQsIHQpO1xuICAgICAgcmV0dXJuIEcoe1xuICAgICAgICBfdGFnOiBcIklDb25jYXRcIixcbiAgICAgICAgbGVmdDogZS5sZWZ0LFxuICAgICAgICByaWdodDogclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHIgPSB2ZShlLnJpZ2h0LnJpZ2h0LCB0KTtcbiAgICAgIGlmIChyLmRlcHRoID09PSBlLmRlcHRoIC0gMykge1xuICAgICAgICBjb25zdCBzID0gRyh7XG4gICAgICAgICAgX3RhZzogXCJJQ29uY2F0XCIsXG4gICAgICAgICAgbGVmdDogZS5yaWdodC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRyh7XG4gICAgICAgICAgX3RhZzogXCJJQ29uY2F0XCIsXG4gICAgICAgICAgbGVmdDogZS5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcyA9IEcoe1xuICAgICAgICAgIF90YWc6IFwiSUNvbmNhdFwiLFxuICAgICAgICAgIGxlZnQ6IGUubGVmdCxcbiAgICAgICAgICByaWdodDogZS5yaWdodC5sZWZ0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRyh7XG4gICAgICAgICAgX3RhZzogXCJJQ29uY2F0XCIsXG4gICAgICAgICAgbGVmdDogcyxcbiAgICAgICAgICByaWdodDogclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2UgaWYgKHQucmlnaHQuZGVwdGggPj0gdC5sZWZ0LmRlcHRoKSB7XG4gICAgY29uc3QgciA9IHZlKGUsIHQubGVmdCk7XG4gICAgcmV0dXJuIEcoe1xuICAgICAgX3RhZzogXCJJQ29uY2F0XCIsXG4gICAgICBsZWZ0OiByLFxuICAgICAgcmlnaHQ6IHQucmlnaHRcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByID0gdmUoZSwgdC5sZWZ0LmxlZnQpO1xuICAgIGlmIChyLmRlcHRoID09PSB0LmRlcHRoIC0gMykge1xuICAgICAgY29uc3QgcyA9IEcoe1xuICAgICAgICBfdGFnOiBcIklDb25jYXRcIixcbiAgICAgICAgbGVmdDogcixcbiAgICAgICAgcmlnaHQ6IHQubGVmdC5yaWdodFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gRyh7XG4gICAgICAgIF90YWc6IFwiSUNvbmNhdFwiLFxuICAgICAgICBsZWZ0OiBzLFxuICAgICAgICByaWdodDogdC5yaWdodFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBHKHtcbiAgICAgICAgX3RhZzogXCJJQ29uY2F0XCIsXG4gICAgICAgIGxlZnQ6IHQubGVmdC5yaWdodCxcbiAgICAgICAgcmlnaHQ6IHQucmlnaHRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEcoe1xuICAgICAgICBfdGFnOiBcIklDb25jYXRcIixcbiAgICAgICAgbGVmdDogcixcbiAgICAgICAgcmlnaHQ6IHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSksIHZFID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGhuKGVtKGUsIHQpKSksIFRtID0gKGUpID0+IGUubGVuZ3RoID09PSAwLCBIZSA9IChlKSA9PiBlLmxlbmd0aCA+IDAsIHhsID0gLyogQF9fUFVSRV9fICovIEZtKDApLCBqbCA9IChlKSA9PiBodChlLCAwKSwgQ2UgPSBqbCwgd0UgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZS5iYWNraW5nLl90YWcgPT09IFwiSVNpbmdsZXRvblwiID8gaWUodChlLmJhY2tpbmcuYSwgMCkpIDogaG4oZihXZShlKSwgZnQoKG4sIHIpID0+IHQobiwgcikpKSkpLCBWZSA9IChlKSA9PiBPYyhlLCAxKSwgT0UgPSBraSwgJGMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9EdXJhdGlvblwiKSwgTGwgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApLCBCbyA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjQpLCAkciA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNjApLCBFYyA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMWUzKSwgVm8gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDFlNiksIEtvID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxZTkpLCBDbSA9IC9eKC0/XFxkKyg/OlxcLlxcZCspPylcXHMrKG5hbm9zP3xtaWNyb3M/fG1pbGxpcz98c2Vjb25kcz98bWludXRlcz98aG91cnM/fGRheXM/fHdlZWtzPykkLywgUGUgPSAoZSkgPT4ge1xuICBpZiAoRGwoZSkpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChrYyhlKSlcbiAgICByZXR1cm4gSHIoZSk7XG4gIGlmIChCZChlKSlcbiAgICByZXR1cm4gdWMoZSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpICYmIGUubGVuZ3RoID09PSAyICYmIGUuZXZlcnkoa2MpKVxuICAgIHJldHVybiBlWzBdID09PSAtMSAvIDAgfHwgZVsxXSA9PT0gLTEgLyAwIHx8IE51bWJlci5pc05hTihlWzBdKSB8fCBOdW1iZXIuaXNOYU4oZVsxXSkgPyBxbCA6IGVbMF0gPT09IDEgLyAwIHx8IGVbMV0gPT09IDEgLyAwID8geG0gOiB1YyhCaWdJbnQoTWF0aC5yb3VuZChlWzBdICogMWU5KSkgKyBCaWdJbnQoTWF0aC5yb3VuZChlWzFdKSkpO1xuICBpZiAoemQoZSkpIHtcbiAgICBjb25zdCB0ID0gQ20uZXhlYyhlKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgW24sIHIsIHNdID0gdCwgYyA9IE51bWJlcihyKTtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIFwibmFub1wiOlxuICAgICAgICBjYXNlIFwibmFub3NcIjpcbiAgICAgICAgICByZXR1cm4gdWMoQmlnSW50KHIpKTtcbiAgICAgICAgY2FzZSBcIm1pY3JvXCI6XG4gICAgICAgIGNhc2UgXCJtaWNyb3NcIjpcbiAgICAgICAgICByZXR1cm4gam0oQmlnSW50KHIpKTtcbiAgICAgICAgY2FzZSBcIm1pbGxpXCI6XG4gICAgICAgIGNhc2UgXCJtaWxsaXNcIjpcbiAgICAgICAgICByZXR1cm4gSHIoYyk7XG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgICByZXR1cm4gTG0oYyk7XG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgICByZXR1cm4gRG0oYyk7XG4gICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICAgIHJldHVybiBxbShjKTtcbiAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICAgIHJldHVybiBVbShjKTtcbiAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICAgICAgcmV0dXJuIHptKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIER1cmF0aW9uSW5wdXRcIik7XG59LCBXbyA9IHtcbiAgX3RhZzogXCJNaWxsaXNcIixcbiAgbWlsbGlzOiAwXG59LCBObSA9IHtcbiAgX3RhZzogXCJJbmZpbml0eVwiXG59LCBBbSA9IHtcbiAgWyRjXTogJGMsXG4gIFtGXSgpIHtcbiAgICByZXR1cm4gcSh0aGlzLCBjbCh0aGlzLnZhbHVlKSk7XG4gIH0sXG4gIFtFXShlKSB7XG4gICAgcmV0dXJuIERsKGUpICYmIEdtKHRoaXMsIGUpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYER1cmF0aW9uKCR7UW0odGhpcyl9KWA7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmFsdWUuX3RhZykge1xuICAgICAgY2FzZSBcIk1pbGxpc1wiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9pZDogXCJEdXJhdGlvblwiLFxuICAgICAgICAgIF90YWc6IFwiTWlsbGlzXCIsXG4gICAgICAgICAgbWlsbGlzOiB0aGlzLnZhbHVlLm1pbGxpc1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcIk5hbm9zXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgX2lkOiBcIkR1cmF0aW9uXCIsXG4gICAgICAgICAgX3RhZzogXCJOYW5vc1wiLFxuICAgICAgICAgIGhydGltZTogVm0odGhpcylcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9pZDogXCJEdXJhdGlvblwiLFxuICAgICAgICAgIF90YWc6IFwiSW5maW5pdHlcIlxuICAgICAgICB9O1xuICAgIH1cbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn0sIGplID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUoQW0pO1xuICByZXR1cm4ga2MoZSkgPyBpc05hTihlKSB8fCBlIDw9IDAgPyB0LnZhbHVlID0gV28gOiBOdW1iZXIuaXNGaW5pdGUoZSkgPyBOdW1iZXIuaXNJbnRlZ2VyKGUpID8gdC52YWx1ZSA9IHtcbiAgICBfdGFnOiBcIk1pbGxpc1wiLFxuICAgIG1pbGxpczogZVxuICB9IDogdC52YWx1ZSA9IHtcbiAgICBfdGFnOiBcIk5hbm9zXCIsXG4gICAgbmFub3M6IEJpZ0ludChNYXRoLnJvdW5kKGUgKiAxZTYpKVxuICB9IDogdC52YWx1ZSA9IE5tIDogZSA8PSBMbCA/IHQudmFsdWUgPSBXbyA6IHQudmFsdWUgPSB7XG4gICAgX3RhZzogXCJOYW5vc1wiLFxuICAgIG5hbm9zOiBlXG4gIH0sIHQ7XG59LCBEbCA9IChlKSA9PiAkKGUsICRjKSwgUG0gPSAoZSkgPT4ge1xuICBzd2l0Y2ggKGUudmFsdWUuX3RhZykge1xuICAgIGNhc2UgXCJNaWxsaXNcIjpcbiAgICAgIHJldHVybiBlLnZhbHVlLm1pbGxpcyA9PT0gMDtcbiAgICBjYXNlIFwiTmFub3NcIjpcbiAgICAgIHJldHVybiBlLnZhbHVlLm5hbm9zID09PSBMbDtcbiAgICBjYXNlIFwiSW5maW5pdHlcIjpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufSwgcWwgPSAvKiBAX19QVVJFX18gKi8gamUoMCksIHhtID0gLyogQF9fUFVSRV9fICovIGplKDEgLyAwKSwgdWMgPSAoZSkgPT4gamUoZSksIGptID0gKGUpID0+IGplKGUgKiBFYyksIEhyID0gKGUpID0+IGplKGUpLCBMbSA9IChlKSA9PiBqZShlICogMWUzKSwgRG0gPSAoZSkgPT4gamUoZSAqIDZlNCksIHFtID0gKGUpID0+IGplKGUgKiAzNmU1KSwgVW0gPSAoZSkgPT4gamUoZSAqIDg2NGU1KSwgem0gPSAoZSkgPT4gamUoZSAqIDYwNDhlNSksIEljID0gKGUpID0+IEttKGUsIHtcbiAgb25NaWxsaXM6ICh0KSA9PiB0LFxuICBvbk5hbm9zOiAodCkgPT4gTnVtYmVyKHQpIC8gMWU2XG59KSwgQm0gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gUGUoZSk7XG4gIHN3aXRjaCAodC52YWx1ZS5fdGFnKSB7XG4gICAgY2FzZSBcIkluZmluaXR5XCI6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBpbmZpbml0ZSBkdXJhdGlvbiB0byBuYW5vc1wiKTtcbiAgICBjYXNlIFwiTmFub3NcIjpcbiAgICAgIHJldHVybiB0LnZhbHVlLm5hbm9zO1xuICAgIGNhc2UgXCJNaWxsaXNcIjpcbiAgICAgIHJldHVybiBCaWdJbnQoTWF0aC5yb3VuZCh0LnZhbHVlLm1pbGxpcyAqIDFlNikpO1xuICB9XG59LCBWbSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBQZShlKTtcbiAgc3dpdGNoICh0LnZhbHVlLl90YWcpIHtcbiAgICBjYXNlIFwiSW5maW5pdHlcIjpcbiAgICAgIHJldHVybiBbMSAvIDAsIDBdO1xuICAgIGNhc2UgXCJOYW5vc1wiOlxuICAgICAgcmV0dXJuIFtOdW1iZXIodC52YWx1ZS5uYW5vcyAvIEtvKSwgTnVtYmVyKHQudmFsdWUubmFub3MgJSBLbyldO1xuICAgIGNhc2UgXCJNaWxsaXNcIjpcbiAgICAgIHJldHVybiBbTWF0aC5mbG9vcih0LnZhbHVlLm1pbGxpcyAvIDFlMyksIE1hdGgucm91bmQodC52YWx1ZS5taWxsaXMgJSAxZTMgKiAxZTYpXTtcbiAgfVxufSwgS20gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gUGUoZSk7XG4gIHN3aXRjaCAobi52YWx1ZS5fdGFnKSB7XG4gICAgY2FzZSBcIk5hbm9zXCI6XG4gICAgICByZXR1cm4gdC5vbk5hbm9zKG4udmFsdWUubmFub3MpO1xuICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgcmV0dXJuIHQub25NaWxsaXMoMSAvIDApO1xuICAgIGNhc2UgXCJNaWxsaXNcIjpcbiAgICAgIHJldHVybiB0Lm9uTWlsbGlzKG4udmFsdWUubWlsbGlzKTtcbiAgfVxufSksIEVpID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IFBlKGUpLCBzID0gUGUodCk7XG4gIGlmIChyLnZhbHVlLl90YWcgPT09IFwiSW5maW5pdHlcIiB8fCBzLnZhbHVlLl90YWcgPT09IFwiSW5maW5pdHlcIilcbiAgICByZXR1cm4gbi5vbk1pbGxpcyhJYyhyKSwgSWMocykpO1xuICBpZiAoci52YWx1ZS5fdGFnID09PSBcIk5hbm9zXCIgfHwgcy52YWx1ZS5fdGFnID09PSBcIk5hbm9zXCIpIHtcbiAgICBjb25zdCBjID0gci52YWx1ZS5fdGFnID09PSBcIk5hbm9zXCIgPyByLnZhbHVlLm5hbm9zIDogQmlnSW50KE1hdGgucm91bmQoci52YWx1ZS5taWxsaXMgKiAxZTYpKSwgaSA9IHMudmFsdWUuX3RhZyA9PT0gXCJOYW5vc1wiID8gcy52YWx1ZS5uYW5vcyA6IEJpZ0ludChNYXRoLnJvdW5kKHMudmFsdWUubWlsbGlzICogMWU2KSk7XG4gICAgcmV0dXJuIG4ub25OYW5vcyhjLCBpKTtcbiAgfVxuICByZXR1cm4gbi5vbk1pbGxpcyhyLnZhbHVlLm1pbGxpcywgcy52YWx1ZS5taWxsaXMpO1xufSksIFdtID0gKGUsIHQpID0+IEVpKGUsIHQsIHtcbiAgb25NaWxsaXM6IChuLCByKSA9PiBuID09PSByLFxuICBvbk5hbm9zOiAobiwgcikgPT4gbiA9PT0gclxufSksIEptID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEVpKGUsIHQsIHtcbiAgb25NaWxsaXM6IChuLCByKSA9PiBuIDw9IHIsXG4gIG9uTmFub3M6IChuLCByKSA9PiBuIDw9IHJcbn0pKSwgSG0gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gRWkoZSwgdCwge1xuICBvbk1pbGxpczogKG4sIHIpID0+IG4gPj0gcixcbiAgb25OYW5vczogKG4sIHIpID0+IG4gPj0gclxufSkpLCBHbSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBXbShQZShlKSwgUGUodCkpKSwgWW0gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gUGUoZSk7XG4gIGlmICh0LnZhbHVlLl90YWcgPT09IFwiSW5maW5pdHlcIilcbiAgICByZXR1cm4ge1xuICAgICAgZGF5czogMSAvIDAsXG4gICAgICBob3VyczogMSAvIDAsXG4gICAgICBtaW51dGVzOiAxIC8gMCxcbiAgICAgIHNlY29uZHM6IDEgLyAwLFxuICAgICAgbWlsbGlzOiAxIC8gMCxcbiAgICAgIG5hbm9zOiAxIC8gMFxuICAgIH07XG4gIGNvbnN0IG4gPSBCbSh0KSwgciA9IG4gLyBWbywgcyA9IHIgLyBFYywgYyA9IHMgLyAkciwgaSA9IGMgLyAkciwgbyA9IGkgLyBCbztcbiAgcmV0dXJuIHtcbiAgICBkYXlzOiBOdW1iZXIobyksXG4gICAgaG91cnM6IE51bWJlcihpICUgQm8pLFxuICAgIG1pbnV0ZXM6IE51bWJlcihjICUgJHIpLFxuICAgIHNlY29uZHM6IE51bWJlcihzICUgJHIpLFxuICAgIG1pbGxpczogTnVtYmVyKHIgJSBFYyksXG4gICAgbmFub3M6IE51bWJlcihuICUgVm8pXG4gIH07XG59LCBRbSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBQZShlKTtcbiAgaWYgKHQudmFsdWUuX3RhZyA9PT0gXCJJbmZpbml0eVwiKVxuICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gIGlmIChQbSh0KSlcbiAgICByZXR1cm4gXCIwXCI7XG4gIGNvbnN0IG4gPSBZbSh0KSwgciA9IFtdO1xuICByZXR1cm4gbi5kYXlzICE9PSAwICYmIHIucHVzaChgJHtuLmRheXN9ZGApLCBuLmhvdXJzICE9PSAwICYmIHIucHVzaChgJHtuLmhvdXJzfWhgKSwgbi5taW51dGVzICE9PSAwICYmIHIucHVzaChgJHtuLm1pbnV0ZXN9bWApLCBuLnNlY29uZHMgIT09IDAgJiYgci5wdXNoKGAke24uc2Vjb25kc31zYCksIG4ubWlsbGlzICE9PSAwICYmIHIucHVzaChgJHtuLm1pbGxpc31tc2ApLCBuLm5hbm9zICE9PSAwICYmIHIucHVzaChgJHtuLm5hbm9zfW5zYCksIHIuam9pbihcIiBcIik7XG59LCBidCA9IDUsIElpID0gLyogQF9fUFVSRV9fICovIE1hdGgucG93KDIsIGJ0KSwgWm0gPSBJaSAtIDEsIFhtID0gSWkgLyAyLCBlcCA9IElpIC8gNDtcbmZ1bmN0aW9uIHRwKGUpIHtcbiAgcmV0dXJuIGUgLT0gZSA+PiAxICYgMTQzMTY1NTc2NSwgZSA9IChlICYgODU4OTkzNDU5KSArIChlID4+IDIgJiA4NTg5OTM0NTkpLCBlID0gZSArIChlID4+IDQpICYgMjUyNjQ1MTM1LCBlICs9IGUgPj4gOCwgZSArPSBlID4+IDE2LCBlICYgMTI3O1xufVxuZnVuY3Rpb24gS3QoZSwgdCkge1xuICByZXR1cm4gdCA+Pj4gZSAmIFptO1xufVxuZnVuY3Rpb24geHQoZSkge1xuICByZXR1cm4gMSA8PCBlO1xufVxuZnVuY3Rpb24gVWwoZSwgdCkge1xuICByZXR1cm4gdHAoZSAmIHQgLSAxKTtcbn1cbmNvbnN0IG5wID0gKGUsIHQpID0+ICh7XG4gIHZhbHVlOiBlLFxuICBwcmV2aW91czogdFxufSk7XG5mdW5jdGlvbiBMdChlLCB0LCBuLCByKSB7XG4gIGxldCBzID0gcjtcbiAgaWYgKCFlKSB7XG4gICAgY29uc3QgYyA9IHIubGVuZ3RoO1xuICAgIHMgPSBuZXcgQXJyYXkoYyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjOyArK2kpIHNbaV0gPSByW2ldO1xuICB9XG4gIHJldHVybiBzW3RdID0gbiwgcztcbn1cbmZ1bmN0aW9uIHpsKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IG4ubGVuZ3RoIC0gMTtcbiAgbGV0IHMgPSAwLCBjID0gMCwgaSA9IG47XG4gIGlmIChlKVxuICAgIHMgPSBjID0gdDtcbiAgZWxzZVxuICAgIGZvciAoaSA9IG5ldyBBcnJheShyKTsgcyA8IHQ7ICkgaVtjKytdID0gbltzKytdO1xuICBmb3IgKCsrczsgcyA8PSByOyApIGlbYysrXSA9IG5bcysrXTtcbiAgcmV0dXJuIGUgJiYgKGkubGVuZ3RoID0gciksIGk7XG59XG5mdW5jdGlvbiBycChlLCB0LCBuLCByKSB7XG4gIGNvbnN0IHMgPSByLmxlbmd0aDtcbiAgaWYgKGUpIHtcbiAgICBsZXQgYSA9IHM7XG4gICAgZm9yICg7IGEgPj0gdDsgKSByW2EtLV0gPSByW2FdO1xuICAgIHJldHVybiByW3RdID0gbiwgcjtcbiAgfVxuICBsZXQgYyA9IDAsIGkgPSAwO1xuICBjb25zdCBvID0gbmV3IEFycmF5KHMgKyAxKTtcbiAgZm9yICg7IGMgPCB0OyApIG9baSsrXSA9IHJbYysrXTtcbiAgZm9yIChvW3RdID0gbjsgYyA8IHM7ICkgb1srK2ldID0gcltjKytdO1xuICByZXR1cm4gbztcbn1cbmNsYXNzIFFlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdSh0aGlzLCBcIl90YWdcIiwgXCJFbXB0eU5vZGVcIik7XG4gIH1cbiAgbW9kaWZ5KHQsIG4sIHIsIHMsIGMsIGkpIHtcbiAgICBjb25zdCBvID0gcih2KCkpO1xuICAgIHJldHVybiBXKG8pID8gbmV3IFFlKCkgOiAoKytpLnZhbHVlLCBuZXcgZHQodCwgcywgYywgbykpO1xuICB9XG59XG5mdW5jdGlvbiB3ZShlKSB7XG4gIHJldHVybiBlbChlLCBcIkVtcHR5Tm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHNwKGUpIHtcbiAgcmV0dXJuIHdlKGUpIHx8IGUuX3RhZyA9PT0gXCJMZWFmTm9kZVwiIHx8IGUuX3RhZyA9PT0gXCJDb2xsaXNpb25Ob2RlXCI7XG59XG5mdW5jdGlvbiBScyhlLCB0KSB7XG4gIHJldHVybiB3ZShlKSA/ICExIDogdCA9PT0gZS5lZGl0O1xufVxuY2xhc3MgZHQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByLCBzKSB7XG4gICAgdSh0aGlzLCBcImVkaXRcIik7XG4gICAgdSh0aGlzLCBcImhhc2hcIik7XG4gICAgdSh0aGlzLCBcImtleVwiKTtcbiAgICB1KHRoaXMsIFwidmFsdWVcIik7XG4gICAgdSh0aGlzLCBcIl90YWdcIiwgXCJMZWFmTm9kZVwiKTtcbiAgICB0aGlzLmVkaXQgPSB0LCB0aGlzLmhhc2ggPSBuLCB0aGlzLmtleSA9IHIsIHRoaXMudmFsdWUgPSBzO1xuICB9XG4gIG1vZGlmeSh0LCBuLCByLCBzLCBjLCBpKSB7XG4gICAgaWYgKE8oYywgdGhpcy5rZXkpKSB7XG4gICAgICBjb25zdCBhID0gcih0aGlzLnZhbHVlKTtcbiAgICAgIHJldHVybiBhID09PSB0aGlzLnZhbHVlID8gdGhpcyA6IFcoYSkgPyAoLS1pLnZhbHVlLCBuZXcgUWUoKSkgOiBScyh0aGlzLCB0KSA/ICh0aGlzLnZhbHVlID0gYSwgdGhpcykgOiBuZXcgZHQodCwgcywgYywgYSk7XG4gICAgfVxuICAgIGNvbnN0IG8gPSByKHYoKSk7XG4gICAgcmV0dXJuIFcobykgPyB0aGlzIDogKCsraS52YWx1ZSwgQmwodCwgbiwgdGhpcy5oYXNoLCB0aGlzLCBzLCBuZXcgZHQodCwgcywgYywgbykpKTtcbiAgfVxufVxuY2xhc3MgRmkge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgdSh0aGlzLCBcImVkaXRcIik7XG4gICAgdSh0aGlzLCBcImhhc2hcIik7XG4gICAgdSh0aGlzLCBcImNoaWxkcmVuXCIpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIFwiQ29sbGlzaW9uTm9kZVwiKTtcbiAgICB0aGlzLmVkaXQgPSB0LCB0aGlzLmhhc2ggPSBuLCB0aGlzLmNoaWxkcmVuID0gcjtcbiAgfVxuICBtb2RpZnkodCwgbiwgciwgcywgYywgaSkge1xuICAgIGlmIChzID09PSB0aGlzLmhhc2gpIHtcbiAgICAgIGNvbnN0IGEgPSBScyh0aGlzLCB0KSwgaCA9IHRoaXMudXBkYXRlQ29sbGlzaW9uTGlzdChhLCB0LCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIHIsIGMsIGkpO1xuICAgICAgcmV0dXJuIGggPT09IHRoaXMuY2hpbGRyZW4gPyB0aGlzIDogaC5sZW5ndGggPiAxID8gbmV3IEZpKHQsIHRoaXMuaGFzaCwgaCkgOiBoWzBdO1xuICAgIH1cbiAgICBjb25zdCBvID0gcih2KCkpO1xuICAgIHJldHVybiBXKG8pID8gdGhpcyA6ICgrK2kudmFsdWUsIEJsKHQsIG4sIHRoaXMuaGFzaCwgdGhpcywgcywgbmV3IGR0KHQsIHMsIGMsIG8pKSk7XG4gIH1cbiAgdXBkYXRlQ29sbGlzaW9uTGlzdCh0LCBuLCByLCBzLCBjLCBpLCBvKSB7XG4gICAgY29uc3QgYSA9IHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgYTsgKytkKSB7XG4gICAgICBjb25zdCBnID0gc1tkXTtcbiAgICAgIGlmIChcImtleVwiIGluIGcgJiYgTyhpLCBnLmtleSkpIHtcbiAgICAgICAgY29uc3QgcCA9IGcudmFsdWUsIF8gPSBjKHApO1xuICAgICAgICByZXR1cm4gXyA9PT0gcCA/IHMgOiBXKF8pID8gKC0tby52YWx1ZSwgemwodCwgZCwgcykpIDogTHQodCwgZCwgbmV3IGR0KG4sIHIsIGksIF8pLCBzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaCA9IGModigpKTtcbiAgICByZXR1cm4gVyhoKSA/IHMgOiAoKytvLnZhbHVlLCBMdCh0LCBhLCBuZXcgZHQobiwgciwgaSwgaCksIHMpKTtcbiAgfVxufVxuY2xhc3MgV3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgdSh0aGlzLCBcImVkaXRcIik7XG4gICAgdSh0aGlzLCBcIm1hc2tcIik7XG4gICAgdSh0aGlzLCBcImNoaWxkcmVuXCIpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIFwiSW5kZXhlZE5vZGVcIik7XG4gICAgdGhpcy5lZGl0ID0gdCwgdGhpcy5tYXNrID0gbiwgdGhpcy5jaGlsZHJlbiA9IHI7XG4gIH1cbiAgbW9kaWZ5KHQsIG4sIHIsIHMsIGMsIGkpIHtcbiAgICBjb25zdCBvID0gdGhpcy5tYXNrLCBhID0gdGhpcy5jaGlsZHJlbiwgaCA9IEt0KG4sIHMpLCBkID0geHQoaCksIGcgPSBVbChvLCBkKSwgcCA9IG8gJiBkLCBfID0gUnModGhpcywgdCk7XG4gICAgaWYgKCFwKSB7XG4gICAgICBjb25zdCBIID0gbmV3IFFlKCkubW9kaWZ5KHQsIG4gKyBidCwgciwgcywgYywgaSk7XG4gICAgICByZXR1cm4gSCA/IGEubGVuZ3RoID49IFhtID8gaXAodCwgaCwgSCwgbywgYSkgOiBuZXcgV3QodCwgbyB8IGQsIHJwKF8sIGcsIEgsIGEpKSA6IHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGIgPSBhW2ddLCBNID0gYi5tb2RpZnkodCwgbiArIGJ0LCByLCBzLCBjLCBpKTtcbiAgICBpZiAoYiA9PT0gTSkgcmV0dXJuIHRoaXM7XG4gICAgbGV0IEQgPSBvLCBYO1xuICAgIGlmICh3ZShNKSkge1xuICAgICAgaWYgKEQgJj0gfmQsICFEKSByZXR1cm4gbmV3IFFlKCk7XG4gICAgICBpZiAoYS5sZW5ndGggPD0gMiAmJiBzcChhW2cgXiAxXSkpXG4gICAgICAgIHJldHVybiBhW2cgXiAxXTtcbiAgICAgIFggPSB6bChfLCBnLCBhKTtcbiAgICB9IGVsc2VcbiAgICAgIFggPSBMdChfLCBnLCBNLCBhKTtcbiAgICByZXR1cm4gXyA/ICh0aGlzLm1hc2sgPSBELCB0aGlzLmNoaWxkcmVuID0gWCwgdGhpcykgOiBuZXcgV3QodCwgRCwgWCk7XG4gIH1cbn1cbmNsYXNzIFJpIHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIHUodGhpcywgXCJlZGl0XCIpO1xuICAgIHUodGhpcywgXCJzaXplXCIpO1xuICAgIHUodGhpcywgXCJjaGlsZHJlblwiKTtcbiAgICB1KHRoaXMsIFwiX3RhZ1wiLCBcIkFycmF5Tm9kZVwiKTtcbiAgICB0aGlzLmVkaXQgPSB0LCB0aGlzLnNpemUgPSBuLCB0aGlzLmNoaWxkcmVuID0gcjtcbiAgfVxuICBtb2RpZnkodCwgbiwgciwgcywgYywgaSkge1xuICAgIGxldCBvID0gdGhpcy5zaXplO1xuICAgIGNvbnN0IGEgPSB0aGlzLmNoaWxkcmVuLCBoID0gS3QobiwgcyksIGQgPSBhW2hdLCBnID0gKGQgfHwgbmV3IFFlKCkpLm1vZGlmeSh0LCBuICsgYnQsIHIsIHMsIGMsIGkpO1xuICAgIGlmIChkID09PSBnKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBwID0gUnModGhpcywgdCk7XG4gICAgbGV0IF87XG4gICAgaWYgKHdlKGQpICYmICF3ZShnKSlcbiAgICAgICsrbywgXyA9IEx0KHAsIGgsIGcsIGEpO1xuICAgIGVsc2UgaWYgKCF3ZShkKSAmJiB3ZShnKSkge1xuICAgICAgaWYgKC0tbywgbyA8PSBlcClcbiAgICAgICAgcmV0dXJuIGNwKHQsIG8sIGgsIGEpO1xuICAgICAgXyA9IEx0KHAsIGgsIG5ldyBRZSgpLCBhKTtcbiAgICB9IGVsc2VcbiAgICAgIF8gPSBMdChwLCBoLCBnLCBhKTtcbiAgICByZXR1cm4gcCA/ICh0aGlzLnNpemUgPSBvLCB0aGlzLmNoaWxkcmVuID0gXywgdGhpcykgOiBuZXcgUmkodCwgbywgXyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNwKGUsIHQsIG4sIHIpIHtcbiAgY29uc3QgcyA9IG5ldyBBcnJheSh0IC0gMSk7XG4gIGxldCBjID0gMCwgaSA9IDA7XG4gIGZvciAobGV0IG8gPSAwLCBhID0gci5sZW5ndGg7IG8gPCBhOyArK28pXG4gICAgaWYgKG8gIT09IG4pIHtcbiAgICAgIGNvbnN0IGggPSByW29dO1xuICAgICAgaCAmJiAhd2UoaCkgJiYgKHNbYysrXSA9IGgsIGkgfD0gMSA8PCBvKTtcbiAgICB9XG4gIHJldHVybiBuZXcgV3QoZSwgaSwgcyk7XG59XG5mdW5jdGlvbiBpcChlLCB0LCBuLCByLCBzKSB7XG4gIGNvbnN0IGMgPSBbXTtcbiAgbGV0IGkgPSByLCBvID0gMDtcbiAgZm9yIChsZXQgYSA9IDA7IGk7ICsrYSlcbiAgICBpICYgMSAmJiAoY1thXSA9IHNbbysrXSksIGkgPj4+PSAxO1xuICByZXR1cm4gY1t0XSA9IG4sIG5ldyBSaShlLCBvICsgMSwgYyk7XG59XG5mdW5jdGlvbiBvcChlLCB0LCBuLCByLCBzLCBjKSB7XG4gIGlmIChuID09PSBzKSByZXR1cm4gbmV3IEZpKGUsIG4sIFtjLCByXSk7XG4gIGNvbnN0IGkgPSBLdCh0LCBuKSwgbyA9IEt0KHQsIHMpO1xuICBpZiAoaSA9PT0gbylcbiAgICByZXR1cm4gKGEpID0+IG5ldyBXdChlLCB4dChpKSB8IHh0KG8pLCBbYV0pO1xuICB7XG4gICAgY29uc3QgYSA9IGkgPCBvID8gW3IsIGNdIDogW2MsIHJdO1xuICAgIHJldHVybiBuZXcgV3QoZSwgeHQoaSkgfCB4dChvKSwgYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJsKGUsIHQsIG4sIHIsIHMsIGMpIHtcbiAgbGV0IGksIG8gPSB0O1xuICBmb3IgKDsgOyApIHtcbiAgICBjb25zdCBhID0gb3AoZSwgbywgbiwgciwgcywgYyk7XG4gICAgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIilcbiAgICAgIGkgPSBucChhLCBpKSwgbyA9IG8gKyBidDtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBoID0gYTtcbiAgICAgIGZvciAoOyBpICE9IG51bGw7IClcbiAgICAgICAgaCA9IGkudmFsdWUoaCksIGkgPSBpLnByZXZpb3VzO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICB9XG59XG5jb25zdCBWbCA9IFwiZWZmZWN0L0hhc2hNYXBcIiwgRmMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihWbCksIGFwID0ge1xuICBbRmNdOiBGYyxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBNcyh0aGlzLCAoZSwgdCkgPT4gW2UsIHRdKTtcbiAgfSxcbiAgW0ZdKCkge1xuICAgIGxldCBlID0gayhWbCk7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMpXG4gICAgICBlIF49IGYoayh0WzBdKSwgUihrKHRbMV0pKSk7XG4gICAgcmV0dXJuIHEodGhpcywgZSk7XG4gIH0sXG4gIFtFXShlKSB7XG4gICAgaWYgKGZwKGUpKSB7XG4gICAgICBpZiAoZS5fc2l6ZSAhPT0gdGhpcy5fc2l6ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMpIHtcbiAgICAgICAgY29uc3QgbiA9IGYoZSwgVGkodFswXSwgayh0WzBdKSkpO1xuICAgICAgICBpZiAoVyhuKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGlmICghTyh0WzFdLCBuLnZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcy50b0pTT04oKSk7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkhhc2hNYXBcIixcbiAgICAgIHZhbHVlczogQXJyYXkuZnJvbSh0aGlzKS5tYXAoVilcbiAgICB9O1xuICB9LFxuICBbVV0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgTWkgPSAoZSwgdCwgbiwgcikgPT4ge1xuICBjb25zdCBzID0gT2JqZWN0LmNyZWF0ZShhcCk7XG4gIHJldHVybiBzLl9lZGl0YWJsZSA9IGUsIHMuX2VkaXQgPSB0LCBzLl9yb290ID0gbiwgcy5fc2l6ZSA9IHIsIHM7XG59O1xuY2xhc3MgTXMge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdSh0aGlzLCBcIm1hcFwiKTtcbiAgICB1KHRoaXMsIFwiZlwiKTtcbiAgICB1KHRoaXMsIFwidlwiKTtcbiAgICB0aGlzLm1hcCA9IHQsIHRoaXMuZiA9IG4sIHRoaXMudiA9IEtsKHRoaXMubWFwLl9yb290LCB0aGlzLmYsIHZvaWQgMCk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAoVyh0aGlzLnYpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogITAsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgY29uc3QgdCA9IHRoaXMudi52YWx1ZTtcbiAgICByZXR1cm4gdGhpcy52ID0gR3IodC5jb250KSwge1xuICAgICAgZG9uZTogITEsXG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH07XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBNcyh0aGlzLm1hcCwgdGhpcy5mKTtcbiAgfVxufVxuY29uc3QgR3IgPSAoZSkgPT4gZSA/IFdsKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10sIGVbNF0pIDogdigpLCBLbCA9IChlLCB0LCBuID0gdm9pZCAwKSA9PiB7XG4gIHN3aXRjaCAoZS5fdGFnKSB7XG4gICAgY2FzZSBcIkxlYWZOb2RlXCI6XG4gICAgICByZXR1cm4geWUoZS52YWx1ZSkgPyBJKHtcbiAgICAgICAgdmFsdWU6IHQoZS5rZXksIGUudmFsdWUudmFsdWUpLFxuICAgICAgICBjb250OiBuXG4gICAgICB9KSA6IEdyKG4pO1xuICAgIGNhc2UgXCJDb2xsaXNpb25Ob2RlXCI6XG4gICAgY2FzZSBcIkFycmF5Tm9kZVwiOlxuICAgIGNhc2UgXCJJbmRleGVkTm9kZVwiOiB7XG4gICAgICBjb25zdCByID0gZS5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBXbChyLmxlbmd0aCwgciwgMCwgdCwgbik7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gR3Iobik7XG4gIH1cbn0sIFdsID0gKGUsIHQsIG4sIHIsIHMpID0+IHtcbiAgZm9yICg7IG4gPCBlOyApIHtcbiAgICBjb25zdCBjID0gdFtuKytdO1xuICAgIGlmIChjICYmICF3ZShjKSlcbiAgICAgIHJldHVybiBLbChjLCByLCBbZSwgdCwgbiwgciwgc10pO1xuICB9XG4gIHJldHVybiBHcihzKTtcbn0sIHVwID0gLyogQF9fUFVSRV9fICovIE1pKCExLCAwLCAvKiBAX19QVVJFX18gKi8gbmV3IFFlKCksIDApLCBUcyA9ICgpID0+IHVwLCBscCA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBIbChUcygpKTtcbiAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgam4odCwgblswXSwgblsxXSk7XG4gIHJldHVybiBwcCh0KTtcbn0sIGZwID0gKGUpID0+ICQoZSwgRmMpLCBocCA9IChlKSA9PiBlICYmIHdlKGUuX3Jvb3QpLCBkcCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBUaShlLCB0LCBrKHQpKSksIFRpID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgbGV0IHIgPSBlLl9yb290LCBzID0gMDtcbiAgZm9yICg7IDsgKVxuICAgIHN3aXRjaCAoci5fdGFnKSB7XG4gICAgICBjYXNlIFwiTGVhZk5vZGVcIjpcbiAgICAgICAgcmV0dXJuIE8odCwgci5rZXkpID8gci52YWx1ZSA6IHYoKTtcbiAgICAgIGNhc2UgXCJDb2xsaXNpb25Ob2RlXCI6IHtcbiAgICAgICAgaWYgKG4gPT09IHIuaGFzaCkge1xuICAgICAgICAgIGNvbnN0IGMgPSByLmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gYy5sZW5ndGg7IGkgPCBvOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjW2ldO1xuICAgICAgICAgICAgaWYgKFwia2V5XCIgaW4gYSAmJiBPKHQsIGEua2V5KSlcbiAgICAgICAgICAgICAgcmV0dXJuIGEudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2KCk7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSW5kZXhlZE5vZGVcIjoge1xuICAgICAgICBjb25zdCBjID0gS3QocywgbiksIGkgPSB4dChjKTtcbiAgICAgICAgaWYgKHIubWFzayAmIGkpIHtcbiAgICAgICAgICByID0gci5jaGlsZHJlbltVbChyLm1hc2ssIGkpXSwgcyArPSBidDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdigpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkFycmF5Tm9kZVwiOiB7XG4gICAgICAgIGlmIChyID0gci5jaGlsZHJlbltLdChzLCBuKV0sIHIpIHtcbiAgICAgICAgICBzICs9IGJ0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2KCk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdigpO1xuICAgIH1cbn0pLCBncCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB5ZShUaShlLCB0LCBrKHQpKSkpLCBqbiA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBDaShlLCB0LCAoKSA9PiBJKG4pKSksIG1wID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IGUuX2VkaXRhYmxlID8gKGUuX3Jvb3QgPSB0LCBlLl9zaXplID0gbiwgZSkgOiB0ID09PSBlLl9yb290ID8gZSA6IE1pKGUuX2VkaXRhYmxlLCBlLl9lZGl0LCB0LCBuKSksIEpsID0gKGUpID0+IG5ldyBNcyhlLCAodCkgPT4gdCksIFJjID0gKGUpID0+IGUuX3NpemUsIEhsID0gKGUpID0+IE1pKCEwLCBlLl9lZGl0ICsgMSwgZS5fcm9vdCwgZS5fc2l6ZSksIHBwID0gKGUpID0+IChlLl9lZGl0YWJsZSA9ICExLCBlKSwgQ2kgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4gX3AoZSwgdCwgayh0KSwgbikpLCBfcCA9IC8qIEBfX1BVUkVfXyAqLyBsKDQsIChlLCB0LCBuLCByKSA9PiB7XG4gIGNvbnN0IHMgPSB7XG4gICAgdmFsdWU6IGUuX3NpemVcbiAgfSwgYyA9IGUuX3Jvb3QubW9kaWZ5KGUuX2VkaXRhYmxlID8gZS5fZWRpdCA6IE5hTiwgMCwgciwgbiwgdCwgcyk7XG4gIHJldHVybiBmKGUsIG1wKGMsIHMudmFsdWUpKTtcbn0pLCBKbyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBDaShlLCB0LCB2KSksIHlwID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IENzKGUsIFRzKCksIChuLCByLCBzKSA9PiBqbihuLCBzLCB0KHIsIHMpKSkpLCBicCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBDcyhlLCB2b2lkIDAsIChuLCByLCBzKSA9PiB0KHIsIHMpKSksIENzID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IGUuX3Jvb3Q7XG4gIGlmIChyLl90YWcgPT09IFwiTGVhZk5vZGVcIilcbiAgICByZXR1cm4geWUoci52YWx1ZSkgPyBuKHQsIHIudmFsdWUudmFsdWUsIHIua2V5KSA6IHQ7XG4gIGlmIChyLl90YWcgPT09IFwiRW1wdHlOb2RlXCIpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IHMgPSBbci5jaGlsZHJlbl07XG4gIGxldCBjO1xuICBmb3IgKDsgYyA9IHMucG9wKCk7IClcbiAgICBmb3IgKGxldCBpID0gMCwgbyA9IGMubGVuZ3RoOyBpIDwgbzsgKSB7XG4gICAgICBjb25zdCBhID0gY1tpKytdO1xuICAgICAgYSAmJiAhd2UoYSkgJiYgKGEuX3RhZyA9PT0gXCJMZWFmTm9kZVwiID8geWUoYS52YWx1ZSkgJiYgKHQgPSBuKHQsIGEudmFsdWUudmFsdWUsIGEua2V5KSkgOiBzLnB1c2goYS5jaGlsZHJlbikpO1xuICAgIH1cbiAgcmV0dXJuIHQ7XG59KSwgR2wgPSBcImVmZmVjdC9IYXNoU2V0XCIsIE1jID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoR2wpLCBTcCA9IHtcbiAgW01jXTogTWMsXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBKbCh0aGlzLl9rZXlNYXApO1xuICB9LFxuICBbRl0oKSB7XG4gICAgcmV0dXJuIHEodGhpcywgUihrKHRoaXMuX2tleU1hcCkpKGsoR2wpKSk7XG4gIH0sXG4gIFtFXShlKSB7XG4gICAgcmV0dXJuIGtwKGUpID8gUmModGhpcy5fa2V5TWFwKSA9PT0gUmMoZS5fa2V5TWFwKSAmJiBPKHRoaXMuX2tleU1hcCwgZS5fa2V5TWFwKSA6ICExO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiSGFzaFNldFwiLFxuICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHRoaXMpLm1hcChWKVxuICAgIH07XG4gIH0sXG4gIFtVXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBOcyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBPYmplY3QuY3JlYXRlKFNwKTtcbiAgcmV0dXJuIHQuX2tleU1hcCA9IGUsIHQ7XG59LCBrcCA9IChlKSA9PiAkKGUsIE1jKSwgdnAgPSAvKiBAX19QVVJFX18gKi8gTnMoLyogQF9fUFVSRV9fICovIFRzKCkpLCBBcyA9ICgpID0+IHZwLCB3cCA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBOaShBcygpKTtcbiAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgTG4odCwgbik7XG4gIHJldHVybiBBaSh0KTtcbn0sIE9wID0gKC4uLmUpID0+IHtcbiAgY29uc3QgdCA9IE5pKEFzKCkpO1xuICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICBMbih0LCBuKTtcbiAgcmV0dXJuIEFpKHQpO1xufSwgJHAgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZ3AoZS5fa2V5TWFwLCB0KSksIEVwID0gKGUpID0+IFJjKGUuX2tleU1hcCksIE5pID0gKGUpID0+IE5zKEhsKGUuX2tleU1hcCkpLCBBaSA9IChlKSA9PiAoZS5fa2V5TWFwLl9lZGl0YWJsZSA9ICExLCBlKSwgWWwgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gTmkoZSk7XG4gIHJldHVybiB0KG4pLCBBaShuKTtcbn0pLCBMbiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBlLl9rZXlNYXAuX2VkaXRhYmxlID8gKGpuKHQsICEwKShlLl9rZXlNYXApLCBlKSA6IE5zKGpuKHQsICEwKShlLl9rZXlNYXApKSksIFFsID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGUuX2tleU1hcC5fZWRpdGFibGUgPyAoSm8odCkoZS5fa2V5TWFwKSwgZSkgOiBOcyhKbyh0KShlLl9rZXlNYXApKSksIElwID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFlsKGUsIChuKSA9PiB7XG4gIGZvciAoY29uc3QgciBvZiB0KVxuICAgIFFsKG4sIHIpO1xufSkpLCBGcCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBZbChBcygpLCAobikgPT4ge1xuICBScChlLCAocikgPT4gTG4obiwgcikpO1xuICBmb3IgKGNvbnN0IHIgb2YgdClcbiAgICBMbihuLCByKTtcbn0pKSwgUnAgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gYnAoZS5fa2V5TWFwLCAobiwgcikgPT4gdChyKSkpLCBNcCA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBDcyhlLl9rZXlNYXAsIHQsIChyLCBzLCBjKSA9PiBuKHIsIGMpKSksIFN0ID0gQXMsIFRwID0gd3AsIFBpID0gT3AsIENwID0gJHAsIFpsID0gRXAsIENuID0gTG4sIFhsID0gUWwsIEhvID0gSXAsIERuID0gRnAsIHFuID0gTXAsIEdvID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTXV0YWJsZVJlZlwiKSwgTnAgPSB7XG4gIFtHb106IEdvLFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiTXV0YWJsZVJlZlwiLFxuICAgICAgY3VycmVudDogVih0aGlzLmN1cnJlbnQpXG4gICAgfTtcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn0sIFBzID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUoTnApO1xuICByZXR1cm4gdC5jdXJyZW50ID0gZSwgdDtcbn0sIEFwID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IE8odCwgZS5jdXJyZW50KSA/IChlLmN1cnJlbnQgPSBuLCAhMCkgOiAhMSksIFplID0gKGUpID0+IGUuY3VycmVudCwgeHMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gKGUuY3VycmVudCA9IHQsIGUpKSwganMgPSBcImVmZmVjdC9GaWJlcklkXCIsIGt0ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoanMpLCBKdCA9IFwiTm9uZVwiLCBUYyA9IFwiUnVudGltZVwiLCBDYyA9IFwiQ29tcG9zaXRlXCIsIFBwID0gLyogQF9fUFVSRV9fICovIEIoYCR7anN9LSR7SnR9YCk7XG52YXIgWmE7XG5sZXQgeHAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHUodGhpcywgWmEsIGt0KTtcbiAgICB1KHRoaXMsIFwiX3RhZ1wiLCBKdCk7XG4gICAgdSh0aGlzLCBcImlkXCIsIC0xKTtcbiAgICB1KHRoaXMsIFwic3RhcnRUaW1lTWlsbGlzXCIsIC0xKTtcbiAgfVxuICBbKFphID0ga3QsIEYpXSgpIHtcbiAgICByZXR1cm4gUHA7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4geGkodCkgJiYgdC5fdGFnID09PSBKdDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gUSh0aGlzLnRvSlNPTigpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJGaWJlcklkXCIsXG4gICAgICBfdGFnOiB0aGlzLl90YWdcbiAgICB9O1xuICB9XG4gIFtVXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfVxufTtcbnZhciBYYTtcbmNsYXNzIGpwIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJpZFwiKTtcbiAgICB1KHRoaXMsIFwic3RhcnRUaW1lTWlsbGlzXCIpO1xuICAgIHUodGhpcywgWGEsIGt0KTtcbiAgICB1KHRoaXMsIFwiX3RhZ1wiLCBUYyk7XG4gICAgdGhpcy5pZCA9IHQsIHRoaXMuc3RhcnRUaW1lTWlsbGlzID0gbjtcbiAgfVxuICBbKFhhID0ga3QsIEYpXSgpIHtcbiAgICByZXR1cm4gcSh0aGlzLCBCKGAke2pzfS0ke3RoaXMuX3RhZ30tJHt0aGlzLmlkfS0ke3RoaXMuc3RhcnRUaW1lTWlsbGlzfWApKTtcbiAgfVxuICBbRV0odCkge1xuICAgIHJldHVybiB4aSh0KSAmJiB0Ll90YWcgPT09IFRjICYmIHRoaXMuaWQgPT09IHQuaWQgJiYgdGhpcy5zdGFydFRpbWVNaWxsaXMgPT09IHQuc3RhcnRUaW1lTWlsbGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkZpYmVySWRcIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc3RhcnRUaW1lTWlsbGlzOiB0aGlzLnN0YXJ0VGltZU1pbGxpc1xuICAgIH07XG4gIH1cbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9XG59XG52YXIgZXU7XG5jbGFzcyBMcCB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICB1KHRoaXMsIFwibGVmdFwiKTtcbiAgICB1KHRoaXMsIFwicmlnaHRcIik7XG4gICAgdSh0aGlzLCBldSwga3QpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIENjKTtcbiAgICB1KHRoaXMsIFwiX2hhc2hcIik7XG4gICAgdGhpcy5sZWZ0ID0gdCwgdGhpcy5yaWdodCA9IG47XG4gIH1cbiAgWyhldSA9IGt0LCBGKV0oKSB7XG4gICAgcmV0dXJuIGYoQihgJHtqc30tJHt0aGlzLl90YWd9YCksIFIoayh0aGlzLmxlZnQpKSwgUihrKHRoaXMucmlnaHQpKSwgcSh0aGlzKSk7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4geGkodCkgJiYgdC5fdGFnID09PSBDYyAmJiBPKHRoaXMubGVmdCwgdC5sZWZ0KSAmJiBPKHRoaXMucmlnaHQsIHQucmlnaHQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkZpYmVySWRcIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIGxlZnQ6IFYodGhpcy5sZWZ0KSxcbiAgICAgIHJpZ2h0OiBWKHRoaXMucmlnaHQpXG4gICAgfTtcbiAgfVxuICBbVV0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH1cbn1cbmNvbnN0IGVmID0gLyogQF9fUFVSRV9fICovIG5ldyB4cCgpLCB4aSA9IChlKSA9PiAkKGUsIGt0KSwgdGYgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZS5fdGFnID09PSBKdCA/IHQgOiB0Ll90YWcgPT09IEp0ID8gZSA6IG5ldyBMcChlLCB0KSksIERwID0gKGUpID0+IGYoZSwgcW4oZWYsICh0LCBuKSA9PiB0ZihuKSh0KSkpLCBOYyA9IChlKSA9PiB7XG4gIHN3aXRjaCAoZS5fdGFnKSB7XG4gICAgY2FzZSBKdDpcbiAgICAgIHJldHVybiBTdCgpO1xuICAgIGNhc2UgVGM6XG4gICAgICByZXR1cm4gUGkoZS5pZCk7XG4gICAgY2FzZSBDYzpcbiAgICAgIHJldHVybiBmKE5jKGUubGVmdCksIERuKE5jKGUucmlnaHQpKSk7XG4gIH1cbn0sIFlvID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXIvSWQvX2ZpYmVyQ291bnRlclwiKSwgKCkgPT4gUHMoMCkpLCBuZiA9IChlKSA9PiBBcnJheS5mcm9tKE5jKGUpKS5tYXAoKG4pID0+IGAjJHtufWApLmpvaW4oXCIsXCIpLCBxcCA9ICgpID0+IHtcbiAgY29uc3QgZSA9IFplKFlvKTtcbiAgcmV0dXJuIGYoWW8sIHhzKGUgKyAxKSksIG5ldyBqcChlLCBEYXRlLm5vdygpKTtcbn0sIEh0ID0gZWYsIFVwID0gdGYsIEVFID0gRHAsIHpwID0gbmYsIHJmID0gcXAsIGppID0gVHMsIEJwID0gbHAsIFZwID0gaHAsIHNmID0gZHAsIGNmID0gam4sIG9mID0gSmwsIEtwID0gQ2ksIFdwID0geXAsIGFmID0gQ3MsIFVuID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTGlzdFwiKSwgQWMgPSAoZSkgPT4geihlKSwgSnAgPSAoZSkgPT4gRGQodmkoZSksIEFjKSwgSHAgPSAvKiBAX19QVVJFX18gKi8gSnAoTyksIEdwID0ge1xuICBbVW5dOiBVbixcbiAgX3RhZzogXCJDb25zXCIsXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJMaXN0XCIsXG4gICAgICBfdGFnOiBcIkNvbnNcIixcbiAgICAgIHZhbHVlczogQWModGhpcykubWFwKFYpXG4gICAgfTtcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBbRV0oZSkge1xuICAgIHJldHVybiBsZihlKSAmJiB0aGlzLl90YWcgPT09IGUuX3RhZyAmJiBIcCh0aGlzLCBlKTtcbiAgfSxcbiAgW0ZdKCkge1xuICAgIHJldHVybiBxKHRoaXMsIGVyKEFjKHRoaXMpKSk7XG4gIH0sXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBlID0gITEsIHQgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoZSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXR1cm4oKTtcbiAgICAgICAgaWYgKHQuX3RhZyA9PT0gXCJOaWxcIilcbiAgICAgICAgICByZXR1cm4gZSA9ICEwLCB0aGlzLnJldHVybigpO1xuICAgICAgICBjb25zdCBuID0gdC5oZWFkO1xuICAgICAgICByZXR1cm4gdCA9IHQudGFpbCwge1xuICAgICAgICAgIGRvbmU6IGUsXG4gICAgICAgICAgdmFsdWU6IG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXR1cm4obikge1xuICAgICAgICByZXR1cm4gZSB8fCAoZSA9ICEwKSwge1xuICAgICAgICAgIGRvbmU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBuXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBZciA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgcmV0dXJuIG4uaGVhZCA9IGUsIG4udGFpbCA9IHQsIG47XG59LCBZcCA9IC8qIEBfX1BVUkVfXyAqLyBCKFwiTmlsXCIpLCBRcCA9IHtcbiAgW1VuXTogVW4sXG4gIF90YWc6IFwiTmlsXCIsXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBRKHRoaXMudG9KU09OKCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJMaXN0XCIsXG4gICAgICBfdGFnOiBcIk5pbFwiXG4gICAgfTtcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBbRl0oKSB7XG4gICAgcmV0dXJuIFlwO1xuICB9LFxuICBbRV0oZSkge1xuICAgIHJldHVybiBsZihlKSAmJiB0aGlzLl90YWcgPT09IGUuX3RhZztcbiAgfSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogITAsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgdWYgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShRcCksIGxmID0gKGUpID0+ICQoZSwgVW4pLCBKZSA9IChlKSA9PiBlLl90YWcgPT09IFwiTmlsXCIsIFpwID0gKGUpID0+IGUuX3RhZyA9PT0gXCJDb25zXCIsIFhwID0gKCkgPT4gdWYsIHZ0ID0gKGUsIHQpID0+IFlyKGUsIHQpLCBHdCA9IFhwLCBMaSA9IChlKSA9PiBZcihlLCB1ZiksIGVfID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IG5fKHQsIGUpKSwgdF8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gdnQodCwgZSkpLCBuXyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGlmIChKZShlKSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKEplKHQpKVxuICAgIHJldHVybiBlO1xuICB7XG4gICAgY29uc3QgbiA9IFlyKHQuaGVhZCwgZSk7XG4gICAgbGV0IHIgPSBuLCBzID0gdC50YWlsO1xuICAgIGZvciAoOyAhSmUocyk7ICkge1xuICAgICAgY29uc3QgYyA9IFlyKHMuaGVhZCwgZSk7XG4gICAgICByLnRhaWwgPSBjLCByID0gYywgcyA9IHMudGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbn0pLCByXyA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiB7XG4gIGxldCByID0gdCwgcyA9IGU7XG4gIGZvciAoOyAhSmUocyk7IClcbiAgICByID0gbihyLCBzLmhlYWQpLCBzID0gcy50YWlsO1xuICByZXR1cm4gcjtcbn0pLCBzXyA9IChlKSA9PiB7XG4gIGxldCB0ID0gR3QoKSwgbiA9IGU7XG4gIGZvciAoOyAhSmUobik7IClcbiAgICB0ID0gdF8odCwgbi5oZWFkKSwgbiA9IG4udGFpbDtcbiAgcmV0dXJuIHQ7XG59LCBEaSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdCAmJiBPYmplY3QuYXNzaWduKHRoaXMsIHQpO1xuICB9XG4gIHJldHVybiBlLnByb3RvdHlwZSA9IE9zLCBlO1xufSgpLCBJRSA9IChlKSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT3MpLCBlKSwgY18gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9EaWZmZXJDb250ZXh0UGF0Y2hcIik7XG5mdW5jdGlvbiBRbyhlKSB7XG4gIHJldHVybiBlO1xufVxuY29uc3QgY3IgPSB7XG4gIC4uLkRpLnByb3RvdHlwZSxcbiAgW2NfXToge1xuICAgIF9WYWx1ZTogUW8sXG4gICAgX1BhdGNoOiBRb1xuICB9XG59LCBpXyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKGNyKSwge1xuICBfdGFnOiBcIkVtcHR5XCJcbn0pLCBvXyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKGlfKSwgZmYgPSAoKSA9PiBvXywgYV8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShjciksIHtcbiAgX3RhZzogXCJBbmRUaGVuXCJcbn0pLCB1XyA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKGFfKTtcbiAgcmV0dXJuIG4uZmlyc3QgPSBlLCBuLnNlY29uZCA9IHQsIG47XG59LCBsXyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKGNyKSwge1xuICBfdGFnOiBcIkFkZFNlcnZpY2VcIlxufSksIGZfID0gKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IE9iamVjdC5jcmVhdGUobF8pO1xuICByZXR1cm4gbi5rZXkgPSBlLCBuLnNlcnZpY2UgPSB0LCBuO1xufSwgaF8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShjciksIHtcbiAgX3RhZzogXCJSZW1vdmVTZXJ2aWNlXCJcbn0pLCBkXyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBPYmplY3QuY3JlYXRlKGhfKTtcbiAgcmV0dXJuIHQua2V5ID0gZSwgdDtcbn0sIGdfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoY3IpLCB7XG4gIF90YWc6IFwiVXBkYXRlU2VydmljZVwiXG59KSwgbV8gPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShnXyk7XG4gIHJldHVybiBuLmtleSA9IGUsIG4udXBkYXRlID0gdCwgbjtcbn0sIHBfID0gKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IG5ldyBNYXAoZS51bnNhZmVNYXApO1xuICBsZXQgciA9IGZmKCk7XG4gIGZvciAoY29uc3QgW3MsIGNdIG9mIHQudW5zYWZlTWFwLmVudHJpZXMoKSlcbiAgICBpZiAobi5oYXMocykpIHtcbiAgICAgIGNvbnN0IGkgPSBuLmdldChzKTtcbiAgICAgIG4uZGVsZXRlKHMpLCBPKGksIGMpIHx8IChyID0gUHIobV8ocywgKCkgPT4gYykpKHIpKTtcbiAgICB9IGVsc2VcbiAgICAgIG4uZGVsZXRlKHMpLCByID0gUHIoZl8ocywgYykpKHIpO1xuICBmb3IgKGNvbnN0IFtzXSBvZiBuLmVudHJpZXMoKSlcbiAgICByID0gUHIoZF8ocykpKHIpO1xuICByZXR1cm4gcjtcbn0sIFByID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHVfKGUsIHQpKSwgX18gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBpZiAoZS5fdGFnID09PSBcIkVtcHR5XCIpXG4gICAgcmV0dXJuIHQ7XG4gIGxldCBuID0gITEsIHIgPSBpZShlKTtcbiAgY29uc3QgcyA9IG5ldyBNYXAodC51bnNhZmVNYXApO1xuICBmb3IgKDsgSGUocik7ICkge1xuICAgIGNvbnN0IGkgPSBDZShyKSwgbyA9IFZlKHIpO1xuICAgIHN3aXRjaCAoaS5fdGFnKSB7XG4gICAgICBjYXNlIFwiRW1wdHlcIjoge1xuICAgICAgICByID0gbztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiQWRkU2VydmljZVwiOiB7XG4gICAgICAgIHMuc2V0KGkua2V5LCBpLnNlcnZpY2UpLCByID0gbztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiQW5kVGhlblwiOiB7XG4gICAgICAgIHIgPSBiZShiZShvLCBpLnNlY29uZCksIGkuZmlyc3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJSZW1vdmVTZXJ2aWNlXCI6IHtcbiAgICAgICAgcy5kZWxldGUoaS5rZXkpLCByID0gbztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiVXBkYXRlU2VydmljZVwiOiB7XG4gICAgICAgIHMuc2V0KGkua2V5LCBpLnVwZGF0ZShzLmdldChpLmtleSkpKSwgbiA9ICEwLCByID0gbztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghbilcbiAgICByZXR1cm4gVnQocyk7XG4gIGNvbnN0IGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IFtpXSBvZiB0LnVuc2FmZU1hcClcbiAgICBzLmhhcyhpKSAmJiAoYy5zZXQoaSwgcy5nZXQoaSkpLCBzLmRlbGV0ZShpKSk7XG4gIGZvciAoY29uc3QgW2ksIG9dIG9mIHMpXG4gICAgYy5zZXQoaSwgbyk7XG4gIHJldHVybiBWdChjKTtcbn0pLCB5XyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0RpZmZlckhhc2hTZXRQYXRjaFwiKTtcbmZ1bmN0aW9uIGxjKGUpIHtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBMcyA9IHtcbiAgLi4uRGkucHJvdG90eXBlLFxuICBbeV9dOiB7XG4gICAgX1ZhbHVlOiBsYyxcbiAgICBfS2V5OiBsYyxcbiAgICBfUGF0Y2g6IGxjXG4gIH1cbn0sIGJfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoTHMpLCB7XG4gIF90YWc6IFwiRW1wdHlcIlxufSksIFNfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoYl8pLCBoZiA9ICgpID0+IFNfLCBrXyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKExzKSwge1xuICBfdGFnOiBcIkFuZFRoZW5cIlxufSksIHZfID0gKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IE9iamVjdC5jcmVhdGUoa18pO1xuICByZXR1cm4gbi5maXJzdCA9IGUsIG4uc2Vjb25kID0gdCwgbjtcbn0sIHdfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoTHMpLCB7XG4gIF90YWc6IFwiQWRkXCJcbn0pLCBPXyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBPYmplY3QuY3JlYXRlKHdfKTtcbiAgcmV0dXJuIHQudmFsdWUgPSBlLCB0O1xufSwgJF8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShMcyksIHtcbiAgX3RhZzogXCJSZW1vdmVcIlxufSksIEVfID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUoJF8pO1xuICByZXR1cm4gdC52YWx1ZSA9IGUsIHQ7XG59LCBJXyA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IFtuLCByXSA9IHFuKFtlLCBoZigpXSwgKFtzLCBjXSwgaSkgPT4gQ3AoaSkocykgPyBbWGwoaSkocyksIGNdIDogW3MsIFBjKE9fKGkpKShjKV0pKHQpO1xuICByZXR1cm4gcW4ociwgKHMsIGMpID0+IFBjKEVfKGMpKShzKSkobik7XG59LCBQYyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB2XyhlLCB0KSksIEZfID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgaWYgKGUuX3RhZyA9PT0gXCJFbXB0eVwiKVxuICAgIHJldHVybiB0O1xuICBsZXQgbiA9IHQsIHIgPSBpZShlKTtcbiAgZm9yICg7IEhlKHIpOyApIHtcbiAgICBjb25zdCBzID0gQ2UociksIGMgPSBWZShyKTtcbiAgICBzd2l0Y2ggKHMuX3RhZykge1xuICAgICAgY2FzZSBcIkVtcHR5XCI6IHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkFuZFRoZW5cIjoge1xuICAgICAgICByID0gYmUocy5maXJzdCkoYmUocy5zZWNvbmQpKGMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiQWRkXCI6IHtcbiAgICAgICAgbiA9IENuKHMudmFsdWUpKG4pLCByID0gYztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiUmVtb3ZlXCI6XG4gICAgICAgIG4gPSBYbChzLnZhbHVlKShuKSwgciA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiBuO1xufSksIFJfID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRGlmZmVyUmVhZG9ubHlBcnJheVBhdGNoXCIpO1xuZnVuY3Rpb24gWm8oZSkge1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IGlyID0ge1xuICAuLi5EaS5wcm90b3R5cGUsXG4gIFtSX106IHtcbiAgICBfVmFsdWU6IFpvLFxuICAgIF9QYXRjaDogWm9cbiAgfVxufSwgTV8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShpciksIHtcbiAgX3RhZzogXCJFbXB0eVwiXG59KSwgVF8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShNXyksIGRmID0gKCkgPT4gVF8sIENfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoaXIpLCB7XG4gIF90YWc6IFwiQW5kVGhlblwiXG59KSwgTl8gPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShDXyk7XG4gIHJldHVybiBuLmZpcnN0ID0gZSwgbi5zZWNvbmQgPSB0LCBuO1xufSwgQV8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShpciksIHtcbiAgX3RhZzogXCJBcHBlbmRcIlxufSksIFBfID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5jcmVhdGUoQV8pO1xuICByZXR1cm4gdC52YWx1ZXMgPSBlLCB0O1xufSwgeF8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShpciksIHtcbiAgX3RhZzogXCJTbGljZVwiXG59KSwgal8gPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZSh4Xyk7XG4gIHJldHVybiBuLmZyb20gPSBlLCBuLnVudGlsID0gdCwgbjtcbn0sIExfID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoaXIpLCB7XG4gIF90YWc6IFwiVXBkYXRlXCJcbn0pLCBEXyA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKExfKTtcbiAgcmV0dXJuIG4uaW5kZXggPSBlLCBuLnBhdGNoID0gdCwgbjtcbn0sIHFfID0gKGUpID0+IHtcbiAgbGV0IHQgPSAwLCBuID0gZGYoKTtcbiAgZm9yICg7IHQgPCBlLm9sZFZhbHVlLmxlbmd0aCAmJiB0IDwgZS5uZXdWYWx1ZS5sZW5ndGg7ICkge1xuICAgIGNvbnN0IHIgPSBlLm9sZFZhbHVlW3RdLCBzID0gZS5uZXdWYWx1ZVt0XSwgYyA9IGUuZGlmZmVyLmRpZmYociwgcyk7XG4gICAgTyhjLCBlLmRpZmZlci5lbXB0eSkgfHwgKG4gPSB4cihuLCBEXyh0LCBjKSkpLCB0ID0gdCArIDE7XG4gIH1cbiAgcmV0dXJuIHQgPCBlLm9sZFZhbHVlLmxlbmd0aCAmJiAobiA9IHhyKG4sIGpfKDAsIHQpKSksIHQgPCBlLm5ld1ZhbHVlLmxlbmd0aCAmJiAobiA9IHhyKG4sIFBfKEtnKHQpKGUubmV3VmFsdWUpKSkpLCBuO1xufSwgeHIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gTl8oZSwgdCkpLCBVXyA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiB7XG4gIGlmIChlLl90YWcgPT09IFwiRW1wdHlcIilcbiAgICByZXR1cm4gdDtcbiAgbGV0IHIgPSB0LnNsaWNlKCksIHMgPSBrZShlKTtcbiAgZm9yICg7IERnKHMpOyApIHtcbiAgICBjb25zdCBjID0gdWUocyksIGkgPSBfdChzKTtcbiAgICBzd2l0Y2ggKGMuX3RhZykge1xuICAgICAgY2FzZSBcIkVtcHR5XCI6IHtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkFuZFRoZW5cIjoge1xuICAgICAgICBpLnVuc2hpZnQoYy5maXJzdCwgYy5zZWNvbmQpLCBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiQXBwZW5kXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIGMudmFsdWVzKVxuICAgICAgICAgIHIucHVzaChvKTtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlNsaWNlXCI6IHtcbiAgICAgICAgciA9IHIuc2xpY2UoYy5mcm9tLCBjLnVudGlsKSwgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlVwZGF0ZVwiOiB7XG4gICAgICAgIHJbYy5pbmRleF0gPSBuLnBhdGNoKGMucGF0Y2gsIHJbYy5pbmRleF0pLCBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufSksIHpfID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRGlmZmVyXCIpLCBCXyA9IHtcbiAgW3pfXToge1xuICAgIF9QOiBQLFxuICAgIF9WOiBQXG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgZG4gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShCXyk7XG4gIHJldHVybiB0LmVtcHR5ID0gZS5lbXB0eSwgdC5kaWZmID0gZS5kaWZmLCB0LmNvbWJpbmUgPSBlLmNvbWJpbmUsIHQucGF0Y2ggPSBlLnBhdGNoLCB0O1xufSwgVl8gPSAoKSA9PiBkbih7XG4gIGVtcHR5OiBmZigpLFxuICBjb21iaW5lOiAoZSwgdCkgPT4gUHIodCkoZSksXG4gIGRpZmY6IChlLCB0KSA9PiBwXyhlLCB0KSxcbiAgcGF0Y2g6IChlLCB0KSA9PiBfXyh0KShlKVxufSksIEtfID0gKCkgPT4gZG4oe1xuICBlbXB0eTogaGYoKSxcbiAgY29tYmluZTogKGUsIHQpID0+IFBjKHQpKGUpLFxuICBkaWZmOiAoZSwgdCkgPT4gSV8oZSwgdCksXG4gIHBhdGNoOiAoZSwgdCkgPT4gRl8odCkoZSlcbn0pLCBXXyA9IChlKSA9PiBkbih7XG4gIGVtcHR5OiBkZigpLFxuICBjb21iaW5lOiAodCwgbikgPT4geHIodCwgbiksXG4gIGRpZmY6ICh0LCBuKSA9PiBxXyh7XG4gICAgb2xkVmFsdWU6IHQsXG4gICAgbmV3VmFsdWU6IG4sXG4gICAgZGlmZmVyOiBlXG4gIH0pLFxuICBwYXRjaDogKHQsIG4pID0+IFVfKHQsIG4sIGUpXG59KSwgZ2YgPSAoKSA9PiBKXygoZSwgdCkgPT4gdCksIEpfID0gKGUpID0+IGRuKHtcbiAgZW1wdHk6IFAsXG4gIGNvbWJpbmU6ICh0LCBuKSA9PiB0ID09PSBQID8gbiA6IG4gPT09IFAgPyB0IDogKHIpID0+IG4odChyKSksXG4gIGRpZmY6ICh0LCBuKSA9PiBPKHQsIG4pID8gUCA6IFFuKG4pLFxuICBwYXRjaDogKHQsIG4pID0+IGUobiwgdChuKSlcbn0pLCB6biA9IDI1NSwgbWYgPSA4LCB4YyA9IChlKSA9PiBlICYgem4sIGpjID0gKGUpID0+IGUgPj4gbWYgJiB6biwgb3IgPSAoZSwgdCkgPT4gKGUgJiB6bikgKyAoKHQgJiBlICYgem4pIDw8IG1mKSwgSF8gPSAvKiBAX19QVVJFX18gKi8gb3IoMCwgMCksIEdfID0gKGUpID0+IG9yKGUsIGUpLCBZXyA9IChlKSA9PiBvcihlLCAwKSwgUV8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gb3IoeGMoZSkgJiB+dCwgamMoZSkpKSwgWl8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZSB8IHQpLCBYXyA9IChlKSA9PiB+ZSA+Pj4gMCAmIHpuLCBleSA9IDAsIGduID0gMSwgdHkgPSAyLCBwZiA9IDQsIExjID0gMTYsIF9mID0gMzIsIG55ID0gKGUpID0+IERzKGUsIF9mKSwgcnkgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZSB8IHQpLCBHZSA9IChlKSA9PiB5ZihlKSAmJiAhY3koZSksIHlmID0gKGUpID0+IERzKGUsIGduKSwgRHMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gKGUgJiB0KSAhPT0gMCksIGJmID0gKC4uLmUpID0+IGUucmVkdWNlKCh0LCBuKSA9PiB0IHwgbiwgMCksIHN5ID0gLyogQF9fUFVSRV9fICovIGJmKGV5KSwgWG8gPSAoZSkgPT4gRHMoZSwgcGYpLCBjeSA9IChlKSA9PiBEcyhlLCBMYyksIGd0ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IG9yKGUgXiB0LCB0KSksIER0ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGUgJiAoWF8oeGModCkpIHwgamModCkpIHwgeGModCkgJiBqYyh0KSksIGVhID0gLyogQF9fUFVSRV9fICovIGRuKHtcbiAgZW1wdHk6IEhfLFxuICBkaWZmOiAoZSwgdCkgPT4gZ3QoZSwgdCksXG4gIGNvbWJpbmU6IChlLCB0KSA9PiBaXyh0KShlKSxcbiAgcGF0Y2g6IChlLCB0KSA9PiBEdCh0LCBlKVxufSksIGl5ID0gR18sIFNmID0gWV8sIHRhID0gUV8sIGtmID0gKGUsIHQpID0+ICh7XG4gIF90YWc6IFwiUGFyXCIsXG4gIGxlZnQ6IGUsXG4gIHJpZ2h0OiB0XG59KSwgRXIgPSAoZSwgdCkgPT4gKHtcbiAgX3RhZzogXCJTZXFcIixcbiAgbGVmdDogZSxcbiAgcmlnaHQ6IHRcbn0pLCBveSA9IChlKSA9PiB7XG4gIGxldCB0ID0gTGkoZSksIG4gPSBHdCgpO1xuICBmb3IgKDsgOyApIHtcbiAgICBjb25zdCBbciwgc10gPSByXyh0LCBbdmYoKSwgR3QoKV0sIChbYywgaV0sIG8pID0+IHtcbiAgICAgIGNvbnN0IFthLCBoXSA9IGF5KG8pO1xuICAgICAgcmV0dXJuIFtkeShjLCBhKSwgZV8oaSwgaCldO1xuICAgIH0pO1xuICAgIGlmIChuID0gdXkobiwgciksIEplKHMpKVxuICAgICAgcmV0dXJuIHNfKG4pO1xuICAgIHQgPSBzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkJVRzogQmxvY2tlZFJlcXVlc3RzLmZsYXR0ZW4gLSBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9FZmZlY3QtVFMvZWZmZWN0L2lzc3Vlc1wiKTtcbn0sIGF5ID0gKGUpID0+IHtcbiAgbGV0IHQgPSBlLCBuID0gdmYoKSwgciA9IEd0KCksIHMgPSBHdCgpO1xuICBmb3IgKDsgOyApXG4gICAgc3dpdGNoICh0Ll90YWcpIHtcbiAgICAgIGNhc2UgXCJFbXB0eVwiOiB7XG4gICAgICAgIGlmIChKZShyKSlcbiAgICAgICAgICByZXR1cm4gW24sIHNdO1xuICAgICAgICB0ID0gci5oZWFkLCByID0gci50YWlsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJQYXJcIjoge1xuICAgICAgICByID0gdnQodC5yaWdodCwgciksIHQgPSB0LmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlNlcVwiOiB7XG4gICAgICAgIGNvbnN0IGMgPSB0LmxlZnQsIGkgPSB0LnJpZ2h0O1xuICAgICAgICBzd2l0Y2ggKGMuX3RhZykge1xuICAgICAgICAgIGNhc2UgXCJFbXB0eVwiOiB7XG4gICAgICAgICAgICB0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiUGFyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBjLmxlZnQsIGEgPSBjLnJpZ2h0O1xuICAgICAgICAgICAgdCA9IGtmKEVyKG8sIGkpLCBFcihhLCBpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlNlcVwiOiB7XG4gICAgICAgICAgICBjb25zdCBvID0gYy5sZWZ0LCBhID0gYy5yaWdodDtcbiAgICAgICAgICAgIHQgPSBFcihvLCBFcihhLCBpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlNpbmdsZVwiOiB7XG4gICAgICAgICAgICB0ID0gYywgcyA9IHZ0KGksIHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlNpbmdsZVwiOiB7XG4gICAgICAgIGlmIChuID0gaHkobiwgdCksIEplKHIpKVxuICAgICAgICAgIHJldHVybiBbbiwgc107XG4gICAgICAgIHQgPSByLmhlYWQsIHIgPSByLnRhaWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBCbG9ja2VkUmVxdWVzdHMuc3RlcCAtIHBsZWFzZSByZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL0VmZmVjdC1UUy9lZmZlY3QvaXNzdWVzXCIpO1xufSwgdXkgPSAoZSwgdCkgPT4ge1xuICBpZiAoSmUoZSkpXG4gICAgcmV0dXJuIExpKGZjKHQpKTtcbiAgaWYgKGd5KHQpKVxuICAgIHJldHVybiBlO1xuICBjb25zdCBuID0gU3koZS5oZWFkKSwgciA9IG15KHQpO1xuICByZXR1cm4gbi5sZW5ndGggPT09IDEgJiYgci5sZW5ndGggPT09IDEgJiYgTyhuWzBdLCByWzBdKSA/IHZ0KGJ5KGUuaGVhZCwgZmModCkpLCBlLnRhaWwpIDogdnQoZmModCksIGUpO1xufSwgbHkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9SZXF1ZXN0QmxvY2svUmVxdWVzdEJsb2NrUGFyYWxsZWxcIiksIGZ5ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogKGUpID0+IGVcbn07XG52YXIgdHU7XG50dSA9IGx5O1xuY2xhc3MgcWkge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcIm1hcFwiKTtcbiAgICB1KHRoaXMsIHR1LCBmeSk7XG4gICAgdGhpcy5tYXAgPSB0O1xuICB9XG59XG5jb25zdCB2ZiA9ICgpID0+IG5ldyBxaShqaSgpKSwgaHkgPSAoZSwgdCkgPT4gbmV3IHFpKEtwKGUubWFwLCB0LmRhdGFTb3VyY2UsIChuKSA9PiBJZyhOcihuLCBNbSh0LmJsb2NrZWRSZXF1ZXN0KSksICgpID0+IGllKHQuYmxvY2tlZFJlcXVlc3QpKSkpLCBkeSA9IChlLCB0KSA9PiBuZXcgcWkoYWYoZS5tYXAsIHQubWFwLCAobiwgciwgcykgPT4gY2YobiwgcywgdHQoc2YobiwgcyksIHtcbiAgb25Ob25lOiAoKSA9PiByLFxuICBvblNvbWU6IChjKSA9PiB2ZShyLCBjKVxufSkpKSksIGd5ID0gKGUpID0+IFZwKGUubWFwKSwgbXkgPSAoZSkgPT4gQXJyYXkuZnJvbShvZihlLm1hcCkpLCBmYyA9IChlKSA9PiB5eShXcChlLm1hcCwgKHQpID0+IGllKHQpKSksIHB5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvUmVxdWVzdEJsb2NrL1JlcXVlc3RCbG9ja1NlcXVlbnRpYWxcIiksIF95ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogKGUpID0+IGVcbn07XG52YXIgbnU7XG5udSA9IHB5O1xuY2xhc3Mgd2Yge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcIm1hcFwiKTtcbiAgICB1KHRoaXMsIG51LCBfeSk7XG4gICAgdGhpcy5tYXAgPSB0O1xuICB9XG59XG5jb25zdCB5eSA9IChlKSA9PiBuZXcgd2YoZSksIGJ5ID0gKGUsIHQpID0+IG5ldyB3ZihhZih0Lm1hcCwgZS5tYXAsIChuLCByLCBzKSA9PiBjZihuLCBzLCB0dChzZihuLCBzKSwge1xuICBvbk5vbmU6ICgpID0+IEFlKCksXG4gIG9uU29tZTogKGMpID0+IHZlKGMsIHIpXG59KSkpKSwgU3kgPSAoZSkgPT4gQXJyYXkuZnJvbShvZihlLm1hcCkpLCBreSA9IChlKSA9PiBBcnJheS5mcm9tKGUubWFwKSwgbW4gPSBcIkRpZVwiLCB3dCA9IFwiRW1wdHlcIiwgRnQgPSBcIkZhaWxcIiwgcG4gPSBcIkludGVycnVwdFwiLCBZdCA9IFwiUGFyYWxsZWxcIiwgUXQgPSBcIlNlcXVlbnRpYWxcIiwgT2YgPSBcImVmZmVjdC9DYXVzZVwiLCAkZiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKE9mKSwgdnkgPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9FOiAoZSkgPT4gZVxufSwgX24gPSB7XG4gIFskZl06IHZ5LFxuICBbRl0oKSB7XG4gICAgcmV0dXJuIGYoayhPZiksIFIoayhqeSh0aGlzKSkpLCBxKHRoaXMpKTtcbiAgfSxcbiAgW0VdKGUpIHtcbiAgICByZXR1cm4gd3koZSkgJiYgeHkodGhpcywgZSk7XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlIFwiRW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfaWQ6IFwiQ2F1c2VcIixcbiAgICAgICAgICBfdGFnOiB0aGlzLl90YWdcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJEaWVcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfaWQ6IFwiQ2F1c2VcIixcbiAgICAgICAgICBfdGFnOiB0aGlzLl90YWcsXG4gICAgICAgICAgZGVmZWN0OiBWKHRoaXMuZGVmZWN0KVxuICAgICAgICB9O1xuICAgICAgY2FzZSBcIkludGVycnVwdFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9pZDogXCJDYXVzZVwiLFxuICAgICAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgICAgICBmaWJlcklkOiB0aGlzLmZpYmVySWQudG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJGYWlsXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgX2lkOiBcIkNhdXNlXCIsXG4gICAgICAgICAgX3RhZzogdGhpcy5fdGFnLFxuICAgICAgICAgIGZhaWx1cmU6IFYodGhpcy5lcnJvcilcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJTZXF1ZW50aWFsXCI6XG4gICAgICBjYXNlIFwiUGFyYWxsZWxcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfaWQ6IFwiQ2F1c2VcIixcbiAgICAgICAgICBfdGFnOiB0aGlzLl90YWcsXG4gICAgICAgICAgbGVmdDogVih0aGlzLmxlZnQpLFxuICAgICAgICAgIHJpZ2h0OiBWKHRoaXMucmlnaHQpXG4gICAgICAgIH07XG4gICAgfVxuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYXIodGhpcyk7XG4gIH0sXG4gIFtVXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfVxufSwgWnQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKF9uKTtcbiAgcmV0dXJuIGUuX3RhZyA9IHd0LCBlO1xufSkoKSwgQm4gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShfbik7XG4gIHJldHVybiB0Ll90YWcgPSBGdCwgdC5lcnJvciA9IGUsIHQ7XG59LCBPZSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBPYmplY3QuY3JlYXRlKF9uKTtcbiAgcmV0dXJuIHQuX3RhZyA9IG1uLCB0LmRlZmVjdCA9IGUsIHQ7XG59LCBUZSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBPYmplY3QuY3JlYXRlKF9uKTtcbiAgcmV0dXJuIHQuX3RhZyA9IHBuLCB0LmZpYmVySWQgPSBlLCB0O1xufSwgT3QgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShfbik7XG4gIHJldHVybiBuLl90YWcgPSBZdCwgbi5sZWZ0ID0gZSwgbi5yaWdodCA9IHQsIG47XG59LCBzZSA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKF9uKTtcbiAgcmV0dXJuIG4uX3RhZyA9IFF0LCBuLmxlZnQgPSBlLCBuLnJpZ2h0ID0gdCwgbjtcbn0sIHd5ID0gKGUpID0+ICQoZSwgJGYpLCBPeSA9IChlKSA9PiBlLl90YWcgPT09IHd0LCBGRSA9IChlKSA9PiBlLl90YWcgPT09IEZ0LCAkeSA9IChlKSA9PiBlLl90YWcgPT09IG1uLCBFeSA9IChlKSA9PiBlLl90YWcgPT09IHd0ID8gITAgOiBYdChlLCAhMCwgKHQsIG4pID0+IHtcbiAgc3dpdGNoIChuLl90YWcpIHtcbiAgICBjYXNlIHd0OlxuICAgICAgcmV0dXJuIEkodCk7XG4gICAgY2FzZSBtbjpcbiAgICBjYXNlIEZ0OlxuICAgIGNhc2UgcG46XG4gICAgICByZXR1cm4gSSghMSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2KCk7XG4gIH1cbn0pLCBJeSA9IChlKSA9PiB5ZShOeShlKSksIFVpID0gKGUpID0+IFZpKHZvaWQgMCwgRHkpKGUpLCBGeSA9IChlKSA9PiB5dChYdChlLCBBZSgpLCAodCwgbikgPT4gbi5fdGFnID09PSBGdCA/IEkoZih0LCBiZShuLmVycm9yKSkpIDogdigpKSksIFJ5ID0gKGUpID0+IHl0KFh0KGUsIEFlKCksICh0LCBuKSA9PiBuLl90YWcgPT09IG1uID8gSShmKHQsIGJlKG4uZGVmZWN0KSkpIDogdigpKSksIE15ID0gKGUpID0+IFh0KGUsIFN0KCksICh0LCBuKSA9PiBuLl90YWcgPT09IHBuID8gSShmKHQsIENuKG4uZmliZXJJZCkpKSA6IHYoKSksIFR5ID0gKGUpID0+IHppKGUsICh0KSA9PiB0Ll90YWcgPT09IEZ0ID8gSSh0LmVycm9yKSA6IHYoKSksIEN5ID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IFR5KGUpO1xuICBzd2l0Y2ggKHQuX3RhZykge1xuICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICByZXR1cm4gYWUoZSk7XG4gICAgY2FzZSBcIlNvbWVcIjpcbiAgICAgIHJldHVybiAkZSh0LnZhbHVlKTtcbiAgfVxufSwgTnkgPSAoZSkgPT4gemkoZSwgKHQpID0+IHQuX3RhZyA9PT0gcG4gPyBJKHQuZmliZXJJZCkgOiB2KCkpLCBuYSA9IChlKSA9PiBCaShlLCB7XG4gIG9uRW1wdHk6IFp0LFxuICBvbkZhaWw6ICgpID0+IFp0LFxuICBvbkRpZTogT2UsXG4gIG9uSW50ZXJydXB0OiBUZSxcbiAgb25TZXF1ZW50aWFsOiBzZSxcbiAgb25QYXJhbGxlbDogT3Rcbn0pLCBBeSA9IChlKSA9PiBCaShlLCB7XG4gIG9uRW1wdHk6IFp0LFxuICBvbkZhaWw6IE9lLFxuICBvbkRpZTogT2UsXG4gIG9uSW50ZXJydXB0OiBUZSxcbiAgb25TZXF1ZW50aWFsOiBzZSxcbiAgb25QYXJhbGxlbDogT3Rcbn0pLCBSRSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBQeShlLCAobikgPT4gQm4odChuKSkpKSwgUHkgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gQmkoZSwge1xuICBvbkVtcHR5OiBadCxcbiAgb25GYWlsOiAobikgPT4gdChuKSxcbiAgb25EaWU6IChuKSA9PiBPZShuKSxcbiAgb25JbnRlcnJ1cHQ6IChuKSA9PiBUZShuKSxcbiAgb25TZXF1ZW50aWFsOiAobiwgcikgPT4gc2UobiwgciksXG4gIG9uUGFyYWxsZWw6IChuLCByKSA9PiBPdChuLCByKVxufSkpLCB4eSA9IChlLCB0KSA9PiB7XG4gIGxldCBuID0gaWUoZSksIHIgPSBpZSh0KTtcbiAgZm9yICg7IEhlKG4pICYmIEhlKHIpOyApIHtcbiAgICBjb25zdCBbcywgY10gPSBmKENlKG4pLCBYdChbU3QoKSwgQWUoKV0sIChbYSwgaF0sIGQpID0+IHtcbiAgICAgIGNvbnN0IFtnLCBwXSA9IERjKGQpO1xuICAgICAgcmV0dXJuIEkoW2YoYSwgRG4oZykpLCBmKGgsIHZlKHApKV0pO1xuICAgIH0pKSwgW2ksIG9dID0gZihDZShyKSwgWHQoW1N0KCksIEFlKCldLCAoW2EsIGhdLCBkKSA9PiB7XG4gICAgICBjb25zdCBbZywgcF0gPSBEYyhkKTtcbiAgICAgIHJldHVybiBJKFtmKGEsIERuKGcpKSwgZihoLCB2ZShwKSldKTtcbiAgICB9KSk7XG4gICAgaWYgKCFPKHMsIGkpKVxuICAgICAgcmV0dXJuICExO1xuICAgIG4gPSBjLCByID0gbztcbiAgfVxuICByZXR1cm4gITA7XG59LCBqeSA9IChlKSA9PiBMeShpZShlKSwgQWUoKSksIEx5ID0gKGUsIHQpID0+IHtcbiAgZm9yICg7IDsgKSB7XG4gICAgY29uc3QgW24sIHJdID0gZihlLCBraShbU3QoKSwgQWUoKV0sIChbYywgaV0sIG8pID0+IHtcbiAgICAgIGNvbnN0IFthLCBoXSA9IERjKG8pO1xuICAgICAgcmV0dXJuIFtmKGMsIERuKGEpKSwgZihpLCB2ZShoKSldO1xuICAgIH0pKSwgcyA9IFpsKG4pID4gMCA/IGYodCwgYmUobikpIDogdDtcbiAgICBpZiAoVG0ocikpXG4gICAgICByZXR1cm4geXQocyk7XG4gICAgZSA9IHIsIHQgPSBzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihrcyhcIkNhdXNlLmZsYXR0ZW5DYXVzZUxvb3BcIikpO1xufSwgemkgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gW2VdO1xuICBmb3IgKDsgbi5sZW5ndGggPiAwOyApIHtcbiAgICBjb25zdCByID0gbi5wb3AoKSwgcyA9IHQocik7XG4gICAgc3dpdGNoIChzLl90YWcpIHtcbiAgICAgIGNhc2UgXCJOb25lXCI6IHtcbiAgICAgICAgc3dpdGNoIChyLl90YWcpIHtcbiAgICAgICAgICBjYXNlIFF0OlxuICAgICAgICAgIGNhc2UgWXQ6IHtcbiAgICAgICAgICAgIG4ucHVzaChyLnJpZ2h0KSwgbi5wdXNoKHIubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiU29tZVwiOlxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHYoKTtcbn0pLCBEYyA9IChlKSA9PiB7XG4gIGxldCB0ID0gZTtcbiAgY29uc3QgbiA9IFtdO1xuICBsZXQgciA9IFN0KCksIHMgPSBBZSgpO1xuICBmb3IgKDsgdCAhPT0gdm9pZCAwOyApXG4gICAgc3dpdGNoICh0Ll90YWcpIHtcbiAgICAgIGNhc2Ugd3Q6IHtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiBbciwgc107XG4gICAgICAgIHQgPSBuLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgRnQ6IHtcbiAgICAgICAgaWYgKHIgPSBDbihyLCBhYyh0Ll90YWcsIHQuZXJyb3IpKSwgbi5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIFtyLCBzXTtcbiAgICAgICAgdCA9IG4ucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBtbjoge1xuICAgICAgICBpZiAociA9IENuKHIsIGFjKHQuX3RhZywgdC5kZWZlY3QpKSwgbi5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIFtyLCBzXTtcbiAgICAgICAgdCA9IG4ucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBwbjoge1xuICAgICAgICBpZiAociA9IENuKHIsIGFjKHQuX3RhZywgdC5maWJlcklkKSksIG4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiBbciwgc107XG4gICAgICAgIHQgPSBuLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUXQ6IHtcbiAgICAgICAgc3dpdGNoICh0LmxlZnQuX3RhZykge1xuICAgICAgICAgIGNhc2Ugd3Q6IHtcbiAgICAgICAgICAgIHQgPSB0LnJpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUXQ6IHtcbiAgICAgICAgICAgIHQgPSBzZSh0LmxlZnQubGVmdCwgc2UodC5sZWZ0LnJpZ2h0LCB0LnJpZ2h0KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBZdDoge1xuICAgICAgICAgICAgdCA9IE90KHNlKHQubGVmdC5sZWZ0LCB0LnJpZ2h0KSwgc2UodC5sZWZ0LnJpZ2h0LCB0LnJpZ2h0KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcyA9IGJlKHMsIHQucmlnaHQpLCB0ID0gdC5sZWZ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBZdDoge1xuICAgICAgICBuLnB1c2godC5yaWdodCksIHQgPSB0LmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgdGhyb3cgbmV3IEVycm9yKGtzKFwiQ2F1c2UuZXZhbHVhdGVDYXVzZUxvb3BcIikpO1xufSwgRHkgPSB7XG4gIGVtcHR5Q2FzZTogTG8sXG4gIGZhaWxDYXNlOiBiYyxcbiAgZGllQ2FzZTogYmMsXG4gIGludGVycnVwdENhc2U6IExvLFxuICBzZXF1ZW50aWFsQ2FzZTogKGUsIHQsIG4pID0+IHQgJiYgbixcbiAgcGFyYWxsZWxDYXNlOiAoZSwgdCwgbikgPT4gdCAmJiBuXG59LCByYSA9IFwiU2VxdWVudGlhbENhc2VcIiwgc2EgPSBcIlBhcmFsbGVsQ2FzZVwiLCBCaSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB7XG4gIG9uRGllOiB0LFxuICBvbkVtcHR5OiBuLFxuICBvbkZhaWw6IHIsXG4gIG9uSW50ZXJydXB0OiBzLFxuICBvblBhcmFsbGVsOiBjLFxuICBvblNlcXVlbnRpYWw6IGlcbn0pID0+IFZpKGUsIHZvaWQgMCwge1xuICBlbXB0eUNhc2U6ICgpID0+IG4sXG4gIGZhaWxDYXNlOiAobywgYSkgPT4gcihhKSxcbiAgZGllQ2FzZTogKG8sIGEpID0+IHQoYSksXG4gIGludGVycnVwdENhc2U6IChvLCBhKSA9PiBzKGEpLFxuICBzZXF1ZW50aWFsQ2FzZTogKG8sIGEsIGgpID0+IGkoYSwgaCksXG4gIHBhcmFsbGVsQ2FzZTogKG8sIGEsIGgpID0+IGMoYSwgaClcbn0pKSwgWHQgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4ge1xuICBsZXQgciA9IHQsIHMgPSBlO1xuICBjb25zdCBjID0gW107XG4gIGZvciAoOyBzICE9PSB2b2lkIDA7ICkge1xuICAgIGNvbnN0IGkgPSBuKHIsIHMpO1xuICAgIHN3aXRjaCAociA9IHllKGkpID8gaS52YWx1ZSA6IHIsIHMuX3RhZykge1xuICAgICAgY2FzZSBRdDoge1xuICAgICAgICBjLnB1c2gocy5yaWdodCksIHMgPSBzLmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBZdDoge1xuICAgICAgICBjLnB1c2gocy5yaWdodCksIHMgPSBzLmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBzID0gdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcyA9PT0gdm9pZCAwICYmIGMubGVuZ3RoID4gMCAmJiAocyA9IGMucG9wKCkpO1xuICB9XG4gIHJldHVybiByO1xufSksIFZpID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IFtlXSwgcyA9IFtdO1xuICBmb3IgKDsgci5sZW5ndGggPiAwOyApIHtcbiAgICBjb25zdCBpID0gci5wb3AoKTtcbiAgICBzd2l0Y2ggKGkuX3RhZykge1xuICAgICAgY2FzZSB3dDoge1xuICAgICAgICBzLnB1c2goYWUobi5lbXB0eUNhc2UodCkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEZ0OiB7XG4gICAgICAgIHMucHVzaChhZShuLmZhaWxDYXNlKHQsIGkuZXJyb3IpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBtbjoge1xuICAgICAgICBzLnB1c2goYWUobi5kaWVDYXNlKHQsIGkuZGVmZWN0KSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgcG46IHtcbiAgICAgICAgcy5wdXNoKGFlKG4uaW50ZXJydXB0Q2FzZSh0LCBpLmZpYmVySWQpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBRdDoge1xuICAgICAgICByLnB1c2goaS5yaWdodCksIHIucHVzaChpLmxlZnQpLCBzLnB1c2goJGUoe1xuICAgICAgICAgIF90YWc6IHJhXG4gICAgICAgIH0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFl0OiB7XG4gICAgICAgIHIucHVzaChpLnJpZ2h0KSwgci5wdXNoKGkubGVmdCksIHMucHVzaCgkZSh7XG4gICAgICAgICAgX3RhZzogc2FcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYyA9IFtdO1xuICBmb3IgKDsgcy5sZW5ndGggPiAwOyApIHtcbiAgICBjb25zdCBpID0gcy5wb3AoKTtcbiAgICBzd2l0Y2ggKGkuX3RhZykge1xuICAgICAgY2FzZSBcIkxlZnRcIjoge1xuICAgICAgICBzd2l0Y2ggKGkubGVmdC5fdGFnKSB7XG4gICAgICAgICAgY2FzZSByYToge1xuICAgICAgICAgICAgY29uc3QgbyA9IGMucG9wKCksIGEgPSBjLnBvcCgpLCBoID0gbi5zZXF1ZW50aWFsQ2FzZSh0LCBvLCBhKTtcbiAgICAgICAgICAgIGMucHVzaChoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHNhOiB7XG4gICAgICAgICAgICBjb25zdCBvID0gYy5wb3AoKSwgYSA9IGMucG9wKCksIGggPSBuLnBhcmFsbGVsQ2FzZSh0LCBvLCBhKTtcbiAgICAgICAgICAgIGMucHVzaChoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJSaWdodFwiOiB7XG4gICAgICAgIGMucHVzaChpLnJpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IENhdXNlLnJlZHVjZVdpdGhDb250ZXh0IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNcIik7XG4gIHJldHVybiBjLnBvcCgpO1xufSksIGFyID0gKGUsIHQpID0+IFVpKGUpID8gXCJBbGwgZmliZXJzIGludGVycnVwdGVkIHdpdGhvdXQgZXJyb3JzLlwiIDogSWYoZSkubWFwKGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LnJlbmRlckVycm9yQ2F1c2UpICE9PSAhMCB8fCBuLmNhdXNlID09PSB2b2lkIDAgPyBuLnN0YWNrIDogYCR7bi5zdGFja30ge1xuJHtFZihuLmNhdXNlLCBcIiAgXCIpfVxufWA7XG59KS5qb2luKGBcbmApLCBFZiA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBlLnN0YWNrLnNwbGl0KGBcbmApO1xuICBsZXQgciA9IGAke3R9W2NhdXNlXTogJHtuWzBdfWA7XG4gIGZvciAobGV0IHMgPSAxLCBjID0gbi5sZW5ndGg7IHMgPCBjOyBzKyspXG4gICAgciArPSBgXG4ke3R9JHtuW3NdfWA7XG4gIHJldHVybiBlLmNhdXNlICYmIChyICs9IGAge1xuJHtFZihlLmNhdXNlLCBgJHt0fSAgYCl9XG4ke3R9fWApLCByO1xufTtcbmNsYXNzIFFyIGV4dGVuZHMgZ2xvYmFsVGhpcy5FcnJvciB7XG4gIGNvbnN0cnVjdG9yKG4pIHtcbiAgICBjb25zdCByID0gdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICE9PSBudWxsLCBzID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDE7XG4gICAgc3VwZXIocXkobiksIHIgJiYgXCJjYXVzZVwiIGluIG4gJiYgdHlwZW9mIG4uY2F1c2UgPCBcInVcIiA/IHtcbiAgICAgIGNhdXNlOiBuZXcgUXIobi5jYXVzZSlcbiAgICB9IDogdm9pZCAwKTtcbiAgICB1KHRoaXMsIFwic3BhblwiKTtcbiAgICB0aGlzLm1lc3NhZ2UgPT09IFwiXCIgJiYgKHRoaXMubWVzc2FnZSA9IFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkXCIpLCBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzLCB0aGlzLm5hbWUgPSBuIGluc3RhbmNlb2YgRXJyb3IgPyBuLm5hbWUgOiBcIkVycm9yXCIsIHIgJiYgKGVuIGluIG4gJiYgKHRoaXMuc3BhbiA9IG5bZW5dKSwgT2JqZWN0LmtleXMobikuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgYyBpbiB0aGlzIHx8ICh0aGlzW2NdID0gbltjXSk7XG4gICAgfSkpLCB0aGlzLnN0YWNrID0gQnkoYCR7dGhpcy5uYW1lfTogJHt0aGlzLm1lc3NhZ2V9YCwgbiBpbnN0YW5jZW9mIEVycm9yICYmIG4uc3RhY2sgPyBuLnN0YWNrIDogXCJcIiwgdGhpcy5zcGFuKTtcbiAgfVxufVxuY29uc3QgcXkgPSAoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZTtcbiAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgcmV0dXJuIGUubWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZiAoJChlLCBcInRvU3RyaW5nXCIpICYmIFpuKGUudG9TdHJpbmcpICYmIGUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiYgZS50b1N0cmluZyAhPT0gZ2xvYmFsVGhpcy5BcnJheS5wcm90b3R5cGUudG9TdHJpbmcpXG4gICAgICByZXR1cm4gZS50b1N0cmluZygpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gaWwoZSk7XG59LCBVeSA9IC9cXCgoLiopXFwpL2csIHp5ID0gLyogQF9fUFVSRV9fICovIEMoXCJlZmZlY3QvVHJhY2VyL3NwYW5Ub1RyYWNlXCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKSwgQnkgPSAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gW2VdLCBzID0gdC5zdGFydHNXaXRoKGUpID8gdC5zbGljZShlLmxlbmd0aCkuc3BsaXQoYFxuYCkgOiB0LnNwbGl0KGBcbmApO1xuICBmb3IgKGxldCBjID0gMTsgYyA8IHMubGVuZ3RoICYmICFzW2NdLmluY2x1ZGVzKFwiR2VuZXJhdG9yLm5leHRcIik7IGMrKykge1xuICAgIGlmIChzW2NdLmluY2x1ZGVzKFwiZWZmZWN0X2ludGVybmFsX2Z1bmN0aW9uXCIpKSB7XG4gICAgICByLnBvcCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHIucHVzaChzW2NdLnJlcGxhY2UoL2F0IC4qZWZmZWN0X2luc3RydWN0aW9uX2kuKlxcKCguKilcXCkvLCBcImF0ICQxXCIpLnJlcGxhY2UoL0VmZmVjdFByaW1pdGl2ZVxcLlxcdysvLCBcIjxhbm9ueW1vdXM+XCIpKTtcbiAgfVxuICBpZiAobikge1xuICAgIGxldCBjID0gbiwgaSA9IDA7XG4gICAgZm9yICg7IGMgJiYgYy5fdGFnID09PSBcIlNwYW5cIiAmJiBpIDwgMTA7ICkge1xuICAgICAgY29uc3QgbyA9IHp5LmdldChjKTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgYSA9IG8oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBoID0gYS5tYXRjaEFsbChVeSk7XG4gICAgICAgICAgbGV0IGQgPSAhMTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIGddIG9mIGgpXG4gICAgICAgICAgICBkID0gITAsIHIucHVzaChgICAgIGF0ICR7Yy5uYW1lfSAoJHtnfSlgKTtcbiAgICAgICAgICBkIHx8IHIucHVzaChgICAgIGF0ICR7Yy5uYW1lfSAoJHthLnJlcGxhY2UoL15hdCAvLCBcIlwiKX0pYCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHIucHVzaChgICAgIGF0ICR7Yy5uYW1lfWApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHIucHVzaChgICAgIGF0ICR7Yy5uYW1lfWApO1xuICAgICAgYyA9IGl0KGMucGFyZW50KSwgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gci5qb2luKGBcbmApO1xufSwgZW4gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9TcGFuQW5ub3RhdGlvblwiKSwgSWYgPSAoZSkgPT4gVmkoZSwgdm9pZCAwLCB7XG4gIGVtcHR5Q2FzZTogKCkgPT4gW10sXG4gIGRpZUNhc2U6ICh0LCBuKSA9PiBbbmV3IFFyKG4pXSxcbiAgZmFpbENhc2U6ICh0LCBuKSA9PiBbbmV3IFFyKG4pXSxcbiAgaW50ZXJydXB0Q2FzZTogKCkgPT4gW10sXG4gIHBhcmFsbGVsQ2FzZTogKHQsIG4sIHIpID0+IFsuLi5uLCAuLi5yXSxcbiAgc2VxdWVudGlhbENhc2U6ICh0LCBuLCByKSA9PiBbLi4ubiwgLi4ucl1cbn0pLCB1ciA9IFwiUGVuZGluZ1wiLCBxcyA9IFwiRG9uZVwiLCBWeSA9IFwiZWZmZWN0L0RlZmVycmVkXCIsIEt5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoVnkpLCBXeSA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0U6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfQTogKGUpID0+IGVcbn0sIEp5ID0gKGUpID0+ICh7XG4gIF90YWc6IHVyLFxuICBqb2luZXJzOiBlXG59KSwgRmYgPSAoZSkgPT4gKHtcbiAgX3RhZzogcXMsXG4gIGVmZmVjdDogZVxufSk7XG5jbGFzcyBsciB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwic2VsZlwiKTtcbiAgICB1KHRoaXMsIFwiY2FsbGVkXCIsICExKTtcbiAgICB0aGlzLnNlbGYgPSB0O1xuICB9XG4gIG5leHQodCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxlZCA/IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZG9uZTogITBcbiAgICB9IDogKHRoaXMuY2FsbGVkID0gITAsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnNlbGYsXG4gICAgICBkb25lOiAhMVxuICAgIH0pO1xuICB9XG4gIHJldHVybih0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG4gIHRocm93KHQpIHtcbiAgICB0aHJvdyB0O1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgbHIodGhpcy5zZWxmKTtcbiAgfVxufVxuY29uc3QgUmYgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gbmV3IEooXCJCbG9ja2VkXCIpO1xuICByZXR1cm4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IHQsIG47XG59LCBIeSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgSihcIlJ1bkJsb2NrZWRcIik7XG4gIHJldHVybiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IGUsIHQ7XG59LCB0biA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0VmZmVjdFwiKTtcbmNsYXNzIEd5IHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJwYXRjaFwiKTtcbiAgICB1KHRoaXMsIFwib3BcIik7XG4gICAgdSh0aGlzLCBcIl9vcFwiLCBwaSk7XG4gICAgdGhpcy5wYXRjaCA9IHQsIHRoaXMub3AgPSBuO1xuICB9XG59XG52YXIgcnU7XG5jbGFzcyBKIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHUodGhpcywgXCJfb3BcIik7XG4gICAgdSh0aGlzLCBcImVmZmVjdF9pbnN0cnVjdGlvbl9pMFwiKTtcbiAgICB1KHRoaXMsIFwiZWZmZWN0X2luc3RydWN0aW9uX2kxXCIpO1xuICAgIHUodGhpcywgXCJlZmZlY3RfaW5zdHJ1Y3Rpb25faTJcIik7XG4gICAgdSh0aGlzLCBcInRyYWNlXCIpO1xuICAgIHUodGhpcywgcnUsIHp0KTtcbiAgICB0aGlzLl9vcCA9IHQ7XG4gIH1cbiAgWyhydSA9IHRuLCBFKV0odCkge1xuICAgIHJldHVybiB0aGlzID09PSB0O1xuICB9XG4gIFtGXSgpIHtcbiAgICByZXR1cm4gcSh0aGlzLCBoaSh0aGlzKSk7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkVmZmVjdFwiLFxuICAgICAgX29wOiB0aGlzLl9vcCxcbiAgICAgIGVmZmVjdF9pbnN0cnVjdGlvbl9pMDogVih0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCksXG4gICAgICBlZmZlY3RfaW5zdHJ1Y3Rpb25faTE6IFYodGhpcy5lZmZlY3RfaW5zdHJ1Y3Rpb25faTEpLFxuICAgICAgZWZmZWN0X2luc3RydWN0aW9uX2kyOiBWKHRoaXMuZWZmZWN0X2luc3RydWN0aW9uX2kyKVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcy50b0pTT04oKSk7XG4gIH1cbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgbHIobmV3IFhuKHRoaXMpKTtcbiAgfVxufVxudmFyIHN1O1xuY2xhc3MgTWYge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcIl9vcFwiKTtcbiAgICB1KHRoaXMsIFwiZWZmZWN0X2luc3RydWN0aW9uX2kwXCIpO1xuICAgIHUodGhpcywgXCJlZmZlY3RfaW5zdHJ1Y3Rpb25faTFcIik7XG4gICAgdSh0aGlzLCBcImVmZmVjdF9pbnN0cnVjdGlvbl9pMlwiKTtcbiAgICB1KHRoaXMsIFwidHJhY2VcIik7XG4gICAgdSh0aGlzLCBzdSwgenQpO1xuICAgIHRoaXMuX29wID0gdCwgdGhpcy5fdGFnID0gdDtcbiAgfVxuICBbKHN1ID0gdG4sIEUpXSh0KSB7XG4gICAgcmV0dXJuIGVvKHQpICYmIHQuX29wID09PSBcIkZhaWx1cmVcIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgTyh0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCwgdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICB9XG4gIFtGXSgpIHtcbiAgICByZXR1cm4gZihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIEIodGhpcy5fdGFnKSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIFIoayh0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCkpLFxuICAgICAgcSh0aGlzKVxuICAgICk7XG4gIH1cbiAgZ2V0IGNhdXNlKCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMDtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiRXhpdFwiLFxuICAgICAgX3RhZzogdGhpcy5fb3AsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZS50b0pTT04oKVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcy50b0pTT04oKSk7XG4gIH1cbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgbHIobmV3IFhuKHRoaXMpKTtcbiAgfVxufVxudmFyIGN1O1xuY2xhc3MgVGYge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcIl9vcFwiKTtcbiAgICB1KHRoaXMsIFwiZWZmZWN0X2luc3RydWN0aW9uX2kwXCIpO1xuICAgIHUodGhpcywgXCJlZmZlY3RfaW5zdHJ1Y3Rpb25faTFcIik7XG4gICAgdSh0aGlzLCBcImVmZmVjdF9pbnN0cnVjdGlvbl9pMlwiKTtcbiAgICB1KHRoaXMsIFwidHJhY2VcIik7XG4gICAgdSh0aGlzLCBjdSwgenQpO1xuICAgIHRoaXMuX29wID0gdCwgdGhpcy5fdGFnID0gdDtcbiAgfVxuICBbKGN1ID0gdG4sIEUpXSh0KSB7XG4gICAgcmV0dXJuIGVvKHQpICYmIHQuX29wID09PSBcIlN1Y2Nlc3NcIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgTyh0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCwgdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICB9XG4gIFtGXSgpIHtcbiAgICByZXR1cm4gZihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIEIodGhpcy5fdGFnKSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIFIoayh0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCkpLFxuICAgICAgcSh0aGlzKVxuICAgICk7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMDtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiRXhpdFwiLFxuICAgICAgX3RhZzogdGhpcy5fb3AsXG4gICAgICB2YWx1ZTogVih0aGlzLnZhbHVlKVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcy50b0pTT04oKSk7XG4gIH1cbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgbHIobmV3IFhuKHRoaXMpKTtcbiAgfVxufVxuY29uc3QgTGUgPSAoZSkgPT4gJChlLCB0biksIEwgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gbmV3IEoodWwpO1xuICByZXR1cm4gdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCB0O1xufSwgQ2YgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4gRWUoKHIpID0+IG0oZSwgKHMpID0+IG0oWWUoTigoKSA9PiByKHQocykpKSksIChjKSA9PiBOKCgpID0+IG4ocywgYykpLnBpcGUoU2Uoe1xuICBvbkZhaWx1cmU6IChpKSA9PiB7XG4gICAgc3dpdGNoIChjLl90YWcpIHtcbiAgICAgIGNhc2UgdGU6XG4gICAgICAgIHJldHVybiBaKHNlKGMuZWZmZWN0X2luc3RydWN0aW9uX2kwLCBpKSk7XG4gICAgICBjYXNlIG5lOlxuICAgICAgICByZXR1cm4gWihpKTtcbiAgICB9XG4gIH0sXG4gIG9uU3VjY2VzczogKCkgPT4gY1xufSkpKSkpKSwgZmUgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gbShlLCAoKSA9PiBTKHQpKSksIG50ID0gKGUpID0+IGZlKGUsIHZvaWQgMCksIE5mID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBuZXcgSih3cyk7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMjoge1xuICAgICAgZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBhcmd1bWVudHNbMF0sIGUuY29tbWl0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMzoge1xuICAgICAgZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBhcmd1bWVudHNbMF0sIGUuZWZmZWN0X2luc3RydWN0aW9uX2kxID0gYXJndW1lbnRzWzFdLCBlLmNvbW1pdCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDQ6IHtcbiAgICAgIGUuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gYXJndW1lbnRzWzBdLCBlLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IGFyZ3VtZW50c1sxXSwgZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTIgPSBhcmd1bWVudHNbMl0sIGUuY29tbWl0ID0gYXJndW1lbnRzWzNdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioa3MoXCJ5b3UncmUgbm90IHN1cHBvc2VkIHRvIGVuZCB1cCBoZXJlXCIpKTtcbiAgfVxuICByZXR1cm4gZTtcbn0sIFZuID0gKGUsIHQgPSBIdCkgPT4ge1xuICBjb25zdCBuID0gbmV3IEooUm4pO1xuICBsZXQgcjtcbiAgcmV0dXJuIG4uZWZmZWN0X2luc3RydWN0aW9uX2kwID0gKHMpID0+IHtcbiAgICByID0gZShzKTtcbiAgfSwgbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTEgPSB0LCBEZihuLCAocykgPT4gTGUocikgPyByIDogSyk7XG59LCBBZiA9IChlLCB0ID0gSHQpID0+IE4oKCkgPT4gVm4oZSwgdCkpLCB4ZSA9IChlLCB0ID0gSHQpID0+IE5mKGUsIGZ1bmN0aW9uKCkge1xuICBsZXQgbiwgcjtcbiAgZnVuY3Rpb24gcyhhKSB7XG4gICAgbiA/IG4oYSkgOiByID09PSB2b2lkIDAgJiYgKHIgPSBhKTtcbiAgfVxuICBjb25zdCBjID0gbmV3IEooUm4pO1xuICBjLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IChhKSA9PiB7XG4gICAgbiA9IGEsIHIgJiYgYShyKTtcbiAgfSwgYy5lZmZlY3RfaW5zdHJ1Y3Rpb25faTEgPSB0O1xuICBsZXQgaSwgbztcbiAgcmV0dXJuIHRoaXMuZWZmZWN0X2luc3RydWN0aW9uX2kwLmxlbmd0aCAhPT0gMSA/IChvID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCBpID0gZWUoKCkgPT4gdGhpcy5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAocywgby5zaWduYWwpKSkgOiBpID0gZWUoKCkgPT4gdGhpcy5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAocykpLCBpIHx8IG8gPyBEZihjLCAoYSkgPT4gKG8gJiYgby5hYm9ydCgpLCBpID8/IEspKSA6IGM7XG59KSwgUGYgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gbmV3IEooVHIpO1xuICByZXR1cm4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IHQsIG47XG59KSwgWnIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gWGUoZSwge1xuICBvbkZhaWx1cmU6IHQsXG4gIG9uU3VjY2VzczogU1xufSkpLCBjYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L09yaWdpbmFsQW5ub3RhdGlvblwiKSwgS2kgPSAoZSwgdCkgPT4geWUodCkgPyBuZXcgUHJveHkoZSwge1xuICBoYXMobiwgcikge1xuICAgIHJldHVybiByID09PSBlbiB8fCByID09PSBjYSB8fCByIGluIG47XG4gIH0sXG4gIGdldChuLCByKSB7XG4gICAgcmV0dXJuIHIgPT09IGVuID8gdC52YWx1ZSA6IHIgPT09IGNhID8gZSA6IG5bcl07XG4gIH1cbn0pIDogZSwgWHIgPSAoZSkgPT4gU3MoZSkgJiYgIShlbiBpbiBlKSA/IEwoKHQpID0+IFooT2UoS2koZSwgaW8odCkpKSkpIDogWihPZShlKSksIHFjID0gKGUpID0+IHhmKCgpID0+IE9lKG5ldyBGYihlKSkpLCBubiA9IChlKSA9PiBYZShlLCB7XG4gIG9uRmFpbHVyZTogKHQpID0+IFMoJGUodCkpLFxuICBvblN1Y2Nlc3M6ICh0KSA9PiBTKGFlKHQpKVxufSksIFllID0gKGUpID0+IGpmKGUsIHtcbiAgb25GYWlsdXJlOiBBLFxuICBvblN1Y2Nlc3M6IGpcbn0pLCB4ID0gKGUpID0+IFNzKGUpICYmICEoZW4gaW4gZSkgPyBMKCh0KSA9PiBaKEJuKEtpKGUsIGlvKHQpKSkpKSA6IFooQm4oZSkpLCBVcyA9IChlKSA9PiBtKHkoZSksIHgpLCBaID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBNZih0ZSk7XG4gIHJldHVybiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IGUsIHQ7XG59LCB4ZiA9IChlKSA9PiBtKHkoZSksIFopLCBXaSA9IC8qIEBfX1BVUkVfXyAqLyBMKChlKSA9PiBTKGUuaWQoKSkpLCBmciA9IChlKSA9PiBMKCh0KSA9PiBlKHQuaWQoKSkpLCBtID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IG5ldyBKKHpyKTtcbiAgcmV0dXJuIG4uZWZmZWN0X2luc3RydWN0aW9uX2kwID0gZSwgbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTEgPSB0LCBuO1xufSksIGp0ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IG0oZSwgKG4pID0+IHtcbiAgY29uc3QgciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQobikgOiB0O1xuICByZXR1cm4gTGUocikgPyByIDogbmwocikgPyBWbigocykgPT4ge1xuICAgIHIudGhlbigoYykgPT4gcyhTKGMpKSwgKGMpID0+IHMoeChuZXcgR3MoYywgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIGluIEVmZmVjdC5hbmRUaGVuXCIpKSkpO1xuICB9KSA6IFMocik7XG59KSksIFl5ID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBKKFwiT25TdGVwXCIpO1xuICByZXR1cm4gdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCB0O1xufSwgenMgPSAoZSkgPT4gbShlLCBQKSwgamYgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gU2UoZSwge1xuICBvbkZhaWx1cmU6IChuKSA9PiBTKHQub25GYWlsdXJlKG4pKSxcbiAgb25TdWNjZXNzOiAobikgPT4gUyh0Lm9uU3VjY2VzcyhuKSlcbn0pKSwgU2UgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gbmV3IEooQnIpO1xuICByZXR1cm4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IHQub25GYWlsdXJlLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMiA9IHQub25TdWNjZXNzLCBuO1xufSksIFhlID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFNlKGUsIHtcbiAgb25GYWlsdXJlOiAobikgPT4ge1xuICAgIGlmIChSeShuKS5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIFooQXkobikpO1xuICAgIGNvbnN0IHMgPSBGeShuKTtcbiAgICByZXR1cm4gcy5sZW5ndGggPiAwID8gdC5vbkZhaWx1cmUoamwocykpIDogWihuKTtcbiAgfSxcbiAgb25TdWNjZXNzOiB0Lm9uU3VjY2Vzc1xufSkpLCBLZSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBOKCgpID0+IHtcbiAgY29uc3QgbiA9IHooZSksIHIgPSBTaShuLmxlbmd0aCk7XG4gIGxldCBzID0gMDtcbiAgcmV0dXJuIGZlKFlpKHtcbiAgICB3aGlsZTogKCkgPT4gcyA8IG4ubGVuZ3RoLFxuICAgIGJvZHk6ICgpID0+IHQobltzXSwgcyksXG4gICAgc3RlcDogKGMpID0+IHtcbiAgICAgIHJbcysrXSA9IGM7XG4gICAgfVxuICB9KSwgcik7XG59KSksIEJzID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IE4oKCkgPT4ge1xuICBjb25zdCBuID0geihlKTtcbiAgbGV0IHIgPSAwO1xuICByZXR1cm4gWWkoe1xuICAgIHdoaWxlOiAoKSA9PiByIDwgbi5sZW5ndGgsXG4gICAgYm9keTogKCkgPT4gdChuW3JdLCByKSxcbiAgICBzdGVwOiAoKSA9PiB7XG4gICAgICByKys7XG4gICAgfVxuICB9KTtcbn0pKSwgUXkgPSAvKiBAX19QVVJFX18gKi8gbShXaSwgKGUpID0+IExmKGUpKSwgTGYgPSAoZSkgPT4gWihUZShlKSksIEppID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBKKHVuKTtcbiAgcmV0dXJuIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gaXkoZ24pLCB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9ICgpID0+IGUsIHQ7XG59LCBaeSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBFZSgobikgPT4gbShZZShuKGUpKSwgKHIpID0+IHhiKHQsIHIpKSkpLCBUID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IG0oZSwgKG4pID0+IHkoKCkgPT4gdChuKSkpKSwgSGkgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gWGUoZSwge1xuICBvbkZhaWx1cmU6IChuKSA9PiBVcygoKSA9PiB0Lm9uRmFpbHVyZShuKSksXG4gIG9uU3VjY2VzczogKG4pID0+IHkoKCkgPT4gdC5vblN1Y2Nlc3MobikpXG59KSksIFZzID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFNlKGUsIHtcbiAgb25GYWlsdXJlOiAobikgPT4ge1xuICAgIGNvbnN0IHIgPSBDeShuKTtcbiAgICBzd2l0Y2ggKHIuX3RhZykge1xuICAgICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFVzKCgpID0+IHQoci5sZWZ0KSk7XG4gICAgICBjYXNlIFwiUmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFooci5yaWdodCk7XG4gICAgfVxuICB9LFxuICBvblN1Y2Nlc3M6IFNcbn0pKSwgcm4gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gRWUoKG4pID0+IFNlKG4oZSksIHtcbiAgb25GYWlsdXJlOiAocikgPT4ge1xuICAgIGNvbnN0IHMgPSBBKHIpO1xuICAgIHJldHVybiBTZSh0KHMpLCB7XG4gICAgICBvbkZhaWx1cmU6IChjKSA9PiBBKHNlKHIsIGMpKSxcbiAgICAgIG9uU3VjY2VzczogKCkgPT4gc1xuICAgIH0pO1xuICB9LFxuICBvblN1Y2Nlc3M6IChyKSA9PiB7XG4gICAgY29uc3QgcyA9IGoocik7XG4gICAgcmV0dXJuIG9lKHQocyksIHMpO1xuICB9XG59KSkpLCBEZiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBybihlLCB0byh7XG4gIG9uRmFpbHVyZTogKG4pID0+IFVpKG4pID8gbnQodChNeShuKSkpIDogSyxcbiAgb25TdWNjZXNzOiAoKSA9PiBLXG59KSkpLCBYeSA9IChlKSA9PiBlYihlLCBQKSwgZWIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gWGUoZSwge1xuICBvbkZhaWx1cmU6IChuKSA9PiBYcih0KG4pKSxcbiAgb25TdWNjZXNzOiBTXG59KSksIFMgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gbmV3IFRmKG5lKTtcbiAgcmV0dXJuIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gZSwgdDtcbn0sIE4gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gbmV3IEood3MpO1xuICByZXR1cm4gdC5jb21taXQgPSBlLCB0O1xufSwgeSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgSihhbCk7XG4gIHJldHVybiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IGUsIHQ7XG59LCBHaSA9IC8qIEBfX1BVUkVfXyAqLyBsKChlKSA9PiBlLmxlbmd0aCA9PT0gMyB8fCBlLmxlbmd0aCA9PT0gMiAmJiAhKFNzKGVbMV0pICYmIFwib25seUVmZmVjdFwiIGluIGVbMV0pLCAoZSwgdCkgPT4gbShlLCAobikgPT4ge1xuICBjb25zdCByID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChuKSA6IHQ7XG4gIHJldHVybiBMZShyKSA/IGZlKHIsIG4pIDogbmwocikgPyBWbigocykgPT4ge1xuICAgIHIudGhlbigoYykgPT4gcyhTKG4pKSwgKGMpID0+IHMoeChuZXcgR3MoYywgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIGluIEVmZmVjdC50YXBcIikpKSk7XG4gIH0pIDogUyhuKTtcbn0pKSwgdGIgPSAoZSkgPT4gTCgodCkgPT4ge1xuICBjb25zdCBuID0gdC5nZXRGaWJlclJlZih6YyksIHIgPSBmKG4sIGRlKCgpID0+IHQuc2NvcGUoKSkpO1xuICByZXR1cm4gZShocih6YywgSShyKSkpO1xufSksIEtzID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBKKHVuKTtcbiAgcmV0dXJuIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gU2YoZ24pLCB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9ICgpID0+IGUsIHQ7XG59LCBFZSA9IChlKSA9PiBOZihlLCBmdW5jdGlvbigpIHtcbiAgY29uc3QgdCA9IG5ldyBKKHVuKTtcbiAgcmV0dXJuIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gU2YoZ24pLCB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IChuKSA9PiB5ZihuKSA/IGVlKCgpID0+IHRoaXMuZWZmZWN0X2luc3RydWN0aW9uX2kwKEppKSkgOiBlZSgoKSA9PiB0aGlzLmVmZmVjdF9pbnN0cnVjdGlvbl9pMChLcykpLCB0O1xufSksIEsgPSAvKiBAX19QVVJFX18gKi8gUyh2b2lkIDApLCBuYiA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgSih1bik7XG4gIHJldHVybiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IGUsIHQuZWZmZWN0X2luc3RydWN0aW9uX2kxID0gdm9pZCAwLCB0O1xufSwgcmIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gbSh0LCAobikgPT4gbiA/IGYoZSwgVChJKSkgOiBTKHYoKSkpKSwgWWkgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gbmV3IEooVnIpO1xuICByZXR1cm4gdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLndoaWxlLCB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9IGUuYm9keSwgdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTIgPSBlLnN0ZXAsIHQ7XG59LCBzYiA9IChlKSA9PiBOKCgpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBKKE1uKTtcbiAgcmV0dXJuIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwID0gZSgpLCB0O1xufSksIGNiID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzWzFdLmJpbmQoYXJndW1lbnRzWzBdKTtcbiAgcmV0dXJuIHNiKCgpID0+IGUoZikpO1xufSwgaWIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gbmV3IEoodW4pO1xuICByZXR1cm4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSB0LCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSA9ICgpID0+IGUsIG47XG59KSwgUWkgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gbmV3IEooQ3IpO1xuICByZXR1cm4gdHlwZW9mIChlID09IG51bGwgPyB2b2lkIDAgOiBlLnByaW9yaXR5KSA8IFwidVwiID8gT2IodCwgZS5wcmlvcml0eSkgOiB0O1xufSwgcWYgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gbShlLCAobikgPT4gVCh0LCAocikgPT4gW24sIHJdKSkpLCBaaSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBtKGUsIChuKSA9PiBmZSh0LCBuKSkpLCBvZSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBtKGUsICgpID0+IHQpKSwgVWYgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4gbShlLCAocikgPT4gVCh0LCAocykgPT4gbihyLCBzKSkpKSwgemYgPSAoZSkgPT4gbShXaSwgKHQpID0+IGYoZSwgZXModCkpKSwgZXMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gbShlLmludGVycnVwdEFzRm9yayh0KSwgKCkgPT4gZS5hd2FpdCkpLCBvYiA9IHtcbiAgX3RhZzogXCJBbGxcIixcbiAgc3lzbG9nOiAwLFxuICBsYWJlbDogXCJBTExcIixcbiAgb3JkaW5hbDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgYWIgPSB7XG4gIF90YWc6IFwiRmF0YWxcIixcbiAgc3lzbG9nOiAyLFxuICBsYWJlbDogXCJGQVRBTFwiLFxuICBvcmRpbmFsOiA1ZTQsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgdWIgPSB7XG4gIF90YWc6IFwiRXJyb3JcIixcbiAgc3lzbG9nOiAzLFxuICBsYWJlbDogXCJFUlJPUlwiLFxuICBvcmRpbmFsOiA0ZTQsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgbGIgPSB7XG4gIF90YWc6IFwiV2FybmluZ1wiLFxuICBzeXNsb2c6IDQsXG4gIGxhYmVsOiBcIldBUk5cIixcbiAgb3JkaW5hbDogM2U0LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn0sIEJmID0ge1xuICBfdGFnOiBcIkluZm9cIixcbiAgc3lzbG9nOiA2LFxuICBsYWJlbDogXCJJTkZPXCIsXG4gIG9yZGluYWw6IDJlNCxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBWZiA9IHtcbiAgX3RhZzogXCJEZWJ1Z1wiLFxuICBzeXNsb2c6IDcsXG4gIGxhYmVsOiBcIkRFQlVHXCIsXG4gIG9yZGluYWw6IDFlNCxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBmYiA9IHtcbiAgX3RhZzogXCJUcmFjZVwiLFxuICBzeXNsb2c6IDcsXG4gIGxhYmVsOiBcIlRSQUNFXCIsXG4gIG9yZGluYWw6IDAsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSwgaGIgPSB7XG4gIF90YWc6IFwiTm9uZVwiLFxuICBzeXNsb2c6IDcsXG4gIGxhYmVsOiBcIk9GRlwiLFxuICBvcmRpbmFsOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBkYiA9IFwiZWZmZWN0L0ZpYmVyUmVmXCIsIGdiID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoZGIpLCBtYiA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0E6IChlKSA9PiBlXG59LCBYaSA9IChlKSA9PiBMKCh0KSA9PiBqKHQuZ2V0RmliZXJSZWYoZSkpKSwgV3MgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gbShYaShlKSwgdCkpLCBpYSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBwYihlLCAoKSA9PiBbdm9pZCAwLCB0XSkpLCBwYiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBMKChuKSA9PiB7XG4gIGNvbnN0IFtyLCBzXSA9IHQobi5nZXRGaWJlclJlZihlKSk7XG4gIHJldHVybiBuLnNldEZpYmVyUmVmKGUsIHMpLCBTKHIpO1xufSkpLCBociA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBDZihaaShYaSh0KSwgaWEodCwgbikpLCAoKSA9PiBlLCAocikgPT4gaWEodCwgcikpKSwgX2IgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4gV3ModCwgKHIpID0+IGhyKGUsIHQsIG4ocikpKSksIGdlID0gKGUsIHQpID0+IHluKGUsIHtcbiAgZGlmZmVyOiBnZigpLFxuICBmb3JrOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5mb3JrKSA/PyBQLFxuICBqb2luOiB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmpvaW5cbn0pLCB5YiA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBLXygpO1xuICByZXR1cm4geW4oZSwge1xuICAgIGRpZmZlcjogdCxcbiAgICBmb3JrOiB0LmVtcHR5XG4gIH0pO1xufSwgYmIgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gV18oZ2YoKSk7XG4gIHJldHVybiB5bihlLCB7XG4gICAgZGlmZmVyOiB0LFxuICAgIGZvcms6IHQuZW1wdHlcbiAgfSk7XG59LCBLZiA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWXygpO1xuICByZXR1cm4geW4oZSwge1xuICAgIGRpZmZlcjogdCxcbiAgICBmb3JrOiB0LmVtcHR5XG4gIH0pO1xufSwgeW4gPSAoZSwgdCkgPT4gKHtcbiAgLi4ubnIsXG4gIFtnYl06IG1iLFxuICBpbml0aWFsOiBlLFxuICBjb21taXQoKSB7XG4gICAgcmV0dXJuIFhpKHRoaXMpO1xuICB9LFxuICBkaWZmOiAociwgcykgPT4gdC5kaWZmZXIuZGlmZihyLCBzKSxcbiAgY29tYmluZTogKHIsIHMpID0+IHQuZGlmZmVyLmNvbWJpbmUociwgcyksXG4gIHBhdGNoOiAocikgPT4gKHMpID0+IHQuZGlmZmVyLnBhdGNoKHIsIHMpLFxuICBmb3JrOiB0LmZvcmssXG4gIGpvaW46IHQuam9pbiA/PyAoKHIsIHMpID0+IHMpXG59KSwgU2IgPSAoZSkgPT4geW4oZSwge1xuICBkaWZmZXI6IGVhLFxuICBmb3JrOiBlYS5lbXB0eVxufSksIHJ0ID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudENvbnRleHRcIiksICgpID0+IEtmKE9pKCkpKSwgZHIgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50U2NoZWR1bGluZ1ByaW9yaXR5XCIpLCAoKSA9PiBnZSgwKSksIFdmID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudE1heE9wc0JlZm9yZVlpZWxkXCIpLCAoKSA9PiBnZSgyMDQ4KSksIGtiID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudExvZ0Fubm90YXRpb25cIiksICgpID0+IGdlKGppKCkpKSwgdmIgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50TG9nTGV2ZWxcIiksICgpID0+IGdlKEJmKSksIHdiID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudExvZ1NwYW5cIiksICgpID0+IGdlKEd0KCkpKSwgT2IgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gaHIoZSwgZHIsIHQpKSwgJGIgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50Q29uY3VycmVuY3lcIiksICgpID0+IGdlKFwidW5ib3VuZGVkXCIpKSwgRWIgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50UmVxdWVzdEJhdGNoaW5nXCIpLCAoKSA9PiBnZSghMCkpLCBJYiA9IC8qIEBfX1BVUkVfXyAqLyBDKC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0ZpYmVyUmVmL2N1cnJlbnRVbmhhbmRsZWRFcnJvckxvZ0xldmVsXCIpLCAoKSA9PiBnZShJKFZmKSkpLCBVYyA9IC8qIEBfX1BVUkVfXyAqLyBDKC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0ZpYmVyUmVmL2N1cnJlbnRNZXRyaWNMYWJlbHNcIiksICgpID0+IGJiKEJ0KCkpKSwgemMgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50Rm9ya1Njb3BlT3ZlcnJpZGVcIiksICgpID0+IGdlKHYoKSwge1xuICBmb3JrOiAoKSA9PiB2KCksXG4gIGpvaW46IChlLCB0KSA9PiBlXG59KSksIElyID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudEludGVycnVwdGVkQ2F1c2VcIiksICgpID0+IGdlKFp0LCB7XG4gIGZvcms6ICgpID0+IFp0LFxuICBqb2luOiAoZSwgdCkgPT4gZVxufSkpLCBvYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1Njb3BlXCIpLCBhYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0Nsb3NlYWJsZVNjb3BlXCIpLCBKZiA9IChlLCB0KSA9PiBlLmFkZEZpbmFsaXplcigoKSA9PiBudCh0KSksIHRzID0gKGUsIHQpID0+IGUuYWRkRmluYWxpemVyKHQpLCBCYyA9IChlLCB0KSA9PiBlLmNsb3NlKHQpLCBKcyA9IChlLCB0KSA9PiBlLmZvcmsodCksIEhmID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBjbGFzcyBlIGV4dGVuZHMgZ2xvYmFsVGhpcy5FcnJvciB7XG4gICAgY29tbWl0KCkge1xuICAgICAgcmV0dXJuIHgodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgIGNvbnN0IG4gPSB7XG4gICAgICAgIC4uLnRoaXNcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICYmIChuLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UpLCB0aGlzLmNhdXNlICYmIChuLmNhdXNlID0gdGhpcy5jYXVzZSksIG47XG4gICAgfVxuICAgIFtVXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nICE9PSBnbG9iYWxUaGlzLkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA/IHRoaXMuc3RhY2sgPyBgJHt0aGlzLnRvU3RyaW5nKCl9XG4ke3RoaXMuc3RhY2suc3BsaXQoYFxuYCkuc2xpY2UoMSkuam9pbihgXG5gKX1gIDogdGhpcy50b1N0cmluZygpIDogXCJCdW5cIiBpbiBnbG9iYWxUaGlzID8gYXIoQm4odGhpcyksIHtcbiAgICAgICAgcmVuZGVyRXJyb3JDYXVzZTogITBcbiAgICAgIH0pIDogdGhpcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZS5wcm90b3R5cGUsIGZnKSwgZTtcbn0oKSwgR2YgPSAoZSwgdCkgPT4ge1xuICBjbGFzcyBuIGV4dGVuZHMgSGYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHUodGhpcywgXCJfdGFnXCIsIHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuLnByb3RvdHlwZSwgZSksIG4ucHJvdG90eXBlLm5hbWUgPSB0LCBuO1xufSwgdWEgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9DYXVzZS9lcnJvcnMvUnVudGltZUV4Y2VwdGlvblwiKSwgRmIgPSAvKiBAX19QVVJFX18gKi8gR2Yoe1xuICBbdWFdOiB1YVxufSwgXCJSdW50aW1lRXhjZXB0aW9uXCIpLCBSYiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0NhdXNlL2Vycm9ycy9JbnRlcnJ1cHRlZEV4Y2VwdGlvblwiKSwgTWIgPSAoZSkgPT4gJChlLCBSYiksIGxhID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvQ2F1c2UvZXJyb3JzL05vU3VjaEVsZW1lbnRcIiksIEhzID0gLyogQF9fUFVSRV9fICovIEdmKHtcbiAgW2xhXTogbGFcbn0sIFwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvblwiKSwgZmEgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9DYXVzZS9lcnJvcnMvVW5rbm93bkV4Y2VwdGlvblwiKSwgR3MgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGNsYXNzIGUgZXh0ZW5kcyBIZiB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgc3VwZXIocyA/PyBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIiwge1xuICAgICAgICBjYXVzZTogclxuICAgICAgfSk7XG4gICAgICB1KHRoaXMsIFwiX3RhZ1wiLCBcIlVua25vd25FeGNlcHRpb25cIik7XG4gICAgICB1KHRoaXMsIFwiZXJyb3JcIik7XG4gICAgICB0aGlzLmVycm9yID0gcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZS5wcm90b3R5cGUsIHtcbiAgICBbZmFdOiBmYSxcbiAgICBuYW1lOiBcIlVua25vd25FeGNlcHRpb25cIlxuICB9KSwgZTtcbn0oKSwgZW8gPSAoZSkgPT4gTGUoZSkgJiYgXCJfdGFnXCIgaW4gZSAmJiAoZS5fdGFnID09PSBcIlN1Y2Nlc3NcIiB8fCBlLl90YWcgPT09IFwiRmFpbHVyZVwiKSwgTUUgPSAoZSkgPT4gZS5fdGFnID09PSBcIkZhaWx1cmVcIiwgVEUgPSAoZSkgPT4gZS5fdGFnID09PSBcIlN1Y2Nlc3NcIiwgVGIgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBzd2l0Y2ggKGUuX3RhZykge1xuICAgIGNhc2UgdGU6XG4gICAgICByZXR1cm4gQShlLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCk7XG4gICAgY2FzZSBuZTpcbiAgICAgIHJldHVybiBqKHQpO1xuICB9XG59KSwgaGMgPSAoZSkgPT4gVGIoZSwgdm9pZCAwKSwgTm4gPSAoZSwgdCkgPT4gTmIoZSwgdCAhPSBudWxsICYmIHQucGFyYWxsZWwgPyBPdCA6IHNlKSwgRm4gPSAoZSkgPT4gQShPZShlKSksIGhhID0gKGUpID0+IEEoQm4oZSkpLCBBID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBNZih0ZSk7XG4gIHJldHVybiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCA9IGUsIHQ7XG59LCBDYiA9IChlKSA9PiBBKFRlKGUpKSwgZGMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBzd2l0Y2ggKGUuX3RhZykge1xuICAgIGNhc2UgdGU6XG4gICAgICByZXR1cm4gQShlLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCk7XG4gICAgY2FzZSBuZTpcbiAgICAgIHJldHVybiBqKHQoZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApKTtcbiAgfVxufSksIHRvID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHtcbiAgb25GYWlsdXJlOiB0LFxuICBvblN1Y2Nlc3M6IG5cbn0pID0+IHtcbiAgc3dpdGNoIChlLl90YWcpIHtcbiAgICBjYXNlIHRlOlxuICAgICAgcmV0dXJuIHQoZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICAgIGNhc2UgbmU6XG4gICAgICByZXR1cm4gbihlLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCk7XG4gIH1cbn0pLCBWYyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB7XG4gIG9uRmFpbHVyZTogdCxcbiAgb25TdWNjZXNzOiBuXG59KSA9PiB7XG4gIHN3aXRjaCAoZS5fdGFnKSB7XG4gICAgY2FzZSB0ZTpcbiAgICAgIHJldHVybiB0KGUuZWZmZWN0X2luc3RydWN0aW9uX2kwKTtcbiAgICBjYXNlIG5lOlxuICAgICAgcmV0dXJuIG4oZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICB9XG59KSwgaiA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgVGYobmUpO1xuICByZXR1cm4gdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAgPSBlLCB0O1xufSwgTmUgPSAvKiBAX19QVVJFX18gKi8gaih2b2lkIDApLCBDRSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBubyhlLCB0LCB7XG4gIG9uU3VjY2VzczogKG4sIHIpID0+IFtuLCByXSxcbiAgb25GYWlsdXJlOiBzZVxufSkpLCBORSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBubyhlLCB0LCB7XG4gIG9uU3VjY2VzczogKG4sIHIpID0+IHIsXG4gIG9uRmFpbHVyZTogc2Vcbn0pKSwgbm8gPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwge1xuICBvbkZhaWx1cmU6IG4sXG4gIG9uU3VjY2VzczogclxufSkgPT4ge1xuICBzd2l0Y2ggKGUuX3RhZykge1xuICAgIGNhc2UgdGU6XG4gICAgICBzd2l0Y2ggKHQuX3RhZykge1xuICAgICAgICBjYXNlIG5lOlxuICAgICAgICAgIHJldHVybiBBKGUuZWZmZWN0X2luc3RydWN0aW9uX2kwKTtcbiAgICAgICAgY2FzZSB0ZTpcbiAgICAgICAgICByZXR1cm4gQShuKGUuZWZmZWN0X2luc3RydWN0aW9uX2kwLCB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMCkpO1xuICAgICAgfVxuICAgIGNhc2UgbmU6XG4gICAgICBzd2l0Y2ggKHQuX3RhZykge1xuICAgICAgICBjYXNlIG5lOlxuICAgICAgICAgIHJldHVybiBqKHIoZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAsIHQuZWZmZWN0X2luc3RydWN0aW9uX2kwKSk7XG4gICAgICAgIGNhc2UgdGU6XG4gICAgICAgICAgcmV0dXJuIEEodC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICAgICAgfVxuICB9XG59KSwgTmIgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gUGwoZSk7XG4gIHJldHVybiBIZShuKSA/IGYoVmUobiksIGtpKGYoQ2UobiksIGRjKGllKSksIChyLCBzKSA9PiBmKHIsIG5vKHMsIHtcbiAgICBvblN1Y2Nlc3M6IChjLCBpKSA9PiBmKGMsIGJlKGkpKSxcbiAgICBvbkZhaWx1cmU6IHRcbiAgfSkpKSwgZGMoeXQpLCBkYygocikgPT4gV2UocikpLCBJKSA6IHYoKTtcbn0sIFlmID0gKGUpID0+ICh7XG4gIC4uLm5yLFxuICBbS3ldOiBXeSxcbiAgc3RhdGU6IFBzKEp5KFtdKSksXG4gIGNvbW1pdCgpIHtcbiAgICByZXR1cm4gcm8odGhpcyk7XG4gIH0sXG4gIGJsb2NraW5nT246IGVcbn0pLCBBYiA9ICgpID0+IG0oV2ksIChlKSA9PiBQYihlKSksIFBiID0gKGUpID0+IHkoKCkgPT4gWWYoZSkpLCBybyA9IChlKSA9PiBBZigodCkgPT4ge1xuICBjb25zdCBuID0gWmUoZS5zdGF0ZSk7XG4gIHN3aXRjaCAobi5fdGFnKSB7XG4gICAgY2FzZSBxczpcbiAgICAgIHJldHVybiB0KG4uZWZmZWN0KTtcbiAgICBjYXNlIHVyOlxuICAgICAgcmV0dXJuIG4uam9pbmVycy5wdXNoKHQpLCBEYihlLCB0KTtcbiAgfVxufSwgZS5ibG9ja2luZ09uKSwgWXMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4geSgoKSA9PiB7XG4gIGNvbnN0IG4gPSBaZShlLnN0YXRlKTtcbiAgc3dpdGNoIChuLl90YWcpIHtcbiAgICBjYXNlIHFzOlxuICAgICAgcmV0dXJuICExO1xuICAgIGNhc2UgdXI6IHtcbiAgICAgIHhzKGUuc3RhdGUsIEZmKHQpKTtcbiAgICAgIGZvciAobGV0IHIgPSAwLCBzID0gbi5qb2luZXJzLmxlbmd0aDsgciA8IHM7IHIrKylcbiAgICAgICAgbi5qb2luZXJzW3JdKHQpO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfVxufSkpLCB4YiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBZcyhlLCB0KSksIGpiID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFlzKGUsIFoodCkpKSwgQUUgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gWXMoZSwgTGYodCkpKSwgUEUgPSAoZSkgPT4geSgoKSA9PiBaZShlLnN0YXRlKS5fdGFnID09PSBxcyksIExiID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFlzKGUsIFModCkpKSwgUWYgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gWmUoZS5zdGF0ZSk7XG4gIGlmIChuLl90YWcgPT09IHVyKSB7XG4gICAgeHMoZS5zdGF0ZSwgRmYodCkpO1xuICAgIGZvciAobGV0IHIgPSAwLCBzID0gbi5qb2luZXJzLmxlbmd0aDsgciA8IHM7IHIrKylcbiAgICAgIG4uam9pbmVyc1tyXSh0KTtcbiAgfVxufSwgRGIgPSAoZSwgdCkgPT4geSgoKSA9PiB7XG4gIGNvbnN0IG4gPSBaZShlLnN0YXRlKTtcbiAgaWYgKG4uX3RhZyA9PT0gdXIpIHtcbiAgICBjb25zdCByID0gbi5qb2luZXJzLmluZGV4T2YodCk7XG4gICAgciA+PSAwICYmIG4uam9pbmVycy5zcGxpY2UociwgMSk7XG4gIH1cbn0pLCBxYiA9IC8qIEBfX1BVUkVfXyAqLyBMKChlKSA9PiBqKGUuY3VycmVudENvbnRleHQpKSwgWmYgPSAoKSA9PiBxYiwgYm4gPSAoZSkgPT4gbShaZigpLCBlKSwgc28gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gaHIocnQsIHQpKGUpKSwgY28gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gX2IocnQsIChuKSA9PiBmbihuLCB0KSkoZSkpLCBVYiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBibigobikgPT4gc28oZSwgdChuKSkpKSwgaW8gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gZS5jdXJyZW50U3BhbjtcbiAgcmV0dXJuIHQgIT09IHZvaWQgMCAmJiB0Ll90YWcgPT09IFwiU3BhblwiID8gSSh0KSA6IHYoKTtcbn0sIGRhID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTXV0YWJsZUhhc2hNYXBcIiksIHpiID0ge1xuICBbZGFdOiBkYSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBvbyh0aGlzKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcy50b0pTT04oKSk7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIk11dGFibGVIYXNoTWFwXCIsXG4gICAgICB2YWx1ZXM6IEFycmF5LmZyb20odGhpcykubWFwKFYpXG4gICAgfTtcbiAgfSxcbiAgW1VdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5jbGFzcyBvbyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwic2VsZlwiKTtcbiAgICB1KHRoaXMsIFwicmVmZXJlbnRpYWxJdGVyYXRvclwiKTtcbiAgICB1KHRoaXMsIFwiYnVja2V0SXRlcmF0b3JcIik7XG4gICAgdGhpcy5zZWxmID0gdCwgdGhpcy5yZWZlcmVudGlhbEl0ZXJhdG9yID0gdC5yZWZlcmVudGlhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5idWNrZXRJdGVyYXRvciAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXMuYnVja2V0SXRlcmF0b3IubmV4dCgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlZmVyZW50aWFsSXRlcmF0b3IubmV4dCgpO1xuICAgIHJldHVybiB0LmRvbmUgPyAodGhpcy5idWNrZXRJdGVyYXRvciA9IG5ldyBCYih0aGlzLnNlbGYuYnVja2V0cy52YWx1ZXMoKSksIHRoaXMubmV4dCgpKSA6IHQ7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBvbyh0aGlzLnNlbGYpO1xuICB9XG59XG5jbGFzcyBCYiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwiYmFja2luZ1wiKTtcbiAgICB1KHRoaXMsIFwiY3VycmVudEJ1Y2tldFwiKTtcbiAgICB0aGlzLmJhY2tpbmcgPSB0O1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5iYWNraW5nLm5leHQoKTtcbiAgICAgIGlmIChuLmRvbmUpXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgdGhpcy5jdXJyZW50QnVja2V0ID0gbi52YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRCdWNrZXQubmV4dCgpO1xuICAgIHJldHVybiB0LmRvbmUgPyAodGhpcy5jdXJyZW50QnVja2V0ID0gdm9pZCAwLCB0aGlzLm5leHQoKSkgOiB0O1xuICB9XG59XG5jb25zdCBWYiA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE9iamVjdC5jcmVhdGUoemIpO1xuICByZXR1cm4gZS5yZWZlcmVudGlhbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGUuYnVja2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGUuYnVja2V0c1NpemUgPSAwLCBlO1xufSwgb3QgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBpZiAoVXIodCkgPT09ICExKVxuICAgIHJldHVybiBlLnJlZmVyZW50aWFsLmhhcyh0KSA/IEkoZS5yZWZlcmVudGlhbC5nZXQodCkpIDogdigpO1xuICBjb25zdCBuID0gdFtGXSgpLCByID0gZS5idWNrZXRzLmdldChuKTtcbiAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IHYoKSA6IEtiKGUsIHIsIHQpO1xufSksIEtiID0gKGUsIHQsIG4sIHIgPSAhMSkgPT4ge1xuICBmb3IgKGxldCBzID0gMCwgYyA9IHQubGVuZ3RoOyBzIDwgYzsgcysrKVxuICAgIGlmIChuW0VdKHRbc11bMF0pKSB7XG4gICAgICBjb25zdCBpID0gdFtzXVsxXTtcbiAgICAgIHJldHVybiByICYmICh0LnNwbGljZShzLCAxKSwgZS5idWNrZXRzU2l6ZS0tKSwgSShpKTtcbiAgICB9XG4gIHJldHVybiB2KCk7XG59LCBPbiA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB5ZShvdChlLCB0KSkpLCAkbiA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiB7XG4gIGlmIChVcih0KSA9PT0gITEpXG4gICAgcmV0dXJuIGUucmVmZXJlbnRpYWwuc2V0KHQsIG4pLCBlO1xuICBjb25zdCByID0gdFtGXSgpLCBzID0gZS5idWNrZXRzLmdldChyKTtcbiAgcmV0dXJuIHMgPT09IHZvaWQgMCA/IChlLmJ1Y2tldHMuc2V0KHIsIFtbdCwgbl1dKSwgZS5idWNrZXRzU2l6ZSsrLCBlKSA6IChXYihlLCBzLCB0KSwgcy5wdXNoKFt0LCBuXSksIGUuYnVja2V0c1NpemUrKywgZSk7XG59KSwgV2IgPSAoZSwgdCwgbikgPT4ge1xuICBmb3IgKGxldCByID0gMCwgcyA9IHQubGVuZ3RoOyByIDwgczsgcisrKVxuICAgIGlmIChuW0VdKHRbcl1bMF0pKSB7XG4gICAgICB0LnNwbGljZShyLCAxKSwgZS5idWNrZXRzU2l6ZS0tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbn0sIEpiID0gXCJlZmZlY3QvQ2xvY2tcIiwgZ2EgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihKYiksIFFzID0gLyogQF9fUFVSRV9fICovIEl0KFwiZWZmZWN0L0Nsb2NrXCIpLCBIYiA9IDIgKiogMzEgLSAxLCBtYSA9IHtcbiAgdW5zYWZlU2NoZWR1bGUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBJYyh0KTtcbiAgICBpZiAobiA+IEhiKVxuICAgICAgcmV0dXJuIGJjO1xuICAgIGxldCByID0gITE7XG4gICAgY29uc3QgcyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgciA9ICEwLCBlKCk7XG4gICAgfSwgbik7XG4gICAgcmV0dXJuICgpID0+IChjbGVhclRpbWVvdXQocyksICFyKTtcbiAgfVxufSwgcGEgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDFlNik7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPiBcInVcIilcbiAgICByZXR1cm4gKCkgPT4gQmlnSW50KERhdGUubm93KCkpICogZTtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luID09IFwibnVtYmVyXCIgJiYgcGVyZm9ybWFuY2UudGltZU9yaWdpbiA9PT0gMClcbiAgICByZXR1cm4gKCkgPT4gQmlnSW50KE1hdGgucm91bmQocGVyZm9ybWFuY2Uubm93KCkgKiAxZTYpKTtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoLyogQF9fUFVSRV9fICovIERhdGUubm93KCkpICogZSAtIC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoLyogQF9fUFVSRV9fICovIE1hdGgucm91bmQoLyogQF9fUFVSRV9fICovIHBlcmZvcm1hbmNlLm5vdygpICogMWU2KSk7XG4gIHJldHVybiAoKSA9PiB0ICsgQmlnSW50KE1hdGgucm91bmQocGVyZm9ybWFuY2Uubm93KCkgKiAxZTYpKTtcbn0oKSwgR2IgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIFwiaHJ0aW1lXCIgaW4gcHJvY2VzcyAmJiB0eXBlb2YgcHJvY2Vzcy5ocnRpbWUuYmlnaW50ID09IFwiZnVuY3Rpb25cIiA/IHByb2Nlc3MuaHJ0aW1lIDogdm9pZCAwO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIHBhO1xuICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIHBhKCkgLSAvKiBAX19QVVJFX18gKi8gZS5iaWdpbnQoKTtcbiAgcmV0dXJuICgpID0+IHQgKyBlLmJpZ2ludCgpO1xufSgpO1xudmFyIGl1O1xuaXUgPSBnYTtcbmNsYXNzIFliIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdSh0aGlzLCBpdSwgZ2EpO1xuICAgIHUodGhpcywgXCJjdXJyZW50VGltZU1pbGxpc1wiLCAvKiBAX19QVVJFX18gKi8geSgoKSA9PiB0aGlzLnVuc2FmZUN1cnJlbnRUaW1lTWlsbGlzKCkpKTtcbiAgICB1KHRoaXMsIFwiY3VycmVudFRpbWVOYW5vc1wiLCAvKiBAX19QVVJFX18gKi8geSgoKSA9PiB0aGlzLnVuc2FmZUN1cnJlbnRUaW1lTmFub3MoKSkpO1xuICB9XG4gIHVuc2FmZUN1cnJlbnRUaW1lTWlsbGlzKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG4gIHVuc2FmZUN1cnJlbnRUaW1lTmFub3MoKSB7XG4gICAgcmV0dXJuIEdiKCk7XG4gIH1cbiAgc2NoZWR1bGVyKCkge1xuICAgIHJldHVybiBTKG1hKTtcbiAgfVxuICBzbGVlcCh0KSB7XG4gICAgcmV0dXJuIHhlKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gbWEudW5zYWZlU2NoZWR1bGUoKCkgPT4gbihLKSwgdCk7XG4gICAgICByZXR1cm4gbnQoeShyKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFFiID0gKCkgPT4gbmV3IFliKCksIFhmID0gXCJBbmRcIiwgZWggPSBcIk9yXCIsIHRoID0gXCJJbnZhbGlkRGF0YVwiLCBuaCA9IFwiTWlzc2luZ0RhdGFcIiwgcmggPSBcIlNvdXJjZVVuYXZhaWxhYmxlXCIsIHNoID0gXCJVbnN1cHBvcnRlZFwiLCBaYiA9IFwiZWZmZWN0L0NvbmZpZ0Vycm9yXCIsIF9hID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoWmIpLCBTbiA9IHtcbiAgX3RhZzogXCJDb25maWdFcnJvclwiLFxuICBbX2FdOiBfYVxufSwgY2ggPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShTbik7XG4gIHJldHVybiBuLl9vcCA9IFhmLCBuLmxlZnQgPSBlLCBuLnJpZ2h0ID0gdCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwidG9TdHJpbmdcIiwge1xuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubGVmdH0gYW5kICR7dGhpcy5yaWdodH1gO1xuICAgIH1cbiAgfSksIG47XG59LCBpaCA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKFNuKTtcbiAgcmV0dXJuIG4uX29wID0gZWgsIG4ubGVmdCA9IGUsIG4ucmlnaHQgPSB0LCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5sZWZ0fSBvciAke3RoaXMucmlnaHR9YDtcbiAgICB9XG4gIH0pLCBuO1xufSwgWGIgPSAoZSwgdCwgbiA9IHtcbiAgcGF0aERlbGltOiBcIi5cIlxufSkgPT4ge1xuICBjb25zdCByID0gT2JqZWN0LmNyZWF0ZShTbik7XG4gIHJldHVybiByLl9vcCA9IHRoLCByLnBhdGggPSBlLCByLm1lc3NhZ2UgPSB0LCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gYChJbnZhbGlkIGRhdGEgYXQgJHtmKHRoaXMucGF0aCwgbG4obi5wYXRoRGVsaW0pKX06IFwiJHt0aGlzLm1lc3NhZ2V9XCIpYDtcbiAgICB9XG4gIH0pLCByO1xufSwgJHQgPSAoZSwgdCwgbiA9IHtcbiAgcGF0aERlbGltOiBcIi5cIlxufSkgPT4ge1xuICBjb25zdCByID0gT2JqZWN0LmNyZWF0ZShTbik7XG4gIHJldHVybiByLl9vcCA9IG5oLCByLnBhdGggPSBlLCByLm1lc3NhZ2UgPSB0LCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gYChNaXNzaW5nIGRhdGEgYXQgJHtmKHRoaXMucGF0aCwgbG4obi5wYXRoRGVsaW0pKX06IFwiJHt0aGlzLm1lc3NhZ2V9XCIpYDtcbiAgICB9XG4gIH0pLCByO1xufSwgZVMgPSAoZSwgdCwgbiwgciA9IHtcbiAgcGF0aERlbGltOiBcIi5cIlxufSkgPT4ge1xuICBjb25zdCBzID0gT2JqZWN0LmNyZWF0ZShTbik7XG4gIHJldHVybiBzLl9vcCA9IHJoLCBzLnBhdGggPSBlLCBzLm1lc3NhZ2UgPSB0LCBzLmNhdXNlID0gbiwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwidG9TdHJpbmdcIiwge1xuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGAoU291cmNlIHVuYXZhaWxhYmxlIGF0ICR7Zih0aGlzLnBhdGgsIGxuKHIucGF0aERlbGltKSl9OiBcIiR7dGhpcy5tZXNzYWdlfVwiKWA7XG4gICAgfVxuICB9KSwgcztcbn0sIHRTID0gKGUsIHQsIG4gPSB7XG4gIHBhdGhEZWxpbTogXCIuXCJcbn0pID0+IHtcbiAgY29uc3QgciA9IE9iamVjdC5jcmVhdGUoU24pO1xuICByZXR1cm4gci5fb3AgPSBzaCwgci5wYXRoID0gZSwgci5tZXNzYWdlID0gdCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwidG9TdHJpbmdcIiwge1xuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGAoVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIGF0ICR7Zih0aGlzLnBhdGgsIGxuKG4ucGF0aERlbGltKSl9OiBcIiR7dGhpcy5tZXNzYWdlfVwiKWA7XG4gICAgfVxuICB9KSwgcjtcbn0sIHV0ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgc3dpdGNoIChlLl9vcCkge1xuICAgIGNhc2UgWGY6XG4gICAgICByZXR1cm4gY2godXQoZS5sZWZ0LCB0KSwgdXQoZS5yaWdodCwgdCkpO1xuICAgIGNhc2UgZWg6XG4gICAgICByZXR1cm4gaWgodXQoZS5sZWZ0LCB0KSwgdXQoZS5yaWdodCwgdCkpO1xuICAgIGNhc2UgdGg6XG4gICAgICByZXR1cm4gWGIoWy4uLnQsIC4uLmUucGF0aF0sIGUubWVzc2FnZSk7XG4gICAgY2FzZSBuaDpcbiAgICAgIHJldHVybiAkdChbLi4udCwgLi4uZS5wYXRoXSwgZS5tZXNzYWdlKTtcbiAgICBjYXNlIHJoOlxuICAgICAgcmV0dXJuIGVTKFsuLi50LCAuLi5lLnBhdGhdLCBlLm1lc3NhZ2UsIGUuY2F1c2UpO1xuICAgIGNhc2Ugc2g6XG4gICAgICByZXR1cm4gdFMoWy4uLnQsIC4uLmUucGF0aF0sIGUubWVzc2FnZSk7XG4gIH1cbn0pLCBuUyA9IHtcbiAgX3RhZzogXCJFbXB0eVwiXG59LCBnYyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGxldCBuID0gTGkodCksIHIgPSBlO1xuICBmb3IgKDsgWnAobik7ICkge1xuICAgIGNvbnN0IHMgPSBuLmhlYWQ7XG4gICAgc3dpdGNoIChzLl90YWcpIHtcbiAgICAgIGNhc2UgXCJFbXB0eVwiOiB7XG4gICAgICAgIG4gPSBuLnRhaWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkFuZFRoZW5cIjoge1xuICAgICAgICBuID0gdnQocy5maXJzdCwgdnQocy5zZWNvbmQsIG4udGFpbCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJNYXBOYW1lXCI6IHtcbiAgICAgICAgciA9IGZ0KHIsIHMuZiksIG4gPSBuLnRhaWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5lc3RlZFwiOiB7XG4gICAgICAgIHIgPSBLcihyLCBzLm5hbWUpLCBuID0gbi50YWlsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJVbm5lc3RlZFwiOiB7XG4gICAgICAgIGlmIChmKFRuKHIpLCBDZyhzLm5hbWUpKSlcbiAgICAgICAgICByID0gX3QociksIG4gPSBuLnRhaWw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gJGUoJHQociwgYEV4cGVjdGVkICR7cy5uYW1lfSB0byBiZSBpbiBwYXRoIGluIENvbmZpZ1Byb3ZpZGVyI3VubmVzdGVkYCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFlKHIpO1xufSksIHJTID0gXCJDb25zdGFudFwiLCBzUyA9IFwiRmFpbFwiLCBjUyA9IFwiRmFsbGJhY2tcIiwgaVMgPSBcIkRlc2NyaWJlZFwiLCBvUyA9IFwiTGF6eVwiLCBhUyA9IFwiTWFwT3JGYWlsXCIsIHVTID0gXCJOZXN0ZWRcIiwgbFMgPSBcIlByaW1pdGl2ZVwiLCBmUyA9IFwiU2VxdWVuY2VcIiwgaFMgPSBcIkhhc2hNYXBcIiwgZFMgPSBcIlppcFdpdGhcIiwgbnMgPSAoZSwgdCkgPT4gWy4uLmUsIC4uLnRdLCBnUyA9IFwiZWZmZWN0L0NvbmZpZ1Byb3ZpZGVyXCIsIHlhID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoZ1MpLCBtUyA9IC8qIEBfX1BVUkVfXyAqLyBJdChcImVmZmVjdC9Db25maWdQcm92aWRlclwiKSwgcFMgPSBcImVmZmVjdC9Db25maWdQcm92aWRlckZsYXRcIiwgYmEgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihwUyksIF9TID0gKGUpID0+ICh7XG4gIFt5YV06IHlhLFxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC4uLmVcbn0pLCB5UyA9IChlKSA9PiAoe1xuICBbYmFdOiBiYSxcbiAgcGF0Y2g6IGUucGF0Y2gsXG4gIGxvYWQ6ICh0LCBuLCByID0gITApID0+IGUubG9hZCh0LCBuLCByKSxcbiAgZW51bWVyYXRlQ2hpbGRyZW46IGUuZW51bWVyYXRlQ2hpbGRyZW5cbn0pLCBiUyA9IChlKSA9PiBfUyh7XG4gIGxvYWQ6ICh0KSA9PiBtKF9lKGUsIEJ0KCksIHQsICExKSwgKG4pID0+IHR0KFRuKG4pLCB7XG4gICAgb25Ob25lOiAoKSA9PiB4KCR0KEJ0KCksIGBFeHBlY3RlZCBhIHNpbmdsZSB2YWx1ZSBoYXZpbmcgc3RydWN0dXJlOiAke3R9YCkpLFxuICAgIG9uU29tZTogU1xuICB9KSksXG4gIGZsYXR0ZW5lZDogZVxufSksIFNTID0gKGUpID0+IHtcbiAgY29uc3Qge1xuICAgIHBhdGhEZWxpbTogdCxcbiAgICBzZXFEZWxpbTogblxuICB9ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgIHBhdGhEZWxpbTogXCJfXCIsXG4gICAgc2VxRGVsaW06IFwiLFwiXG4gIH0sIGUpLCByID0gKGEpID0+IGYoYSwgbG4odCkpLCBzID0gKGEpID0+IGEuc3BsaXQodCksIGMgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIFwiZW52XCIgaW4gcHJvY2VzcyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgPT0gXCJvYmplY3RcIiA/IHByb2Nlc3MuZW52IDoge307XG4gIHJldHVybiBiUyh5Uyh7XG4gICAgbG9hZDogKGEsIGgsIGQgPSAhMCkgPT4ge1xuICAgICAgY29uc3QgZyA9IHIoYSksIHAgPSBjKCksIF8gPSBnIGluIHAgPyBJKHBbZ10pIDogdigpO1xuICAgICAgcmV0dXJuIGYoXywgVnMoKCkgPT4gJHQoYSwgYEV4cGVjdGVkICR7Z30gdG8gZXhpc3QgaW4gdGhlIHByb2Nlc3MgY29udGV4dGApKSwgbSgoYikgPT4gJFMoYiwgYSwgaCwgbiwgZCkpKTtcbiAgICB9LFxuICAgIGVudW1lcmF0ZUNoaWxkcmVuOiAoYSkgPT4geSgoKSA9PiB7XG4gICAgICBjb25zdCBoID0gYygpLCBwID0gT2JqZWN0LmtleXMoaCkubWFwKChfKSA9PiBzKF8udG9VcHBlckNhc2UoKSkpLmZpbHRlcigoXykgPT4ge1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICBjb25zdCBNID0gZihhLCB2bChiKSksIEQgPSBfW2JdO1xuICAgICAgICAgIGlmIChEID09PSB2b2lkIDAgfHwgTSAhPT0gRClcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9KS5mbGF0TWFwKChfKSA9PiBfLnNsaWNlKGEubGVuZ3RoLCBhLmxlbmd0aCArIDEpKTtcbiAgICAgIHJldHVybiBUcChwKTtcbiAgICB9KSxcbiAgICBwYXRjaDogblNcbiAgfSkpO1xufSwga1MgPSAoZSwgdCwgbiwgcikgPT4ge1xuICBjb25zdCBzID0gem8obi5sZW5ndGgsIChhKSA9PiBhID49IHIubGVuZ3RoID8gdigpIDogSShbZShhKSwgYSArIDFdKSksIGMgPSB6byhyLmxlbmd0aCwgKGEpID0+IGEgPj0gbi5sZW5ndGggPyB2KCkgOiBJKFt0KGEpLCBhICsgMV0pKSwgaSA9IG5zKG4sIHMpLCBvID0gbnMociwgYyk7XG4gIHJldHVybiBbaSwgb107XG59LCB2UyA9IChlLCB0KSA9PiB7XG4gIGxldCBuID0gdDtcbiAgaWYgKG4uX3RhZyA9PT0gXCJOZXN0ZWRcIikge1xuICAgIGNvbnN0IHIgPSBlLnNsaWNlKCk7XG4gICAgZm9yICg7IG4uX3RhZyA9PT0gXCJOZXN0ZWRcIjsgKVxuICAgICAgci5wdXNoKG4ubmFtZSksIG4gPSBuLmNvbmZpZztcbiAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gZTtcbn0sIF9lID0gKGUsIHQsIG4sIHIpID0+IHtcbiAgY29uc3QgcyA9IG47XG4gIHN3aXRjaCAocy5fdGFnKSB7XG4gICAgY2FzZSByUzpcbiAgICAgIHJldHVybiBTKGtlKHMudmFsdWUpKTtcbiAgICBjYXNlIGlTOlxuICAgICAgcmV0dXJuIE4oKCkgPT4gX2UoZSwgdCwgcy5jb25maWcsIHIpKTtcbiAgICBjYXNlIHNTOlxuICAgICAgcmV0dXJuIHgoJHQodCwgcy5tZXNzYWdlKSk7XG4gICAgY2FzZSBjUzpcbiAgICAgIHJldHVybiBmKE4oKCkgPT4gX2UoZSwgdCwgcy5maXJzdCwgcikpLCBacigoYykgPT4gcy5jb25kaXRpb24oYykgPyBmKF9lKGUsIHQsIHMuc2Vjb25kLCByKSwgWnIoKGkpID0+IHgoaWgoYywgaSkpKSkgOiB4KGMpKSk7XG4gICAgY2FzZSBvUzpcbiAgICAgIHJldHVybiBOKCgpID0+IF9lKGUsIHQsIHMuY29uZmlnKCksIHIpKTtcbiAgICBjYXNlIGFTOlxuICAgICAgcmV0dXJuIE4oKCkgPT4gZihfZShlLCB0LCBzLm9yaWdpbmFsLCByKSwgbShLZSgoYykgPT4gZihzLm1hcE9yRmFpbChjKSwgVnModXQodlModCwgcy5vcmlnaW5hbCkpKSkpKSkpO1xuICAgIGNhc2UgdVM6XG4gICAgICByZXR1cm4gTigoKSA9PiBfZShlLCBucyh0LCBrZShzLm5hbWUpKSwgcy5jb25maWcsIHIpKTtcbiAgICBjYXNlIGxTOlxuICAgICAgcmV0dXJuIGYoZ2ModCwgZS5wYXRjaCksIG0oKGMpID0+IGYoZS5sb2FkKGMsIHMsIHIpLCBtKChpKSA9PiB7XG4gICAgICAgIGlmIChpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IG8gPSBmKHpnKGMpLCBkZSgoKSA9PiBcIjxuL2E+XCIpKTtcbiAgICAgICAgICByZXR1cm4geCgkdChbXSwgYEV4cGVjdGVkICR7cy5kZXNjcmlwdGlvbn0gd2l0aCBuYW1lICR7b31gKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFMoaSk7XG4gICAgICB9KSkpKTtcbiAgICBjYXNlIGZTOlxuICAgICAgcmV0dXJuIGYoZ2ModCwgZS5wYXRjaCksIG0oKGMpID0+IGYoZS5lbnVtZXJhdGVDaGlsZHJlbihjKSwgbShJUyksIG0oKGkpID0+IGkubGVuZ3RoID09PSAwID8gTigoKSA9PiBUKF9lKGUsIHQsIHMuY29uZmlnLCAhMCksIGtlKSkgOiBmKEtlKGksIChvKSA9PiBfZShlLCB4Zyh0LCBgWyR7b31dYCksIHMuY29uZmlnLCAhMCkpLCBUKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBYZyhvKTtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSAwID8ga2UoQnQoKSkgOiBrZShhKTtcbiAgICAgIH0pKSkpKSk7XG4gICAgY2FzZSBoUzpcbiAgICAgIHJldHVybiBOKCgpID0+IGYoZ2ModCwgZS5wYXRjaCksIG0oKGMpID0+IGYoZS5lbnVtZXJhdGVDaGlsZHJlbihjKSwgbSgoaSkgPT4gZihpLCBLZSgobykgPT4gX2UoZSwgbnMoYywga2UobykpLCBzLnZhbHVlQ29uZmlnLCByKSksIFQoKG8pID0+IG8ubGVuZ3RoID09PSAwID8ga2UoamkoKSkgOiBmKEVTKG8pLCBmdCgoYSkgPT4gQnAoVW8oeihpKSwgYSkpKSkpKSkpKSkpO1xuICAgIGNhc2UgZFM6XG4gICAgICByZXR1cm4gTigoKSA9PiBmKF9lKGUsIHQsIHMubGVmdCwgciksIG5uLCBtKChjKSA9PiBmKF9lKGUsIHQsIHMucmlnaHQsIHIpLCBubiwgbSgoaSkgPT4ge1xuICAgICAgICBpZiAoYXQoYykgJiYgYXQoaSkpXG4gICAgICAgICAgcmV0dXJuIHgoY2goYy5sZWZ0LCBpLmxlZnQpKTtcbiAgICAgICAgaWYgKGF0KGMpICYmIFB0KGkpKVxuICAgICAgICAgIHJldHVybiB4KGMubGVmdCk7XG4gICAgICAgIGlmIChQdChjKSAmJiBhdChpKSlcbiAgICAgICAgICByZXR1cm4geChpLmxlZnQpO1xuICAgICAgICBpZiAoUHQoYykgJiYgUHQoaSkpIHtcbiAgICAgICAgICBjb25zdCBvID0gZih0LCBsbihcIi5cIikpLCBhID0gd1ModCwgbyksIFtoLCBkXSA9IGtTKGEsIGEsIGYoYy5yaWdodCwgZnQoYWUpKSwgZihpLnJpZ2h0LCBmdChhZSkpKTtcbiAgICAgICAgICByZXR1cm4gZihoLCBVbyhkKSwgS2UoKFtnLCBwXSkgPT4gZihxZihnLCBwKSwgVCgoW18sIGJdKSA9PiBzLnppcChfLCBiKSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBDb25maWdQcm92aWRlci5mcm9tRmxhdExvb3AgLSBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9FZmZlY3QtVFMvZWZmZWN0L2lzc3Vlc1wiKTtcbiAgICAgIH0pKSkpKTtcbiAgfVxufSwgd1MgPSAoZSwgdCkgPT4gKG4pID0+ICRlKCR0KGUsIGBUaGUgZWxlbWVudCBhdCBpbmRleCAke259IGluIGEgc2VxdWVuY2UgYXQgcGF0aCBcIiR7dH1cIiB3YXMgbWlzc2luZ2ApKSwgT1MgPSAoZSwgdCkgPT4gZS5zcGxpdChuZXcgUmVnRXhwKGBcXFxccyoke25tKHQpfVxcXFxzKmApKSwgJFMgPSAoZSwgdCwgbiwgciwgcykgPT4gcyA/IGYoT1MoZSwgciksIEtlKChjKSA9PiBuLnBhcnNlKGMudHJpbSgpKSksIFZzKHV0KHQpKSkgOiBmKG4ucGFyc2UoZSksIEhpKHtcbiAgb25GYWlsdXJlOiB1dCh0KSxcbiAgb25TdWNjZXNzOiBrZVxufSkpLCBFUyA9IChlKSA9PiBPYmplY3Qua2V5cyhlWzBdKS5tYXAoKHQpID0+IGUubWFwKChuKSA9PiBuW3RdKSksIElTID0gKGUpID0+IGYoS2UoZSwgUlMpLCBIaSh7XG4gIG9uRmFpbHVyZTogKCkgPT4gQnQoKSxcbiAgb25TdWNjZXNzOiBXcih4bilcbn0pLCBubiwgVCh2ZykpLCBGUyA9IC9eKFxcWyhcXGQrKVxcXSkkLywgUlMgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gZS5tYXRjaChGUyk7XG4gIGlmICh0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgbiA9IHRbMl07XG4gICAgcmV0dXJuIGYobiAhPT0gdm9pZCAwICYmIG4ubGVuZ3RoID4gMCA/IEkobikgOiB2KCksIGJsKE1TKSk7XG4gIH1cbiAgcmV0dXJuIHYoKTtcbn0sIE1TID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE51bWJlci5wYXJzZUludChlKTtcbiAgcmV0dXJuIE51bWJlci5pc05hTih0KSA/IHYoKSA6IEkodCk7XG59LCBTYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0NvbnNvbGVcIiksIG9oID0gLyogQF9fUFVSRV9fICovIEl0KFwiZWZmZWN0L0NvbnNvbGVcIiksIFRTID0ge1xuICBbU2FdOiBTYSxcbiAgYXNzZXJ0KGUsIC4uLnQpIHtcbiAgICByZXR1cm4geSgoKSA9PiB7XG4gICAgICBjb25zb2xlLmFzc2VydChlLCAuLi50KTtcbiAgICB9KTtcbiAgfSxcbiAgY2xlYXI6IC8qIEBfX1BVUkVfXyAqLyB5KCgpID0+IHtcbiAgICBjb25zb2xlLmNsZWFyKCk7XG4gIH0pLFxuICBjb3VudChlKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS5jb3VudChlKTtcbiAgICB9KTtcbiAgfSxcbiAgY291bnRSZXNldChlKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS5jb3VudFJlc2V0KGUpO1xuICAgIH0pO1xuICB9LFxuICBkZWJ1ZyguLi5lKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS5kZWJ1ZyguLi5lKTtcbiAgICB9KTtcbiAgfSxcbiAgZGlyKGUsIHQpIHtcbiAgICByZXR1cm4geSgoKSA9PiB7XG4gICAgICBjb25zb2xlLmRpcihlLCB0KTtcbiAgICB9KTtcbiAgfSxcbiAgZGlyeG1sKC4uLmUpIHtcbiAgICByZXR1cm4geSgoKSA9PiB7XG4gICAgICBjb25zb2xlLmRpcnhtbCguLi5lKTtcbiAgICB9KTtcbiAgfSxcbiAgZXJyb3IoLi4uZSkge1xuICAgIHJldHVybiB5KCgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4uZSk7XG4gICAgfSk7XG4gIH0sXG4gIGdyb3VwKGUpIHtcbiAgICByZXR1cm4gZSAhPSBudWxsICYmIGUuY29sbGFwc2VkID8geSgoKSA9PiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubGFiZWwpKSA6IHkoKCkgPT4gY29uc29sZS5ncm91cChlID09IG51bGwgPyB2b2lkIDAgOiBlLmxhYmVsKSk7XG4gIH0sXG4gIGdyb3VwRW5kOiAvKiBAX19QVVJFX18gKi8geSgoKSA9PiB7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9KSxcbiAgaW5mbyguLi5lKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS5pbmZvKC4uLmUpO1xuICAgIH0pO1xuICB9LFxuICBsb2coLi4uZSkge1xuICAgIHJldHVybiB5KCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKC4uLmUpO1xuICAgIH0pO1xuICB9LFxuICB0YWJsZShlLCB0KSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS50YWJsZShlLCB0KTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZShlKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4gY29uc29sZS50aW1lKGUpKTtcbiAgfSxcbiAgdGltZUVuZChlKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4gY29uc29sZS50aW1lRW5kKGUpKTtcbiAgfSxcbiAgdGltZUxvZyhlLCAuLi50KSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS50aW1lTG9nKGUsIC4uLnQpO1xuICAgIH0pO1xuICB9LFxuICB0cmFjZSguLi5lKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS50cmFjZSguLi5lKTtcbiAgICB9KTtcbiAgfSxcbiAgd2FybiguLi5lKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKC4uLmUpO1xuICAgIH0pO1xuICB9LFxuICB1bnNhZmU6IGNvbnNvbGVcbn0sIENTID0gXCJlZmZlY3QvUmFuZG9tXCIsIGthID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoQ1MpLCBOUyA9IC8qIEBfX1BVUkVfXyAqLyBJdChcImVmZmVjdC9SYW5kb21cIik7XG52YXIgb3U7XG5vdSA9IGthO1xuY2xhc3MgQVMge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcInNlZWRcIik7XG4gICAgdSh0aGlzLCBvdSwga2EpO1xuICAgIHUodGhpcywgXCJQUk5HXCIpO1xuICAgIHRoaXMuc2VlZCA9IHQsIHRoaXMuUFJORyA9IG5ldyBZZCh0KTtcbiAgfVxuICBnZXQgbmV4dCgpIHtcbiAgICByZXR1cm4geSgoKSA9PiB0aGlzLlBSTkcubnVtYmVyKCkpO1xuICB9XG4gIGdldCBuZXh0Qm9vbGVhbigpIHtcbiAgICByZXR1cm4gVCh0aGlzLm5leHQsICh0KSA9PiB0ID4gMC41KTtcbiAgfVxuICBnZXQgbmV4dEludCgpIHtcbiAgICByZXR1cm4geSgoKSA9PiB0aGlzLlBSTkcuaW50ZWdlcihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuICB9XG4gIG5leHRSYW5nZSh0LCBuKSB7XG4gICAgcmV0dXJuIFQodGhpcy5uZXh0LCAocikgPT4gKG4gLSB0KSAqIHIgKyB0KTtcbiAgfVxuICBuZXh0SW50QmV0d2Vlbih0LCBuKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4gdGhpcy5QUk5HLmludGVnZXIobiAtIHQpICsgdCk7XG4gIH1cbiAgc2h1ZmZsZSh0KSB7XG4gICAgcmV0dXJuIFBTKHQsIChuKSA9PiB0aGlzLm5leHRJbnRCZXR3ZWVuKDAsIG4pKTtcbiAgfVxufVxuY29uc3QgUFMgPSAoZSwgdCkgPT4gTigoKSA9PiBmKHkoKCkgPT4gQXJyYXkuZnJvbShlKSksIG0oKG4pID0+IHtcbiAgY29uc3QgciA9IFtdO1xuICBmb3IgKGxldCBzID0gbi5sZW5ndGg7IHMgPj0gMjsgcyA9IHMgLSAxKVxuICAgIHIucHVzaChzKTtcbiAgcmV0dXJuIGYociwgQnMoKHMpID0+IGYodChzKSwgVCgoYykgPT4geFMobiwgcyAtIDEsIGMpKSkpLCBmZShQbChuKSkpO1xufSkpKSwgeFMgPSAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gZVt0XTtcbiAgcmV0dXJuIGVbdF0gPSBlW25dLCBlW25dID0gciwgZTtcbn0sIGpTID0gKGUpID0+IG5ldyBBUyhrKGUpKSwgdmEgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9UcmFjZXJcIiksIExTID0gKGUpID0+ICh7XG4gIFt2YV06IHZhLFxuICAuLi5lXG59KSwgYWggPSAvKiBAX19QVVJFX18gKi8gSXQoXCJlZmZlY3QvVHJhY2VyXCIpLCB1aCA9IC8qIEBfX1BVUkVfXyAqLyBJdChcImVmZmVjdC9QYXJlbnRTcGFuXCIpLCB3YSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IFwiYWJjZGVmMDEyMzQ1Njc4OVwiLCB0ID0gZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgbGV0IHIgPSBcIlwiO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgbjsgcysrKVxuICAgICAgciArPSBlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0KSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG59KCk7XG5jbGFzcyBEUyB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIsIHMsIGMsIGkpIHtcbiAgICB1KHRoaXMsIFwibmFtZVwiKTtcbiAgICB1KHRoaXMsIFwicGFyZW50XCIpO1xuICAgIHUodGhpcywgXCJjb250ZXh0XCIpO1xuICAgIHUodGhpcywgXCJzdGFydFRpbWVcIik7XG4gICAgdSh0aGlzLCBcImtpbmRcIik7XG4gICAgdSh0aGlzLCBcIl90YWdcIiwgXCJTcGFuXCIpO1xuICAgIHUodGhpcywgXCJzcGFuSWRcIik7XG4gICAgdSh0aGlzLCBcInRyYWNlSWRcIiwgXCJuYXRpdmVcIik7XG4gICAgdSh0aGlzLCBcInNhbXBsZWRcIiwgITApO1xuICAgIHUodGhpcywgXCJzdGF0dXNcIik7XG4gICAgdSh0aGlzLCBcImF0dHJpYnV0ZXNcIik7XG4gICAgdSh0aGlzLCBcImV2ZW50c1wiLCBbXSk7XG4gICAgdSh0aGlzLCBcImxpbmtzXCIpO1xuICAgIHRoaXMubmFtZSA9IHQsIHRoaXMucGFyZW50ID0gbiwgdGhpcy5jb250ZXh0ID0gciwgdGhpcy5zdGFydFRpbWUgPSBjLCB0aGlzLmtpbmQgPSBpLCB0aGlzLnN0YXR1cyA9IHtcbiAgICAgIF90YWc6IFwiU3RhcnRlZFwiLFxuICAgICAgc3RhcnRUaW1lOiBjXG4gICAgfSwgdGhpcy5hdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy50cmFjZUlkID0gbi5fdGFnID09PSBcIlNvbWVcIiA/IG4udmFsdWUudHJhY2VJZCA6IHdhKDMyKSwgdGhpcy5zcGFuSWQgPSB3YSgxNiksIHRoaXMubGlua3MgPSBBcnJheS5mcm9tKHMpO1xuICB9XG4gIGVuZCh0LCBuKSB7XG4gICAgdGhpcy5zdGF0dXMgPSB7XG4gICAgICBfdGFnOiBcIkVuZGVkXCIsXG4gICAgICBlbmRUaW1lOiB0LFxuICAgICAgZXhpdDogbixcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5zdGF0dXMuc3RhcnRUaW1lXG4gICAgfTtcbiAgfVxuICBhdHRyaWJ1dGUodCwgbikge1xuICAgIHRoaXMuYXR0cmlidXRlcy5zZXQodCwgbik7XG4gIH1cbiAgZXZlbnQodCwgbiwgcikge1xuICAgIHRoaXMuZXZlbnRzLnB1c2goW3QsIG4sIHIgPz8ge31dKTtcbiAgfVxuICBhZGRMaW5rcyh0KSB7XG4gICAgdGhpcy5saW5rcy5wdXNoKC4uLnQpO1xuICB9XG59XG5jb25zdCBxUyA9IC8qIEBfX1BVUkVfXyAqLyBMUyh7XG4gIHNwYW46IChlLCB0LCBuLCByLCBzLCBjKSA9PiBuZXcgRFMoZSwgdCwgbiwgciwgcywgYyksXG4gIGNvbnRleHQ6IChlKSA9PiBlKClcbn0pLCBVUyA9IC8qIEBfX1BVUkVfXyAqLyBmKC8qIEBfX1BVUkVfXyAqLyBPaSgpLCAvKiBAX19QVVJFX18gKi8gQXQoUXMsIC8qIEBfX1BVUkVfXyAqLyBRYigpKSwgLyogQF9fUFVSRV9fICovIEF0KG9oLCBUUyksIC8qIEBfX1BVUkVfXyAqLyBBdChOUywgLyogQF9fUFVSRV9fICovIGpTKC8qIEBfX1BVUkVfXyAqLyBNYXRoLnJhbmRvbSgpKSksIC8qIEBfX1BVUkVfXyAqLyBBdChtUywgLyogQF9fUFVSRV9fICovIFNTKCkpLCAvKiBAX19QVVJFX18gKi8gQXQoYWgsIHFTKSksIHJzID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRGVmYXVsdFNlcnZpY2VzL2N1cnJlbnRTZXJ2aWNlc1wiKSwgKCkgPT4gS2YoVVMpKSwgelMgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gUGUoZSk7XG4gIHJldHVybiBsaCgobikgPT4gbi5zbGVlcCh0KSk7XG59LCBCUyA9IChlKSA9PiBMKCh0KSA9PiBlKHQuY3VycmVudERlZmF1bHRTZXJ2aWNlcykpLCBsaCA9IChlKSA9PiBCUygodCkgPT4gZSh0LnVuc2FmZU1hcC5nZXQoUXMua2V5KSkpLCBWUyA9IC8qIEBfX1BVUkVfXyAqLyBsaCgoZSkgPT4gZS5jdXJyZW50VGltZU1pbGxpcyksIEtTID0gelMsIFdTID0gVlM7XG5mdW5jdGlvbiBKUyhlKSB7XG4gIHJldHVybiBuZXcgZXQoZSk7XG59XG5mdW5jdGlvbiBIUygpIHtcbiAgcmV0dXJuIEpTKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xufVxuY29uc3QgT2EgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZnNcIik7XG52YXIgYXU7XG5hdSA9IE9hO1xuY2xhc3MgZXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcImxvY2Fsc1wiKTtcbiAgICB1KHRoaXMsIGF1LCBPYSk7XG4gICAgdGhpcy5sb2NhbHMgPSB0O1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuY29uc3QgR1MgPSAoZSwgdCwgbiwgciA9ICExKSA9PiB7XG4gIGNvbnN0IHMgPSBlO1xuICBsZXQgYyA9IHQsIGkgPSBuLCBvID0gciwgYTtcbiAgZm9yICg7IGEgPT09IHZvaWQgMDsgKVxuICAgIGlmIChsZShjKSAmJiBsZShpKSkge1xuICAgICAgY29uc3QgaCA9IHVlKGMpWzBdLCBkID0gX3QoYyksIGcgPSB1ZShpKVswXSwgcCA9IHVlKGkpWzFdLCBfID0gX3QoaSk7XG4gICAgICBoLnN0YXJ0VGltZU1pbGxpcyA8IGcuc3RhcnRUaW1lTWlsbGlzID8gKGkgPSBfLCBvID0gITApIDogaC5zdGFydFRpbWVNaWxsaXMgPiBnLnN0YXJ0VGltZU1pbGxpcyA/IGMgPSBkIDogaC5pZCA8IGcuaWQgPyAoaSA9IF8sIG8gPSAhMCkgOiBoLmlkID4gZy5pZCA/IGMgPSBkIDogYSA9IFtwLCBvXTtcbiAgICB9IGVsc2VcbiAgICAgIGEgPSBbcy5pbml0aWFsLCAhMF07XG4gIHJldHVybiBhO1xufSwgWVMgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gbmV3IE1hcChlLmxvY2Fscyk7XG4gIHJldHVybiBuLmxvY2Fscy5mb3JFYWNoKChzLCBjKSA9PiB7XG4gICAgY29uc3QgaSA9IHNbMF1bMV07XG4gICAgaWYgKCFzWzBdWzBdW0VdKHQpKSB7XG4gICAgICBpZiAoIXIuaGFzKGMpKSB7XG4gICAgICAgIGlmIChPKGksIGMuaW5pdGlhbCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByLnNldChjLCBbW3QsIGMuam9pbihjLmluaXRpYWwsIGkpXV0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gci5nZXQoYyksIFthLCBoXSA9IEdTKGMsIG8sIHMpO1xuICAgICAgaWYgKGgpIHtcbiAgICAgICAgY29uc3QgZCA9IGMuZGlmZihhLCBpKSwgZyA9IG9bMF1bMV0sIHAgPSBjLmpvaW4oZywgYy5wYXRjaChkKShnKSk7XG4gICAgICAgIGlmICghTyhnLCBwKSkge1xuICAgICAgICAgIGxldCBfO1xuICAgICAgICAgIGNvbnN0IGIgPSBvWzBdWzBdO1xuICAgICAgICAgIGJbRV0odCkgPyBfID0gW1tiLCBwXSwgLi4uby5zbGljZSgxKV0gOiBfID0gW1t0LCBwXSwgLi4ub10sIHIuc2V0KGMsIF8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgbmV3IGV0KHIpO1xufSksIFFTID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBmaChlLCBuLCB0KSwgbmV3IGV0KG4pO1xufSksIGZoID0gKGUsIHQsIG4pID0+IHtcbiAgZS5sb2NhbHMuZm9yRWFjaCgociwgcykgPT4ge1xuICAgIGNvbnN0IGMgPSByWzBdWzFdLCBpID0gcy5wYXRjaChzLmZvcmspKGMpO1xuICAgIE8oYywgaSkgPyB0LnNldChzLCByKSA6IHQuc2V0KHMsIFtbbiwgaV0sIC4uLnJdKTtcbiAgfSk7XG59LCBoaCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBuZXcgTWFwKGUubG9jYWxzKTtcbiAgcmV0dXJuIG4uZGVsZXRlKHQpLCBuZXcgZXQobik7XG59KSwgWlMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gZS5sb2NhbHMuaGFzKHQpID8gSSh1ZShlLmxvY2Fscy5nZXQodCkpWzFdKSA6IHYoKSksIEtuID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGYoWlMoZSwgdCksIGRlKCgpID0+IHQuaW5pdGlhbCkpKSwgS2MgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwge1xuICBmaWJlcklkOiB0LFxuICBmaWJlclJlZjogbixcbiAgdmFsdWU6IHJcbn0pID0+IHtcbiAgaWYgKGUubG9jYWxzLnNpemUgPT09IDApXG4gICAgcmV0dXJuIG5ldyBldCgvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW24sIFtbdCwgcl1dXV0pKTtcbiAgY29uc3QgcyA9IG5ldyBNYXAoZS5sb2NhbHMpO1xuICByZXR1cm4gV2MocywgdCwgbiwgciksIG5ldyBldChzKTtcbn0pLCBXYyA9IChlLCB0LCBuLCByKSA9PiB7XG4gIGNvbnN0IHMgPSBlLmdldChuKSA/PyBbXTtcbiAgbGV0IGM7XG4gIGlmIChsZShzKSkge1xuICAgIGNvbnN0IFtpLCBvXSA9IHVlKHMpO1xuICAgIGlmIChpW0VdKHQpKSB7XG4gICAgICBpZiAoTyhvLCByKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYyA9IFtbdCwgcl0sIC4uLnMuc2xpY2UoMSldO1xuICAgIH0gZWxzZVxuICAgICAgYyA9IFtbdCwgcl0sIC4uLnNdO1xuICB9IGVsc2VcbiAgICBjID0gW1t0LCByXV07XG4gIGUuc2V0KG4sIGMpO1xufSwgWFMgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwge1xuICBlbnRyaWVzOiB0LFxuICBmb3JrQXM6IG5cbn0pID0+IHtcbiAgaWYgKGUubG9jYWxzLnNpemUgPT09IDApXG4gICAgcmV0dXJuIG5ldyBldChuZXcgTWFwKHQpKTtcbiAgY29uc3QgciA9IG5ldyBNYXAoZS5sb2NhbHMpO1xuICByZXR1cm4gbiAhPT0gdm9pZCAwICYmIGZoKGUsIHIsIG4pLCB0LmZvckVhY2goKFtzLCBjXSkgPT4ge1xuICAgIGMubGVuZ3RoID09PSAxID8gV2MociwgY1swXVswXSwgcywgY1swXVsxXSkgOiBjLmZvckVhY2goKFtpLCBvXSkgPT4ge1xuICAgICAgV2MociwgaSwgcywgbyk7XG4gICAgfSk7XG4gIH0pLCBuZXcgZXQocik7XG59KSwgZTAgPSBLbiwgdDAgPSBYUywgbjAgPSBIUywgcjAgPSBvYiwgczAgPSBhYiwgYzAgPSB1YiwgaTAgPSBsYiwgbzAgPSBCZiwgYTAgPSBWZiwgdTAgPSBmYiwgbDAgPSBoYiwgZjAgPSAvKiBAX19QVVJFX18gKi8gZih4biwgLyogQF9fUFVSRV9fICovICRnKChlKSA9PiBlLm9yZGluYWwpKSwgaDAgPSAvKiBAX19QVVJFX18gKi8gRWcoZjApLCBkMCA9IChlKSA9PiB7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJBbGxcIjpcbiAgICAgIHJldHVybiByMDtcbiAgICBjYXNlIFwiRGVidWdcIjpcbiAgICAgIHJldHVybiBhMDtcbiAgICBjYXNlIFwiRXJyb3JcIjpcbiAgICAgIHJldHVybiBjMDtcbiAgICBjYXNlIFwiRmF0YWxcIjpcbiAgICAgIHJldHVybiBzMDtcbiAgICBjYXNlIFwiSW5mb1wiOlxuICAgICAgcmV0dXJuIG8wO1xuICAgIGNhc2UgXCJUcmFjZVwiOlxuICAgICAgcmV0dXJuIHUwO1xuICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICByZXR1cm4gbDA7XG4gICAgY2FzZSBcIldhcm5pbmdcIjpcbiAgICAgIHJldHVybiBpMDtcbiAgfVxufSwgZGggPSAoZSkgPT4gZS5yZXBsYWNlKC9bXFxzPVwiXS9nLCBcIl9cIiksIGcwID0gKGUpID0+ICh0KSA9PiBgJHtkaCh0LmxhYmVsKX09JHtlIC0gdC5zdGFydFRpbWV9bXNgLCBtMCA9IHRyLCBwMCA9IGhnO1xuY2xhc3MgYW8gZXh0ZW5kcyBwMCB7XG59XG5jb25zdCBzcyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1JlYWRhYmxlXCIpLCBnaCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1JlZlwiKSwgbWggPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9BOiAoZSkgPT4gZVxufTtcbnZhciB1dSwgbHUsIGZ1O1xuY2xhc3MgXzAgZXh0ZW5kcyAoZnUgPSBhbywgbHUgPSBnaCwgdXUgPSBzcywgZnUpIHtcbiAgY29uc3RydWN0b3Iobikge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInJlZlwiKTtcbiAgICB1KHRoaXMsIGx1LCBtaCk7XG4gICAgdSh0aGlzLCB1dSwgc3MpO1xuICAgIHUodGhpcywgXCJnZXRcIik7XG4gICAgdGhpcy5yZWYgPSBuLCB0aGlzLmdldCA9IHkoKCkgPT4gWmUodGhpcy5yZWYpKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0O1xuICB9XG4gIG1vZGlmeShuKSB7XG4gICAgcmV0dXJuIHkoKCkgPT4ge1xuICAgICAgY29uc3QgciA9IFplKHRoaXMucmVmKSwgW3MsIGNdID0gbihyKTtcbiAgICAgIHJldHVybiByICE9PSBjICYmIHhzKGMpKHRoaXMucmVmKSwgcztcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgcGggPSAoZSkgPT4gbmV3IF8wKFBzKGUpKSwgSmMgPSAoZSkgPT4geSgoKSA9PiBwaChlKSksIG10ID0gKGUpID0+IGUuZ2V0LCBjcyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBlLm1vZGlmeSgoKSA9PiBbdm9pZCAwLCB0XSkpLCB5MCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBlLm1vZGlmeSh0KSksICRhID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGUubW9kaWZ5KChuKSA9PiBbdm9pZCAwLCB0KG4pXSkpLCBfaCA9IFwiRW1wdHlcIiwgeWggPSBcIkFkZFwiLCBiaCA9IFwiUmVtb3ZlXCIsIFNoID0gXCJVcGRhdGVcIiwga2ggPSBcIkFuZFRoZW5cIiwgYjAgPSB7XG4gIF90YWc6IF9oXG59LCB2aCA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBuZXcgTWFwKGUubG9jYWxzKTtcbiAgbGV0IHIgPSBiMDtcbiAgZm9yIChjb25zdCBbcywgY10gb2YgdC5sb2NhbHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgaSA9IHVlKGMpWzFdLCBvID0gbi5nZXQocyk7XG4gICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgYSA9IHVlKG8pWzFdO1xuICAgICAgTyhhLCBpKSB8fCAociA9IG1jKHtcbiAgICAgICAgX3RhZzogU2gsXG4gICAgICAgIGZpYmVyUmVmOiBzLFxuICAgICAgICBwYXRjaDogcy5kaWZmKGEsIGkpXG4gICAgICB9KShyKSk7XG4gICAgfSBlbHNlXG4gICAgICByID0gbWMoe1xuICAgICAgICBfdGFnOiB5aCxcbiAgICAgICAgZmliZXJSZWY6IHMsXG4gICAgICAgIHZhbHVlOiBpXG4gICAgICB9KShyKTtcbiAgICBuLmRlbGV0ZShzKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtzXSBvZiBuLmVudHJpZXMoKSlcbiAgICByID0gbWMoe1xuICAgICAgX3RhZzogYmgsXG4gICAgICBmaWJlclJlZjogc1xuICAgIH0pKHIpO1xuICByZXR1cm4gcjtcbn0sIG1jID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+ICh7XG4gIF90YWc6IGtoLFxuICBmaXJzdDogZSxcbiAgc2Vjb25kOiB0XG59KSksIHdoID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IHtcbiAgbGV0IHIgPSBuLCBzID0ga2UoZSk7XG4gIGZvciAoOyBsZShzKTsgKSB7XG4gICAgY29uc3QgYyA9IHVlKHMpLCBpID0gX3Qocyk7XG4gICAgc3dpdGNoIChjLl90YWcpIHtcbiAgICAgIGNhc2UgX2g6IHtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSB5aDoge1xuICAgICAgICByID0gS2Mociwge1xuICAgICAgICAgIGZpYmVySWQ6IHQsXG4gICAgICAgICAgZmliZXJSZWY6IGMuZmliZXJSZWYsXG4gICAgICAgICAgdmFsdWU6IGMudmFsdWVcbiAgICAgICAgfSksIHMgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYmg6IHtcbiAgICAgICAgciA9IGhoKHIsIGMuZmliZXJSZWYpLCBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFNoOiB7XG4gICAgICAgIGNvbnN0IG8gPSBLbihyLCBjLmZpYmVyUmVmKTtcbiAgICAgICAgciA9IEtjKHIsIHtcbiAgICAgICAgICBmaWJlcklkOiB0LFxuICAgICAgICAgIGZpYmVyUmVmOiBjLmZpYmVyUmVmLFxuICAgICAgICAgIHZhbHVlOiBjLmZpYmVyUmVmLnBhdGNoKGMucGF0Y2gpKG8pXG4gICAgICAgIH0pLCBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGtoOiB7XG4gICAgICAgIHMgPSBLcihjLmZpcnN0KShLcihjLnNlY29uZCkoaSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59KSwgT2ggPSBcImVmZmVjdC9NZXRyaWNMYWJlbFwiLCBIYyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKE9oKTtcbnZhciBodTtcbmNsYXNzIFMwIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJrZXlcIik7XG4gICAgdSh0aGlzLCBcInZhbHVlXCIpO1xuICAgIHUodGhpcywgaHUsIEhjKTtcbiAgICB1KHRoaXMsIFwiX2hhc2hcIik7XG4gICAgdGhpcy5rZXkgPSB0LCB0aGlzLnZhbHVlID0gbiwgdGhpcy5faGFzaCA9IEIoT2ggKyB0aGlzLmtleSArIHRoaXMudmFsdWUpO1xuICB9XG4gIFsoaHUgPSBIYywgRildKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNoO1xuICB9XG4gIFtFXSh0KSB7XG4gICAgcmV0dXJuIHYwKHQpICYmIHRoaXMua2V5ID09PSB0LmtleSAmJiB0aGlzLnZhbHVlID09PSB0LnZhbHVlO1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuY29uc3QgazAgPSAoZSwgdCkgPT4gbmV3IFMwKGUsIHQpLCB2MCA9IChlKSA9PiAkKGUsIEhjKSwgdzAgPSAoZSkgPT4gVChlLCBJKSwgTzAgPSAoZSkgPT4ge1xuICBsZXQgdCwgbjtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IHQgPSBlIDogKHQgPSBlLnRyeSwgbiA9IGUuY2F0Y2gpLCBOKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFMoZWUodCkpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHJldHVybiB4KG4gPyBlZSgoKSA9PiBuKHIpKSA6IG5ldyBHcyhyLCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgaW4gRWZmZWN0LnRyeVwiKSk7XG4gICAgfVxuICB9KTtcbn0sICQwID0gKGUpID0+IEEwKGUsIEkwLCB2aCksIEUwID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IE4oKCkgPT4gdChlKSA/IFMoZSkgOiB4KG4oZSkpKSksICRoID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFhlKGUsIHtcbiAgb25GYWlsdXJlOiAobikgPT4gUyh0Lm9uRmFpbHVyZShuKSksXG4gIG9uU3VjY2VzczogKG4pID0+IFModC5vblN1Y2Nlc3MobikpXG59KSksIEkwID0gLyogQF9fUFVSRV9fICovIEwoKGUpID0+IFMoZS5nZXRGaWJlclJlZnMoKSkpLCBGMCA9IChlKSA9PiAkaChlLCB7XG4gIG9uRmFpbHVyZTogU2MsXG4gIG9uU3VjY2VzczogU2Ncbn0pLCBFYSA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBTZShlLCB7XG4gIG9uRmFpbHVyZTogKG4pID0+IHhmKCgpID0+IHQobikpLFxuICBvblN1Y2Nlc3M6IFNcbn0pKSwgUjAgPSAoZSkgPT4gVChlLCAodCkgPT4gIXQpLCBNMCA9IChlKSA9PiBqMCgodCwgbikgPT4gZihlLCB3aCh0LCBuKSkpLCBUMCA9IChlKSA9PiBlLmxlbmd0aCA+PSAxID8geGUoKHQsIG4pID0+IHtcbiAgdHJ5IHtcbiAgICBlKG4pLnRoZW4oKHIpID0+IHQoaihyKSksIChyKSA9PiB0KEZuKHIpKSk7XG4gIH0gY2F0Y2ggKHIpIHtcbiAgICB0KEZuKHIpKTtcbiAgfVxufSkgOiB4ZSgodCkgPT4ge1xuICB0cnkge1xuICAgIGUoKS50aGVuKChuKSA9PiB0KGoobikpLCAobikgPT4gdChGbihuKSkpO1xuICB9IGNhdGNoIChuKSB7XG4gICAgdChGbihuKSk7XG4gIH1cbn0pLCBFaCA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBibigocikgPT4gc28oZSwgQXQociwgdCwgbikpKSksIEMwID0gS1MsIE4wID0gLyogQF9fUFVSRV9fICovIFMoLyogQF9fUFVSRV9fICovIHYoKSksIEEwID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IG0odCwgKHIpID0+IG0oZSwgKHMpID0+IFQodCwgKGMpID0+IFtuKHIsIGMpLCBzXSkpKSksIFAwID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IFNlKGUsIHtcbiAgb25GYWlsdXJlOiAobikgPT4gb2UodChuKSwgWihuKSksXG4gIG9uU3VjY2VzczogU1xufSkpLCB4MCA9IChlKSA9PiB7XG4gIGxldCB0LCBuO1xuICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyB0ID0gZSA6ICh0ID0gZS50cnksIG4gPSBlLmNhdGNoKTtcbiAgY29uc3QgciA9IChzKSA9PiBuID8gVXMoKCkgPT4gbihzKSkgOiB4KG5ldyBHcyhzLCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgaW4gRWZmZWN0LnRyeVByb21pc2VcIikpO1xuICByZXR1cm4gdC5sZW5ndGggPj0gMSA/IHhlKChzLCBjKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHQoYykudGhlbigoaSkgPT4gcyhqKGkpKSwgKGkpID0+IHMocihpKSkpO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIHMocihpKSk7XG4gICAgfVxuICB9KSA6IHhlKChzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHQoKS50aGVuKChjKSA9PiBzKGooYykpLCAoYykgPT4gcyhyKGMpKSk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgcyhyKGMpKTtcbiAgICB9XG4gIH0pO1xufSwgajAgPSAoZSkgPT4gTCgodCkgPT4gKHQuc2V0RmliZXJSZWZzKGUodC5pZCgpLCB0LmdldEZpYmVyUmVmcygpKSksIEspKSwgTDAgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gTigoKSA9PiB0KCkgPyBUKGUsIEkpIDogUyh2KCkpKSksIEQwID0gKGUpID0+IGUgPT0gbnVsbCA/IHgobmV3IEhzKCkpIDogUyhlKSwgSWggPSBcIlNlcXVlbnRpYWxcIiwgRmggPSBcIlBhcmFsbGVsXCIsIHEwID0gXCJQYXJhbGxlbE5cIiwgWnMgPSB7XG4gIF90YWc6IEloXG59LCBVMCA9IHtcbiAgX3RhZzogRmhcbn0sIHowID0gKGUpID0+ICh7XG4gIF90YWc6IHEwLFxuICBwYXJhbGxlbGlzbTogZVxufSksIEIwID0gKGUpID0+IGUuX3RhZyA9PT0gSWgsIFYwID0gKGUpID0+IGUuX3RhZyA9PT0gRmgsIEdjID0gWnMsIFljID0gVTAsIFFjID0gejAsIFduID0gdmgsIEpuID0gd2gsIFhzID0gXCJlZmZlY3QvRmliZXJTdGF0dXNcIiwgRXQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihYcyksIGlzID0gXCJEb25lXCIsIElhID0gXCJSdW5uaW5nXCIsIEZhID0gXCJTdXNwZW5kZWRcIiwgSzAgPSAvKiBAX19QVVJFX18gKi8gQihgJHtYc30tJHtpc31gKTtcbnZhciBkdTtcbmNsYXNzIFcwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdSh0aGlzLCBkdSwgRXQpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIGlzKTtcbiAgfVxuICBbKGR1ID0gRXQsIEYpXSgpIHtcbiAgICByZXR1cm4gSzA7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4gdW8odCkgJiYgdC5fdGFnID09PSBpcztcbiAgfVxufVxudmFyIGd1O1xuY2xhc3MgSjAge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcInJ1bnRpbWVGbGFnc1wiKTtcbiAgICB1KHRoaXMsIGd1LCBFdCk7XG4gICAgdSh0aGlzLCBcIl90YWdcIiwgSWEpO1xuICAgIHRoaXMucnVudGltZUZsYWdzID0gdDtcbiAgfVxuICBbKGd1ID0gRXQsIEYpXSgpIHtcbiAgICByZXR1cm4gZihrKFhzKSwgUihrKHRoaXMuX3RhZykpLCBSKGsodGhpcy5ydW50aW1lRmxhZ3MpKSwgcSh0aGlzKSk7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4gdW8odCkgJiYgdC5fdGFnID09PSBJYSAmJiB0aGlzLnJ1bnRpbWVGbGFncyA9PT0gdC5ydW50aW1lRmxhZ3M7XG4gIH1cbn1cbnZhciBtdTtcbmNsYXNzIEgwIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJydW50aW1lRmxhZ3NcIik7XG4gICAgdSh0aGlzLCBcImJsb2NraW5nT25cIik7XG4gICAgdSh0aGlzLCBtdSwgRXQpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIEZhKTtcbiAgICB0aGlzLnJ1bnRpbWVGbGFncyA9IHQsIHRoaXMuYmxvY2tpbmdPbiA9IG47XG4gIH1cbiAgWyhtdSA9IEV0LCBGKV0oKSB7XG4gICAgcmV0dXJuIGYoayhYcyksIFIoayh0aGlzLl90YWcpKSwgUihrKHRoaXMucnVudGltZUZsYWdzKSksIFIoayh0aGlzLmJsb2NraW5nT24pKSwgcSh0aGlzKSk7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4gdW8odCkgJiYgdC5fdGFnID09PSBGYSAmJiB0aGlzLnJ1bnRpbWVGbGFncyA9PT0gdC5ydW50aW1lRmxhZ3MgJiYgTyh0aGlzLmJsb2NraW5nT24sIHQuYmxvY2tpbmdPbik7XG4gIH1cbn1cbmNvbnN0IEcwID0gLyogQF9fUFVSRV9fICovIG5ldyBXMCgpLCBZMCA9IChlKSA9PiBuZXcgSjAoZSksIFEwID0gKGUsIHQpID0+IG5ldyBIMChlLCB0KSwgdW8gPSAoZSkgPT4gJChlLCBFdCksIFowID0gKGUpID0+IGUuX3RhZyA9PT0gaXMsIFgwID0gRzAsIFJoID0gWTAsIGVrID0gUTAsIHRrID0gWjAsIG5rID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm9cIiksIG9zID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9FeGl0XCIpLCBSYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL01pY3JvQ2F1c2VcIiksIHJrID0ge1xuICBfRTogUFxufTtcbnZhciBwdTtcbmNsYXNzIE1oIGV4dGVuZHMgZ2xvYmFsVGhpcy5FcnJvciB7XG4gIGNvbnN0cnVjdG9yKG4sIHIsIHMpIHtcbiAgICBjb25zdCBjID0gYE1pY3JvQ2F1c2UuJHtufWA7XG4gICAgbGV0IGksIG8sIGE7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yKSB7XG4gICAgICBpID0gYCgke2N9KSAke3IubmFtZX1gLCBvID0gci5tZXNzYWdlO1xuICAgICAgY29uc3QgaCA9IG8uc3BsaXQoYFxuYCkubGVuZ3RoO1xuICAgICAgYSA9IHIuc3RhY2sgPyBgKCR7Y30pICR7ci5zdGFjay5zcGxpdChgXG5gKS5zbGljZSgwLCBoICsgMykuam9pbihgXG5gKX1gIDogYCR7aX06ICR7b31gO1xuICAgIH0gZWxzZVxuICAgICAgaSA9IGMsIG8gPSBVdChyLCAwKSwgYSA9IGAke2l9OiAke299YDtcbiAgICBzLmxlbmd0aCA+IDAgJiYgKGEgKz0gYFxuICAgICR7cy5qb2luKGBcbiAgICBgKX1gKTtcbiAgICBzdXBlcihvKTtcbiAgICB1KHRoaXMsIFwiX3RhZ1wiKTtcbiAgICB1KHRoaXMsIFwidHJhY2VzXCIpO1xuICAgIHUodGhpcywgcHUpO1xuICAgIHRoaXMuX3RhZyA9IG4sIHRoaXMudHJhY2VzID0gcywgdGhpc1tSYV0gPSByaywgdGhpcy5uYW1lID0gaSwgdGhpcy5zdGFjayA9IGE7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG4gIFsocHUgPSBSYSwgVSldKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG59XG5jbGFzcyBzayBleHRlbmRzIE1oIHtcbiAgY29uc3RydWN0b3IobiwgciA9IFtdKSB7XG4gICAgc3VwZXIoXCJEaWVcIiwgbiwgcik7XG4gICAgdSh0aGlzLCBcImRlZmVjdFwiKTtcbiAgICB0aGlzLmRlZmVjdCA9IG47XG4gIH1cbn1cbmNvbnN0IGNrID0gKGUsIHQgPSBbXSkgPT4gbmV3IHNrKGUsIHQpO1xuY2xhc3MgaWsgZXh0ZW5kcyBNaCB7XG4gIGNvbnN0cnVjdG9yKHQgPSBbXSkge1xuICAgIHN1cGVyKFwiSW50ZXJydXB0XCIsIFwiaW50ZXJydXB0ZWRcIiwgdCk7XG4gIH1cbn1cbmNvbnN0IG9rID0gKGUgPSBbXSkgPT4gbmV3IGlrKGUpLCBhayA9IChlKSA9PiBlLl90YWcgPT09IFwiSW50ZXJydXB0XCIsIE1hID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9GaWJlclwiKSwgdWsgPSB7XG4gIF9BOiBQLFxuICBfRTogUFxufTtcbnZhciBfdTtcbl91ID0gTWE7XG5jbGFzcyBsayB7XG4gIGNvbnN0cnVjdG9yKHQsIG4gPSAhMCkge1xuICAgIHUodGhpcywgXCJjb250ZXh0XCIpO1xuICAgIHUodGhpcywgXCJpbnRlcnJ1cHRpYmxlXCIpO1xuICAgIHUodGhpcywgX3UpO1xuICAgIHUodGhpcywgXCJfc3RhY2tcIiwgW10pO1xuICAgIHUodGhpcywgXCJfb2JzZXJ2ZXJzXCIsIFtdKTtcbiAgICB1KHRoaXMsIFwiX2V4aXRcIik7XG4gICAgdSh0aGlzLCBcIl9jaGlsZHJlblwiKTtcbiAgICB1KHRoaXMsIFwiY3VycmVudE9wQ291bnRcIiwgMCk7XG4gICAgdSh0aGlzLCBcIl9pbnRlcnJ1cHRlZFwiLCAhMSk7XG4gICAgLy8gY2FuY2VsIHRoZSB5aWVsZGVkIG9wZXJhdGlvbiwgb3IgZm9yIHRoZSB5aWVsZGVkIGV4aXQgdmFsdWVcbiAgICB1KHRoaXMsIFwiX3lpZWxkZWRcIik7XG4gICAgdGhpcy5jb250ZXh0ID0gdCwgdGhpcy5pbnRlcnJ1cHRpYmxlID0gbiwgdGhpc1tNYV0gPSB1aztcbiAgfVxuICBnZXRSZWYodCkge1xuICAgIHJldHVybiBwbSh0aGlzLmNvbnRleHQsIHQpO1xuICB9XG4gIGFkZE9ic2VydmVyKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhpdCA/ICh0KHRoaXMuX2V4aXQpLCBTYykgOiAodGhpcy5fb2JzZXJ2ZXJzLnB1c2godCksICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZih0KTtcbiAgICAgIG4gPj0gMCAmJiB0aGlzLl9vYnNlcnZlcnMuc3BsaWNlKG4sIDEpO1xuICAgIH0pO1xuICB9XG4gIHVuc2FmZUludGVycnVwdCgpIHtcbiAgICB0aGlzLl9leGl0IHx8ICh0aGlzLl9pbnRlcnJ1cHRlZCA9ICEwLCB0aGlzLmludGVycnVwdGlibGUgJiYgdGhpcy5ldmFsdWF0ZShtbykpO1xuICB9XG4gIHVuc2FmZVBvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4aXQ7XG4gIH1cbiAgZXZhbHVhdGUodCkge1xuICAgIGlmICh0aGlzLl9leGl0KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLl95aWVsZGVkICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLl95aWVsZGVkO1xuICAgICAgdGhpcy5feWllbGRlZCA9IHZvaWQgMCwgcygpO1xuICAgIH1cbiAgICBjb25zdCBuID0gdGhpcy5ydW5Mb29wKHQpO1xuICAgIGlmIChuID09PSBGcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gVGEuaW50ZXJydXB0Q2hpbGRyZW4gJiYgVGEuaW50ZXJydXB0Q2hpbGRyZW4odGhpcyk7XG4gICAgaWYgKHIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlKHVzKHIsICgpID0+IG4pKTtcbiAgICB0aGlzLl9leGl0ID0gbjtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMuX29ic2VydmVycy5sZW5ndGg7IHMrKylcbiAgICAgIHRoaXMuX29ic2VydmVyc1tzXShuKTtcbiAgICB0aGlzLl9vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgfVxuICBydW5Mb29wKHQpIHtcbiAgICBsZXQgbiA9ICExLCByID0gdDtcbiAgICB0aGlzLmN1cnJlbnRPcENvdW50ID0gMDtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRPcENvdW50KyssICFuICYmIHRoaXMuZ2V0UmVmKHBvKS5zaG91bGRZaWVsZCh0aGlzKSkge1xuICAgICAgICAgIG4gPSAhMDtcbiAgICAgICAgICBjb25zdCBzID0gcjtcbiAgICAgICAgICByID0gdXMobWssICgpID0+IHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyID0gcltaY10odGhpcyksIHIgPT09IEZyKSB7XG4gICAgICAgICAgY29uc3QgcyA9IHRoaXMuX3lpZWxkZWQ7XG4gICAgICAgICAgcmV0dXJuIG9zIGluIHMgPyAodGhpcy5feWllbGRlZCA9IHZvaWQgMCwgcykgOiBGcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHJldHVybiAkKHIsIFpjKSA/IFhjKHMpIDogWGMoYE1pY3JvRmliZXIucnVuTG9vcDogTm90IGEgdmFsaWQgZWZmZWN0OiAke1N0cmluZyhyKX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q29udCh0KSB7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fc3RhY2sucG9wKCk7XG4gICAgICBpZiAoIW4pIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBuW2FzXSAmJiBuW2FzXSh0aGlzKTtcbiAgICAgIGlmIChyKSByZXR1cm4ge1xuICAgICAgICBbdF06IHJcbiAgICAgIH07XG4gICAgICBpZiAoblt0XSkgcmV0dXJuIG47XG4gICAgfVxuICB9XG4gIHlpZWxkV2l0aCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3lpZWxkZWQgPSB0LCBGcjtcbiAgfVxuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gPz8gKHRoaXMuX2NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbn1cbmNvbnN0IFRhID0gLyogQF9fUFVSRV9fICovIEMoXCJlZmZlY3QvTWljcm8vZmliZXJNaWRkbGV3YXJlXCIsICgpID0+ICh7XG4gIGludGVycnVwdENoaWxkcmVuOiB2b2lkIDBcbn0pKSwgVGggPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9pZGVudGlmaWVyXCIpLCBZID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vYXJnc1wiKSwgWmMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9ldmFsdWF0ZVwiKSwgc24gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9zdWNjZXNzQ29udFwiKSwgcXQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9mYWlsdXJlQ29udFwiKSwgYXMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9lbnN1cmVDb250XCIpLCBGciA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL1lpZWxkXCIpLCBmayA9IHtcbiAgX0E6IFAsXG4gIF9FOiBQLFxuICBfUjogUFxufSwgaGsgPSB7XG4gIC4uLm0wLFxuICBfb3A6IFwiTWljcm9cIixcbiAgW25rXTogZmssXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBybChuZXcgWG4odGhpcykpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJNaWNyb1wiLFxuICAgICAgb3A6IHRoaXNbVGhdLFxuICAgICAgLi4uWSBpbiB0aGlzID8ge1xuICAgICAgICBhcmdzOiB0aGlzW1ldXG4gICAgICB9IDogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFEodGhpcyk7XG4gIH0sXG4gIFtVXSgpIHtcbiAgICByZXR1cm4gUSh0aGlzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRrKGUpIHtcbiAgcmV0dXJuIFhjKFwiTWljcm8uZXZhbHVhdGU6IE5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cbmNvbnN0IGVjID0gKGUpID0+ICh7XG4gIC4uLmhrLFxuICBbVGhdOiBlLm9wLFxuICBbWmNdOiBlLmV2YWwgPz8gZGssXG4gIFtzbl06IGUuY29udEEsXG4gIFtxdF06IGUuY29udEUsXG4gIFthc106IGUuZW5zdXJlXG59KSwgbG8gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gZWMoZSk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZSh0KTtcbiAgICByZXR1cm4gbltZXSA9IGUuc2luZ2xlID09PSAhMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSwgbjtcbiAgfTtcbn0sIENoID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IHtcbiAgICAuLi5lYyhlKSxcbiAgICBbb3NdOiBvcyxcbiAgICBfdGFnOiBlLm9wLFxuICAgIGdldCBbZS5wcm9wXSgpIHtcbiAgICAgIHJldHVybiB0aGlzW1ldO1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2lkOiBcIk1pY3JvRXhpdFwiLFxuICAgICAgICBfdGFnOiBlLm9wLFxuICAgICAgICBbZS5wcm9wXTogdGhpc1tZXVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtFXShuKSB7XG4gICAgICByZXR1cm4geWsobikgJiYgbi5fdGFnID09PSBlLm9wICYmIE8odGhpc1tZXSwgbltZXSk7XG4gICAgfSxcbiAgICBbRl0oKSB7XG4gICAgICByZXR1cm4gcSh0aGlzLCBSKEIoZS5vcCkpKGsodGhpc1tZXSkpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgY29uc3QgciA9IE9iamVjdC5jcmVhdGUodCk7XG4gICAgcmV0dXJuIHJbWV0gPSBuLCByW3NuXSA9IHZvaWQgMCwgcltxdF0gPSB2b2lkIDAsIHJbYXNdID0gdm9pZCAwLCByO1xuICB9O1xufSwgZm8gPSAvKiBAX19QVVJFX18gKi8gQ2goe1xuICBvcDogXCJTdWNjZXNzXCIsXG4gIHByb3A6IFwidmFsdWVcIixcbiAgZXZhbChlKSB7XG4gICAgY29uc3QgdCA9IGUuZ2V0Q29udChzbik7XG4gICAgcmV0dXJuIHQgPyB0W3NuXSh0aGlzW1ldLCBlKSA6IGUueWllbGRXaXRoKHRoaXMpO1xuICB9XG59KSwgTmggPSAvKiBAX19QVVJFX18gKi8gQ2goe1xuICBvcDogXCJGYWlsdXJlXCIsXG4gIHByb3A6IFwiY2F1c2VcIixcbiAgZXZhbChlKSB7XG4gICAgbGV0IHQgPSBlLmdldENvbnQocXQpO1xuICAgIGZvciAoOyBhayh0aGlzW1ldKSAmJiB0ICYmIGUuaW50ZXJydXB0aWJsZTsgKVxuICAgICAgdCA9IGUuZ2V0Q29udChxdCk7XG4gICAgcmV0dXJuIHQgPyB0W3F0XSh0aGlzW1ldLCBlKSA6IGUueWllbGRXaXRoKHRoaXMpO1xuICB9XG59KSwgZ2sgPSAvKiBAX19QVVJFX18gKi8gbG8oe1xuICBvcDogXCJZaWVsZFwiLFxuICBldmFsKGUpIHtcbiAgICBsZXQgdCA9ICExO1xuICAgIHJldHVybiBlLmdldFJlZihwbykuc2NoZWR1bGVUYXNrKCgpID0+IHtcbiAgICAgIHQgfHwgZS5ldmFsdWF0ZShiayk7XG4gICAgfSwgdGhpc1tZXSA/PyAwKSwgZS55aWVsZFdpdGgoKCkgPT4ge1xuICAgICAgdCA9ICEwO1xuICAgIH0pO1xuICB9XG59KSwgbWsgPSAvKiBAX19QVVJFX18gKi8gZ2soMCksIHBrID0gLyogQF9fUFVSRV9fICovIGZvKHZvaWQgMCksIGhvID0gLyogQF9fUFVSRV9fICovIGxvKHtcbiAgb3A6IFwiV2l0aE1pY3JvRmliZXJcIixcbiAgZXZhbChlKSB7XG4gICAgcmV0dXJuIHRoaXNbWV0oZSk7XG4gIH1cbn0pLCB1cyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKF9rKTtcbiAgcmV0dXJuIG5bWV0gPSBlLCBuW3NuXSA9IHQsIG47XG59KSwgX2sgPSAvKiBAX19QVVJFX18gKi8gZWMoe1xuICBvcDogXCJPblN1Y2Nlc3NcIixcbiAgZXZhbChlKSB7XG4gICAgcmV0dXJuIGUuX3N0YWNrLnB1c2godGhpcyksIHRoaXNbWV07XG4gIH1cbn0pLCB5ayA9IChlKSA9PiAkKGUsIG9zKSwgQWggPSBmbywgZ28gPSBOaCwgbW8gPSAvKiBAX19QVVJFX18gKi8gZ28oLyogQF9fUFVSRV9fICovIG9rKCkpLCBYYyA9IChlKSA9PiBnbyhjayhlKSksIGJrID0gLyogQF9fUFVSRV9fICovIEFoKHZvaWQgMCksIFNrID0gXCJzZXRJbW1lZGlhdGVcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5zZXRJbW1lZGlhdGUgOiAoZSkgPT4gc2V0VGltZW91dChlLCAwKTtcbmNsYXNzIFBoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdSh0aGlzLCBcInRhc2tzXCIsIFtdKTtcbiAgICB1KHRoaXMsIFwicnVubmluZ1wiLCAhMSk7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuNS45XG4gICAgICovXG4gICAgdSh0aGlzLCBcImFmdGVyU2NoZWR1bGVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMucnVubmluZyA9ICExLCB0aGlzLnJ1blRhc2tzKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgc2NoZWR1bGVUYXNrKHQsIG4pIHtcbiAgICB0aGlzLnRhc2tzLnB1c2godCksIHRoaXMucnVubmluZyB8fCAodGhpcy5ydW5uaW5nID0gITAsIFNrKHRoaXMuYWZ0ZXJTY2hlZHVsZWQpKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDMuNS45XG4gICAqL1xuICBydW5UYXNrcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50YXNrcztcbiAgICB0aGlzLnRhc2tzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDAsIHIgPSB0Lmxlbmd0aDsgbiA8IHI7IG4rKylcbiAgICAgIHRbbl0oKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDMuNS45XG4gICAqL1xuICBzaG91bGRZaWVsZCh0KSB7XG4gICAgcmV0dXJuIHQuY3VycmVudE9wQ291bnQgPj0gdC5nZXRSZWYod2spO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMy41LjlcbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGZvciAoOyB0aGlzLnRhc2tzLmxlbmd0aCA+IDA7IClcbiAgICAgIHRoaXMucnVuVGFza3MoKTtcbiAgfVxufVxuY29uc3Qga2sgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gaG8oKG4pID0+IHtcbiAgY29uc3QgciA9IG4uY29udGV4dDtcbiAgcmV0dXJuIG4uY29udGV4dCA9IHQociksIEVrKGUsICgpID0+IChuLmNvbnRleHQgPSByLCBwaykpO1xufSkpLCB2ayA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBrayhlLCBmbih0KSkpO1xuY2xhc3Mgd2sgZXh0ZW5kcyAoLyogQF9fUFVSRV9fICovICRpKCkoXCJlZmZlY3QvTWljcm8vY3VycmVudE1heE9wc0JlZm9yZVlpZWxkXCIsIHtcbiAgZGVmYXVsdFZhbHVlOiAoKSA9PiAyMDQ4XG59KSkge1xufVxuY2xhc3MgcG8gZXh0ZW5kcyAoLyogQF9fUFVSRV9fICovICRpKCkoXCJlZmZlY3QvTWljcm8vY3VycmVudFNjaGVkdWxlclwiLCB7XG4gIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IFBoKClcbn0pKSB7XG59XG5jb25zdCBPayA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKCRrKTtcbiAgcmV0dXJuIG5bWV0gPSBlLCBuW3NuXSA9IHQub25TdWNjZXNzLCBuW3F0XSA9IHQub25GYWlsdXJlLCBuO1xufSksICRrID0gLyogQF9fUFVSRV9fICovIGVjKHtcbiAgb3A6IFwiT25TdWNjZXNzQW5kRmFpbHVyZVwiLFxuICBldmFsKGUpIHtcbiAgICByZXR1cm4gZS5fc3RhY2sucHVzaCh0aGlzKSwgdGhpc1tZXTtcbiAgfVxufSksIEVrID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEZrKChuKSA9PiBPayhuKGUpLCB7XG4gIG9uRmFpbHVyZTogKHIpID0+IHVzKHQoZ28ocikpLCAoKSA9PiBOaChyKSksXG4gIG9uU3VjY2VzczogKHIpID0+IHVzKHQoQWgocikpLCAoKSA9PiBmbyhyKSlcbn0pKSksIHhoID0gLyogQF9fUFVSRV9fICovIGxvKHtcbiAgb3A6IFwiU2V0SW50ZXJydXB0aWJsZVwiLFxuICBlbnN1cmUoZSkge1xuICAgIGlmIChlLmludGVycnVwdGlibGUgPSB0aGlzW1ldLCBlLl9pbnRlcnJ1cHRlZCAmJiBlLmludGVycnVwdGlibGUpXG4gICAgICByZXR1cm4gKCkgPT4gbW87XG4gIH1cbn0pLCBJayA9IChlKSA9PiBobygodCkgPT4gdC5pbnRlcnJ1cHRpYmxlID8gZSA6ICh0LmludGVycnVwdGlibGUgPSAhMCwgdC5fc3RhY2sucHVzaCh4aCghMSkpLCB0Ll9pbnRlcnJ1cHRlZCA/IG1vIDogZSkpLCBGayA9IChlKSA9PiBobygodCkgPT4gdC5pbnRlcnJ1cHRpYmxlID8gKHQuaW50ZXJydXB0aWJsZSA9ICExLCB0Ll9zdGFjay5wdXNoKHhoKCEwKSksIGUoSWspKSA6IGUoUCkpLCBSayA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBuZXcgbGsocG8uY29udGV4dChuZXcgUGgoKSkpO1xuICByZXR1cm4gbi5ldmFsdWF0ZShlKSwgbjtcbn07XG5jbGFzcyBqaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHUodGhpcywgXCJidWNrZXRzXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBzY2hlZHVsZVRhc2sodCwgbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1Y2tldHMubGVuZ3RoO1xuICAgIGxldCBzLCBjID0gMDtcbiAgICBmb3IgKDsgYyA8IHIgJiYgdGhpcy5idWNrZXRzW2NdWzBdIDw9IG47IGMrKylcbiAgICAgIHMgPSB0aGlzLmJ1Y2tldHNbY107XG4gICAgcyAmJiBzWzBdID09PSBuID8gc1sxXS5wdXNoKHQpIDogYyA9PT0gciA/IHRoaXMuYnVja2V0cy5wdXNoKFtuLCBbdF1dKSA6IHRoaXMuYnVja2V0cy5zcGxpY2UoYywgMCwgW24sIFt0XV0pO1xuICB9XG59XG5jbGFzcyBNayB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwibWF4TmV4dFRpY2tCZWZvcmVUaW1lclwiKTtcbiAgICAvKipcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwicnVubmluZ1wiLCAhMSk7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdSh0aGlzLCBcInRhc2tzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgamgoKSk7XG4gICAgdGhpcy5tYXhOZXh0VGlja0JlZm9yZVRpbWVyID0gdDtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBzdGFydmVJbnRlcm5hbCh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMudGFza3MuYnVja2V0cztcbiAgICB0aGlzLnRhc2tzLmJ1Y2tldHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtyLCBzXSBvZiBuKVxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBzLmxlbmd0aDsgYysrKVxuICAgICAgICBzW2NdKCk7XG4gICAgdGhpcy50YXNrcy5idWNrZXRzLmxlbmd0aCA9PT0gMCA/IHRoaXMucnVubmluZyA9ICExIDogdGhpcy5zdGFydmUodCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgc3RhcnZlKHQgPSAwKSB7XG4gICAgdCA+PSB0aGlzLm1heE5leHRUaWNrQmVmb3JlVGltZXIgPyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnZlSW50ZXJuYWwoMCksIDApIDogUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCkudGhlbigoKSA9PiB0aGlzLnN0YXJ2ZUludGVybmFsKHQgKyAxKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgc2hvdWxkWWllbGQodCkge1xuICAgIHJldHVybiB0LmN1cnJlbnRPcENvdW50ID4gdC5nZXRGaWJlclJlZihXZikgPyB0LmdldEZpYmVyUmVmKGRyKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNjaGVkdWxlVGFzayh0LCBuKSB7XG4gICAgdGhpcy50YXNrcy5zY2hlZHVsZVRhc2sodCwgbiksIHRoaXMucnVubmluZyB8fCAodGhpcy5ydW5uaW5nID0gITAsIHRoaXMuc3RhcnZlKCkpO1xuICB9XG59XG5jb25zdCBMaCA9IC8qIEBfX1BVUkVfXyAqLyBDKC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1NjaGVkdWxlci9kZWZhdWx0U2NoZWR1bGVyXCIpLCAoKSA9PiBuZXcgTWsoMjA0OCkpO1xuY2xhc3MgVGsge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwidGFza3NcIiwgLyogQF9fUFVSRV9fICovIG5ldyBqaCgpKTtcbiAgICAvKipcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZGVmZXJyZWRcIiwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNjaGVkdWxlVGFzayh0LCBuKSB7XG4gICAgdGhpcy5kZWZlcnJlZCA/IExoLnNjaGVkdWxlVGFzayh0LCBuKSA6IHRoaXMudGFza3Muc2NoZWR1bGVUYXNrKHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNob3VsZFlpZWxkKHQpIHtcbiAgICByZXR1cm4gdC5jdXJyZW50T3BDb3VudCA+IHQuZ2V0RmliZXJSZWYoV2YpID8gdC5nZXRGaWJlclJlZihkcikgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICBmb3IgKDsgdGhpcy50YXNrcy5idWNrZXRzLmxlbmd0aCA+IDA7ICkge1xuICAgICAgY29uc3QgdCA9IHRoaXMudGFza3MuYnVja2V0cztcbiAgICAgIHRoaXMudGFza3MuYnVja2V0cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbbiwgcl0gb2YgdClcbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKVxuICAgICAgICAgIHJbc10oKTtcbiAgICB9XG4gICAgdGhpcy5kZWZlcnJlZCA9ICEwO1xuICB9XG59XG5jb25zdCBfbyA9IC8qIEBfX1BVUkVfXyAqLyBDKC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0ZpYmVyUmVmL2N1cnJlbnRTY2hlZHVsZXJcIiksICgpID0+IGdlKExoKSksIERoID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvRmliZXJSZWYvY3VycmVudFJlcXVlc3RNYXBcIiksICgpID0+IGdlKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpKSwgQ2EgPSAoZSwgdCwgbiwgcikgPT4ge1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIHZvaWQgMDpcbiAgICAgIHJldHVybiB0KCk7XG4gICAgY2FzZSBcInVuYm91bmRlZFwiOlxuICAgICAgcmV0dXJuIG4oKTtcbiAgICBjYXNlIFwiaW5oZXJpdFwiOlxuICAgICAgcmV0dXJuIFdzKCRiLCAocykgPT4gcyA9PT0gXCJ1bmJvdW5kZWRcIiA/IG4oKSA6IHMgPiAxID8gcihzKSA6IHQoKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBlID4gMSA/IHIoZSkgOiB0KCk7XG4gIH1cbn0sIHlvID0gXCJJbnRlcnJ1cHRTaWduYWxcIiwgYm8gPSBcIlN0YXRlZnVsXCIsIFNvID0gXCJSZXN1bWVcIiwga28gPSBcIllpZWxkTm93XCIsIHBjID0gKGUpID0+ICh7XG4gIF90YWc6IHlvLFxuICBjYXVzZTogZVxufSksIGpyID0gKGUpID0+ICh7XG4gIF90YWc6IGJvLFxuICBvbkZpYmVyOiBlXG59KSwgQ3QgPSAoZSkgPT4gKHtcbiAgX3RhZzogU28sXG4gIGVmZmVjdDogZVxufSksIENrID0gKCkgPT4gKHtcbiAgX3RhZzoga29cbn0pLCBOayA9IFwiZWZmZWN0L0ZpYmVyU2NvcGVcIiwgbHMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihOayk7XG52YXIgeXU7XG55dSA9IGxzO1xuY2xhc3MgQWsge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB1KHRoaXMsIHl1LCBscyk7XG4gICAgdSh0aGlzLCBcImZpYmVySWRcIiwgSHQpO1xuICAgIHUodGhpcywgXCJyb290c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICBhZGQodCwgbikge1xuICAgIHRoaXMucm9vdHMuYWRkKG4pLCBuLmFkZE9ic2VydmVyKCgpID0+IHtcbiAgICAgIHRoaXMucm9vdHMuZGVsZXRlKG4pO1xuICAgIH0pO1xuICB9XG59XG52YXIgYnU7XG5idSA9IGxzO1xuY2xhc3MgUGsge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdSh0aGlzLCBcImZpYmVySWRcIik7XG4gICAgdSh0aGlzLCBcInBhcmVudFwiKTtcbiAgICB1KHRoaXMsIGJ1LCBscyk7XG4gICAgdGhpcy5maWJlcklkID0gdCwgdGhpcy5wYXJlbnQgPSBuO1xuICB9XG4gIGFkZCh0LCBuKSB7XG4gICAgdGhpcy5wYXJlbnQudGVsbChqcigocikgPT4ge1xuICAgICAgci5hZGRDaGlsZChuKSwgbi5hZGRPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIHIucmVtb3ZlQ2hpbGQobik7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IHhrID0gKGUpID0+IG5ldyBQayhlLmlkKCksIGUpLCB0YyA9IC8qIEBfX1BVUkVfXyAqLyBDKC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L0ZpYmVyU2NvcGUvR2xvYmFsXCIpLCAoKSA9PiBuZXcgQWsoKSksIGprID0gXCJlZmZlY3QvRmliZXJcIiwgTGsgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihqayksIERrID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfRTogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9BOiAoZSkgPT4gZVxufSwgcWsgPSBcImVmZmVjdC9GaWJlclwiLCBVayA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKHFrKSwgeEUgPSAoZSkgPT4gZS5hd2FpdCwgakUgPSAoZSkgPT4gZS5pbmhlcml0QWxsLCBmcyA9IChlKSA9PiBaaSh6cyhlLmF3YWl0KSwgZS5pbmhlcml0QWxsKTtcbih7XG4gIC4uLm5yXG59KTtcbmNvbnN0IGN0ID0gXCJlZmZlY3QvRmliZXJDdXJyZW50XCIsIHprID0gXCJlZmZlY3QvTG9nZ2VyXCIsIEJrID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoemspLCBWayA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX01lc3NhZ2U6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0cHV0OiAoZSkgPT4gZVxufSwgdm8gPSAoZSkgPT4gKHtcbiAgW0JrXTogVmssXG4gIGxvZzogZSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59KSwgS2sgPSAvXlteXFxzXCI9XSokLywgV2sgPSAoZSwgdCkgPT4gKHtcbiAgYW5ub3RhdGlvbnM6IG4sXG4gIGNhdXNlOiByLFxuICBkYXRlOiBzLFxuICBmaWJlcklkOiBjLFxuICBsb2dMZXZlbDogaSxcbiAgbWVzc2FnZTogbyxcbiAgc3BhbnM6IGFcbn0pID0+IHtcbiAgY29uc3QgaCA9IChiKSA9PiBiLm1hdGNoKEtrKSA/IGIgOiBlKGIpLCBkID0gKGIsIE0pID0+IGAke2RoKGIpfT0ke2goTSl9YCwgZyA9IChiLCBNKSA9PiBcIiBcIiArIGQoYiwgTSk7XG4gIGxldCBwID0gZChcInRpbWVzdGFtcFwiLCBzLnRvSVNPU3RyaW5nKCkpO1xuICBwICs9IGcoXCJsZXZlbFwiLCBpLmxhYmVsKSwgcCArPSBnKFwiZmliZXJcIiwgbmYoYykpO1xuICBjb25zdCBfID0gUGcobyk7XG4gIGZvciAobGV0IGIgPSAwOyBiIDwgXy5sZW5ndGg7IGIrKylcbiAgICBwICs9IGcoXCJtZXNzYWdlXCIsIFV0KF9bYl0sIHQpKTtcbiAgT3kocikgfHwgKHAgKz0gZyhcImNhdXNlXCIsIGFyKHIsIHtcbiAgICByZW5kZXJFcnJvckNhdXNlOiAhMFxuICB9KSkpO1xuICBmb3IgKGNvbnN0IGIgb2YgYSlcbiAgICBwICs9IFwiIFwiICsgZzAocy5nZXRUaW1lKCkpKGIpO1xuICBmb3IgKGNvbnN0IFtiLCBNXSBvZiBuKVxuICAgIHAgKz0gZyhiLCBVdChNLCB0KSk7XG4gIHJldHVybiBwO1xufSwgSmsgPSAoZSkgPT4gYFwiJHtlLnJlcGxhY2UoL1xcXFwoW1xcc1xcU10pfChcIikvZywgXCJcXFxcJDEkMlwiKX1cImAsIEhrID0gLyogQF9fUFVSRV9fICovIHZvKC8qIEBfX1BVUkVfXyAqLyBXayhKaykpLCBHayA9IHR5cGVvZiBwcm9jZXNzID09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvY2Vzcy5zdGRvdXQgPT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnN0ZG91dCAhPT0gbnVsbDtcbkdrICYmIHByb2Nlc3Muc3Rkb3V0LmlzVFRZO1xuY29uc3QgcWggPSBcImVmZmVjdC9NZXRyaWNCb3VuZGFyaWVzXCIsIGVpID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IocWgpO1xudmFyIFN1O1xuY2xhc3MgWWsge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcInZhbHVlc1wiKTtcbiAgICB1KHRoaXMsIFN1LCBlaSk7XG4gICAgdSh0aGlzLCBcIl9oYXNoXCIpO1xuICAgIHRoaXMudmFsdWVzID0gdCwgdGhpcy5faGFzaCA9IGYoQihxaCksIFIoZXIodGhpcy52YWx1ZXMpKSk7XG4gIH1cbiAgWyhTdSA9IGVpLCBGKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc2g7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4gUWsodCkgJiYgTyh0aGlzLnZhbHVlcywgdC52YWx1ZXMpO1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuY29uc3QgUWsgPSAoZSkgPT4gJChlLCBlaSksIFprID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGYoZSwgU2woaWUoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSksIHRtKTtcbiAgcmV0dXJuIG5ldyBZayh0KTtcbn0sIFhrID0gKGUpID0+IGYoQWcoZS5jb3VudCAtIDEsICh0KSA9PiBlLnN0YXJ0ICogTWF0aC5wb3coZS5mYWN0b3IsIHQpKSwgaG4sIFprKSwgZXYgPSBcImVmZmVjdC9NZXRyaWNLZXlUeXBlXCIsIFVoID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoZXYpLCB6aCA9IFwiZWZmZWN0L01ldHJpY0tleVR5cGUvQ291bnRlclwiLCB0aSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKHpoKSwgdHYgPSBcImVmZmVjdC9NZXRyaWNLZXlUeXBlL0ZyZXF1ZW5jeVwiLCBudiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKHR2KSwgcnYgPSBcImVmZmVjdC9NZXRyaWNLZXlUeXBlL0dhdWdlXCIsIHN2ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IocnYpLCBCaCA9IFwiZWZmZWN0L01ldHJpY0tleVR5cGUvSGlzdG9ncmFtXCIsIG5pID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoQmgpLCBjdiA9IFwiZWZmZWN0L01ldHJpY0tleVR5cGUvU3VtbWFyeVwiLCBpdiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKGN2KSwgVmggPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbjogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9PdXQ6IChlKSA9PiBlXG59O1xudmFyIGt1LCB2dTtcbmNsYXNzIG92IHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJpbmNyZW1lbnRhbFwiKTtcbiAgICB1KHRoaXMsIFwiYmlnaW50XCIpO1xuICAgIHUodGhpcywgdnUsIFZoKTtcbiAgICB1KHRoaXMsIGt1LCB0aSk7XG4gICAgdSh0aGlzLCBcIl9oYXNoXCIpO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSB0LCB0aGlzLmJpZ2ludCA9IG4sIHRoaXMuX2hhc2ggPSBCKHpoKTtcbiAgfVxuICBbKHZ1ID0gVWgsIGt1ID0gdGksIEYpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuICBbRV0odCkge1xuICAgIHJldHVybiBLaCh0KTtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbnZhciB3dSwgT3U7XG5jbGFzcyBhdiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwiYm91bmRhcmllc1wiKTtcbiAgICB1KHRoaXMsIE91LCBWaCk7XG4gICAgdSh0aGlzLCB3dSwgbmkpO1xuICAgIHUodGhpcywgXCJfaGFzaFwiKTtcbiAgICB0aGlzLmJvdW5kYXJpZXMgPSB0LCB0aGlzLl9oYXNoID0gZihCKEJoKSwgUihrKHRoaXMuYm91bmRhcmllcykpKTtcbiAgfVxuICBbKE91ID0gVWgsIHd1ID0gbmksIEYpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuICBbRV0odCkge1xuICAgIHJldHVybiBXaCh0KSAmJiBPKHRoaXMuYm91bmRhcmllcywgdC5ib3VuZGFyaWVzKTtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbmNvbnN0IHV2ID0gKGUpID0+IG5ldyBvdigoZSA9PSBudWxsID8gdm9pZCAwIDogZS5pbmNyZW1lbnRhbCkgPz8gITEsIChlID09IG51bGwgPyB2b2lkIDAgOiBlLmJpZ2ludCkgPz8gITEpLCBsdiA9IChlKSA9PiBuZXcgYXYoZSksIEtoID0gKGUpID0+ICQoZSwgdGkpLCBmdiA9IChlKSA9PiAkKGUsIG52KSwgaHYgPSAoZSkgPT4gJChlLCBzdiksIFdoID0gKGUpID0+ICQoZSwgbmkpLCBkdiA9IChlKSA9PiAkKGUsIGl2KSwgZ3YgPSBcImVmZmVjdC9NZXRyaWNLZXlcIiwgSmggPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihndiksIG12ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfVHlwZTogKGUpID0+IGVcbn0sIHB2ID0gLyogQF9fUFVSRV9fICovIHZpKE8pO1xudmFyICR1O1xuY2xhc3Mgd28ge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByLCBzID0gW10pIHtcbiAgICB1KHRoaXMsIFwibmFtZVwiKTtcbiAgICB1KHRoaXMsIFwia2V5VHlwZVwiKTtcbiAgICB1KHRoaXMsIFwiZGVzY3JpcHRpb25cIik7XG4gICAgdSh0aGlzLCBcInRhZ3NcIik7XG4gICAgdSh0aGlzLCAkdSwgbXYpO1xuICAgIHUodGhpcywgXCJfaGFzaFwiKTtcbiAgICB0aGlzLm5hbWUgPSB0LCB0aGlzLmtleVR5cGUgPSBuLCB0aGlzLmRlc2NyaXB0aW9uID0gciwgdGhpcy50YWdzID0gcywgdGhpcy5faGFzaCA9IGYoQih0aGlzLm5hbWUgKyB0aGlzLmRlc2NyaXB0aW9uKSwgUihrKHRoaXMua2V5VHlwZSkpLCBSKGVyKHRoaXMudGFncykpKTtcbiAgfVxuICBbKCR1ID0gSmgsIEYpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuICBbRV0odCkge1xuICAgIHJldHVybiBfdih0KSAmJiB0aGlzLm5hbWUgPT09IHQubmFtZSAmJiBPKHRoaXMua2V5VHlwZSwgdC5rZXlUeXBlKSAmJiBPKHRoaXMuZGVzY3JpcHRpb24sIHQuZGVzY3JpcHRpb24pICYmIHB2KHRoaXMudGFncywgdC50YWdzKTtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbmNvbnN0IF92ID0gKGUpID0+ICQoZSwgSmgpLCB5diA9IChlLCB0KSA9PiBuZXcgd28oZSwgdXYodCksIEVzKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZGVzY3JpcHRpb24pKSwgYnYgPSAoZSwgdCwgbikgPT4gbmV3IHdvKGUsIGx2KHQpLCBFcyhuKSksIFN2ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHQubGVuZ3RoID09PSAwID8gZSA6IG5ldyB3byhlLm5hbWUsIGUua2V5VHlwZSwgZS5kZXNjcmlwdGlvbiwgQXIoZS50YWdzLCB0KSkpLCBrdiA9IFwiZWZmZWN0L01ldHJpY1N0YXRlXCIsIGdyID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3Ioa3YpLCBIaCA9IFwiZWZmZWN0L01ldHJpY1N0YXRlL0NvdW50ZXJcIiwgcmkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihIaCksIEdoID0gXCJlZmZlY3QvTWV0cmljU3RhdGUvRnJlcXVlbmN5XCIsIHNpID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoR2gpLCBZaCA9IFwiZWZmZWN0L01ldHJpY1N0YXRlL0dhdWdlXCIsIGNpID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoWWgpLCBRaCA9IFwiZWZmZWN0L01ldHJpY1N0YXRlL0hpc3RvZ3JhbVwiLCBpaSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFFoKSwgWmggPSBcImVmZmVjdC9NZXRyaWNTdGF0ZS9TdW1tYXJ5XCIsIG9pID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoWmgpLCBtciA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0E6IChlKSA9PiBlXG59O1xudmFyIEV1LCBJdTtcbmNsYXNzIHZ2IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHUodGhpcywgXCJjb3VudFwiKTtcbiAgICB1KHRoaXMsIEl1LCBtcik7XG4gICAgdSh0aGlzLCBFdSwgcmkpO1xuICAgIHRoaXMuY291bnQgPSB0O1xuICB9XG4gIFsoSXUgPSBnciwgRXUgPSByaSwgRildKCkge1xuICAgIHJldHVybiBmKGsoSGgpLCBSKGsodGhpcy5jb3VudCkpLCBxKHRoaXMpKTtcbiAgfVxuICBbRV0odCkge1xuICAgIHJldHVybiBOdih0KSAmJiB0aGlzLmNvdW50ID09PSB0LmNvdW50O1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuY29uc3Qgd3YgPSAvKiBAX19QVVJFX18gKi8gdmkoTyk7XG52YXIgRnUsIFJ1O1xuY2xhc3MgT3Yge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcIm9jY3VycmVuY2VzXCIpO1xuICAgIHUodGhpcywgUnUsIG1yKTtcbiAgICB1KHRoaXMsIEZ1LCBzaSk7XG4gICAgdSh0aGlzLCBcIl9oYXNoXCIpO1xuICAgIHRoaXMub2NjdXJyZW5jZXMgPSB0O1xuICB9XG4gIFsoUnUgPSBnciwgRnUgPSBzaSwgRildKCkge1xuICAgIHJldHVybiBmKEIoR2gpLCBSKGVyKHoodGhpcy5vY2N1cnJlbmNlcy5lbnRyaWVzKCkpKSksIHEodGhpcykpO1xuICB9XG4gIFtFXSh0KSB7XG4gICAgcmV0dXJuIEF2KHQpICYmIHd2KHoodGhpcy5vY2N1cnJlbmNlcy5lbnRyaWVzKCkpLCB6KHQub2NjdXJyZW5jZXMuZW50cmllcygpKSk7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG52YXIgTXUsIFR1O1xuY2xhc3MgJHYge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdSh0aGlzLCBcInZhbHVlXCIpO1xuICAgIHUodGhpcywgVHUsIG1yKTtcbiAgICB1KHRoaXMsIE11LCBjaSk7XG4gICAgdGhpcy52YWx1ZSA9IHQ7XG4gIH1cbiAgWyhUdSA9IGdyLCBNdSA9IGNpLCBGKV0oKSB7XG4gICAgcmV0dXJuIGYoayhZaCksIFIoayh0aGlzLnZhbHVlKSksIHEodGhpcykpO1xuICB9XG4gIFtFXSh0KSB7XG4gICAgcmV0dXJuIFB2KHQpICYmIHRoaXMudmFsdWUgPT09IHQudmFsdWU7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG52YXIgQ3UsIE51O1xuY2xhc3MgRXYge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByLCBzLCBjKSB7XG4gICAgdSh0aGlzLCBcImJ1Y2tldHNcIik7XG4gICAgdSh0aGlzLCBcImNvdW50XCIpO1xuICAgIHUodGhpcywgXCJtaW5cIik7XG4gICAgdSh0aGlzLCBcIm1heFwiKTtcbiAgICB1KHRoaXMsIFwic3VtXCIpO1xuICAgIHUodGhpcywgTnUsIG1yKTtcbiAgICB1KHRoaXMsIEN1LCBpaSk7XG4gICAgdGhpcy5idWNrZXRzID0gdCwgdGhpcy5jb3VudCA9IG4sIHRoaXMubWluID0gciwgdGhpcy5tYXggPSBzLCB0aGlzLnN1bSA9IGM7XG4gIH1cbiAgWyhOdSA9IGdyLCBDdSA9IGlpLCBGKV0oKSB7XG4gICAgcmV0dXJuIGYoayhRaCksIFIoayh0aGlzLmJ1Y2tldHMpKSwgUihrKHRoaXMuY291bnQpKSwgUihrKHRoaXMubWluKSksIFIoayh0aGlzLm1heCkpLCBSKGsodGhpcy5zdW0pKSwgcSh0aGlzKSk7XG4gIH1cbiAgW0VdKHQpIHtcbiAgICByZXR1cm4geHYodCkgJiYgTyh0aGlzLmJ1Y2tldHMsIHQuYnVja2V0cykgJiYgdGhpcy5jb3VudCA9PT0gdC5jb3VudCAmJiB0aGlzLm1pbiA9PT0gdC5taW4gJiYgdGhpcy5tYXggPT09IHQubWF4ICYmIHRoaXMuc3VtID09PSB0LnN1bTtcbiAgfVxuICBwaXBlKCkge1xuICAgIHJldHVybiB3KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbnZhciBBdSwgUHU7XG5jbGFzcyBJdiB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIsIHMsIGMsIGkpIHtcbiAgICB1KHRoaXMsIFwiZXJyb3JcIik7XG4gICAgdSh0aGlzLCBcInF1YW50aWxlc1wiKTtcbiAgICB1KHRoaXMsIFwiY291bnRcIik7XG4gICAgdSh0aGlzLCBcIm1pblwiKTtcbiAgICB1KHRoaXMsIFwibWF4XCIpO1xuICAgIHUodGhpcywgXCJzdW1cIik7XG4gICAgdSh0aGlzLCBQdSwgbXIpO1xuICAgIHUodGhpcywgQXUsIG9pKTtcbiAgICB0aGlzLmVycm9yID0gdCwgdGhpcy5xdWFudGlsZXMgPSBuLCB0aGlzLmNvdW50ID0gciwgdGhpcy5taW4gPSBzLCB0aGlzLm1heCA9IGMsIHRoaXMuc3VtID0gaTtcbiAgfVxuICBbKFB1ID0gZ3IsIEF1ID0gb2ksIEYpXSgpIHtcbiAgICByZXR1cm4gZihrKFpoKSwgUihrKHRoaXMuZXJyb3IpKSwgUihrKHRoaXMucXVhbnRpbGVzKSksIFIoayh0aGlzLmNvdW50KSksIFIoayh0aGlzLm1pbikpLCBSKGsodGhpcy5tYXgpKSwgUihrKHRoaXMuc3VtKSksIHEodGhpcykpO1xuICB9XG4gIFtFXSh0KSB7XG4gICAgcmV0dXJuIGp2KHQpICYmIHRoaXMuZXJyb3IgPT09IHQuZXJyb3IgJiYgTyh0aGlzLnF1YW50aWxlcywgdC5xdWFudGlsZXMpICYmIHRoaXMuY291bnQgPT09IHQuY291bnQgJiYgdGhpcy5taW4gPT09IHQubWluICYmIHRoaXMubWF4ID09PSB0Lm1heCAmJiB0aGlzLnN1bSA9PT0gdC5zdW07XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5jb25zdCBGdiA9IChlKSA9PiBuZXcgdnYoZSksIFJ2ID0gKGUpID0+IG5ldyBPdihlKSwgTXYgPSAoZSkgPT4gbmV3ICR2KGUpLCBUdiA9IChlKSA9PiBuZXcgRXYoZS5idWNrZXRzLCBlLmNvdW50LCBlLm1pbiwgZS5tYXgsIGUuc3VtKSwgQ3YgPSAoZSkgPT4gbmV3IEl2KGUuZXJyb3IsIGUucXVhbnRpbGVzLCBlLmNvdW50LCBlLm1pbiwgZS5tYXgsIGUuc3VtKSwgTnYgPSAoZSkgPT4gJChlLCByaSksIEF2ID0gKGUpID0+ICQoZSwgc2kpLCBQdiA9IChlKSA9PiAkKGUsIGNpKSwgeHYgPSAoZSkgPT4gJChlLCBpaSksIGp2ID0gKGUpID0+ICQoZSwgb2kpLCBMdiA9IFwiZWZmZWN0L01ldHJpY0hvb2tcIiwgRHYgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihMdiksIHF2ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW46IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0OiAoZSkgPT4gZVxufSwgcHIgPSAoZSkgPT4gKHtcbiAgW0R2XTogcXYsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgLi4uZVxufSksIE5hID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgVXYgPSAoZSkgPT4ge1xuICBsZXQgdCA9IGUua2V5VHlwZS5iaWdpbnQgPyBOYSA6IDA7XG4gIGNvbnN0IG4gPSBlLmtleVR5cGUuaW5jcmVtZW50YWwgPyBlLmtleVR5cGUuYmlnaW50ID8gKHMpID0+IHMgPj0gTmEgOiAocykgPT4gcyA+PSAwIDogKHMpID0+ICEwLCByID0gKHMpID0+IHtcbiAgICBuKHMpICYmICh0ID0gdCArIHMpO1xuICB9O1xuICByZXR1cm4gcHIoe1xuICAgIGdldDogKCkgPT4gRnYodCksXG4gICAgdXBkYXRlOiByLFxuICAgIG1vZGlmeTogclxuICB9KTtcbn0sIHp2ID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgciBvZiBlLmtleVR5cGUucHJlcmVnaXN0ZXJlZFdvcmRzKVxuICAgIHQuc2V0KHIsIDApO1xuICBjb25zdCBuID0gKHIpID0+IHtcbiAgICBjb25zdCBzID0gdC5nZXQocikgPz8gMDtcbiAgICB0LnNldChyLCBzICsgMSk7XG4gIH07XG4gIHJldHVybiBwcih7XG4gICAgZ2V0OiAoKSA9PiBSdih0KSxcbiAgICB1cGRhdGU6IG4sXG4gICAgbW9kaWZ5OiBuXG4gIH0pO1xufSwgQnYgPSAoZSwgdCkgPT4ge1xuICBsZXQgbiA9IHQ7XG4gIHJldHVybiBwcih7XG4gICAgZ2V0OiAoKSA9PiBNdihuKSxcbiAgICB1cGRhdGU6IChyKSA9PiB7XG4gICAgICBuID0gcjtcbiAgICB9LFxuICAgIG1vZGlmeTogKHIpID0+IHtcbiAgICAgIG4gPSBuICsgcjtcbiAgICB9XG4gIH0pO1xufSwgVnYgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gZS5rZXlUeXBlLmJvdW5kYXJpZXMudmFsdWVzLCBuID0gdC5sZW5ndGgsIHIgPSBuZXcgVWludDMyQXJyYXkobiArIDEpLCBzID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgbGV0IGMgPSAwLCBpID0gMCwgbyA9IE51bWJlci5NQVhfVkFMVUUsIGEgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICBmKHQsIFdyKHhuKSwgZnQoKGcsIHApID0+IHtcbiAgICBzW3BdID0gZztcbiAgfSkpO1xuICBjb25zdCBoID0gKGcpID0+IHtcbiAgICBsZXQgcCA9IDAsIF8gPSBuO1xuICAgIGZvciAoOyBwICE9PSBfOyApIHtcbiAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKHAgKyAoXyAtIHApIC8gMiksIE0gPSBzW2JdO1xuICAgICAgZyA8PSBNID8gXyA9IGIgOiBwID0gYiwgXyA9PT0gcCArIDEgJiYgKGcgPD0gc1twXSA/IF8gPSBwIDogcCA9IF8pO1xuICAgIH1cbiAgICByW3BdID0gcltwXSArIDEsIGMgPSBjICsgMSwgaSA9IGkgKyBnLCBnIDwgbyAmJiAobyA9IGcpLCBnID4gYSAmJiAoYSA9IGcpO1xuICB9LCBkID0gKCkgPT4ge1xuICAgIGNvbnN0IGcgPSBTaShuKTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgXyA9IDA7IF8gPCBuOyBfKyspIHtcbiAgICAgIGNvbnN0IGIgPSBzW19dLCBNID0gcltfXTtcbiAgICAgIHAgPSBwICsgTSwgZ1tfXSA9IFtiLCBwXTtcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH07XG4gIHJldHVybiBwcih7XG4gICAgZ2V0OiAoKSA9PiBUdih7XG4gICAgICBidWNrZXRzOiBkKCksXG4gICAgICBjb3VudDogYyxcbiAgICAgIG1pbjogbyxcbiAgICAgIG1heDogYSxcbiAgICAgIHN1bTogaVxuICAgIH0pLFxuICAgIHVwZGF0ZTogaCxcbiAgICBtb2RpZnk6IGhcbiAgfSk7XG59LCBLdiA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBlcnJvcjogdCxcbiAgICBtYXhBZ2U6IG4sXG4gICAgbWF4U2l6ZTogcixcbiAgICBxdWFudGlsZXM6IHNcbiAgfSA9IGUua2V5VHlwZSwgYyA9IGYocywgV3IoeG4pKSwgaSA9IFNpKHIpO1xuICBsZXQgbyA9IDAsIGEgPSAwLCBoID0gMCwgZCA9IE51bWJlci5NQVhfVkFMVUUsIGcgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICBjb25zdCBwID0gKGIpID0+IHtcbiAgICBjb25zdCBNID0gW107XG4gICAgbGV0IEQgPSAwO1xuICAgIGZvciAoOyBEICE9PSByIC0gMTsgKSB7XG4gICAgICBjb25zdCBYID0gaVtEXTtcbiAgICAgIGlmIChYICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW0gsIEllXSA9IFgsIERlID0gSHIoYiAtIEgpO1xuICAgICAgICBIbShEZSwgcWwpICYmIEptKERlLCBuKSAmJiBNLnB1c2goSWUpO1xuICAgICAgfVxuICAgICAgRCA9IEQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gV3YodCwgYywgV3IoTSwgeG4pKTtcbiAgfSwgXyA9IChiLCBNKSA9PiB7XG4gICAgaWYgKHIgPiAwKSB7XG4gICAgICBvID0gbyArIDE7XG4gICAgICBjb25zdCBEID0gbyAlIHI7XG4gICAgICBpW0RdID0gW00sIGJdO1xuICAgIH1cbiAgICBhID0gYSArIDEsIGggPSBoICsgYiwgYiA8IGQgJiYgKGQgPSBiKSwgYiA+IGcgJiYgKGcgPSBiKTtcbiAgfTtcbiAgcmV0dXJuIHByKHtcbiAgICBnZXQ6ICgpID0+IEN2KHtcbiAgICAgIGVycm9yOiB0LFxuICAgICAgcXVhbnRpbGVzOiBwKERhdGUubm93KCkpLFxuICAgICAgY291bnQ6IGEsXG4gICAgICBtaW46IGQsXG4gICAgICBtYXg6IGcsXG4gICAgICBzdW06IGhcbiAgICB9KSxcbiAgICB1cGRhdGU6IChbYiwgTV0pID0+IF8oYiwgTSksXG4gICAgbW9kaWZ5OiAoW2IsIE1dKSA9PiBfKGIsIE0pXG4gIH0pO1xufSwgV3YgPSAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gbi5sZW5ndGg7XG4gIGlmICghbGUodCkpXG4gICAgcmV0dXJuIEJ0KCk7XG4gIGNvbnN0IHMgPSB0WzBdLCBjID0gdC5zbGljZSgxKSwgaSA9IEFhKGUsIHIsIHYoKSwgMCwgcywgbiksIG8gPSBrZShpKTtcbiAgcmV0dXJuIGMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIG8ucHVzaChBYShlLCByLCBpLnZhbHVlLCBpLmNvbnN1bWVkLCBhLCBpLnJlc3QpKTtcbiAgfSksIGZ0KG8sIChhKSA9PiBbYS5xdWFudGlsZSwgYS52YWx1ZV0pO1xufSwgQWEgPSAoZSwgdCwgbiwgciwgcywgYykgPT4ge1xuICBsZXQgaSA9IGUsIG8gPSB0LCBhID0gbiwgaCA9IHIsIGQgPSBzLCBnID0gYywgcCA9IGUsIF8gPSB0LCBiID0gbiwgTSA9IHIsIEQgPSBzLCBYID0gYztcbiAgZm9yICg7IDsgKSB7XG4gICAgaWYgKCFsZShnKSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1YW50aWxlOiBkLFxuICAgICAgICB2YWx1ZTogdigpLFxuICAgICAgICBjb25zdW1lZDogaCxcbiAgICAgICAgcmVzdDogW11cbiAgICAgIH07XG4gICAgaWYgKGQgPT09IDEpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBxdWFudGlsZTogZCxcbiAgICAgICAgdmFsdWU6IEkod2woZykpLFxuICAgICAgICBjb25zdW1lZDogaCArIGcubGVuZ3RoLFxuICAgICAgICByZXN0OiBbXVxuICAgICAgfTtcbiAgICBjb25zdCBIID0gVmcoZywgKE10KSA9PiBNdCA8PSBnWzBdKSwgSWUgPSBkICogbywgRGUgPSBpIC8gMiAqIEllLCBxZSA9IGggKyBIWzBdLmxlbmd0aCwga3IgPSBNYXRoLmFicyhxZSAtIEllKTtcbiAgICBpZiAocWUgPCBJZSAtIERlKSB7XG4gICAgICBwID0gaSwgXyA9IG8sIGIgPSBUbihnKSwgTSA9IHFlLCBEID0gZCwgWCA9IEhbMV0sIGkgPSBwLCBvID0gXywgYSA9IGIsIGggPSBNLCBkID0gRCwgZyA9IFg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHFlID4gSWUgKyBEZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1YW50aWxlOiBkLFxuICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgY29uc3VtZWQ6IGgsXG4gICAgICAgIHJlc3Q6IGdcbiAgICAgIH07XG4gICAgc3dpdGNoIChhLl90YWcpIHtcbiAgICAgIGNhc2UgXCJOb25lXCI6IHtcbiAgICAgICAgcCA9IGksIF8gPSBvLCBiID0gVG4oZyksIE0gPSBxZSwgRCA9IGQsIFggPSBIWzFdLCBpID0gcCwgbyA9IF8sIGEgPSBiLCBoID0gTSwgZCA9IEQsIGcgPSBYO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJTb21lXCI6IHtcbiAgICAgICAgY29uc3QgTXQgPSBNYXRoLmFicyhJZSAtIGEudmFsdWUpO1xuICAgICAgICBpZiAoa3IgPCBNdCkge1xuICAgICAgICAgIHAgPSBpLCBfID0gbywgYiA9IFRuKGcpLCBNID0gcWUsIEQgPSBkLCBYID0gSFsxXSwgaSA9IHAsIG8gPSBfLCBhID0gYiwgaCA9IE0sIGQgPSBELCBnID0gWDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1YW50aWxlOiBkLFxuICAgICAgICAgIHZhbHVlOiBJKGEudmFsdWUpLFxuICAgICAgICAgIGNvbnN1bWVkOiBoLFxuICAgICAgICAgIHJlc3Q6IGdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBNZXRyaWNIb29rLnJlc29sdmVRdWFudGlsZXMgLSBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9FZmZlY3QtVFMvZWZmZWN0L2lzc3Vlc1wiKTtcbn0sIEp2ID0gXCJlZmZlY3QvTWV0cmljUGFpclwiLCBIdiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKEp2KSwgR3YgPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9UeXBlOiAoZSkgPT4gZVxufSwgWXYgPSAoZSwgdCkgPT4gKHtcbiAgW0h2XTogR3YsXG4gIG1ldHJpY0tleTogZSxcbiAgbWV0cmljU3RhdGU6IHQsXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufSksIFF2ID0gXCJlZmZlY3QvTWV0cmljUmVnaXN0cnlcIiwgUGEgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihRdik7XG52YXIgeHU7XG54dSA9IFBhO1xuY2xhc3MgWnYge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB1KHRoaXMsIHh1LCBQYSk7XG4gICAgdSh0aGlzLCBcIm1hcFwiLCAvKiBAX19QVVJFX18gKi8gVmIoKSk7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGZvciAoY29uc3QgW24sIHJdIG9mIHRoaXMubWFwKVxuICAgICAgdC5wdXNoKFl2KG4sIHIuZ2V0KCkpKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBnZXQodCkge1xuICAgIGNvbnN0IG4gPSBmKHRoaXMubWFwLCBvdCh0KSwgaXQpO1xuICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgIGlmIChLaCh0LmtleVR5cGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb3VudGVyKHQpO1xuICAgICAgaWYgKGh2KHQua2V5VHlwZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmdldEdhdWdlKHQpO1xuICAgICAgaWYgKGZ2KHQua2V5VHlwZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeSh0KTtcbiAgICAgIGlmIChXaCh0LmtleVR5cGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIaXN0b2dyYW0odCk7XG4gICAgICBpZiAoZHYodC5rZXlUeXBlKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VtbWFyeSh0KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogTWV0cmljUmVnaXN0cnkuZ2V0IC0gdW5rbm93biBNZXRyaWNLZXlUeXBlIC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNcIik7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gbjtcbiAgfVxuICBnZXRDb3VudGVyKHQpIHtcbiAgICBsZXQgbiA9IGYodGhpcy5tYXAsIG90KHQpLCBpdCk7XG4gICAgaWYgKG4gPT0gbnVsbCkge1xuICAgICAgY29uc3QgciA9IFV2KHQpO1xuICAgICAgZih0aGlzLm1hcCwgT24odCkpIHx8IGYodGhpcy5tYXAsICRuKHQsIHIpKSwgbiA9IHI7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGdldEZyZXF1ZW5jeSh0KSB7XG4gICAgbGV0IG4gPSBmKHRoaXMubWFwLCBvdCh0KSwgaXQpO1xuICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHIgPSB6dih0KTtcbiAgICAgIGYodGhpcy5tYXAsIE9uKHQpKSB8fCBmKHRoaXMubWFwLCAkbih0LCByKSksIG4gPSByO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBnZXRHYXVnZSh0KSB7XG4gICAgbGV0IG4gPSBmKHRoaXMubWFwLCBvdCh0KSwgaXQpO1xuICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHIgPSBCdih0LCB0LmtleVR5cGUuYmlnaW50ID8gQmlnSW50KDApIDogMCk7XG4gICAgICBmKHRoaXMubWFwLCBPbih0KSkgfHwgZih0aGlzLm1hcCwgJG4odCwgcikpLCBuID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZ2V0SGlzdG9ncmFtKHQpIHtcbiAgICBsZXQgbiA9IGYodGhpcy5tYXAsIG90KHQpLCBpdCk7XG4gICAgaWYgKG4gPT0gbnVsbCkge1xuICAgICAgY29uc3QgciA9IFZ2KHQpO1xuICAgICAgZih0aGlzLm1hcCwgT24odCkpIHx8IGYodGhpcy5tYXAsICRuKHQsIHIpKSwgbiA9IHI7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGdldFN1bW1hcnkodCkge1xuICAgIGxldCBuID0gZih0aGlzLm1hcCwgb3QodCksIGl0KTtcbiAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICBjb25zdCByID0gS3YodCk7XG4gICAgICBmKHRoaXMubWFwLCBPbih0KSkgfHwgZih0aGlzLm1hcCwgJG4odCwgcikpLCBuID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbn1cbmNvbnN0IFh2ID0gKCkgPT4gbmV3IFp2KCksIGV3ID0gXCJlZmZlY3QvTWV0cmljXCIsIHR3ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoZXcpLCBudyA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX1R5cGU6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW46IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0OiAoZSkgPT4gZVxufSwgeGEgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9NZXRyaWMvZ2xvYmFsTWV0cmljUmVnaXN0cnlcIiksICgpID0+IFh2KCkpLCBYaCA9IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHtcbiAgY29uc3QgcyA9IE9iamVjdC5hc3NpZ24oKGMpID0+IEdpKGMsIChpKSA9PiBpdyhzLCBpKSksIHtcbiAgICBbdHddOiBudyxcbiAgICBrZXlUeXBlOiBlLFxuICAgIHVuc2FmZVVwZGF0ZTogdCxcbiAgICB1bnNhZmVWYWx1ZTogbixcbiAgICB1bnNhZmVNb2RpZnk6IHIsXG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnNhZmVWYWx1ZShbXSksIHRoaXM7XG4gICAgfSxcbiAgICBwaXBlKCkge1xuICAgICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcztcbn0sIG5jID0gKGUsIHQpID0+IGVkKHl2KGUsIHQpKSwgZWQgPSAoZSkgPT4ge1xuICBsZXQgdDtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCByID0gKHMpID0+IHtcbiAgICBpZiAocy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdCAhPT0gdm9pZCAwIHx8ICh0ID0geGEuZ2V0KGUpKSwgdDtcbiAgICBsZXQgYyA9IG4uZ2V0KHMpO1xuICAgIHJldHVybiBjICE9PSB2b2lkIDAgfHwgKGMgPSB4YS5nZXQoU3YoZSwgcykpLCBuLnNldChzLCBjKSksIGM7XG4gIH07XG4gIHJldHVybiBYaChlLmtleVR5cGUsIChzLCBjKSA9PiByKGMpLnVwZGF0ZShzKSwgKHMpID0+IHIocykuZ2V0KCksIChzLCBjKSA9PiByKGMpLm1vZGlmeShzKSk7XG59LCBydyA9IChlLCB0LCBuKSA9PiBlZChidihlLCB0LCBuKSksIHN3ID0gLyogQF9fUFVSRV9fICovIGwoMywgKGUsIHQsIG4pID0+IGN3KGUsIFtrMCh0LCBuKV0pKSwgY3cgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gWGgoZS5rZXlUeXBlLCAobiwgcikgPT4gZS51bnNhZmVVcGRhdGUobiwgQXIodCwgcikpLCAobikgPT4gZS51bnNhZmVWYWx1ZShBcih0LCBuKSksIChuLCByKSA9PiBlLnVuc2FmZU1vZGlmeShuLCBBcih0LCByKSkpKSwgaXcgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gV3MoVWMsIChuKSA9PiB5KCgpID0+IGUudW5zYWZlVXBkYXRlKHQsIG4pKSkpO1xuKHtcbiAgLi4uT3Ncbn0pO1xuY29uc3Qgb3cgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gV3MoRGgsIChuKSA9PiB5KCgpID0+IHtcbiAgaWYgKG4uaGFzKGUpKSB7XG4gICAgY29uc3QgciA9IG4uZ2V0KGUpO1xuICAgIHIuc3RhdGUuY29tcGxldGVkIHx8IChyLnN0YXRlLmNvbXBsZXRlZCA9ICEwLCBRZihyLnJlc3VsdCwgdCkpO1xuICB9XG59KSkpLCBhdyA9IFwiZWZmZWN0L1N1cGVydmlzb3JcIiwgcmMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihhdyksIE9vID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfVDogKGUpID0+IGVcbn07XG52YXIganU7XG5qdSA9IHJjO1xuY29uc3QgTW8gPSBjbGFzcyBNbyB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICB1KHRoaXMsIFwidW5kZXJseWluZ1wiKTtcbiAgICB1KHRoaXMsIFwidmFsdWUwXCIpO1xuICAgIHUodGhpcywganUsIE9vKTtcbiAgICB0aGlzLnVuZGVybHlpbmcgPSB0LCB0aGlzLnZhbHVlMCA9IG47XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlMDtcbiAgfVxuICBvblN0YXJ0KHQsIG4sIHIsIHMpIHtcbiAgICB0aGlzLnVuZGVybHlpbmcub25TdGFydCh0LCBuLCByLCBzKTtcbiAgfVxuICBvbkVuZCh0LCBuKSB7XG4gICAgdGhpcy51bmRlcmx5aW5nLm9uRW5kKHQsIG4pO1xuICB9XG4gIG9uRWZmZWN0KHQsIG4pIHtcbiAgICB0aGlzLnVuZGVybHlpbmcub25FZmZlY3QodCwgbik7XG4gIH1cbiAgb25TdXNwZW5kKHQpIHtcbiAgICB0aGlzLnVuZGVybHlpbmcub25TdXNwZW5kKHQpO1xuICB9XG4gIG9uUmVzdW1lKHQpIHtcbiAgICB0aGlzLnVuZGVybHlpbmcub25SZXN1bWUodCk7XG4gIH1cbiAgbWFwKHQpIHtcbiAgICByZXR1cm4gbmV3IE1vKHRoaXMsIGYodGhpcy52YWx1ZSwgVCh0KSkpO1xuICB9XG4gIHppcCh0KSB7XG4gICAgcmV0dXJuIG5ldyBkcyh0aGlzLCB0KTtcbiAgfVxufTtcbmxldCBocyA9IE1vO1xudmFyIEx1O1xuTHUgPSByYztcbmNvbnN0IFRvID0gY2xhc3MgVG8ge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdSh0aGlzLCBcImxlZnRcIik7XG4gICAgdSh0aGlzLCBcInJpZ2h0XCIpO1xuICAgIHUodGhpcywgXCJfdGFnXCIsIFwiWmlwXCIpO1xuICAgIHUodGhpcywgTHUsIE9vKTtcbiAgICB0aGlzLmxlZnQgPSB0LCB0aGlzLnJpZ2h0ID0gbjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHFmKHRoaXMubGVmdC52YWx1ZSwgdGhpcy5yaWdodC52YWx1ZSk7XG4gIH1cbiAgb25TdGFydCh0LCBuLCByLCBzKSB7XG4gICAgdGhpcy5sZWZ0Lm9uU3RhcnQodCwgbiwgciwgcyksIHRoaXMucmlnaHQub25TdGFydCh0LCBuLCByLCBzKTtcbiAgfVxuICBvbkVuZCh0LCBuKSB7XG4gICAgdGhpcy5sZWZ0Lm9uRW5kKHQsIG4pLCB0aGlzLnJpZ2h0Lm9uRW5kKHQsIG4pO1xuICB9XG4gIG9uRWZmZWN0KHQsIG4pIHtcbiAgICB0aGlzLmxlZnQub25FZmZlY3QodCwgbiksIHRoaXMucmlnaHQub25FZmZlY3QodCwgbik7XG4gIH1cbiAgb25TdXNwZW5kKHQpIHtcbiAgICB0aGlzLmxlZnQub25TdXNwZW5kKHQpLCB0aGlzLnJpZ2h0Lm9uU3VzcGVuZCh0KTtcbiAgfVxuICBvblJlc3VtZSh0KSB7XG4gICAgdGhpcy5sZWZ0Lm9uUmVzdW1lKHQpLCB0aGlzLnJpZ2h0Lm9uUmVzdW1lKHQpO1xuICB9XG4gIG1hcCh0KSB7XG4gICAgcmV0dXJuIG5ldyBocyh0aGlzLCBmKHRoaXMudmFsdWUsIFQodCkpKTtcbiAgfVxuICB6aXAodCkge1xuICAgIHJldHVybiBuZXcgVG8odGhpcywgdCk7XG4gIH1cbn07XG5sZXQgZHMgPSBUbztcbmNvbnN0IHRkID0gKGUpID0+ICQoZSwgcmMpICYmIGVsKGUsIFwiWmlwXCIpO1xudmFyIER1O1xuRHUgPSByYztcbmNsYXNzIHV3IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHUodGhpcywgXCJlZmZlY3RcIik7XG4gICAgdSh0aGlzLCBEdSwgT28pO1xuICAgIHRoaXMuZWZmZWN0ID0gdDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0O1xuICB9XG4gIG9uU3RhcnQodCwgbiwgciwgcykge1xuICB9XG4gIG9uRW5kKHQsIG4pIHtcbiAgfVxuICBvbkVmZmVjdCh0LCBuKSB7XG4gIH1cbiAgb25TdXNwZW5kKHQpIHtcbiAgfVxuICBvblJlc3VtZSh0KSB7XG4gIH1cbiAgbWFwKHQpIHtcbiAgICByZXR1cm4gbmV3IGhzKHRoaXMsIGYodGhpcy52YWx1ZSwgVCh0KSkpO1xuICB9XG4gIHppcCh0KSB7XG4gICAgcmV0dXJuIG5ldyBkcyh0aGlzLCB0KTtcbiAgfVxuICBvblJ1bih0LCBuKSB7XG4gICAgcmV0dXJuIHQoKTtcbiAgfVxufVxuY29uc3QgbHcgPSAoZSkgPT4gbmV3IHV3KGUpLCBzYyA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiZWZmZWN0L1N1cGVydmlzb3Ivbm9uZVwiLCAoKSA9PiBsdyhLKSksIGZ3ID0gZG4sIG5kID0gXCJFbXB0eVwiLCByZCA9IFwiQWRkU3VwZXJ2aXNvclwiLCBzZCA9IFwiUmVtb3ZlU3VwZXJ2aXNvclwiLCBjZCA9IFwiQW5kVGhlblwiLCBBbiA9IHtcbiAgX3RhZzogbmRcbn0sIExyID0gKGUsIHQpID0+ICh7XG4gIF90YWc6IGNkLFxuICBmaXJzdDogZSxcbiAgc2Vjb25kOiB0XG59KSwgaHcgPSAoZSwgdCkgPT4gZHcodCwgaWUoZSkpLCBkdyA9IChlLCB0KSA9PiB7XG4gIGxldCBuID0gZSwgciA9IHQ7XG4gIGZvciAoOyBIZShyKTsgKSB7XG4gICAgY29uc3QgcyA9IENlKHIpO1xuICAgIHN3aXRjaCAocy5fdGFnKSB7XG4gICAgICBjYXNlIG5kOiB7XG4gICAgICAgIHIgPSBWZShyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIHJkOiB7XG4gICAgICAgIG4gPSBuLnppcChzLnN1cGVydmlzb3IpLCByID0gVmUocik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBzZDoge1xuICAgICAgICBuID0gYWkobiwgcy5zdXBlcnZpc29yKSwgciA9IFZlKHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgY2Q6IHtcbiAgICAgICAgciA9IGJlKHMuZmlyc3QpKGJlKHMuc2Vjb25kKShWZShyKSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59LCBhaSA9IChlLCB0KSA9PiBPKGUsIHQpID8gc2MgOiB0ZChlKSA/IGFpKGUubGVmdCwgdCkuemlwKGFpKGUucmlnaHQsIHQpKSA6IGUsIGdzID0gKGUpID0+IE8oZSwgc2MpID8gU3QoKSA6IHRkKGUpID8gZihncyhlLmxlZnQpLCBEbihncyhlLnJpZ2h0KSkpIDogUGkoZSksIGd3ID0gKGUsIHQpID0+IHtcbiAgaWYgKE8oZSwgdCkpXG4gICAgcmV0dXJuIEFuO1xuICBjb25zdCBuID0gZ3MoZSksIHIgPSBncyh0KSwgcyA9IGYociwgSG8obiksIHFuKEFuLCAoaSwgbykgPT4gTHIoaSwge1xuICAgIF90YWc6IHJkLFxuICAgIHN1cGVydmlzb3I6IG9cbiAgfSkpKSwgYyA9IGYobiwgSG8ociksIHFuKEFuLCAoaSwgbykgPT4gTHIoaSwge1xuICAgIF90YWc6IHNkLFxuICAgIHN1cGVydmlzb3I6IG9cbiAgfSkpKTtcbiAgcmV0dXJuIExyKHMsIGMpO1xufSwgbXcgPSAvKiBAX19QVVJFX18gKi8gZncoe1xuICBlbXB0eTogQW4sXG4gIHBhdGNoOiBodyxcbiAgY29tYmluZTogTHIsXG4gIGRpZmY6IGd3XG59KSwgcHcgPSAvKiBAX19QVVJFX18gKi8gbmMoXCJlZmZlY3RfZmliZXJfc3RhcnRlZFwiLCB7XG4gIGluY3JlbWVudGFsOiAhMFxufSksIGphID0gLyogQF9fUFVSRV9fICovIG5jKFwiZWZmZWN0X2ZpYmVyX2FjdGl2ZVwiKSwgX3cgPSAvKiBAX19QVVJFX18gKi8gbmMoXCJlZmZlY3RfZmliZXJfc3VjY2Vzc2VzXCIsIHtcbiAgaW5jcmVtZW50YWw6ICEwXG59KSwgeXcgPSAvKiBAX19QVVJFX18gKi8gbmMoXCJlZmZlY3RfZmliZXJfZmFpbHVyZXNcIiwge1xuICBpbmNyZW1lbnRhbDogITBcbn0pLCBidyA9IC8qIEBfX1BVUkVfXyAqLyBzdygvKiBAX19QVVJFX18gKi8gcncoXCJlZmZlY3RfZmliZXJfbGlmZXRpbWVzXCIsIC8qIEBfX1BVUkVfXyAqLyBYayh7XG4gIHN0YXJ0OiAwLjUsXG4gIGZhY3RvcjogMixcbiAgY291bnQ6IDM1XG59KSksIFwidGltZV91bml0XCIsIFwibWlsbGlzZWNvbmRzXCIpLCBFbiA9IFwiQ29udGludWVcIiwgU3cgPSBcIkRvbmVcIiwgTGEgPSBcIllpZWxkXCIsIGt3ID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfRTogKGUpID0+IGUsXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9BOiAoZSkgPT4gZVxufSwgUnIgPSAoZSkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogRmliZXJSdW50aW1lIC0gJHtVdChlKX0gLSBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9FZmZlY3QtVFMvZWZmZWN0L2lzc3Vlc2ApO1xufSwgemUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9pbnRlcm5hbC9maWJlclJ1bnRpbWUvWWllbGRlZE9wXCIpLCBCZSA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiZWZmZWN0L2ludGVybmFsL2ZpYmVyUnVudGltZS95aWVsZGVkT3BDaGFubmVsXCIsICgpID0+ICh7XG4gIGN1cnJlbnRPcDogbnVsbFxufSkpLCBJbiA9IHtcbiAgW3pyXTogKGUsIHQsIG4pID0+IGVlKCgpID0+IHQuZWZmZWN0X2luc3RydWN0aW9uX2kxKG4pKSxcbiAgT25TdGVwOiAoZSwgdCwgbikgPT4gaihqKG4pKSxcbiAgW0JyXTogKGUsIHQsIG4pID0+IGVlKCgpID0+IHQuZWZmZWN0X2luc3RydWN0aW9uX2kyKG4pKSxcbiAgW3BpXTogKGUsIHQsIG4pID0+IChlLnBhdGNoUnVudGltZUZsYWdzKGUuY3VycmVudFJ1bnRpbWVGbGFncywgdC5wYXRjaCksIEdlKGUuY3VycmVudFJ1bnRpbWVGbGFncykgJiYgZS5pc0ludGVycnVwdGVkKCkgPyBBKGUuZ2V0SW50ZXJydXB0ZWRDYXVzZSgpKSA6IGoobikpLFxuICBbVnJdOiAoZSwgdCwgbikgPT4gKGVlKCgpID0+IHQuZWZmZWN0X2luc3RydWN0aW9uX2kyKG4pKSwgZWUoKCkgPT4gdC5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAoKSkgPyAoZS5wdXNoU3RhY2sodCksIGVlKCgpID0+IHQuZWZmZWN0X2luc3RydWN0aW9uX2kxKCkpKSA6IEspLFxuICBbTW5dOiAoZSwgdCwgbikgPT4ge1xuICAgIGNvbnN0IHIgPSBlZSgoKSA9PiB0LmVmZmVjdF9pbnN0cnVjdGlvbl9pMC5uZXh0KG4pKTtcbiAgICByZXR1cm4gci5kb25lID8gaihyLnZhbHVlKSA6IChlLnB1c2hTdGFjayh0KSwgWmQoci52YWx1ZSkpO1xuICB9XG59LCB2dyA9IHtcbiAgW3lvXTogKGUsIHQsIG4sIHIpID0+IChlLnByb2Nlc3NOZXdJbnRlcnJ1cHRTaWduYWwoci5jYXVzZSksIEdlKHQpID8gQShyLmNhdXNlKSA6IG4pLFxuICBbU29dOiAoZSwgdCwgbiwgcikgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGlzIGlsbGVnYWwgdG8gaGF2ZSBtdWx0aXBsZSBjb25jdXJyZW50IHJ1biBsb29wcyBpbiBhIHNpbmdsZSBmaWJlclwiKTtcbiAgfSxcbiAgW2JvXTogKGUsIHQsIG4sIHIpID0+IChyLm9uRmliZXIoZSwgUmgodCkpLCBuKSxcbiAgW2tvXTogKGUsIHQsIG4sIHIpID0+IG0oUWkoKSwgKCkgPT4gbilcbn0sIHd3ID0gKGUpID0+IEJzKG95KGUpLCAodCkgPT4gcHQoa3kodCksIChbbiwgcl0pID0+IHtcbiAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGMgPSBbXTtcbiAgZm9yIChjb25zdCBvIG9mIHIpIHtcbiAgICBjLnB1c2goV2UobykpO1xuICAgIGZvciAoY29uc3QgYSBvZiBvKVxuICAgICAgcy5zZXQoYS5yZXF1ZXN0LCBhKTtcbiAgfVxuICBjb25zdCBpID0gYy5mbGF0KCk7XG4gIHJldHVybiBocihKdyhuLnJ1bkFsbChjKSwgaSwgKCkgPT4gaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgby5saXN0ZW5lcnMuaW50ZXJydXB0ZWQgPSAhMDtcbiAgfSkpLCBEaCwgcyk7XG59LCAhMSwgITEpKSwgT3cgPSAvKiBAX19QVVJFX18gKi8gYnMoKTtcbnZhciBxdSwgVXU7XG5jbGFzcyBpZCBleHRlbmRzIGFvIHtcbiAgY29uc3RydWN0b3Iobiwgciwgcykge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBVdSwgRGspO1xuICAgIHUodGhpcywgcXUsIGt3KTtcbiAgICB1KHRoaXMsIFwiX2ZpYmVyUmVmc1wiKTtcbiAgICB1KHRoaXMsIFwiX2ZpYmVySWRcIik7XG4gICAgdSh0aGlzLCBcIl9xdWV1ZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IEFycmF5KCkpO1xuICAgIHUodGhpcywgXCJfY2hpbGRyZW5cIiwgbnVsbCk7XG4gICAgdSh0aGlzLCBcIl9vYnNlcnZlcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBBcnJheSgpKTtcbiAgICB1KHRoaXMsIFwiX3J1bm5pbmdcIiwgITEpO1xuICAgIHUodGhpcywgXCJfc3RhY2tcIiwgW10pO1xuICAgIHUodGhpcywgXCJfYXN5bmNJbnRlcnJ1cHRvclwiLCBudWxsKTtcbiAgICB1KHRoaXMsIFwiX2FzeW5jQmxvY2tpbmdPblwiLCBudWxsKTtcbiAgICB1KHRoaXMsIFwiX2V4aXRWYWx1ZVwiLCBudWxsKTtcbiAgICB1KHRoaXMsIFwiX3N0ZXBzXCIsIFtdKTtcbiAgICB1KHRoaXMsIFwiX2lzWWllbGRpbmdcIiwgITEpO1xuICAgIHUodGhpcywgXCJjdXJyZW50UnVudGltZUZsYWdzXCIpO1xuICAgIHUodGhpcywgXCJjdXJyZW50T3BDb3VudFwiLCAwKTtcbiAgICB1KHRoaXMsIFwiY3VycmVudFN1cGVydmlzb3JcIik7XG4gICAgdSh0aGlzLCBcImN1cnJlbnRTY2hlZHVsZXJcIik7XG4gICAgdSh0aGlzLCBcImN1cnJlbnRUcmFjZXJcIik7XG4gICAgdSh0aGlzLCBcImN1cnJlbnRTcGFuXCIpO1xuICAgIHUodGhpcywgXCJjdXJyZW50Q29udGV4dFwiKTtcbiAgICB1KHRoaXMsIFwiY3VycmVudERlZmF1bHRTZXJ2aWNlc1wiKTtcbiAgICB1KHRoaXMsIFwicnVuXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZHJhaW5RdWV1ZU9uQ3VycmVudFRocmVhZCgpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmN1cnJlbnRSdW50aW1lRmxhZ3MgPSBzLCB0aGlzLl9maWJlcklkID0gbiwgdGhpcy5fZmliZXJSZWZzID0gciwgWG8ocykpIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmdldEZpYmVyUmVmKFVjKTtcbiAgICAgIHB3LnVuc2FmZVVwZGF0ZSgxLCBjKSwgamEudW5zYWZlVXBkYXRlKDEsIGMpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hSZWZDYWNoZSgpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICByZXR1cm4gZnModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpZGVudGl0eSBvZiB0aGUgZmliZXIuXG4gICAqL1xuICBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmliZXJJZDtcbiAgfVxuICAvKipcbiAgICogQmVnaW5zIGV4ZWN1dGlvbiBvZiB0aGUgZWZmZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpYmVyIG9uIGluIHRoZVxuICAgKiBiYWNrZ3JvdW5kLiBUaGlzIGNhbiBiZSBjYWxsZWQgdG8gXCJraWNrIG9mZlwiIGV4ZWN1dGlvbiBvZiBhIGZpYmVyIGFmdGVyXG4gICAqIGl0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqL1xuICByZXN1bWUobikge1xuICAgIHRoaXMudGVsbChDdChuKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIGZpYmVyLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5hc2soKG4sIHIpID0+IHIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaWJlciBydW50aW1lIGZsYWdzLlxuICAgKi9cbiAgZ2V0IHJ1bnRpbWVGbGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5hc2soKG4sIHIpID0+IHRrKHIpID8gbi5jdXJyZW50UnVudGltZUZsYWdzIDogci5ydW50aW1lRmxhZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGBGaWJlclNjb3BlYCBmb3IgdGhlIGZpYmVyLlxuICAgKi9cbiAgc2NvcGUoKSB7XG4gICAgcmV0dXJuIHhrKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGltbWVkaWF0ZSBjaGlsZHJlbiBvZiB0aGUgZmliZXIuXG4gICAqL1xuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNrKChuKSA9PiBBcnJheS5mcm9tKG4uZ2V0Q2hpbGRyZW4oKSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaWJlcidzIHNldCBvZiBjaGlsZHJlbi5cbiAgICovXG4gIGdldENoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiA9PT0gbnVsbCAmJiAodGhpcy5fY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSwgdGhpcy5fY2hpbGRyZW47XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW50ZXJydXB0ZWQgY2F1c2Ugb2YgdGhlIGZpYmVyLCB3aGljaCB3aWxsIGJlIGBDYXVzZS5lbXB0eWBcbiAgICogaWYgdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBpbnRlcnJ1cHRlZC5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gaW52b2tlIG9uIGFueSBmaWJlciwgYnV0IGlmIG5vdCBpbnZva2VkXG4gICAqIG9uIHRoaXMgZmliZXIsIHRoZW4gdmFsdWVzIGRlcml2ZWQgZnJvbSB0aGUgZmliZXIncyBzdGF0ZSAoaW5jbHVkaW5nIHRoZVxuICAgKiBsb2cgYW5ub3RhdGlvbnMgYW5kIGxvZyBsZXZlbCkgbWF5IG5vdCBiZSB1cC10by1kYXRlLlxuICAgKi9cbiAgZ2V0SW50ZXJydXB0ZWRDYXVzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaWJlclJlZihJcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgd2hvbGUgc2V0IG9mIGZpYmVyIHJlZnMuXG4gICAqL1xuICBmaWJlclJlZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNrKChuKSA9PiBuLmdldEZpYmVyUmVmcygpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBlZmZlY3QgdGhhdCB3aWxsIGNvbnRhaW4gaW5mb3JtYXRpb24gY29tcHV0ZWQgZnJvbSB0aGUgZmliZXJcbiAgICogc3RhdGUgYW5kIHN0YXR1cyB3aGlsZSBydW5uaW5nIG9uIHRoZSBmaWJlci5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgdGhlIG91dHNpZGUgd29ybGQgdG8gaW50ZXJhY3Qgc2FmZWx5IHdpdGggbXV0YWJsZSBmaWJlciBzdGF0ZVxuICAgKiB3aXRob3V0IGxvY2tzIG9yIGltbXV0YWJsZSBkYXRhLlxuICAgKi9cbiAgYXNrKG4pIHtcbiAgICByZXR1cm4gTigoKSA9PiB7XG4gICAgICBjb25zdCByID0gWWYodGhpcy5fZmliZXJJZCk7XG4gICAgICByZXR1cm4gdGhpcy50ZWxsKGpyKChzLCBjKSA9PiB7XG4gICAgICAgIFFmKHIsIHkoKCkgPT4gbihzLCBjKSkpO1xuICAgICAgfSkpLCBybyhyKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG1lc3NhZ2UgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBmaWJlciBvbiB0aGUgZmliZXIuXG4gICAqL1xuICB0ZWxsKG4pIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKG4pLCB0aGlzLl9ydW5uaW5nIHx8ICh0aGlzLl9ydW5uaW5nID0gITAsIHRoaXMuZHJhaW5RdWV1ZUxhdGVyT25FeGVjdXRvcigpKTtcbiAgfVxuICBnZXQgYXdhaXQoKSB7XG4gICAgcmV0dXJuIHhlKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gKHMpID0+IG4oUyhzKSk7XG4gICAgICByZXR1cm4gdGhpcy50ZWxsKGpyKChzLCBjKSA9PiB7XG4gICAgICAgIHMuX2V4aXRWYWx1ZSAhPT0gbnVsbCA/IHIodGhpcy5fZXhpdFZhbHVlKSA6IHMuYWRkT2JzZXJ2ZXIocik7XG4gICAgICB9KSksIHkoKCkgPT4gdGhpcy50ZWxsKGpyKChzLCBjKSA9PiB7XG4gICAgICAgIHMucmVtb3ZlT2JzZXJ2ZXIocik7XG4gICAgICB9KSkpO1xuICAgIH0sIHRoaXMuaWQoKSk7XG4gIH1cbiAgZ2V0IGluaGVyaXRBbGwoKSB7XG4gICAgcmV0dXJuIEwoKG4sIHIpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBuLmlkKCksIGMgPSBuLmdldEZpYmVyUmVmcygpLCBpID0gci5ydW50aW1lRmxhZ3MsIG8gPSB0aGlzLmdldEZpYmVyUmVmcygpLCBhID0gWVMoYywgcywgbyk7XG4gICAgICBuLnNldEZpYmVyUmVmcyhhKTtcbiAgICAgIGNvbnN0IGggPSBuLmdldEZpYmVyUmVmKHphKSwgZCA9IGYoXG4gICAgICAgIGd0KGksIGgpLFxuICAgICAgICAvLyBEbyBub3QgaW5oZXJpdCBXaW5kRG93biBvciBJbnRlcnJ1cHRpb24hXG4gICAgICAgIHRhKGduKSxcbiAgICAgICAgdGEoTGMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5iKGQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUZW50YXRpdmVseSBvYnNlcnZlcyB0aGUgZmliZXIsIGJ1dCByZXR1cm5zIGltbWVkaWF0ZWx5IGlmIGl0IGlzIG5vdFxuICAgKiBhbHJlYWR5IGRvbmUuXG4gICAqL1xuICBnZXQgcG9sbCgpIHtcbiAgICByZXR1cm4geSgoKSA9PiBFcyh0aGlzLl9leGl0VmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogVW5zYWZlbHkgb2JzZXJ2ZXMgdGhlIGZpYmVyLCBidXQgcmV0dXJucyBpbW1lZGlhdGVseSBpZiBpdCBpcyBub3RcbiAgICogYWxyZWFkeSBkb25lLlxuICAgKi9cbiAgdW5zYWZlUG9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhpdFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbiB0aGUgYmFja2dyb3VuZCwgaW50ZXJydXB0cyB0aGUgZmliZXIgYXMgaWYgaW50ZXJydXB0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGZpYmVyLlxuICAgKi9cbiAgaW50ZXJydXB0QXNGb3JrKG4pIHtcbiAgICByZXR1cm4geSgoKSA9PiB0aGlzLnRlbGwocGMoVGUobikpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEluIHRoZSBiYWNrZ3JvdW5kLCBpbnRlcnJ1cHRzIHRoZSBmaWJlciBhcyBpZiBpbnRlcnJ1cHRlZCBmcm9tIHRoZSBzcGVjaWZpZWQgZmliZXIuXG4gICAqL1xuICB1bnNhZmVJbnRlcnJ1cHRBc0Zvcmsobikge1xuICAgIHRoaXMudGVsbChwYyhUZShuKSkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIG9ic2VydmVyIHRvIHRoZSBsaXN0IG9mIG9ic2VydmVycy5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIG11c3QgYmUgaW52b2tlZCBieSB0aGUgZmliZXIgaXRzZWxmLlxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIobikge1xuICAgIHRoaXMuX2V4aXRWYWx1ZSAhPT0gbnVsbCA/IG4odGhpcy5fZXhpdFZhbHVlKSA6IHRoaXMuX29ic2VydmVycy5wdXNoKG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIgZnJvbSB0aGUgbGlzdCBvZiBvYnNlcnZlcnMgdGhhdCB3aWxsIGJlXG4gICAqIG5vdGlmaWVkIHdoZW4gdGhlIGZpYmVyIGV4aXRzLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICByZW1vdmVPYnNlcnZlcihuKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmZpbHRlcigocikgPT4gciAhPT0gbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgZmliZXIgcmVmcyBvZiB0aGUgZmliZXIuXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIGludm9rZSBvbiBhbnkgZmliZXIsIGJ1dCBpZiBub3QgaW52b2tlZFxuICAgKiBvbiB0aGlzIGZpYmVyLCB0aGVuIHZhbHVlcyBkZXJpdmVkIGZyb20gdGhlIGZpYmVyJ3Mgc3RhdGUgKGluY2x1ZGluZyB0aGVcbiAgICogbG9nIGFubm90YXRpb25zIGFuZCBsb2cgbGV2ZWwpIG1heSBub3QgYmUgdXAtdG8tZGF0ZS5cbiAgICovXG4gIGdldEZpYmVyUmVmcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRGaWJlclJlZih6YSwgdGhpcy5jdXJyZW50UnVudGltZUZsYWdzKSwgdGhpcy5fZmliZXJSZWZzO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBzcGVjaWZpZWQgZmliZXIgcmVmLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICB1bnNhZmVEZWxldGVGaWJlclJlZihuKSB7XG4gICAgdGhpcy5fZmliZXJSZWZzID0gaGgodGhpcy5fZmliZXJSZWZzLCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzdGF0ZSBvZiB0aGUgZmliZXIgcmVmLCBvciBlbHNlIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgaXMgc2FmZSB0byBpbnZva2Ugb24gYW55IGZpYmVyLCBidXQgaWYgbm90IGludm9rZWRcbiAgICogb24gdGhpcyBmaWJlciwgdGhlbiB2YWx1ZXMgZGVyaXZlZCBmcm9tIHRoZSBmaWJlcidzIHN0YXRlIChpbmNsdWRpbmcgdGhlXG4gICAqIGxvZyBhbm5vdGF0aW9ucyBhbmQgbG9nIGxldmVsKSBtYXkgbm90IGJlIHVwLXRvLWRhdGUuXG4gICAqL1xuICBnZXRGaWJlclJlZihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpYmVyUmVmcy5sb2NhbHMuaGFzKG4pID8gdGhpcy5fZmliZXJSZWZzLmxvY2Fscy5nZXQobilbMF1bMV0gOiBuLmluaXRpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpYmVyIHJlZiB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBzZXRGaWJlclJlZihuLCByKSB7XG4gICAgdGhpcy5fZmliZXJSZWZzID0gS2ModGhpcy5fZmliZXJSZWZzLCB7XG4gICAgICBmaWJlcklkOiB0aGlzLl9maWJlcklkLFxuICAgICAgZmliZXJSZWY6IG4sXG4gICAgICB2YWx1ZTogclxuICAgIH0pLCB0aGlzLnJlZnJlc2hSZWZDYWNoZSgpO1xuICB9XG4gIHJlZnJlc2hSZWZDYWNoZSgpIHtcbiAgICB0aGlzLmN1cnJlbnREZWZhdWx0U2VydmljZXMgPSB0aGlzLmdldEZpYmVyUmVmKHJzKSwgdGhpcy5jdXJyZW50VHJhY2VyID0gdGhpcy5jdXJyZW50RGVmYXVsdFNlcnZpY2VzLnVuc2FmZU1hcC5nZXQoYWgua2V5KSwgdGhpcy5jdXJyZW50U3VwZXJ2aXNvciA9IHRoaXMuZ2V0RmliZXJSZWYoVncpLCB0aGlzLmN1cnJlbnRTY2hlZHVsZXIgPSB0aGlzLmdldEZpYmVyUmVmKF9vKSwgdGhpcy5jdXJyZW50Q29udGV4dCA9IHRoaXMuZ2V0RmliZXJSZWYocnQpLCB0aGlzLmN1cnJlbnRTcGFuID0gdGhpcy5jdXJyZW50Q29udGV4dC51bnNhZmVNYXAuZ2V0KHVoLmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdob2xlc2FsZSByZXBsYWNlcyBhbGwgZmliZXIgcmVmcyBvZiB0aGlzIGZpYmVyLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBzZXRGaWJlclJlZnMobikge1xuICAgIHRoaXMuX2ZpYmVyUmVmcyA9IG4sIHRoaXMucmVmcmVzaFJlZkNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWZlcmVuY2UgdG8gdGhlIHNwZWNpZmllZCBmaWJlciBpbnNpZGUgdGhlIGNoaWxkcmVuIHNldC5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIG11c3QgYmUgaW52b2tlZCBieSB0aGUgZmliZXIgaXRzZWxmLlxuICAgKi9cbiAgYWRkQ2hpbGQobikge1xuICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5hZGQobik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWZlcmVuY2UgdG8gdGhlIHNwZWNpZmllZCBmaWJlciBpbnNpZGUgdGhlIGNoaWxkcmVuIHNldC5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIG11c3QgYmUgaW52b2tlZCBieSB0aGUgZmliZXIgaXRzZWxmLlxuICAgKi9cbiAgcmVtb3ZlQ2hpbGQobikge1xuICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5kZWxldGUobik7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZmVycyBhbGwgY2hpbGRyZW4gb2YgdGhpcyBmaWJlciB0aGF0IGFyZSBjdXJyZW50bHkgcnVubmluZyB0byB0aGVcbiAgICogc3BlY2lmaWVkIGZpYmVyIHNjb3BlLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYgYWZ0ZXIgaXQgaGFzXG4gICAqIGV2YWx1YXRlZCB0aGUgZWZmZWN0cyBidXQgcHJpb3IgdG8gZXhpdGluZy5cbiAgICovXG4gIHRyYW5zZmVyQ2hpbGRyZW4obikge1xuICAgIGNvbnN0IHIgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBpZiAodGhpcy5fY2hpbGRyZW4gPSBudWxsLCByICE9PSBudWxsICYmIHIuc2l6ZSA+IDApXG4gICAgICBmb3IgKGNvbnN0IHMgb2YgcilcbiAgICAgICAgcy5fZXhpdFZhbHVlID09PSBudWxsICYmIG4uYWRkKHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncywgcyk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHRoZSBjdXJyZW50IHRocmVhZCwgZXhlY3V0ZXMgYWxsIG1lc3NhZ2VzIGluIHRoZSBmaWJlcidzIGluYm94LiBUaGlzXG4gICAqIG1ldGhvZCBtYXkgcmV0dXJuIGJlZm9yZSBhbGwgd29yayBpcyBkb25lLCBpbiB0aGUgZXZlbnQgdGhlIGZpYmVyIGV4ZWN1dGVzXG4gICAqIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIGRyYWluUXVldWVPbkN1cnJlbnRUaHJlYWQoKSB7XG4gICAgbGV0IG4gPSAhMDtcbiAgICBmb3IgKDsgbjsgKSB7XG4gICAgICBsZXQgciA9IEVuO1xuICAgICAgY29uc3QgcyA9IGdsb2JhbFRoaXNbY3RdO1xuICAgICAgZ2xvYmFsVGhpc1tjdF0gPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IHIgPT09IEVuOyApXG4gICAgICAgICAgciA9IHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCA/IFN3IDogdGhpcy5ldmFsdWF0ZU1lc3NhZ2VXaGlsZVN1c3BlbmRlZCh0aGlzLl9xdWV1ZS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9ICExLCBnbG9iYWxUaGlzW2N0XSA9IHM7XG4gICAgICB9XG4gICAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPiAwICYmICF0aGlzLl9ydW5uaW5nID8gKHRoaXMuX3J1bm5pbmcgPSAhMCwgciA9PT0gTGEgPyAodGhpcy5kcmFpblF1ZXVlTGF0ZXJPbkV4ZWN1dG9yKCksIG4gPSAhMSkgOiBuID0gITApIDogbiA9ICExO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGVzIHRoZSBleGVjdXRpb24gb2YgYWxsIG1lc3NhZ2VzIGluIHRoZSBmaWJlcidzIGluYm94LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBpbW1lZGlhdGVseSBhZnRlciB0aGUgc2NoZWR1bGluZ1xuICAgKiBvcGVyYXRpb24gaXMgY29tcGxldGVkLCBidXQgcG90ZW50aWFsbHkgYmVmb3JlIHN1Y2ggbWVzc2FnZXMgaGF2ZSBiZWVuXG4gICAqIGV4ZWN1dGVkLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBkcmFpblF1ZXVlTGF0ZXJPbkV4ZWN1dG9yKCkge1xuICAgIHRoaXMuY3VycmVudFNjaGVkdWxlci5zY2hlZHVsZVRhc2sodGhpcy5ydW4sIHRoaXMuZ2V0RmliZXJSZWYoZHIpKTtcbiAgfVxuICAvKipcbiAgICogRHJhaW5zIHRoZSBmaWJlcidzIG1lc3NhZ2UgcXVldWUgd2hpbGUgdGhlIGZpYmVyIGlzIGFjdGl2ZWx5IHJ1bm5pbmcsXG4gICAqIHJldHVybmluZyB0aGUgbmV4dCBlZmZlY3QgdG8gZXhlY3V0ZSwgd2hpY2ggbWF5IGJlIHRoZSBpbnB1dCBlZmZlY3QgaWYgbm9cbiAgICogYWRkaXRpb25hbCBlZmZlY3QgbmVlZHMgdG8gYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIGRyYWluUXVldWVXaGlsZVJ1bm5pbmcobiwgcikge1xuICAgIGxldCBzID0gcjtcbiAgICBmb3IgKDsgdGhpcy5fcXVldWUubGVuZ3RoID4gMDsgKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5fcXVldWUuc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgcyA9IHZ3W2MuX3RhZ10odGhpcywgbiwgcywgYyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWJlciBpcyBpbnRlcnJ1cHRlZC5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gaW52b2tlIG9uIGFueSBmaWJlciwgYnV0IGlmIG5vdCBpbnZva2VkXG4gICAqIG9uIHRoaXMgZmliZXIsIHRoZW4gdmFsdWVzIGRlcml2ZWQgZnJvbSB0aGUgZmliZXIncyBzdGF0ZSAoaW5jbHVkaW5nIHRoZVxuICAgKiBsb2cgYW5ub3RhdGlvbnMgYW5kIGxvZyBsZXZlbCkgbWF5IG5vdCBiZSB1cC10by1kYXRlLlxuICAgKi9cbiAgaXNJbnRlcnJ1cHRlZCgpIHtcbiAgICByZXR1cm4gIUV5KHRoaXMuZ2V0RmliZXJSZWYoSXIpKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBpbnRlcnJ1cHRvciB0byB0aGUgc2V0IG9mIGludGVycnVwdG9ycyB0aGF0IGFyZSBpbnRlcnJ1cHRpbmcgdGhpc1xuICAgKiBmaWJlci5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIG11c3QgYmUgaW52b2tlZCBieSB0aGUgZmliZXIgaXRzZWxmLlxuICAgKi9cbiAgYWRkSW50ZXJydXB0ZWRDYXVzZShuKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0RmliZXJSZWYoSXIpO1xuICAgIHRoaXMuc2V0RmliZXJSZWYoSXIsIHNlKHIsIG4pKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgbmV3IGluY29taW5nIGludGVycnVwdCBzaWduYWwuXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIHByb2Nlc3NOZXdJbnRlcnJ1cHRTaWduYWwobikge1xuICAgIHRoaXMuYWRkSW50ZXJydXB0ZWRDYXVzZShuKSwgdGhpcy5zZW5kSW50ZXJydXB0U2lnbmFsVG9BbGxDaGlsZHJlbigpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcnJ1cHRzIGFsbCBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBmaWJlciwgcmV0dXJuaW5nIGFuIGVmZmVjdCB0aGF0IHdpbGxcbiAgICogYXdhaXQgdGhlIGV4aXQgb2YgdGhlIGNoaWxkcmVuLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBmaWJlclxuICAgKiBoYXMgbm8gY2hpbGRyZW4uXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIHNlbmRJbnRlcnJ1cHRTaWduYWxUb0FsbENoaWxkcmVuKCkge1xuICAgIGlmICh0aGlzLl9jaGlsZHJlbiA9PT0gbnVsbCB8fCB0aGlzLl9jaGlsZHJlbi5zaXplID09PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBuID0gITE7XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2NoaWxkcmVuKVxuICAgICAgci50ZWxsKHBjKFRlKHRoaXMuaWQoKSkpKSwgbiA9ICEwO1xuICAgIHJldHVybiBuO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcnJ1cHRzIGFsbCBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBmaWJlciwgcmV0dXJuaW5nIGFuIGVmZmVjdCB0aGF0IHdpbGxcbiAgICogYXdhaXQgdGhlIGV4aXQgb2YgdGhlIGNoaWxkcmVuLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBmaWJlclxuICAgKiBoYXMgbm8gY2hpbGRyZW4uXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIGludGVycnVwdEFsbENoaWxkcmVuKCkge1xuICAgIGlmICh0aGlzLnNlbmRJbnRlcnJ1cHRTaWduYWxUb0FsbENoaWxkcmVuKCkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9jaGlsZHJlbi52YWx1ZXMoKTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcbiAgICAgIGxldCByID0gITE7XG4gICAgICByZXR1cm4gWWkoe1xuICAgICAgICB3aGlsZTogKCkgPT4gIXIsXG4gICAgICAgIGJvZHk6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjID0gbi5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGMuZG9uZSA/IHkoKCkgPT4ge1xuICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgIH0pIDogbnQoYy52YWx1ZS5hd2FpdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlcG9ydEV4aXRWYWx1ZShuKSB7XG4gICAgaWYgKFhvKHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncykpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmdldEZpYmVyUmVmKFVjKSwgcyA9IHRoaXMuaWQoKS5zdGFydFRpbWVNaWxsaXMsIGMgPSBEYXRlLm5vdygpO1xuICAgICAgc3dpdGNoIChidy51bnNhZmVVcGRhdGUoYyAtIHMsIHIpLCBqYS51bnNhZmVVcGRhdGUoLTEsIHIpLCBuLl90YWcpIHtcbiAgICAgICAgY2FzZSBuZToge1xuICAgICAgICAgIF93LnVuc2FmZVVwZGF0ZSgxLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHRlOiB7XG4gICAgICAgICAgeXcudW5zYWZlVXBkYXRlKDEsIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuLl90YWcgPT09IFwiRmFpbHVyZVwiKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5nZXRGaWJlclJlZihJYik7XG4gICAgICAhVWkobi5jYXVzZSkgJiYgci5fdGFnID09PSBcIlNvbWVcIiAmJiB0aGlzLmxvZyhcIkZpYmVyIHRlcm1pbmF0ZWQgd2l0aCBhbiB1bmhhbmRsZWQgZXJyb3JcIiwgbi5jYXVzZSwgcik7XG4gICAgfVxuICB9XG4gIHNldEV4aXRWYWx1ZShuKSB7XG4gICAgdGhpcy5fZXhpdFZhbHVlID0gbiwgdGhpcy5yZXBvcnRFeGl0VmFsdWUobik7XG4gICAgZm9yIChsZXQgciA9IHRoaXMuX29ic2VydmVycy5sZW5ndGggLSAxOyByID49IDA7IHItLSlcbiAgICAgIHRoaXMuX29ic2VydmVyc1tyXShuKTtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBbXTtcbiAgfVxuICBnZXRMb2dnZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZpYmVyUmVmKFJ3KTtcbiAgfVxuICBsb2cobiwgciwgcykge1xuICAgIGNvbnN0IGMgPSB5ZShzKSA/IHMudmFsdWUgOiB0aGlzLmdldEZpYmVyUmVmKHZiKSwgaSA9IHRoaXMuZ2V0RmliZXJSZWYoJHcpO1xuICAgIGlmIChoMChpLCBjKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdGhpcy5nZXRGaWJlclJlZih3YiksIGEgPSB0aGlzLmdldEZpYmVyUmVmKGtiKSwgaCA9IHRoaXMuZ2V0TG9nZ2VycygpLCBkID0gdGhpcy5nZXRGaWJlclJlZnMoKTtcbiAgICBpZiAoWmwoaCkgPiAwKSB7XG4gICAgICBjb25zdCBnID0gTWwodGhpcy5nZXRGaWJlclJlZihycyksIFFzKSwgcCA9IG5ldyBEYXRlKGcudW5zYWZlQ3VycmVudFRpbWVNaWxsaXMoKSk7XG4gICAgICBuZyhkLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgXyBvZiBoKVxuICAgICAgICAgIF8ubG9nKHtcbiAgICAgICAgICAgIGZpYmVySWQ6IHRoaXMuaWQoKSxcbiAgICAgICAgICAgIGxvZ0xldmVsOiBjLFxuICAgICAgICAgICAgbWVzc2FnZTogbixcbiAgICAgICAgICAgIGNhdXNlOiByLFxuICAgICAgICAgICAgY29udGV4dDogZCxcbiAgICAgICAgICAgIHNwYW5zOiBvLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGEsXG4gICAgICAgICAgICBkYXRlOiBwXG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyBhIHNpbmdsZSBtZXNzYWdlIG9uIHRoZSBjdXJyZW50IHRocmVhZCwgd2hpbGUgdGhlIGZpYmVyIGlzXG4gICAqIHN1c3BlbmRlZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoaWxlIGV2YWx1YXRpb24gb2YgdGhlXG4gICAqIGZpYmVyJ3MgZWZmZWN0IGlzIHN1c3BlbmRlZCBkdWUgdG8gYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogKipOT1RFKio6IFRoaXMgbWV0aG9kIG11c3QgYmUgaW52b2tlZCBieSB0aGUgZmliZXIgaXRzZWxmLlxuICAgKi9cbiAgZXZhbHVhdGVNZXNzYWdlV2hpbGVTdXNwZW5kZWQobikge1xuICAgIHN3aXRjaCAobi5fdGFnKSB7XG4gICAgICBjYXNlIGtvOlxuICAgICAgICByZXR1cm4gTGE7XG4gICAgICBjYXNlIHlvOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzTmV3SW50ZXJydXB0U2lnbmFsKG4uY2F1c2UpLCB0aGlzLl9hc3luY0ludGVycnVwdG9yICE9PSBudWxsICYmICh0aGlzLl9hc3luY0ludGVycnVwdG9yKEEobi5jYXVzZSkpLCB0aGlzLl9hc3luY0ludGVycnVwdG9yID0gbnVsbCksIEVuO1xuICAgICAgY2FzZSBTbzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSW50ZXJydXB0b3IgPSBudWxsLCB0aGlzLl9hc3luY0Jsb2NraW5nT24gPSBudWxsLCB0aGlzLmV2YWx1YXRlRWZmZWN0KG4uZWZmZWN0KSwgRW47XG4gICAgICBjYXNlIGJvOlxuICAgICAgICByZXR1cm4gbi5vbkZpYmVyKHRoaXMsIHRoaXMuX2V4aXRWYWx1ZSAhPT0gbnVsbCA/IFgwIDogZWsodGhpcy5jdXJyZW50UnVudGltZUZsYWdzLCB0aGlzLl9hc3luY0Jsb2NraW5nT24pKSwgRW47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUnIobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgYW4gZWZmZWN0IHVudGlsIGNvbXBsZXRpb24sIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBldmFsdWF0ZUVmZmVjdChuKSB7XG4gICAgdGhpcy5jdXJyZW50U3VwZXJ2aXNvci5vblJlc3VtZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHIgPSBHZSh0aGlzLmN1cnJlbnRSdW50aW1lRmxhZ3MpICYmIHRoaXMuaXNJbnRlcnJ1cHRlZCgpID8gQSh0aGlzLmdldEludGVycnVwdGVkQ2F1c2UoKSkgOiBuO1xuICAgICAgZm9yICg7IHIgIT09IG51bGw7ICkge1xuICAgICAgICBjb25zdCBzID0gciwgYyA9IHRoaXMucnVuTG9vcChzKTtcbiAgICAgICAgaWYgKGMgPT09IHplKSB7XG4gICAgICAgICAgY29uc3QgaSA9IEJlLmN1cnJlbnRPcDtcbiAgICAgICAgICBCZS5jdXJyZW50T3AgPSBudWxsLCBpLl9vcCA9PT0gQ3IgPyBueSh0aGlzLmN1cnJlbnRSdW50aW1lRmxhZ3MpID8gKHRoaXMudGVsbChDaygpKSwgdGhpcy50ZWxsKEN0KE5lKSksIHIgPSBudWxsKSA6IHIgPSBOZSA6IGkuX29wID09PSBSbiAmJiAociA9IG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncyA9IGYodGhpcy5jdXJyZW50UnVudGltZUZsYWdzLCByeShMYykpO1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmludGVycnVwdEFsbENoaWxkcmVuKCk7XG4gICAgICAgICAgaSAhPT0gbnVsbCA/IHIgPSBtKGksICgpID0+IGMpIDogKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCA/IHRoaXMuc2V0RXhpdFZhbHVlKGMpIDogdGhpcy50ZWxsKEN0KGMpKSwgciA9IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY3VycmVudFN1cGVydmlzb3Iub25TdXNwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQmVnaW5zIGV4ZWN1dGlvbiBvZiB0aGUgZWZmZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpYmVyIG9uIHRoZSBjdXJyZW50XG4gICAqIHRocmVhZC4gVGhpcyBjYW4gYmUgY2FsbGVkIHRvIFwia2ljayBvZmZcIiBleGVjdXRpb24gb2YgYSBmaWJlciBhZnRlciBpdCBoYXNcbiAgICogYmVlbiBjcmVhdGVkLCBpbiBob3BlcyB0aGF0IHRoZSBlZmZlY3QgY2FuIGJlIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIFRoaXMgaXMgbm90IHRoZSBub3JtYWwgd2F5IG9mIHN0YXJ0aW5nIGEgZmliZXIsIGJ1dCBpdCBpcyB1c2VmdWwgd2hlbiB0aGVcbiAgICogZXhwcmVzcyBnb2FsIG9mIGV4ZWN1dGluZyB0aGUgZmliZXIgaXMgdG8gc3luY2hyb25vdXNseSBwcm9kdWNlIGl0cyBleGl0LlxuICAgKi9cbiAgc3RhcnQobikge1xuICAgIGlmICh0aGlzLl9ydW5uaW5nKVxuICAgICAgdGhpcy50ZWxsKEN0KG4pKTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSAhMDtcbiAgICAgIGNvbnN0IHIgPSBnbG9iYWxUaGlzW2N0XTtcbiAgICAgIGdsb2JhbFRoaXNbY3RdID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZXZhbHVhdGVFZmZlY3Qobik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gITEsIGdsb2JhbFRoaXNbY3RdID0gciwgdGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLmRyYWluUXVldWVMYXRlck9uRXhlY3V0b3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEJlZ2lucyBleGVjdXRpb24gb2YgdGhlIGVmZmVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWJlciBvbiBpbiB0aGVcbiAgICogYmFja2dyb3VuZCwgYW5kIG9uIHRoZSBjb3JyZWN0IHRocmVhZCBwb29sLiBUaGlzIGNhbiBiZSBjYWxsZWQgdG8gXCJraWNrXG4gICAqIG9mZlwiIGV4ZWN1dGlvbiBvZiBhIGZpYmVyIGFmdGVyIGl0IGhhcyBiZWVuIGNyZWF0ZWQsIGluIGhvcGVzIHRoYXQgdGhlXG4gICAqIGVmZmVjdCBjYW4gYmUgZXhlY3V0ZWQgc3luY2hyb25vdXNseS5cbiAgICovXG4gIHN0YXJ0Rm9yayhuKSB7XG4gICAgdGhpcy50ZWxsKEN0KG4pKTtcbiAgfVxuICAvKipcbiAgICogVGFrZXMgdGhlIGN1cnJlbnQgcnVudGltZSBmbGFncywgcGF0Y2hlcyB0aGVtIHRvIHJldHVybiB0aGUgbmV3IHJ1bnRpbWVcbiAgICogZmxhZ3MsIGFuZCB0aGVuIG1ha2VzIGFueSBjaGFuZ2VzIG5lY2Vzc2FyeSB0byBmaWJlciBzdGF0ZSBiYXNlZCBvbiB0aGVcbiAgICogc3BlY2lmaWVkIHBhdGNoLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBwYXRjaFJ1bnRpbWVGbGFncyhuLCByKSB7XG4gICAgY29uc3QgcyA9IER0KG4sIHIpO1xuICAgIHJldHVybiBnbG9iYWxUaGlzW2N0XSA9IHRoaXMsIHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncyA9IHMsIHM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLCBieSBidWlsZGluZyBhIGNhbGxiYWNrIHRoYXQgd2lsbFxuICAgKiByZXN1bWUgZXhlY3V0aW9uLCBhbmQgdGhlbiBmZWVkaW5nIHRoYXQgY2FsbGJhY2sgdG8gdGhlIHJlZ2lzdHJhdGlvblxuICAgKiBmdW5jdGlvbiwgaGFuZGxpbmcgZXJyb3IgY2FzZXMgYW5kIHJlcGVhdGVkIHJlc3VtcHRpb25zIGFwcHJvcHJpYXRlbHkuXG4gICAqXG4gICAqICoqTk9URSoqOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYnkgdGhlIGZpYmVyIGl0c2VsZi5cbiAgICovXG4gIGluaXRpYXRlQXN5bmMobiwgcikge1xuICAgIGxldCBzID0gITE7XG4gICAgY29uc3QgYyA9IChpKSA9PiB7XG4gICAgICBzIHx8IChzID0gITAsIHRoaXMudGVsbChDdChpKSkpO1xuICAgIH07XG4gICAgR2UobikgJiYgKHRoaXMuX2FzeW5jSW50ZXJydXB0b3IgPSBjKTtcbiAgICB0cnkge1xuICAgICAgcihjKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBjKFooT2UoaSkpKTtcbiAgICB9XG4gIH1cbiAgcHVzaFN0YWNrKG4pIHtcbiAgICB0aGlzLl9zdGFjay5wdXNoKG4pLCBuLl9vcCA9PT0gXCJPblN0ZXBcIiAmJiB0aGlzLl9zdGVwcy5wdXNoKHtcbiAgICAgIHJlZnM6IHRoaXMuZ2V0RmliZXJSZWZzKCksXG4gICAgICBmbGFnczogdGhpcy5jdXJyZW50UnVudGltZUZsYWdzXG4gICAgfSk7XG4gIH1cbiAgcG9wU3RhY2soKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX3N0YWNrLnBvcCgpO1xuICAgIGlmIChuKVxuICAgICAgcmV0dXJuIG4uX29wID09PSBcIk9uU3RlcFwiICYmIHRoaXMuX3N0ZXBzLnBvcCgpLCBuO1xuICB9XG4gIGdldE5leHRTdWNjZXNzQ29udCgpIHtcbiAgICBsZXQgbiA9IHRoaXMucG9wU3RhY2soKTtcbiAgICBmb3IgKDsgbjsgKSB7XG4gICAgICBpZiAobi5fb3AgIT09IFRyKVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIG4gPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuICB9XG4gIGdldE5leHRGYWlsQ29udCgpIHtcbiAgICBsZXQgbiA9IHRoaXMucG9wU3RhY2soKTtcbiAgICBmb3IgKDsgbjsgKSB7XG4gICAgICBpZiAobi5fb3AgIT09IHpyICYmIG4uX29wICE9PSBWciAmJiBuLl9vcCAhPT0gTW4pXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgbiA9IHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG4gIH1cbiAgWyhVdSA9IExrLCBxdSA9IFVrLCBzZyldKG4pIHtcbiAgICByZXR1cm4geSgoKSA9PiBUbCh0aGlzLmN1cnJlbnRDb250ZXh0LCBuKSk7XG4gIH1cbiAgTGVmdChuKSB7XG4gICAgcmV0dXJuIHgobi5sZWZ0KTtcbiAgfVxuICBOb25lKG4pIHtcbiAgICByZXR1cm4geChuZXcgSHMoKSk7XG4gIH1cbiAgUmlnaHQobikge1xuICAgIHJldHVybiBqKG4ucmlnaHQpO1xuICB9XG4gIFNvbWUobikge1xuICAgIHJldHVybiBqKG4udmFsdWUpO1xuICB9XG4gIE1pY3JvKG4pIHtcbiAgICByZXR1cm4gVm4oKHIpID0+IHtcbiAgICAgIGxldCBzID0gcjtcbiAgICAgIGNvbnN0IGMgPSBSayh2ayhuLCB0aGlzLmN1cnJlbnRDb250ZXh0KSk7XG4gICAgICByZXR1cm4gYy5hZGRPYnNlcnZlcigoaSkgPT4ge1xuICAgICAgICBpZiAoaS5fdGFnID09PSBcIlN1Y2Nlc3NcIilcbiAgICAgICAgICByZXR1cm4gcyhqKGkudmFsdWUpKTtcbiAgICAgICAgc3dpdGNoIChpLmNhdXNlLl90YWcpIHtcbiAgICAgICAgICBjYXNlIFwiSW50ZXJydXB0XCI6XG4gICAgICAgICAgICByZXR1cm4gcyhBKFRlKEh0KSkpO1xuICAgICAgICAgIGNhc2UgXCJGYWlsXCI6XG4gICAgICAgICAgICByZXR1cm4gcyh4KGkuY2F1c2UuZXJyb3IpKTtcbiAgICAgICAgICBjYXNlIFwiRGllXCI6XG4gICAgICAgICAgICByZXR1cm4gcyhYcihpLmNhdXNlLmRlZmVjdCkpO1xuICAgICAgICB9XG4gICAgICB9KSwgVm4oKGkpID0+IHtcbiAgICAgICAgcyA9IChvKSA9PiB7XG4gICAgICAgICAgaShLKTtcbiAgICAgICAgfSwgYy51bnNhZmVJbnRlcnJ1cHQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFthbF0obikge1xuICAgIGNvbnN0IHIgPSBlZSgoKSA9PiBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCgpKSwgcyA9IHRoaXMuZ2V0TmV4dFN1Y2Nlc3NDb250KCk7XG4gICAgcmV0dXJuIHMgIT09IHZvaWQgMCA/IChzLl9vcCBpbiBJbiB8fCBScihzKSwgSW5bcy5fb3BdKHRoaXMsIHMsIHIpKSA6IChCZS5jdXJyZW50T3AgPSBqKHIpLCB6ZSk7XG4gIH1cbiAgW25lXShuKSB7XG4gICAgY29uc3QgciA9IG4sIHMgPSB0aGlzLmdldE5leHRTdWNjZXNzQ29udCgpO1xuICAgIHJldHVybiBzICE9PSB2b2lkIDAgPyAocy5fb3AgaW4gSW4gfHwgUnIocyksIEluW3MuX29wXSh0aGlzLCBzLCByLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCkpIDogKEJlLmN1cnJlbnRPcCA9IHIsIHplKTtcbiAgfVxuICBbdGVdKG4pIHtcbiAgICBjb25zdCByID0gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAsIHMgPSB0aGlzLmdldE5leHRGYWlsQ29udCgpO1xuICAgIGlmIChzICE9PSB2b2lkIDApXG4gICAgICBzd2l0Y2ggKHMuX29wKSB7XG4gICAgICAgIGNhc2UgVHI6XG4gICAgICAgIGNhc2UgQnI6XG4gICAgICAgICAgcmV0dXJuIEdlKHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncykgJiYgdGhpcy5pc0ludGVycnVwdGVkKCkgPyBBKG5hKHIpKSA6IGVlKCgpID0+IHMuZWZmZWN0X2luc3RydWN0aW9uX2kxKHIpKTtcbiAgICAgICAgY2FzZSBcIk9uU3RlcFwiOlxuICAgICAgICAgIHJldHVybiBHZSh0aGlzLmN1cnJlbnRSdW50aW1lRmxhZ3MpICYmIHRoaXMuaXNJbnRlcnJ1cHRlZCgpID8gQShuYShyKSkgOiBqKEEocikpO1xuICAgICAgICBjYXNlIHBpOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhdGNoUnVudGltZUZsYWdzKHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncywgcy5wYXRjaCksIEdlKHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncykgJiYgdGhpcy5pc0ludGVycnVwdGVkKCkgPyBBKHNlKHIsIHRoaXMuZ2V0SW50ZXJydXB0ZWRDYXVzZSgpKSkgOiBBKHIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFJyKHMpO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBCZS5jdXJyZW50T3AgPSBBKHIpLCB6ZTtcbiAgfVxuICBbdWxdKG4pIHtcbiAgICByZXR1cm4gZWUoKCkgPT4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAodGhpcywgUmgodGhpcy5jdXJyZW50UnVudGltZUZsYWdzKSkpO1xuICB9XG4gIEJsb2NrZWQobikge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldEZpYmVyUmVmcygpLCBzID0gdGhpcy5jdXJyZW50UnVudGltZUZsYWdzO1xuICAgIGlmICh0aGlzLl9zdGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjID0gW10sIGkgPSB0aGlzLl9zdGVwc1t0aGlzLl9zdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBvID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgZm9yICg7IG8gJiYgby5fb3AgIT09IFwiT25TdGVwXCI7IClcbiAgICAgICAgYy5wdXNoKG8pLCBvID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgdGhpcy5zZXRGaWJlclJlZnMoaS5yZWZzKSwgdGhpcy5jdXJyZW50UnVudGltZUZsYWdzID0gaS5mbGFncztcbiAgICAgIGNvbnN0IGEgPSBXbihpLnJlZnMsIHIpLCBoID0gZ3QoaS5mbGFncywgcyk7XG4gICAgICByZXR1cm4gaihSZihuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCwgTCgoZCkgPT4ge1xuICAgICAgICBmb3IgKDsgYy5sZW5ndGggPiAwOyApXG4gICAgICAgICAgZC5wdXNoU3RhY2soYy5wb3AoKSk7XG4gICAgICAgIHJldHVybiBkLnNldEZpYmVyUmVmcyhKbihkLmlkKCksIGQuZ2V0RmliZXJSZWZzKCkpKGEpKSwgZC5jdXJyZW50UnVudGltZUZsYWdzID0gRHQoaCkoZC5jdXJyZW50UnVudGltZUZsYWdzKSwgbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTE7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gRWUoKGMpID0+IG0oJG8oSHkobi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApKSwgKCkgPT4gYyhuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSkpKTtcbiAgfVxuICBSdW5CbG9ja2VkKG4pIHtcbiAgICByZXR1cm4gd3cobi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICB9XG4gIFt1bl0obikge1xuICAgIGNvbnN0IHIgPSBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCwgcyA9IHRoaXMuY3VycmVudFJ1bnRpbWVGbGFncywgYyA9IER0KHMsIHIpO1xuICAgIGlmIChHZShjKSAmJiB0aGlzLmlzSW50ZXJydXB0ZWQoKSlcbiAgICAgIHJldHVybiBBKHRoaXMuZ2V0SW50ZXJydXB0ZWRDYXVzZSgpKTtcbiAgICBpZiAodGhpcy5wYXRjaFJ1bnRpbWVGbGFncyh0aGlzLmN1cnJlbnRSdW50aW1lRmxhZ3MsIHIpLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMSkge1xuICAgICAgY29uc3QgaSA9IGd0KGMsIHMpO1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG5ldyBHeShpLCBuKSksIGVlKCgpID0+IG4uZWZmZWN0X2luc3RydWN0aW9uX2kxKHMpKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBOZTtcbiAgfVxuICBbenJdKG4pIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobiksIG4uZWZmZWN0X2luc3RydWN0aW9uX2kwO1xuICB9XG4gIE9uU3RlcChuKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMDtcbiAgfVxuICBbVHJdKG4pIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobiksIG4uZWZmZWN0X2luc3RydWN0aW9uX2kwO1xuICB9XG4gIFtCcl0obikge1xuICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuKSwgbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTA7XG4gIH1cbiAgW1JuXShuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FzeW5jQmxvY2tpbmdPbiA9IG4uZWZmZWN0X2luc3RydWN0aW9uX2kxLCB0aGlzLmluaXRpYXRlQXN5bmModGhpcy5jdXJyZW50UnVudGltZUZsYWdzLCBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCksIEJlLmN1cnJlbnRPcCA9IG4sIHplO1xuICB9XG4gIFtDcl0obikge1xuICAgIHJldHVybiB0aGlzLl9pc1lpZWxkaW5nID0gITEsIEJlLmN1cnJlbnRPcCA9IG4sIHplO1xuICB9XG4gIFtWcl0obikge1xuICAgIGNvbnN0IHIgPSBuLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCwgcyA9IG4uZWZmZWN0X2luc3RydWN0aW9uX2kxO1xuICAgIHJldHVybiByKCkgPyAodGhpcy5wdXNoU3RhY2sobiksIHMoKSkgOiBOZTtcbiAgfVxuICBbTW5dKG4pIHtcbiAgICByZXR1cm4gSW5bTW5dKHRoaXMsIG4sIHZvaWQgMCk7XG4gIH1cbiAgW3dzXShuKSB7XG4gICAgcmV0dXJuIGVlKCgpID0+IG4uY29tbWl0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWFpbiBydW4tbG9vcCBmb3IgZXZhbHVhdGluZyBlZmZlY3RzLlxuICAgKlxuICAgKiAqKk5PVEUqKjogVGhpcyBtZXRob2QgbXVzdCBiZSBpbnZva2VkIGJ5IHRoZSBmaWJlciBpdHNlbGYuXG4gICAqL1xuICBydW5Mb29wKG4pIHtcbiAgICBsZXQgciA9IG47XG4gICAgZm9yICh0aGlzLmN1cnJlbnRPcENvdW50ID0gMDsgOyApIHtcbiAgICAgIGlmICgodGhpcy5jdXJyZW50UnVudGltZUZsYWdzICYgdHkpICE9PSAwICYmIHRoaXMuY3VycmVudFN1cGVydmlzb3Iub25FZmZlY3QodGhpcywgciksIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgJiYgKHIgPSB0aGlzLmRyYWluUXVldWVXaGlsZVJ1bm5pbmcodGhpcy5jdXJyZW50UnVudGltZUZsYWdzLCByKSksICF0aGlzLl9pc1lpZWxkaW5nKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE9wQ291bnQgKz0gMTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuY3VycmVudFNjaGVkdWxlci5zaG91bGRZaWVsZCh0aGlzKTtcbiAgICAgICAgaWYgKHMgIT09ICExKSB7XG4gICAgICAgICAgdGhpcy5faXNZaWVsZGluZyA9ICEwLCB0aGlzLmN1cnJlbnRPcENvdW50ID0gMDtcbiAgICAgICAgICBjb25zdCBjID0gcjtcbiAgICAgICAgICByID0gbShRaSh7XG4gICAgICAgICAgICBwcmlvcml0eTogc1xuICAgICAgICAgIH0pLCAoKSA9PiBjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIgPSB0aGlzLmN1cnJlbnRUcmFjZXIuY29udGV4dCgoKSA9PiBPdyAhPT0gclt0bl0uX1YgPyBxYyhgQ2Fubm90IGV4ZWN1dGUgYW4gRWZmZWN0IHZlcnNpb25lZCAke3JbdG5dLl9WfSB3aXRoIGEgUnVudGltZSBvZiB2ZXJzaW9uICR7YnMoKX1gKSA6IHRoaXNbci5fb3BdKHIpLCB0aGlzKSwgciA9PT0gemUpIHtcbiAgICAgICAgICBjb25zdCBzID0gQmUuY3VycmVudE9wO1xuICAgICAgICAgIHJldHVybiBzLl9vcCA9PT0gQ3IgfHwgcy5fb3AgPT09IFJuID8gemUgOiAoQmUuY3VycmVudE9wID0gbnVsbCwgcy5fb3AgPT09IG5lIHx8IHMuX29wID09PSB0ZSA/IHMgOiBBKE9lKHMpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgciAhPT0gemUgJiYgISQociwgXCJfb3BcIikgfHwgIShyLl9vcCBpbiB0aGlzKSA/IHIgPSBxYyhgTm90IGEgdmFsaWQgZWZmZWN0OiAke1V0KHIpfWApIDogTWIocykgPyByID0gQShzZShPZShzKSwgVGUoSHQpKSkgOiByID0gWHIocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCAkdyA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiZWZmZWN0L0ZpYmVyUmVmL2N1cnJlbnRNaW5pbXVtTG9nTGV2ZWxcIiwgKCkgPT4gZ2UoZDAoXCJJbmZvXCIpKSksIEV3ID0gKGUpID0+IHZvKCh0KSA9PiB7XG4gIGNvbnN0IG4gPSBlMCh0LmNvbnRleHQsIHJzKTtcbiAgTWwobiwgb2gpLnVuc2FmZS5sb2coZS5sb2codCkpO1xufSksIEl3ID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTG9nZ2VyL2RlZmF1bHRMb2dnZXJcIiksICgpID0+IEV3KEhrKSksIEZ3ID0gLyogQF9fUFVSRV9fICovIEMoLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvTG9nZ2VyL3RyYWNlckxvZ2dlclwiKSwgKCkgPT4gdm8oKHtcbiAgYW5ub3RhdGlvbnM6IGUsXG4gIGNhdXNlOiB0LFxuICBjb250ZXh0OiBuLFxuICBmaWJlcklkOiByLFxuICBsb2dMZXZlbDogcyxcbiAgbWVzc2FnZTogY1xufSkgPT4ge1xuICBjb25zdCBpID0gc3IoS24obiwgcnQpLCB1aCk7XG4gIGlmIChpLl90YWcgPT09IFwiTm9uZVwiIHx8IGkudmFsdWUuX3RhZyA9PT0gXCJFeHRlcm5hbFNwYW5cIilcbiAgICByZXR1cm47XG4gIGNvbnN0IG8gPSBUbChLbihuLCBycyksIFFzKSwgYSA9IHt9O1xuICBmb3IgKGNvbnN0IFtoLCBkXSBvZiBlKVxuICAgIGFbaF0gPSBkO1xuICBhW1wiZWZmZWN0LmZpYmVySWRcIl0gPSB6cChyKSwgYVtcImVmZmVjdC5sb2dMZXZlbFwiXSA9IHMubGFiZWwsIHQgIT09IG51bGwgJiYgdC5fdGFnICE9PSBcIkVtcHR5XCIgJiYgKGFbXCJlZmZlY3QuY2F1c2VcIl0gPSBhcih0LCB7XG4gICAgcmVuZGVyRXJyb3JDYXVzZTogITBcbiAgfSkpLCBpLnZhbHVlLmV2ZW50KFV0KEFycmF5LmlzQXJyYXkoYykgPyBjWzBdIDogYyksIG8udW5zYWZlQ3VycmVudFRpbWVOYW5vcygpLCBhKTtcbn0pKSwgUncgPSAvKiBAX19QVVJFX18gKi8gQygvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcImVmZmVjdC9GaWJlclJlZi9jdXJyZW50TG9nZ2Vyc1wiKSwgKCkgPT4geWIoUGkoSXcsIEZ3KSkpLCBNdyA9IC8qIEBfX1BVUkVfXyAqLyBsKChlKSA9PiBMZShlWzBdKSwgKGUsIHQpID0+IEtzKEdpKGUsIChuKSA9PiBUdygocikgPT4gdChuLCByKSkpKSksIFR3ID0gKGUpID0+IEwoKHQpID0+IHtcbiAgY29uc3QgbiA9IHQuZ2V0RmliZXJSZWZzKCksIHIgPSB0LmN1cnJlbnRSdW50aW1lRmxhZ3M7XG4gIHJldHVybiBtKGZkLCAocykgPT4gdHMocywgKGMpID0+IEwoKGkpID0+IHtcbiAgICBjb25zdCBvID0gaS5nZXRGaWJlclJlZnMoKSwgYSA9IGkuY3VycmVudFJ1bnRpbWVGbGFncywgaCA9IFduKG8sIG4pLCBkID0gZ3QoYSwgciksIGcgPSBXbihuLCBvKTtcbiAgICByZXR1cm4gaS5zZXRGaWJlclJlZnMoSm4oaCwgaS5pZCgpLCBuKSksIEhuKGliKGUoYyksIGQpLCB5KCgpID0+IHtcbiAgICAgIGkuc2V0RmliZXJSZWZzKEpuKGcsIGkuaWQoKSwgaS5nZXRGaWJlclJlZnMoKSkpO1xuICAgIH0pKTtcbiAgfSkpKTtcbn0pLCBDdyA9IChlKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpIHx8IHRsKGUpKVxuICAgIHJldHVybiBbZSwgdigpXTtcbiAgY29uc3QgdCA9IE9iamVjdC5rZXlzKGUpLCBuID0gdC5sZW5ndGg7XG4gIHJldHVybiBbdC5tYXAoKHIpID0+IGVbcl0pLCBJKChyKSA9PiB7XG4gICAgY29uc3QgcyA9IHt9O1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgc1t0W2NdXSA9IHJbY107XG4gICAgcmV0dXJuIHM7XG4gIH0pXTtcbn0sIE53ID0gKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IFtdO1xuICBmb3IgKGNvbnN0IHMgb2YgZSlcbiAgICByLnB1c2gobm4ocykpO1xuICByZXR1cm4gbShjbihyLCBQLCB7XG4gICAgY29uY3VycmVuY3k6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVuY3ksXG4gICAgYmF0Y2hpbmc6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uYmF0Y2hpbmcsXG4gICAgY29uY3VycmVudEZpbmFsaXplcnM6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVudEZpbmFsaXplcnNcbiAgfSksIChzKSA9PiB7XG4gICAgY29uc3QgYyA9IHYoKSwgaSA9IHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KGkpLCBhID0gbmV3IEFycmF5KGkpO1xuICAgIGxldCBoID0gITE7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBpOyBkKyspIHtcbiAgICAgIGNvbnN0IGcgPSBzW2RdO1xuICAgICAgZy5fdGFnID09PSBcIkxlZnRcIiA/IChvW2RdID0gSShnLmxlZnQpLCBoID0gITApIDogKGFbZF0gPSBnLnJpZ2h0LCBvW2RdID0gYyk7XG4gICAgfVxuICAgIHJldHVybiBoID8gdC5fdGFnID09PSBcIlNvbWVcIiA/IHgodC52YWx1ZShvKSkgOiB4KG8pIDogbiAhPSBudWxsICYmIG4uZGlzY2FyZCA/IEsgOiB0Ll90YWcgPT09IFwiU29tZVwiID8gUyh0LnZhbHVlKGEpKSA6IFMoYSk7XG4gIH0pO1xufSwgQXcgPSAoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gW107XG4gIGZvciAoY29uc3QgcyBvZiBlKVxuICAgIHIucHVzaChubihzKSk7XG4gIHJldHVybiBuICE9IG51bGwgJiYgbi5kaXNjYXJkID8gY24ociwgUCwge1xuICAgIGNvbmN1cnJlbmN5OiBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNvbmN1cnJlbmN5LFxuICAgIGJhdGNoaW5nOiBuID09IG51bGwgPyB2b2lkIDAgOiBuLmJhdGNoaW5nLFxuICAgIGRpc2NhcmQ6ICEwLFxuICAgIGNvbmN1cnJlbnRGaW5hbGl6ZXJzOiBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNvbmN1cnJlbnRGaW5hbGl6ZXJzXG4gIH0pIDogVChjbihyLCBQLCB7XG4gICAgY29uY3VycmVuY3k6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVuY3ksXG4gICAgYmF0Y2hpbmc6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uYmF0Y2hpbmcsXG4gICAgY29uY3VycmVudEZpbmFsaXplcnM6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVudEZpbmFsaXplcnNcbiAgfSksIChzKSA9PiB0Ll90YWcgPT09IFwiU29tZVwiID8gdC52YWx1ZShzKSA6IHMpO1xufSwgb2QgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBbbiwgcl0gPSBDdyhlKTtcbiAgcmV0dXJuICh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1vZGUpID09PSBcInZhbGlkYXRlXCIgPyBOdyhuLCByLCB0KSA6ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1vZGUpID09PSBcImVpdGhlclwiID8gQXcobiwgciwgdCkgOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5kaXNjYXJkKSAhPT0gITAgJiYgci5fdGFnID09PSBcIlNvbWVcIiA/IFQoY24obiwgUCwgdCksIHIudmFsdWUpIDogY24obiwgUCwgdCk7XG59LCBjbiA9IC8qIEBfX1BVUkVfXyAqLyBsKChlKSA9PiB0bChlWzBdKSwgKGUsIHQsIG4pID0+IEwoKHIpID0+IHtcbiAgY29uc3QgcyA9IChuID09IG51bGwgPyB2b2lkIDAgOiBuLmJhdGNoaW5nKSA9PT0gITAgfHwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uYmF0Y2hpbmcpID09PSBcImluaGVyaXRcIiAmJiByLmdldEZpYmVyUmVmKEViKTtcbiAgcmV0dXJuIG4gIT0gbnVsbCAmJiBuLmRpc2NhcmQgPyBDYShuLmNvbmN1cnJlbmN5LCAoKSA9PiBOdChHYywgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jb25jdXJyZW50RmluYWxpemVycykoKGMpID0+IHMgPyBwdChlLCAoaSwgbykgPT4gYyh0KGksIG8pKSwgITAsICExLCAxKSA6IEJzKGUsIChpLCBvKSA9PiBjKHQoaSwgbykpKSksICgpID0+IE50KFljLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNvbmN1cnJlbnRGaW5hbGl6ZXJzKSgoYykgPT4gcHQoZSwgKGksIG8pID0+IGModChpLCBvKSksIHMsICExKSksIChjKSA9PiBOdChRYyhjKSwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jb25jdXJyZW50RmluYWxpemVycykoKGkpID0+IHB0KGUsIChvLCBhKSA9PiBpKHQobywgYSkpLCBzLCAhMSwgYykpKSA6IENhKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVuY3ksICgpID0+IE50KEdjLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNvbmN1cnJlbnRGaW5hbGl6ZXJzKSgoYykgPT4gcyA/IHVpKGUsIDEsIChpLCBvKSA9PiBjKHQoaSwgbykpLCAhMCkgOiBLZShlLCAoaSwgbykgPT4gYyh0KGksIG8pKSkpLCAoKSA9PiBOdChZYywgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jb25jdXJyZW50RmluYWxpemVycykoKGMpID0+IGFkKGUsIChpLCBvKSA9PiBjKHQoaSwgbykpLCBzKSksIChjKSA9PiBOdChRYyhjKSwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jb25jdXJyZW50RmluYWxpemVycykoKGkpID0+IHVpKGUsIGMsIChvLCBhKSA9PiBpKHQobywgYSkpLCBzKSkpO1xufSkpLCBhZCA9IChlLCB0LCBuKSA9PiBOKCgpID0+IHtcbiAgY29uc3QgciA9IHooZSksIHMgPSBuZXcgQXJyYXkoci5sZW5ndGgpO1xuICByZXR1cm4gb2UocHQociwgKGksIG8pID0+IG0odChpLCBvKSwgKGEpID0+IHkoKCkgPT4gc1tvXSA9IGEpKSwgbiwgITEpLCBTKHMpKTtcbn0pLCBwdCA9IChlLCB0LCBuLCByLCBzKSA9PiBFZSgoYykgPT4gdGIoKGkpID0+IEwoKG8pID0+IHtcbiAgbGV0IGEgPSBBcnJheS5mcm9tKGUpLnJldmVyc2UoKSwgaCA9IGEubGVuZ3RoO1xuICBpZiAoaCA9PT0gMClcbiAgICByZXR1cm4gSztcbiAgbGV0IGQgPSAwLCBnID0gITE7XG4gIGNvbnN0IHAgPSBzID8gTWF0aC5taW4oYS5sZW5ndGgsIHMpIDogYS5sZW5ndGgsIF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBiID0gbmV3IEFycmF5KCksIE0gPSAoKSA9PiBfLmZvckVhY2goKGNlKSA9PiB7XG4gICAgY2UuY3VycmVudFNjaGVkdWxlci5zY2hlZHVsZVRhc2soKCkgPT4ge1xuICAgICAgY2UudW5zYWZlSW50ZXJydXB0QXNGb3JrKG8uaWQoKSk7XG4gICAgfSwgMCk7XG4gIH0pLCBEID0gbmV3IEFycmF5KCksIFggPSBuZXcgQXJyYXkoKSwgSCA9IG5ldyBBcnJheSgpLCBJZSA9ICgpID0+IHtcbiAgICBjb25zdCBjZSA9IGIuZmlsdGVyKCh7XG4gICAgICBleGl0OiBoZVxuICAgIH0pID0+IGhlLl90YWcgPT09IFwiRmFpbHVyZVwiKS5zb3J0KChoZSwgRmUpID0+IGhlLmluZGV4IDwgRmUuaW5kZXggPyAtMSA6IGhlLmluZGV4ID09PSBGZS5pbmRleCA/IDAgOiAxKS5tYXAoKHtcbiAgICAgIGV4aXQ6IGhlXG4gICAgfSkgPT4gaGUpO1xuICAgIHJldHVybiBjZS5sZW5ndGggPT09IDAgJiYgY2UucHVzaChOZSksIGNlO1xuICB9LCBEZSA9IChjZSwgaGUgPSAhMSkgPT4ge1xuICAgIGNvbnN0IEZlID0gS3MoaShjZSkpLCByZSA9IFB3KEZlLCBvLCBvLmN1cnJlbnRSdW50aW1lRmxhZ3MsIHRjKTtcbiAgICByZXR1cm4gby5jdXJyZW50U2NoZWR1bGVyLnNjaGVkdWxlVGFzaygoKSA9PiB7XG4gICAgICBoZSAmJiByZS51bnNhZmVJbnRlcnJ1cHRBc0Zvcmsoby5pZCgpKSwgcmUucmVzdW1lKEZlKTtcbiAgICB9LCAwKSwgcmU7XG4gIH0sIHFlID0gKCkgPT4ge1xuICAgIHIgfHwgKGggLT0gYS5sZW5ndGgsIGEgPSBbXSksIGcgPSAhMCwgTSgpO1xuICB9LCBrciA9IG4gPyBZeSA6IFllLCBNdCA9IERlKHhlKChjZSkgPT4ge1xuICAgIGNvbnN0IGhlID0gKHJlLCBVZSkgPT4ge1xuICAgICAgcmUuX29wID09PSBcIkJsb2NrZWRcIiA/IEgucHVzaChyZSkgOiAoYi5wdXNoKHtcbiAgICAgICAgaW5kZXg6IFVlLFxuICAgICAgICBleGl0OiByZVxuICAgICAgfSksIHJlLl9vcCA9PT0gXCJGYWlsdXJlXCIgJiYgIWcgJiYgcWUoKSk7XG4gICAgfSwgRmUgPSAoKSA9PiB7XG4gICAgICBpZiAoYS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlID0gYS5wb3AoKTtcbiAgICAgICAgbGV0IFVlID0gZCsrO1xuICAgICAgICBjb25zdCB2ciA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtZSA9IGEucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIFVlID0gZCsrLCBtKFFpKCksICgpID0+IG0oa3IoYyh0KG1lLCBVZSkpKSwgc3QpKTtcbiAgICAgICAgfSwgc3QgPSAobWUpID0+IGEubGVuZ3RoID4gMCAmJiAoaGUobWUsIFVlKSwgYS5sZW5ndGggPiAwKSA/IHZyKCkgOiBTKG1lKSwgd3IgPSBtKGtyKGModChyZSwgVWUpKSksIHN0KSwgUmUgPSBEZSh3cik7XG4gICAgICAgIEQucHVzaChSZSksIF8uYWRkKFJlKSwgZyAmJiBSZS5jdXJyZW50U2NoZWR1bGVyLnNjaGVkdWxlVGFzaygoKSA9PiB7XG4gICAgICAgICAgUmUudW5zYWZlSW50ZXJydXB0QXNGb3JrKG8uaWQoKSk7XG4gICAgICAgIH0sIDApLCBSZS5hZGRPYnNlcnZlcigobWUpID0+IHtcbiAgICAgICAgICBsZXQga247XG4gICAgICAgICAgaWYgKG1lLl9vcCA9PT0gXCJGYWlsdXJlXCIgPyBrbiA9IG1lIDoga24gPSBtZS5lZmZlY3RfaW5zdHJ1Y3Rpb25faTAsIFgucHVzaChSZSksIF8uZGVsZXRlKFJlKSwgaGUoa24sIFVlKSwgYi5sZW5ndGggPT09IGgpXG4gICAgICAgICAgICBjZShTKGRlKE5uKEllKCksIHtcbiAgICAgICAgICAgICAgcGFyYWxsZWw6ICEwXG4gICAgICAgICAgICB9KSwgKCkgPT4gTmUpKSk7XG4gICAgICAgICAgZWxzZSBpZiAoSC5sZW5ndGggKyBiLmxlbmd0aCA9PT0gaCkge1xuICAgICAgICAgICAgY29uc3QgQ28gPSBJZSgpLCBBZCA9IEgubWFwKCh2bikgPT4gdm4uZWZmZWN0X2luc3RydWN0aW9uX2kwKS5yZWR1Y2Uoa2YpO1xuICAgICAgICAgICAgY2UoUyhSZihBZCwgcHQoW2RlKE5uKENvLCB7XG4gICAgICAgICAgICAgIHBhcmFsbGVsOiAhMFxuICAgICAgICAgICAgfSksICgpID0+IE5lKSwgLi4uSC5tYXAoKHZuKSA9PiB2bi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTEpXSwgKHZuKSA9PiB2biwgbiwgITAsIHMpKSkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgRmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGxldCByZSA9IDA7IHJlIDwgcDsgcmUrKylcbiAgICAgIEZlKCk7XG4gIH0pKTtcbiAgcmV0dXJuIG50KHJuKHpzKGMoZnMoTXQpKSksIHRvKHtcbiAgICBvbkZhaWx1cmU6IChjZSkgPT4ge1xuICAgICAgcWUoKTtcbiAgICAgIGNvbnN0IGhlID0gSC5sZW5ndGggKyAxLCBGZSA9IE1hdGgubWluKHR5cGVvZiBzID09IFwibnVtYmVyXCIgPyBzIDogSC5sZW5ndGgsIEgubGVuZ3RoKSwgcmUgPSBBcnJheS5mcm9tKEgpO1xuICAgICAgcmV0dXJuIHhlKChVZSkgPT4ge1xuICAgICAgICBsZXQgdnIgPSAwLCBzdCA9IDA7XG4gICAgICAgIGNvbnN0IHdyID0gKG1lLCBrbikgPT4gKENvKSA9PiB7XG4gICAgICAgICAgdnIrKywgdnIgPT09IGhlICYmIFVlKGooQShjZSkpKSwgcmUubGVuZ3RoID4gMCAmJiBrbiAmJiBSZSgpO1xuICAgICAgICB9LCBSZSA9ICgpID0+IHtcbiAgICAgICAgICBEZShyZS5wb3AoKSwgITApLmFkZE9ic2VydmVyKHdyKHN0LCAhMCkpLCBzdCsrO1xuICAgICAgICB9O1xuICAgICAgICBNdC5hZGRPYnNlcnZlcih3cihzdCwgITEpKSwgc3QrKztcbiAgICAgICAgZm9yIChsZXQgbWUgPSAwOyBtZSA8IEZlOyBtZSsrKVxuICAgICAgICAgIFJlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uU3VjY2VzczogKCkgPT4gS2UoWCwgKGNlKSA9PiBjZS5pbmhlcml0QWxsKVxuICB9KSkpO1xufSkpKSwgdWkgPSAoZSwgdCwgbiwgcikgPT4gTigoKSA9PiB7XG4gIGNvbnN0IHMgPSB6KGUpLCBjID0gbmV3IEFycmF5KHMubGVuZ3RoKTtcbiAgcmV0dXJuIG9lKHB0KHMsIChvLCBhKSA9PiBUKG4obywgYSksIChoKSA9PiBjW2FdID0gaCksIHIsICExLCB0KSwgUyhjKSk7XG59KSwgJG8gPSAoZSkgPT4geHcoZSwgdGMpLCB1ZCA9IChlLCB0LCBuLCByID0gbnVsbCkgPT4ge1xuICBjb25zdCBzID0gbXMoZSwgdCwgbiwgcik7XG4gIHJldHVybiBzLnJlc3VtZShlKSwgcztcbn0sIFB3ID0gKGUsIHQsIG4sIHIgPSBudWxsKSA9PiBtcyhlLCB0LCBuLCByKSwgbXMgPSAoZSwgdCwgbiwgciA9IG51bGwpID0+IHtcbiAgY29uc3QgcyA9IHJmKCksIGMgPSB0LmdldEZpYmVyUmVmcygpLCBpID0gUVMoYywgcyksIG8gPSBuZXcgaWQocywgaSwgbiksIGEgPSBLbihpLCBydCksIGggPSBvLmN1cnJlbnRTdXBlcnZpc29yO1xuICByZXR1cm4gaC5vblN0YXJ0KGEsIGUsIEkodCksIG8pLCBvLmFkZE9ic2VydmVyKChnKSA9PiBoLm9uRW5kKGcsIG8pKSwgKHIgIT09IG51bGwgPyByIDogZih0LmdldEZpYmVyUmVmKHpjKSwgZGUoKCkgPT4gdC5zY29wZSgpKSkpLmFkZChuLCBvKSwgbztcbn0sIHh3ID0gKGUsIHQpID0+IEwoKG4sIHIpID0+IFModWQoZSwgbiwgci5ydW50aW1lRmxhZ3MsIHQpKSksIERhID0gKGUpID0+IGJuKCh0KSA9PiB0dChzcih0LCBSdCksIHtcbiAgb25Ob25lOiAoKSA9PiBlLFxuICBvblNvbWU6IChuKSA9PiB7XG4gICAgc3dpdGNoIChuLnN0cmF0ZWd5Ll90YWcpIHtcbiAgICAgIGNhc2UgXCJQYXJhbGxlbFwiOlxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIGNhc2UgXCJTZXF1ZW50aWFsXCI6XG4gICAgICBjYXNlIFwiUGFyYWxsZWxOXCI6XG4gICAgICAgIHJldHVybiBtKEpzKG4sIFljKSwgKHIpID0+IHlyKGUsIHIpKTtcbiAgICB9XG4gIH1cbn0pKSwgcWEgPSAoZSkgPT4gKHQpID0+IGJuKChuKSA9PiB0dChzcihuLCBSdCksIHtcbiAgb25Ob25lOiAoKSA9PiB0LFxuICBvblNvbWU6IChyKSA9PiByLnN0cmF0ZWd5Ll90YWcgPT09IFwiUGFyYWxsZWxOXCIgJiYgci5zdHJhdGVneS5wYXJhbGxlbGlzbSA9PT0gZSA/IHQgOiBtKEpzKHIsIFFjKGUpKSwgKHMpID0+IHlyKHQsIHMpKVxufSkpLCBOdCA9IChlLCB0KSA9PiAobikgPT4gYm4oKHIpID0+IHR0KHNyKHIsIFJ0KSwge1xuICBvbk5vbmU6ICgpID0+IG4oUCksXG4gIG9uU29tZTogKHMpID0+IHtcbiAgICBpZiAodCA9PT0gITApIHtcbiAgICAgIGNvbnN0IGMgPSBlLl90YWcgPT09IFwiUGFyYWxsZWxcIiA/IERhIDogZS5fdGFnID09PSBcIlNlcXVlbnRpYWxcIiA/IFVhIDogcWEoZS5wYXJhbGxlbGlzbSk7XG4gICAgICBzd2l0Y2ggKHMuc3RyYXRlZ3kuX3RhZykge1xuICAgICAgICBjYXNlIFwiUGFyYWxsZWxcIjpcbiAgICAgICAgICByZXR1cm4gYyhuKERhKSk7XG4gICAgICAgIGNhc2UgXCJTZXF1ZW50aWFsXCI6XG4gICAgICAgICAgcmV0dXJuIGMobihVYSkpO1xuICAgICAgICBjYXNlIFwiUGFyYWxsZWxOXCI6XG4gICAgICAgICAgcmV0dXJuIGMobihxYShzLnN0cmF0ZWd5LnBhcmFsbGVsaXNtKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG4oUCk7XG4gIH1cbn0pKSwgancgPSAoZSkgPT4gbShSdCwgZSksIGxkID0gKGUpID0+IG0oRW8oKSwgKHQpID0+IHJuKGUodCksIChuKSA9PiB0LmNsb3NlKG4pKSksIFVhID0gKGUpID0+IGJuKCh0KSA9PiB0dChzcih0LCBSdCksIHtcbiAgb25Ob25lOiAoKSA9PiBlLFxuICBvblNvbWU6IChuKSA9PiB7XG4gICAgc3dpdGNoIChuLnN0cmF0ZWd5Ll90YWcpIHtcbiAgICAgIGNhc2UgXCJTZXF1ZW50aWFsXCI6XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgY2FzZSBcIlBhcmFsbGVsXCI6XG4gICAgICBjYXNlIFwiUGFyYWxsZWxOXCI6XG4gICAgICAgIHJldHVybiBtKEpzKG4sIEdjKSwgKHIpID0+IHlyKGUsIHIpKTtcbiAgICB9XG4gIH1cbn0pKSwgTHcgPSAvKiBAX19QVVJFX18gKi8gbCgoZSkgPT4gTGUoZVsxXSksIChlLCB0LCBuKSA9PiBfcihlLCB0LCAociwgcykgPT4gW3IsIHNdLCBuKSksIER3ID0gLyogQF9fUFVSRV9fICovIGwoKGUpID0+IExlKGVbMV0pLCAoZSwgdCwgbikgPT4gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVudCkgIT09ICEwICYmICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5iYXRjaGluZykgPT09IHZvaWQgMCB8fCBuLmJhdGNoaW5nID09PSAhMSkgPyBaaShlLCB0KSA6IF9yKGUsIHQsIChyLCBzKSA9PiByLCBuKSksIHF3ID0gLyogQF9fUFVSRV9fICovIGwoKGUpID0+IExlKGVbMV0pLCAoZSwgdCwgbikgPT4gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY29uY3VycmVudCkgIT09ICEwICYmICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5iYXRjaGluZykgPT09IHZvaWQgMCB8fCBuLmJhdGNoaW5nID09PSAhMSkgPyBvZShlLCB0KSA6IF9yKGUsIHQsIChyLCBzKSA9PiBzLCBuKSksIF9yID0gLyogQF9fUFVSRV9fICovIGwoKGUpID0+IExlKGVbMV0pLCAoZSwgdCwgbiwgcikgPT4gVChvZChbZSwgdF0sIHtcbiAgY29uY3VycmVuY3k6IHIgIT0gbnVsbCAmJiByLmNvbmN1cnJlbnQgPyAyIDogMSxcbiAgYmF0Y2hpbmc6IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYmF0Y2hpbmcsXG4gIGNvbmN1cnJlbnRGaW5hbGl6ZXJzOiByID09IG51bGwgPyB2b2lkIDAgOiByLmNvbmN1cnJlbnRGaW5hbGl6ZXJzXG59KSwgKFtzLCBjXSkgPT4gbihzLCBjKSkpLCBSdCA9IC8qIEBfX1BVUkVfXyAqLyBJdChcImVmZmVjdC9TY29wZVwiKSwgZmQgPSBSdCwgVXcgPSAoZSwgdCkgPT4ge1xuICBlLnN0YXRlLl90YWcgPT09IFwiT3BlblwiICYmIGUuc3RhdGUuZmluYWxpemVycy5zZXQoe30sIHQpO1xufSwgencgPSB7XG4gIFtvYV06IG9hLFxuICBbYWFdOiBhYSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBmb3JrKGUpIHtcbiAgICByZXR1cm4geSgoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gaGQoZSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5fdGFnID09PSBcIkNsb3NlZFwiKVxuICAgICAgICByZXR1cm4gdC5zdGF0ZSA9IHRoaXMuc3RhdGUsIHQ7XG4gICAgICBjb25zdCBuID0ge30sIHIgPSAocykgPT4gdC5jbG9zZShzKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZpbmFsaXplcnMuc2V0KG4sIHIpLCBVdyh0LCAocykgPT4geSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUuX3RhZyA9PT0gXCJPcGVuXCIgJiYgdGhpcy5zdGF0ZS5maW5hbGl6ZXJzLmRlbGV0ZShuKTtcbiAgICAgIH0pKSwgdDtcbiAgICB9KTtcbiAgfSxcbiAgY2xvc2UoZSkge1xuICAgIHJldHVybiBOKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLl90YWcgPT09IFwiQ2xvc2VkXCIpXG4gICAgICAgIHJldHVybiBLO1xuICAgICAgY29uc3QgdCA9IEFycmF5LmZyb20odGhpcy5zdGF0ZS5maW5hbGl6ZXJzLnZhbHVlcygpKS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgX3RhZzogXCJDbG9zZWRcIixcbiAgICAgICAgZXhpdDogZVxuICAgICAgfSwgdC5sZW5ndGggPT09IDAgPyBLIDogQjAodGhpcy5zdHJhdGVneSkgPyBmKEtlKHQsIChuKSA9PiBZZShuKGUpKSksIG0oKG4pID0+IGYoTm4obiksIE5yKGhjKSwgZGUoKCkgPT4gTmUpKSkpIDogVjAodGhpcy5zdHJhdGVneSkgPyBmKGFkKHQsIChuKSA9PiBZZShuKGUpKSwgITEpLCBtKChuKSA9PiBmKE5uKG4sIHtcbiAgICAgICAgcGFyYWxsZWw6ICEwXG4gICAgICB9KSwgTnIoaGMpLCBkZSgoKSA9PiBOZSkpKSkgOiBmKHVpKHQsIHRoaXMuc3RyYXRlZ3kucGFyYWxsZWxpc20sIChuKSA9PiBZZShuKGUpKSwgITEpLCBtKChuKSA9PiBmKE5uKG4sIHtcbiAgICAgICAgcGFyYWxsZWw6ICEwXG4gICAgICB9KSwgTnIoaGMpLCBkZSgoKSA9PiBOZSkpKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZEZpbmFsaXplcihlKSB7XG4gICAgcmV0dXJuIE4oKCkgPT4gdGhpcy5zdGF0ZS5fdGFnID09PSBcIkNsb3NlZFwiID8gZSh0aGlzLnN0YXRlLmV4aXQpIDogKHRoaXMuc3RhdGUuZmluYWxpemVycy5zZXQoe30sIGUpLCBLKSk7XG4gIH1cbn0sIGhkID0gKGUgPSBacykgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZSh6dyk7XG4gIHJldHVybiB0LnN0cmF0ZWd5ID0gZSwgdC5zdGF0ZSA9IHtcbiAgICBfdGFnOiBcIk9wZW5cIixcbiAgICBmaW5hbGl6ZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH0sIHQ7XG59LCBFbyA9IChlID0gWnMpID0+IHkoKCkgPT4gaGQoZSkpLCB5ciA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBVYihcbiAgZSxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBmbihycihSdCwgdCkpXG4pKSwgQncgPSAoZSkgPT4geW4oZSwge1xuICBkaWZmZXI6IG13LFxuICBmb3JrOiBBblxufSksIHphID0gLyogQF9fUFVSRV9fICovIFNiKHN5KSwgVncgPSAvKiBAX19QVVJFX18gKi8gQncoc2MpLCBkZCA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBXdyhlLCB0LCB7XG4gIG9uU2VsZldpbjogKHIsIHMpID0+IG0oci5hd2FpdCwgKGMpID0+IHtcbiAgICBzd2l0Y2ggKGMuX3RhZykge1xuICAgICAgY2FzZSBuZTpcbiAgICAgICAgcmV0dXJuIG0oci5pbmhlcml0QWxsLCAoKSA9PiBuLm9uU2VsZkRvbmUoYywgcykpO1xuICAgICAgY2FzZSB0ZTpcbiAgICAgICAgcmV0dXJuIG4ub25TZWxmRG9uZShjLCBzKTtcbiAgICB9XG4gIH0pLFxuICBvbk90aGVyV2luOiAociwgcykgPT4gbShyLmF3YWl0LCAoYykgPT4ge1xuICAgIHN3aXRjaCAoYy5fdGFnKSB7XG4gICAgICBjYXNlIG5lOlxuICAgICAgICByZXR1cm4gbShyLmluaGVyaXRBbGwsICgpID0+IG4ub25PdGhlckRvbmUoYywgcykpO1xuICAgICAgY2FzZSB0ZTpcbiAgICAgICAgcmV0dXJuIG4ub25PdGhlckRvbmUoYywgcyk7XG4gICAgfVxuICB9KVxufSkpLCBLdyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBmcigobikgPT4gZGQoZSwgdCwge1xuICBvblNlbGZEb25lOiAociwgcykgPT4gVmMociwge1xuICAgIG9uRmFpbHVyZTogKGMpID0+IGYoZnMocyksIEVhKChpKSA9PiBPdChjLCBpKSkpLFxuICAgIG9uU3VjY2VzczogKGMpID0+IGYocywgZXMobiksIGZlKGMpKVxuICB9KSxcbiAgb25PdGhlckRvbmU6IChyLCBzKSA9PiBWYyhyLCB7XG4gICAgb25GYWlsdXJlOiAoYykgPT4gZihmcyhzKSwgRWEoKGkpID0+IE90KGksIGMpKSksXG4gICAgb25TdWNjZXNzOiAoYykgPT4gZihzLCBlcyhuKSwgZmUoYykpXG4gIH0pXG59KSkpLCBXdyA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBMKChyLCBzKSA9PiB7XG4gIGNvbnN0IGMgPSBzLnJ1bnRpbWVGbGFncywgaSA9IFBzKCEwKSwgbyA9IG1zKGUsIHIsIGMsIG4uc2VsZlNjb3BlKSwgYSA9IG1zKHQsIHIsIGMsIG4ub3RoZXJTY29wZSk7XG4gIHJldHVybiB4ZSgoaCkgPT4ge1xuICAgIG8uYWRkT2JzZXJ2ZXIoKCkgPT4gQmEobywgYSwgbi5vblNlbGZXaW4sIGksIGgpKSwgYS5hZGRPYnNlcnZlcigoKSA9PiBCYShhLCBvLCBuLm9uT3RoZXJXaW4sIGksIGgpKSwgby5zdGFydEZvcmsoZSksIGEuc3RhcnRGb3JrKHQpO1xuICB9LCBVcChvLmlkKCksIGEuaWQoKSkpO1xufSkpLCBCYSA9IChlLCB0LCBuLCByLCBzKSA9PiB7XG4gIEFwKCEwLCAhMSkocikgJiYgcyhuKGUsIHQpKTtcbn0sIEhuID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEVlKChuKSA9PiBTZShuKGUpLCB7XG4gIG9uRmFpbHVyZTogKHIpID0+IFNlKHQsIHtcbiAgICBvbkZhaWx1cmU6IChzKSA9PiBaKHNlKHIsIHMpKSxcbiAgICBvblN1Y2Nlc3M6ICgpID0+IFoocilcbiAgfSksXG4gIG9uU3VjY2VzczogKHIpID0+IGZlKHQsIHIpXG59KSkpLCBKdyA9IChlLCB0LCBuKSA9PiBmcigocikgPT4gbShtKCRvKEppKGUpKSwgKHMpID0+IHhlKChjKSA9PiB7XG4gIGNvbnN0IGkgPSB0Lm1hcCgoaCkgPT4gaC5saXN0ZW5lcnMuY291bnQpLCBvID0gKCkgPT4ge1xuICAgIGkuZXZlcnkoKGgpID0+IGggPT09IDApICYmIHQuZXZlcnkoKGgpID0+IGgucmVzdWx0LnN0YXRlLmN1cnJlbnQuX3RhZyA9PT0gXCJQZW5kaW5nXCIgPyAhMCA6ICEhKGgucmVzdWx0LnN0YXRlLmN1cnJlbnQuX3RhZyA9PT0gXCJEb25lXCIgJiYgZW8oaC5yZXN1bHQuc3RhdGUuY3VycmVudC5lZmZlY3QpICYmIGgucmVzdWx0LnN0YXRlLmN1cnJlbnQuZWZmZWN0Ll90YWcgPT09IFwiRmFpbHVyZVwiICYmIEl5KGgucmVzdWx0LnN0YXRlLmN1cnJlbnQuZWZmZWN0LmNhdXNlKSkpICYmIChhLmZvckVhY2goKGgpID0+IGgoKSksIG4gPT0gbnVsbCB8fCBuKCksIGMoemYocykpKTtcbiAgfTtcbiAgcy5hZGRPYnNlcnZlcigoaCkgPT4ge1xuICAgIGEuZm9yRWFjaCgoZCkgPT4gZCgpKSwgYyhoKTtcbiAgfSk7XG4gIGNvbnN0IGEgPSB0Lm1hcCgoaCwgZCkgPT4ge1xuICAgIGNvbnN0IGcgPSAocCkgPT4ge1xuICAgICAgaVtkXSA9IHAsIG8oKTtcbiAgICB9O1xuICAgIHJldHVybiBoLmxpc3RlbmVycy5hZGRPYnNlcnZlcihnKSwgKCkgPT4gaC5saXN0ZW5lcnMucmVtb3ZlT2JzZXJ2ZXIoZyk7XG4gIH0pO1xuICByZXR1cm4gbygpLCB5KCgpID0+IHtcbiAgICBhLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufSkpLCAoKSA9PiBOKCgpID0+IHtcbiAgY29uc3QgcyA9IHQuZmxhdE1hcCgoYykgPT4gYy5zdGF0ZS5jb21wbGV0ZWQgPyBbXSA6IFtjXSk7XG4gIHJldHVybiBCcyhzLCAoYykgPT4gb3coYy5yZXF1ZXN0LCBDYihyKSkpO1xufSkpKSwgSHcgPSBcImVmZmVjdC9TY2hlZHVsZUludGVydmFsXCIsIHBzID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoSHcpLCBnZCA9IHtcbiAgW3BzXTogcHMsXG4gIHN0YXJ0TWlsbGlzOiAwLFxuICBlbmRNaWxsaXM6IDBcbn0sIG1kID0gKGUsIHQpID0+IGUgPiB0ID8gZ2QgOiB7XG4gIFtwc106IHBzLFxuICBzdGFydE1pbGxpczogZSxcbiAgZW5kTWlsbGlzOiB0XG59LCBHdyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBZdyhlLCB0KSA9PT0gZSksIFl3ID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGUuZW5kTWlsbGlzIDw9IHQuc3RhcnRNaWxsaXMgPyBlIDogdC5lbmRNaWxsaXMgPD0gZS5zdGFydE1pbGxpcyA/IHQgOiBlLnN0YXJ0TWlsbGlzIDwgdC5zdGFydE1pbGxpcyA/IGUgOiB0LnN0YXJ0TWlsbGlzIDwgZS5zdGFydE1pbGxpcyA/IHQgOiBlLmVuZE1pbGxpcyA8PSB0LmVuZE1pbGxpcyA/IGUgOiB0KSwgUXcgPSAoZSkgPT4gZS5zdGFydE1pbGxpcyA+PSBlLmVuZE1pbGxpcywgWncgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gTWF0aC5tYXgoZS5zdGFydE1pbGxpcywgdC5zdGFydE1pbGxpcyksIHIgPSBNYXRoLm1pbihlLmVuZE1pbGxpcywgdC5lbmRNaWxsaXMpO1xuICByZXR1cm4gbWQobiwgcik7XG59KSwgWHcgPSAoZSkgPT4gbWQoZSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSwgcGQgPSBnZCwgZU8gPSBHdywgdE8gPSBRdywgbk8gPSBadywgck8gPSBYdywgc08gPSBcImVmZmVjdC9TY2hlZHVsZUludGVydmFsc1wiLCBWYSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKHNPKSwgX2QgPSAoZSkgPT4gKHtcbiAgW1ZhXTogVmEsXG4gIGludGVydmFsczogZVxufSksIGNPID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGlPKGUuaW50ZXJ2YWxzLCB0LmludGVydmFscywgQWUoKSkpLCBpTyA9IChlLCB0LCBuKSA9PiB7XG4gIGxldCByID0gZSwgcyA9IHQsIGMgPSBuO1xuICBmb3IgKDsgSGUocikgJiYgSGUocyk7ICkge1xuICAgIGNvbnN0IGkgPSBmKENlKHIpLCBuTyhDZShzKSkpLCBvID0gdE8oaSkgPyBjIDogZihjLCBiZShpKSk7XG4gICAgZihDZShyKSwgZU8oQ2UocykpKSA/IHIgPSBWZShyKSA6IHMgPSBWZShzKSwgYyA9IG87XG4gIH1cbiAgcmV0dXJuIF9kKHl0KGMpKTtcbn0sIGxpID0gKGUpID0+IGYoZS5pbnRlcnZhbHMsIHhsLCBkZSgoKSA9PiBwZCkpLnN0YXJ0TWlsbGlzLCBvTyA9IChlKSA9PiBmKGUuaW50ZXJ2YWxzLCB4bCwgZGUoKCkgPT4gcGQpKS5lbmRNaWxsaXMsIGFPID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGxpKGUpIDwgbGkodCkpLCB1TyA9IChlKSA9PiBIZShlLmludGVydmFscyksIGxPID0gX2QsIGZPID0gY08sIGhPID0gbGksIEthID0gb08sIGRPID0gYU8sIGdPID0gdU8sIElvID0gXCJDb250aW51ZVwiLCB5ZCA9IFwiRG9uZVwiLCBtTyA9IChlKSA9PiAoe1xuICBfdGFnOiBJbyxcbiAgaW50ZXJ2YWxzOiBlXG59KSwgcE8gPSAoZSkgPT4gKHtcbiAgX3RhZzogSW8sXG4gIGludGVydmFsczogbE8oaWUoZSkpXG59KSwgX08gPSB7XG4gIF90YWc6IHlkXG59LCB5TyA9IChlKSA9PiBlLl90YWcgPT09IElvLCBiTyA9IChlKSA9PiBlLl90YWcgPT09IHlkLCBTTyA9IG1PLCBrTyA9IHBPLCBHbiA9IF9PLCBXYSA9IHlPLCBfcyA9IGJPLCBMRSA9IEpmLCBERSA9IHRzLCB2TyA9IEJjLCBxRSA9IHlyLCB3TyA9IEpzLCBVRSA9IEVvLCBPTyA9IFwiZWZmZWN0L1NjaGVkdWxlXCIsIGJkID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoT08pLCAkTyA9IChlKSA9PiAkKGUsIGJkKSwgRU8gPSBcImVmZmVjdC9TY2hlZHVsZURyaXZlclwiLCBJTyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKEVPKSwgRk8gPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9PdXQ6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW46IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogKGUpID0+IGVcbn0sIFJPID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0OiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0luOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX1I6IChlKSA9PiBlXG59O1xudmFyIHp1O1xuenUgPSBiZDtcbmNsYXNzIE1PIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJpbml0aWFsXCIpO1xuICAgIHUodGhpcywgXCJzdGVwXCIpO1xuICAgIHUodGhpcywgenUsIEZPKTtcbiAgICB0aGlzLmluaXRpYWwgPSB0LCB0aGlzLnN0ZXAgPSBuO1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxudmFyIEJ1O1xuQnUgPSBJTztcbmNsYXNzIFRPIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHUodGhpcywgXCJzY2hlZHVsZVwiKTtcbiAgICB1KHRoaXMsIFwicmVmXCIpO1xuICAgIHUodGhpcywgQnUsIFJPKTtcbiAgICB0aGlzLnNjaGVkdWxlID0gdCwgdGhpcy5yZWYgPSBuO1xuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gVChtdCh0aGlzLnJlZiksICh0KSA9PiB0WzFdKTtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICByZXR1cm4gbShtdCh0aGlzLnJlZiksIChbdCwgbl0pID0+IHtcbiAgICAgIHN3aXRjaCAodC5fdGFnKSB7XG4gICAgICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICAgICAgcmV0dXJuIFVzKCgpID0+IG5ldyBIcygpKTtcbiAgICAgICAgY2FzZSBcIlNvbWVcIjpcbiAgICAgICAgICByZXR1cm4gUyh0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgcmVzZXQoKSB7XG4gICAgcmV0dXJuIGNzKHRoaXMucmVmLCBbdigpLCB0aGlzLnNjaGVkdWxlLmluaXRpYWxdKTtcbiAgfVxuICBuZXh0KHQpIHtcbiAgICByZXR1cm4gZihUKG10KHRoaXMucmVmKSwgKG4pID0+IG5bMV0pLCBtKChuKSA9PiBmKFdTLCBtKChyKSA9PiBmKE4oKCkgPT4gdGhpcy5zY2hlZHVsZS5zdGVwKHIsIHQsIG4pKSwgbSgoW3MsIGMsIGldKSA9PiB7XG4gICAgICBjb25zdCBvID0gY3ModGhpcy5yZWYsIFtJKGMpLCBzXSk7XG4gICAgICBpZiAoX3MoaSkpXG4gICAgICAgIHJldHVybiBvZShvLCB4KHYoKSkpO1xuICAgICAgY29uc3QgYSA9IGhPKGkuaW50ZXJ2YWxzKSAtIHI7XG4gICAgICByZXR1cm4gYSA8PSAwID8gZmUobywgYykgOiBmKG8sIG9lKEMwKEhyKGEpKSksIGZlKGMpKTtcbiAgICB9KSkpKSkpO1xuICB9XG59XG5jb25zdCBiciA9IChlLCB0KSA9PiBuZXcgTU8oZSwgdCksIENPID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEZvKGUsIChuLCByKSA9PiB5KCgpID0+IHQobiwgcikpKSksIEZvID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGJyKGUuaW5pdGlhbCwgKG4sIHIsIHMpID0+IG0oZS5zdGVwKG4sIHIsIHMpLCAoW2MsIGksIG9dKSA9PiBfcyhvKSA/IFMoW2MsIGksIEduXSkgOiBUKHQociwgaSksIChhKSA9PiBhID8gW2MsIGksIG9dIDogW2MsIGksIEduXSkpKSksIE5PID0gKGUpID0+IGYoSmMoW3YoKSwgZS5pbml0aWFsXSksIFQoKHQpID0+IG5ldyBUTyhlLCB0KSkpLCBBTyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBQTyhlLCB0LCBmTykpLCBQTyA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBicihbZS5pbml0aWFsLCB0LmluaXRpYWxdLCAociwgcywgYykgPT4gZihVZihlLnN0ZXAociwgcywgY1swXSksIHQuc3RlcChyLCBzLCBjWzFdKSwgKGksIG8pID0+IFtpLCBvXSksIG0oKFtbaSwgbywgYV0sIFtoLCBkLCBnXV0pID0+IFdhKGEpICYmIFdhKGcpID8gZmkoZSwgdCwgcywgaSwgbywgYS5pbnRlcnZhbHMsIGgsIGQsIGcuaW50ZXJ2YWxzLCBuKSA6IFMoW1tpLCBoXSwgW28sIGRdLCBHbl0pKSkpKSwgZmkgPSAoZSwgdCwgbiwgciwgcywgYywgaSwgbywgYSwgaCkgPT4ge1xuICBjb25zdCBkID0gaChjLCBhKTtcbiAgcmV0dXJuIGdPKGQpID8gUyhbW3IsIGldLCBbcywgb10sIFNPKGQpXSkgOiBmKGMsIGRPKGEpKSA/IG0oZS5zdGVwKEthKGMpLCBuLCByKSwgKFtnLCBwLCBfXSkgPT4gX3MoXykgPyBTKFtbZywgaV0sIFtwLCBvXSwgR25dKSA6IGZpKGUsIHQsIG4sIGcsIHAsIF8uaW50ZXJ2YWxzLCBpLCBvLCBhLCBoKSkgOiBtKHQuc3RlcChLYShhKSwgbiwgaSksIChbZywgcCwgX10pID0+IF9zKF8pID8gUyhbW3IsIGddLCBbcywgcF0sIEduXSkgOiBmaShlLCB0LCBuLCByLCBzLCBjLCBnLCBwLCBfLmludGVydmFscywgaCkpO1xufSwgeE8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gak8oZSwgKG4pID0+IHkoKCkgPT4gdChuKSkpKSwgak8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gYnIoZS5pbml0aWFsLCAobiwgciwgcykgPT4gbShlLnN0ZXAobiwgciwgcyksIChbYywgaSwgb10pID0+IFQodChpKSwgKGEpID0+IFtjLCBhLCBvXSkpKSksIExPID0gKGUpID0+IGJyKGUuaW5pdGlhbCwgKHQsIG4sIHIpID0+IGYoZS5zdGVwKHQsIG4sIHIpLCBUKChbcywgYywgaV0pID0+IFtzLCBuLCBpXSkpKSwgRE8gPSAoZSkgPT4gQk8oa2QsICh0KSA9PiB0IDwgZSksIHFPID0gKGUsIHQpID0+IGJyKGUsIChuLCByLCBzKSA9PiB5KCgpID0+IFt0KHMpLCBzLCBrTyhyTyhuKSldKSksIFVPID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEZvKGUsIChuLCByKSA9PiBSMCh0KG4pKSkpLCB6TyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBGbyhlLCAobiwgcikgPT4gdChuKSkpLCBCTyA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBDTyhlLCAobiwgcikgPT4gdChyKSkpLCBEciA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L1NjaGVkdWxlL1NjaGVkdWxlRGVmZWN0XCIpO1xudmFyIFZ1O1xuVnUgPSBEcjtcbmNsYXNzIFZPIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHUodGhpcywgXCJlcnJvclwiKTtcbiAgICB1KHRoaXMsIFZ1KTtcbiAgICB0aGlzLmVycm9yID0gdCwgdGhpc1tEcl0gPSBEcjtcbiAgfVxufVxuY29uc3QgS08gPSAoZSkgPT4gJChlLCBEciksIEphID0gKGUpID0+IFpyKGUsICh0KSA9PiBYcihuZXcgVk8odCkpKSwgV08gPSAoZSkgPT4gUGYoZSwgKHQpID0+IHR0KHppKHQsIChuKSA9PiAkeShuKSAmJiBLTyhuLmRlZmVjdCkgPyBJKG4uZGVmZWN0KSA6IHYoKSksIHtcbiAgb25Ob25lOiAoKSA9PiBaKHQpLFxuICBvblNvbWU6IChuKSA9PiB4KG4uZXJyb3IpXG59KSksIEhhID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEhPKGUsIHQsIChuLCByKSA9PiB4KG4pKSksIEpPID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgaWYgKCRPKHQpKVxuICAgIHJldHVybiBIYShlLCB0KTtcbiAgY29uc3QgbiA9IHQuc2NoZWR1bGUgPz8gTE8oa2QpLCByID0gdC53aGlsZSA/IHpPKG4sIChpKSA9PiB7XG4gICAgY29uc3QgbyA9IHQud2hpbGUoaSk7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09IFwiYm9vbGVhblwiID8gUyhvKSA6IEphKG8pO1xuICB9KSA6IG4sIHMgPSB0LnVudGlsID8gVU8ociwgKGkpID0+IHtcbiAgICBjb25zdCBvID0gdC51bnRpbChpKTtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT0gXCJib29sZWFuXCIgPyBTKG8pIDogSmEobyk7XG4gIH0pIDogciwgYyA9IHQudGltZXMgPyBBTyhzLCBETyh0LnRpbWVzKSkucGlwZSh4TygoaSkgPT4gaVswXSkpIDogcztcbiAgcmV0dXJuIFdPKEhhKGUsIGMpKTtcbn0pLCBITyA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBtKE5PKHQpLCAocikgPT4gWGUoZSwge1xuICBvbkZhaWx1cmU6IChzKSA9PiBuKHMsIHYoKSksXG4gIG9uU3VjY2VzczogKHMpID0+IFNkKGUsIHIsIG4sIHMpXG59KSkpLCBTZCA9IChlLCB0LCBuLCByKSA9PiBYZSh0Lm5leHQociksIHtcbiAgb25GYWlsdXJlOiAoKSA9PiBYeSh0Lmxhc3QpLFxuICBvblN1Y2Nlc3M6IChzKSA9PiBYZShlLCB7XG4gICAgb25GYWlsdXJlOiAoYykgPT4gbihjLCBJKHMpKSxcbiAgICBvblN1Y2Nlc3M6IChjKSA9PiBTZChlLCB0LCBuLCBjKVxuICB9KVxufSksIGtkID0gLyogQF9fUFVSRV9fICovIHFPKDAsIChlKSA9PiBlICsgMSk7XG5jbGFzcyBHTyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB1KHRoaXMsIFwicGVybWl0c1wiKTtcbiAgICB1KHRoaXMsIFwid2FpdGVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB1KHRoaXMsIFwidGFrZW5cIiwgMCk7XG4gICAgdSh0aGlzLCBcInRha2VcIiwgKHQpID0+IEFmKChuKSA9PiB7XG4gICAgICBpZiAodGhpcy5mcmVlIDwgdCkge1xuICAgICAgICBjb25zdCByID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZnJlZSA8IHQgfHwgKHRoaXMud2FpdGVycy5kZWxldGUociksIHRoaXMudGFrZW4gKz0gdCwgbihTKHQpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRlcnMuYWRkKHIpLCB5KCgpID0+IHtcbiAgICAgICAgICB0aGlzLndhaXRlcnMuZGVsZXRlKHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRha2VuICs9IHQsIG4oUyh0KSk7XG4gICAgfSkpO1xuICAgIHUodGhpcywgXCJ1cGRhdGVUYWtlblwiLCAodCkgPT4gTCgobikgPT4gKHRoaXMudGFrZW4gPSB0KHRoaXMudGFrZW4pLCB0aGlzLndhaXRlcnMuc2l6ZSA+IDAgJiYgbi5nZXRGaWJlclJlZihfbykuc2NoZWR1bGVUYXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLndhaXRlcnMudmFsdWVzKCk7XG4gICAgICBsZXQgcyA9IHIubmV4dCgpO1xuICAgICAgZm9yICg7IHMuZG9uZSA9PT0gITEgJiYgdGhpcy5mcmVlID4gMDsgKVxuICAgICAgICBzLnZhbHVlKCksIHMgPSByLm5leHQoKTtcbiAgICB9LCBuLmdldEZpYmVyUmVmKGRyKSksIFModGhpcy5mcmVlKSkpKTtcbiAgICB1KHRoaXMsIFwicmVsZWFzZVwiLCAodCkgPT4gdGhpcy51cGRhdGVUYWtlbigobikgPT4gbiAtIHQpKTtcbiAgICB1KHRoaXMsIFwicmVsZWFzZUFsbFwiLCAvKiBAX19QVVJFX18gKi8gdGhpcy51cGRhdGVUYWtlbigodCkgPT4gMCkpO1xuICAgIHUodGhpcywgXCJ3aXRoUGVybWl0c1wiLCAodCkgPT4gKG4pID0+IEVlKChyKSA9PiBtKHIodGhpcy50YWtlKHQpKSwgKHMpID0+IEhuKHIobiksIHRoaXMucmVsZWFzZShzKSkpKSk7XG4gICAgdSh0aGlzLCBcIndpdGhQZXJtaXRzSWZBdmFpbGFibGVcIiwgKHQpID0+IChuKSA9PiBFZSgocikgPT4gTigoKSA9PiB0aGlzLmZyZWUgPCB0ID8gTjAgOiAodGhpcy50YWtlbiArPSB0LCBIbihyKHcwKG4pKSwgdGhpcy5yZWxlYXNlKHQpKSkpKSk7XG4gICAgdGhpcy5wZXJtaXRzID0gdDtcbiAgfVxuICBnZXQgZnJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJtaXRzIC0gdGhpcy50YWtlbjtcbiAgfVxufVxuY29uc3QgdmQgPSAoZSkgPT4gbmV3IEdPKGUpLCBZTyA9IChlKSA9PiB5KCgpID0+IHZkKGUpKSwgUU8gPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gTCgobiwgcikgPT4ge1xuICBjb25zdCBzID0gdCwgYyA9IHVkKGUsIG4sIHIucnVudGltZUZsYWdzLCB0Yyk7XG4gIGlmIChzLnN0YXRlLl90YWcgPT09IFwiT3BlblwiKSB7XG4gICAgY29uc3QgaSA9ICgpID0+IGZyKChhKSA9PiBPKGEsIGMuaWQoKSkgPyBLIDogbnQoemYoYykpKSwgbyA9IHt9O1xuICAgIHMuc3RhdGUuZmluYWxpemVycy5zZXQobywgaSksIGMuYWRkT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgcy5zdGF0ZS5fdGFnICE9PSBcIkNsb3NlZFwiICYmIHMuc3RhdGUuZmluYWxpemVycy5kZWxldGUobyk7XG4gICAgfSk7XG4gIH0gZWxzZVxuICAgIGMudW5zYWZlSW50ZXJydXB0QXNGb3JrKG4uaWQoKSk7XG4gIHJldHVybiBTKGMpO1xufSkpLCBaTyA9IFwiZWZmZWN0L1JlZi9TeW5jaHJvbml6ZWRSZWZcIiwgWE8gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihaTyksIGUkID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfQTogKGUpID0+IGVcbn07XG52YXIgS3UsIFd1LCBKdSwgSHU7XG5jbGFzcyB0JCBleHRlbmRzIChIdSA9IGFvLCBKdSA9IFhPLCBXdSA9IGdoLCBLdSA9IHNzLCBIdSkge1xuICBjb25zdHJ1Y3RvcihuLCByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwicmVmXCIpO1xuICAgIHUodGhpcywgXCJ3aXRoTG9ja1wiKTtcbiAgICB1KHRoaXMsIEp1LCBlJCk7XG4gICAgdSh0aGlzLCBXdSwgbWgpO1xuICAgIHUodGhpcywgS3UsIHNzKTtcbiAgICB1KHRoaXMsIFwiZ2V0XCIpO1xuICAgIHRoaXMucmVmID0gbiwgdGhpcy53aXRoTG9jayA9IHIsIHRoaXMuZ2V0ID0gbXQodGhpcy5yZWYpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQ7XG4gIH1cbiAgbW9kaWZ5KG4pIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlFZmZlY3QoKHIpID0+IFMobihyKSkpO1xuICB9XG4gIG1vZGlmeUVmZmVjdChuKSB7XG4gICAgcmV0dXJuIHRoaXMud2l0aExvY2soZihtKG10KHRoaXMucmVmKSwgbiksIG0oKFtyLCBzXSkgPT4gZmUoY3ModGhpcy5yZWYsIHMpLCByKSkpKTtcbiAgfVxufVxuY29uc3QgbiQgPSAoZSkgPT4geSgoKSA9PiB3ZChlKSksIHdkID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IHBoKGUpLCBuID0gdmQoMSk7XG4gIHJldHVybiBuZXcgdCQodCwgbi53aXRoUGVybWl0cygxKSk7XG59LCByJCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiZWZmZWN0L01hbmFnZWRSdW50aW1lXCIpLCBzJCA9IFwiRnJlc2hcIiwgYyQgPSBcIkZyb21FZmZlY3RcIiwgaSQgPSBcIlNjb3BlZFwiLCBvJCA9IFwiU3VzcGVuZFwiLCBhJCA9IFwiUHJvdmlkZVwiLCB1JCA9IFwiUHJvdmlkZU1lcmdlXCIsIGwkID0gXCJaaXBXaXRoXCIsIFNyID0gKGUpID0+IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHQgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIChuLCAuLi5yKSA9PiBlKHQsIG4sIC4uLnIpO1xuICB9XG4gIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBSbyA9IC8qIEBfX1BVUkVfXyAqLyBTcigoZSwgdCwgbikgPT4ge1xuICBjb25zdCByID0gcmYoKSwgcyA9IFtbcnQsIFtbciwgZS5jb250ZXh0XV1dXTtcbiAgbiAhPSBudWxsICYmIG4uc2NoZWR1bGVyICYmIHMucHVzaChbX28sIFtbciwgbi5zY2hlZHVsZXJdXV0pO1xuICBsZXQgYyA9IHQwKGUuZmliZXJSZWZzLCB7XG4gICAgZW50cmllczogcyxcbiAgICBmb3JrQXM6IHJcbiAgfSk7XG4gIG4gIT0gbnVsbCAmJiBuLnVwZGF0ZVJlZnMgJiYgKGMgPSBuLnVwZGF0ZVJlZnMoYywgcikpO1xuICBjb25zdCBpID0gbmV3IGlkKHIsIGMsIGUucnVudGltZUZsYWdzKTtcbiAgbGV0IG8gPSB0O1xuICBuICE9IG51bGwgJiYgbi5zY29wZSAmJiAobyA9IG0od08obi5zY29wZSwgWnMpLCAoaCkgPT4gb2UoSmYoaCwgZnIoKGQpID0+IE8oZCwgaS5pZCgpKSA/IEsgOiBlcyhpLCBkKSkpLCBybih0LCAoZCkgPT4gdk8oaCwgZCkpKSkpO1xuICBjb25zdCBhID0gaS5jdXJyZW50U3VwZXJ2aXNvcjtcbiAgcmV0dXJuIGEgIT09IHNjICYmIChhLm9uU3RhcnQoZS5jb250ZXh0LCBvLCB2KCksIGkpLCBpLmFkZE9ic2VydmVyKChoKSA9PiBhLm9uRW5kKGgsIGkpKSksIHRjLmFkZChlLnJ1bnRpbWVGbGFncywgaSksIChuID09IG51bGwgPyB2b2lkIDAgOiBuLmltbWVkaWF0ZSkgPT09ICExID8gaS5yZXN1bWUobykgOiBpLnN0YXJ0KG8pLCBpO1xufSksIGYkID0gLyogQF9fUFVSRV9fICovIFNyKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBtJChlKSh0KTtcbiAgaWYgKG4uX3RhZyA9PT0gXCJGYWlsdXJlXCIpXG4gICAgdGhyb3cgT2Qobi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTApO1xuICByZXR1cm4gbi5lZmZlY3RfaW5zdHJ1Y3Rpb25faTA7XG59KTtcbmNsYXNzIGgkIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihuKSB7XG4gICAgc3VwZXIoYEZpYmVyICMke24uaWQoKS5pZH0gY2Fubm90IGJlIHJlc29sdmVkIHN5bmNocm9ub3VzbHkuIFRoaXMgaXMgY2F1c2VkIGJ5IHVzaW5nIHJ1blN5bmMgb24gYW4gZWZmZWN0IHRoYXQgcGVyZm9ybXMgYXN5bmMgd29ya2ApO1xuICAgIHUodGhpcywgXCJmaWJlclwiKTtcbiAgICB1KHRoaXMsIFwiX3RhZ1wiLCBcIkFzeW5jRmliZXJFeGNlcHRpb25cIik7XG4gICAgdGhpcy5maWJlciA9IG4sIHRoaXMubmFtZSA9IHRoaXMuX3RhZywgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZTtcbiAgfVxufVxuY29uc3QgZCQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICBjb25zdCBuID0gbmV3IGgkKGUpO1xuICByZXR1cm4gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gdCwgbjtcbn0sIF9jID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvUnVudGltZS9GaWJlckZhaWx1cmVcIiksIE1yID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJlZmZlY3QvUnVudGltZS9GaWJlckZhaWx1cmUvQ2F1c2VcIik7XG52YXIgR3UsIFl1O1xuY2xhc3MgZyQgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG4pIHtcbiAgICBjb25zdCByID0gSWYobilbMF07XG4gICAgc3VwZXIoKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubWVzc2FnZSkgfHwgXCJBbiBlcnJvciBoYXMgb2NjdXJyZWRcIik7XG4gICAgdSh0aGlzLCBZdSk7XG4gICAgdSh0aGlzLCBHdSk7XG4gICAgdGhpc1tfY10gPSBfYywgdGhpc1tNcl0gPSBuLCB0aGlzLm5hbWUgPSByID8gYChGaWJlckZhaWx1cmUpICR7ci5uYW1lfWAgOiBcIkZpYmVyRmFpbHVyZVwiLCByICE9IG51bGwgJiYgci5zdGFjayAmJiAodGhpcy5zdGFjayA9IHIuc3RhY2spO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkZpYmVyRmFpbHVyZVwiLFxuICAgICAgY2F1c2U6IHRoaXNbTXJdLnRvSlNPTigpXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCIoRmliZXJGYWlsdXJlKSBcIiArIGFyKHRoaXNbTXJdLCB7XG4gICAgICByZW5kZXJFcnJvckNhdXNlOiAhMFxuICAgIH0pO1xuICB9XG4gIFsoWXUgPSBfYywgR3UgPSBNciwgVSldKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmNvbnN0IE9kID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgY29uc3QgbiA9IG5ldyBnJChlKTtcbiAgcmV0dXJuIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHQsIG47XG59LCAkZCA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBlO1xuICBzd2l0Y2ggKHQuX29wKSB7XG4gICAgY2FzZSBcIkZhaWx1cmVcIjpcbiAgICBjYXNlIFwiU3VjY2Vzc1wiOlxuICAgICAgcmV0dXJuIHQ7XG4gICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgIHJldHVybiBoYSh0LmxlZnQpO1xuICAgIGNhc2UgXCJSaWdodFwiOlxuICAgICAgcmV0dXJuIGoodC5yaWdodCk7XG4gICAgY2FzZSBcIlNvbWVcIjpcbiAgICAgIHJldHVybiBqKHQudmFsdWUpO1xuICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICByZXR1cm4gaGEoSHMoKSk7XG4gIH1cbn0sIG0kID0gLyogQF9fUFVSRV9fICovIFNyKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSAkZCh0KTtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIG47XG4gIGNvbnN0IHIgPSBuZXcgVGsoKSwgcyA9IFJvKGUpKHQsIHtcbiAgICBzY2hlZHVsZXI6IHJcbiAgfSk7XG4gIHIuZmx1c2goKTtcbiAgY29uc3QgYyA9IHMudW5zYWZlUG9sbCgpO1xuICByZXR1cm4gYyB8fCBGbihLaShkJChzKSwgaW8ocykpKTtcbn0pLCBwJCA9IC8qIEBfX1BVUkVfXyAqLyBTcigoZSwgdCwgbikgPT4gRWQoZSwgdCwgbikudGhlbigocikgPT4ge1xuICBzd2l0Y2ggKHIuX3RhZykge1xuICAgIGNhc2UgbmU6XG4gICAgICByZXR1cm4gci5lZmZlY3RfaW5zdHJ1Y3Rpb25faTA7XG4gICAgY2FzZSB0ZTpcbiAgICAgIHRocm93IE9kKHIuZWZmZWN0X2luc3RydWN0aW9uX2kwKTtcbiAgfVxufSkpLCBFZCA9IC8qIEBfX1BVUkVfXyAqLyBTcigoZSwgdCwgbikgPT4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgY29uc3QgcyA9ICRkKHQpO1xuICBzICYmIHIocyk7XG4gIGNvbnN0IGMgPSBSbyhlKSh0KTtcbiAgYy5hZGRPYnNlcnZlcigoaSkgPT4ge1xuICAgIHIoaSk7XG4gIH0pLCAobiA9PSBudWxsID8gdm9pZCAwIDogbi5zaWduYWwpICE9PSB2b2lkIDAgJiYgKG4uc2lnbmFsLmFib3J0ZWQgPyBjLnVuc2FmZUludGVycnVwdEFzRm9yayhjLmlkKCkpIDogbi5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICBjLnVuc2FmZUludGVycnVwdEFzRm9yayhjLmlkKCkpO1xuICB9LCB7XG4gICAgb25jZTogITBcbiAgfSkpO1xufSkpO1xuY2xhc3MgSWQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgdSh0aGlzLCBcImNvbnRleHRcIik7XG4gICAgdSh0aGlzLCBcInJ1bnRpbWVGbGFnc1wiKTtcbiAgICB1KHRoaXMsIFwiZmliZXJSZWZzXCIpO1xuICAgIHRoaXMuY29udGV4dCA9IHQsIHRoaXMucnVudGltZUZsYWdzID0gbiwgdGhpcy5maWJlclJlZnMgPSByO1xuICB9XG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHcodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuY29uc3QgXyQgPSAoZSkgPT4gbmV3IElkKGUuY29udGV4dCwgZS5ydW50aW1lRmxhZ3MsIGUuZmliZXJSZWZzKSwgeSQgPSAoKSA9PiBMKChlLCB0KSA9PiBTKG5ldyBJZChlLmdldEZpYmVyUmVmKHJ0KSwgdC5ydW50aW1lRmxhZ3MsIGUuZ2V0RmliZXJSZWZzKCkpKSksIGIkID0gLyogQF9fUFVSRV9fICovIGJmKGduLCBfZiwgcGYpLCBvbiA9IC8qIEBfX1BVUkVfXyAqLyBfJCh7XG4gIGNvbnRleHQ6IC8qIEBfX1BVUkVfXyAqLyBPaSgpLFxuICBydW50aW1lRmxhZ3M6IGIkLFxuICBmaWJlclJlZnM6IC8qIEBfX1BVUkVfXyAqLyBuMCgpXG59KSwgUyQgPSAvKiBAX19QVVJFX18gKi8gUm8ob24pLCBrJCA9IC8qIEBfX1BVUkVfXyAqLyBwJChvbiksIHYkID0gLyogQF9fUFVSRV9fICovIEVkKG9uKSwgdyQgPSAvKiBAX19QVVJFX18gKi8gZiQob24pLCBPJCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBlLm1vZGlmeUVmZmVjdCh0KSksICQkID0gXCJlZmZlY3QvTGF5ZXJcIiwgRmQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcigkJCksIEUkID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUkluOiAoZSkgPT4gZSxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0U6IChlKSA9PiBlLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUk91dDogKGUpID0+IGVcbn0sIGFuID0ge1xuICBbRmRdOiBFJCxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gdyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59LCBJJCA9IFwiZWZmZWN0L0xheWVyL01lbW9NYXBcIiwgeWMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihJJCksIEYkID0gLyogQF9fUFVSRV9fICovICRpKCkoXCJlZmZlY3QvTGF5ZXIvQ3VycmVudE1lbW9NYXBcIiwge1xuICBkZWZhdWx0VmFsdWU6ICgpID0+IEMkKClcbn0pLCBSJCA9IChlKSA9PiAkKGUsIEZkKSwgTSQgPSAoZSkgPT4gZS5fb3BfbGF5ZXIgPT09IHMkO1xudmFyIFF1O1xuUXUgPSB5YztcbmNsYXNzIFJkIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHUodGhpcywgXCJyZWZcIik7XG4gICAgdSh0aGlzLCBRdSk7XG4gICAgdGhpcy5yZWYgPSB0LCB0aGlzW3ljXSA9IHljO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIG1lbW8gbWFwIHRvIHNlZSBpZiBhIGxheWVyIGV4aXN0cy4gSWYgaXQgaXMsIGltbWVkaWF0ZWx5XG4gICAqIHJldHVybnMgaXQuIE90aGVyd2lzZSwgb2J0YWlucyB0aGUgbGF5ZXIsIHN0b3JlcyBpdCBpbiB0aGUgbWVtbyBtYXAsXG4gICAqIGFuZCBhZGRzIGEgZmluYWxpemVyIHRvIHRoZSBgU2NvcGVgLlxuICAgKi9cbiAgZ2V0T3JFbHNlTWVtb2l6ZSh0LCBuKSB7XG4gICAgcmV0dXJuIGYoTyQodGhpcy5yZWYsIChyKSA9PiB7XG4gICAgICBjb25zdCBzID0gci5nZXQodCk7XG4gICAgICBpZiAocyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IFtjLCBpXSA9IHMsIG8gPSBmKGMsIG0oKFthLCBoXSkgPT4gZihNMChhKSwgZmUoaCkpKSwgcm4odG8oe1xuICAgICAgICAgIG9uRmFpbHVyZTogKCkgPT4gSyxcbiAgICAgICAgICBvblN1Y2Nlc3M6ICgpID0+IHRzKG4sIGkpXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiBTKFtvLCByXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZihKYygwKSwgbSgoYykgPT4gZihBYigpLCBtKChpKSA9PiBmKEpjKCgpID0+IEspLCBUKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBFZSgoZCkgPT4gZihFbygpLCBtKChnKSA9PiBmKGQobShUZCh0LCBnLCAhMCksIChwKSA9PiAkMChwKHRoaXMpKSkpLCBZZSwgbSgocCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAocC5fdGFnKSB7XG4gICAgICAgICAgICBjYXNlIHRlOlxuICAgICAgICAgICAgICByZXR1cm4gZihqYihpLCBwLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCksIG9lKEJjKGcsIHApKSwgb2UoWihwLmVmZmVjdF9pbnN0cnVjdGlvbl9pMCkpKTtcbiAgICAgICAgICAgIGNhc2UgbmU6XG4gICAgICAgICAgICAgIHJldHVybiBmKGNzKG8sIChfKSA9PiBmKEJjKGcsIF8pLCByYih5MChjLCAoYikgPT4gW2IgPT09IDEsIGIgLSAxXSkpLCBudCkpLCBvZSgkYShjLCAoXykgPT4gXyArIDEpKSwgb2UodHMobiwgKF8pID0+IGYoeSgoKSA9PiByLmRlbGV0ZSh0KSksIG9lKG10KG8pKSwgbSgoYikgPT4gYihfKSkpKSksIG9lKExiKGksIHAuZWZmZWN0X2luc3RydWN0aW9uX2kwKSksIGZlKHAuZWZmZWN0X2luc3RydWN0aW9uX2kwWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkpKSksIGggPSBbZihybyhpKSwgcm4oVmMoe1xuICAgICAgICAgIG9uRmFpbHVyZTogKCkgPT4gSyxcbiAgICAgICAgICBvblN1Y2Nlc3M6ICgpID0+ICRhKGMsIChkKSA9PiBkICsgMSlcbiAgICAgICAgfSkpKSwgKGQpID0+IGYobXQobyksIG0oKGcpID0+IGcoZCkpKV07XG4gICAgICAgIHJldHVybiBbYSwgTSQodCkgPyByIDogci5zZXQodCwgaCldO1xuICAgICAgfSkpKSkpKTtcbiAgICB9KSwgenMpO1xuICB9XG59XG5jb25zdCBUJCA9IC8qIEBfX1BVUkVfXyAqLyBOKCgpID0+IFQobiQoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIChlKSA9PiBuZXcgUmQoZSkpKSwgQyQgPSAoKSA9PiBuZXcgUmQod2QoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkpLCBNZCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiBtKFQkLCAobikgPT4gTiQoZSwgbiwgdCkpKSwgTiQgPSAvKiBAX19QVVJFX18gKi8gbCgzLCAoZSwgdCwgbikgPT4gbShUZChlLCBuKSwgKHIpID0+IEVoKHIodCksIEYkLCB0KSkpLCBUZCA9IChlLCB0LCBuID0gITEpID0+IHtcbiAgY29uc3QgciA9IGU7XG4gIHN3aXRjaCAoci5fb3BfbGF5ZXIpIHtcbiAgICBjYXNlIFwiTG9jYWxseVwiOlxuICAgICAgcmV0dXJuIHkoKCkgPT4gKHMpID0+IHIuZihzLmdldE9yRWxzZU1lbW9pemUoci5zZWxmLCB0KSkpO1xuICAgIGNhc2UgXCJFeHRlbmRTY29wZVwiOlxuICAgICAgcmV0dXJuIHkoKCkgPT4gKHMpID0+IGp3KChjKSA9PiBzLmdldE9yRWxzZU1lbW9pemUoci5sYXllciwgYykpKTtcbiAgICBjYXNlIFwiRm9sZFwiOlxuICAgICAgcmV0dXJuIHkoKCkgPT4gKHMpID0+IGYocy5nZXRPckVsc2VNZW1vaXplKHIubGF5ZXIsIHQpLCBTZSh7XG4gICAgICAgIG9uRmFpbHVyZTogKGMpID0+IHMuZ2V0T3JFbHNlTWVtb2l6ZShyLmZhaWx1cmVLKGMpLCB0KSxcbiAgICAgICAgb25TdWNjZXNzOiAoYykgPT4gcy5nZXRPckVsc2VNZW1vaXplKHIuc3VjY2Vzc0soYyksIHQpXG4gICAgICB9KSkpO1xuICAgIGNhc2UgXCJGcmVzaFwiOlxuICAgICAgcmV0dXJuIHkoKCkgPT4gKHMpID0+IGYoci5sYXllciwgTWQodCkpKTtcbiAgICBjYXNlIFwiRnJvbUVmZmVjdFwiOlxuICAgICAgcmV0dXJuIHkobiA/ICgpID0+IChzKSA9PiByLmVmZmVjdCA6ICgpID0+IChzKSA9PiBzLmdldE9yRWxzZU1lbW9pemUoZSwgdCkpO1xuICAgIGNhc2UgXCJQcm92aWRlXCI6XG4gICAgICByZXR1cm4geSgoKSA9PiAocykgPT4gZihzLmdldE9yRWxzZU1lbW9pemUoci5maXJzdCwgdCksIG0oKGMpID0+IGYocy5nZXRPckVsc2VNZW1vaXplKHIuc2Vjb25kLCB0KSwgc28oYykpKSkpO1xuICAgIGNhc2UgXCJTY29wZWRcIjpcbiAgICAgIHJldHVybiB5KG4gPyAoKSA9PiAocykgPT4geXIoci5lZmZlY3QsIHQpIDogKCkgPT4gKHMpID0+IHMuZ2V0T3JFbHNlTWVtb2l6ZShlLCB0KSk7XG4gICAgY2FzZSBcIlN1c3BlbmRcIjpcbiAgICAgIHJldHVybiB5KCgpID0+IChzKSA9PiBzLmdldE9yRWxzZU1lbW9pemUoci5ldmFsdWF0ZSgpLCB0KSk7XG4gICAgY2FzZSBcIlByb3ZpZGVNZXJnZVwiOlxuICAgICAgcmV0dXJuIHkoKCkgPT4gKHMpID0+IGYocy5nZXRPckVsc2VNZW1vaXplKHIuZmlyc3QsIHQpLCBVZihzLmdldE9yRWxzZU1lbW9pemUoci5zZWNvbmQsIHQpLCByLnppcEspKSk7XG4gICAgY2FzZSBcIlppcFdpdGhcIjpcbiAgICAgIHJldHVybiB5KCgpID0+IChzKSA9PiBmKHMuZ2V0T3JFbHNlTWVtb2l6ZShyLmZpcnN0LCB0KSwgX3Iocy5nZXRPckVsc2VNZW1vaXplKHIuc2Vjb25kLCB0KSwgci56aXBLLCB7XG4gICAgICAgIGNvbmN1cnJlbnQ6ICEwXG4gICAgICB9KSkpO1xuICB9XG59LCBBJCA9ICgpID0+IGNjKFpmKCkpLCBQJCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBGcyhlKSwgciA9IG4gPyBlIDogdDtcbiAgcmV0dXJuIGNjKFQobiA/IHQgOiBlLCAoYykgPT4gcnIociwgYykpKTtcbn0pO1xuZnVuY3Rpb24gY2MoZSkge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShhbik7XG4gIHJldHVybiB0Ll9vcF9sYXllciA9IGMkLCB0LmVmZmVjdCA9IGUsIHQ7XG59XG5jb25zdCB4JCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB6JChlLCB0LCAobiwgcikgPT4gZm4obiwgcikpKSwgQ2QgPSAoLi4uZSkgPT4ge1xuICBsZXQgdCA9IGVbMF07XG4gIGZvciAobGV0IG4gPSAxOyBuIDwgZS5sZW5ndGg7IG4rKylcbiAgICB0ID0geCQodCwgZVtuXSk7XG4gIHJldHVybiB0O1xufSwgaiQgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gRnMoZSksIHIgPSBuID8gZSA6IHQ7XG4gIHJldHVybiBMJChUKG4gPyB0IDogZSwgKGMpID0+IHJyKHIsIGMpKSk7XG59KSwgTCQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShhbik7XG4gIHJldHVybiB0Ll9vcF9sYXllciA9IGkkLCB0LmVmZmVjdCA9IGUsIHQ7XG59LCBEJCA9IC8qIEBfX1BVUkVfXyAqLyBsKDIsIChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBGcyhlKTtcbiAgcmV0dXJuIGNjKFMocnIobiA/IGUgOiB0LCBuID8gdCA6IGUpKSk7XG59KSwgTmQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShhbik7XG4gIHJldHVybiB0Ll9vcF9sYXllciA9IG8kLCB0LmV2YWx1YXRlID0gZSwgdDtcbn0sIHEkID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IEZzKGUpLCByID0gbiA/IGUgOiB0LCBzID0gbiA/IHQgOiBlO1xuICByZXR1cm4gY2MoeSgoKSA9PiBycihyLCBzKCkpKSk7XG59KSwgVSQgPSAvKiBAX19QVVJFX18gKi8gbCgyLCAoZSwgdCkgPT4gTmQoKCkgPT4ge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShhbik7XG4gIHJldHVybiBuLl9vcF9sYXllciA9IGEkLCBuLmZpcnN0ID0gT2JqZWN0LmNyZWF0ZShhbiwge1xuICAgIF9vcF9sYXllcjoge1xuICAgICAgdmFsdWU6IHUkLFxuICAgICAgZW51bWVyYWJsZTogITBcbiAgICB9LFxuICAgIGZpcnN0OiB7XG4gICAgICB2YWx1ZTogQSQoKSxcbiAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgfSxcbiAgICBzZWNvbmQ6IHtcbiAgICAgIHZhbHVlOiBBcnJheS5pc0FycmF5KHQpID8gQ2QoLi4udCkgOiB0XG4gICAgfSxcbiAgICB6aXBLOiB7XG4gICAgICB2YWx1ZTogKHIsIHMpID0+IGYociwgZm4ocykpXG4gICAgfVxuICB9KSwgbi5zZWNvbmQgPSBlLCBuO1xufSkpLCB6JCA9IC8qIEBfX1BVUkVfXyAqLyBsKDMsIChlLCB0LCBuKSA9PiBOZCgoKSA9PiB7XG4gIGNvbnN0IHIgPSBPYmplY3QuY3JlYXRlKGFuKTtcbiAgcmV0dXJuIHIuX29wX2xheWVyID0gbCQsIHIuZmlyc3QgPSBlLCByLnNlY29uZCA9IHQsIHIuemlwSyA9IG4sIHI7XG59KSksIEdhID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IGxkKChuKSA9PiBtKE1kKHQsIG4pLCAocikgPT4gY28oZSwgcikpKSksIFlhID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IFduKG9uLmZpYmVyUmVmcywgdC5maWJlclJlZnMpLCByID0gZ3Qob24ucnVudGltZUZsYWdzLCB0LnJ1bnRpbWVGbGFncyk7XG4gIHJldHVybiBFZSgocykgPT4gTCgoYykgPT4ge1xuICAgIGNvbnN0IGkgPSBjLmdldEZpYmVyUmVmKHJ0KSwgbyA9IGMuZ2V0RmliZXJSZWZzKCksIGEgPSBKbihjLmlkKCksIG8pKG4pLCBoID0gYy5jdXJyZW50UnVudGltZUZsYWdzLCBkID0gRHQocikoaCksIGcgPSBXbihhLCBvKSwgcCA9IGd0KGQsIGgpO1xuICAgIHJldHVybiBjLnNldEZpYmVyUmVmcyhhKSwgYy5jdXJyZW50UnVudGltZUZsYWdzID0gZCwgSG4oY28ocyhlKSwgZm4oaSwgdC5jb250ZXh0KSksIEwoKF8pID0+IChfLnNldEZpYmVyUmVmcyhKbihfLmlkKCksIF8uZ2V0RmliZXJSZWZzKCkpKGcpKSwgXy5jdXJyZW50UnVudGltZUZsYWdzID0gRHQocCkoXy5jdXJyZW50UnVudGltZUZsYWdzKSwgSykpKTtcbiAgfSkpO1xufSksIEIkID0gLyogQF9fUFVSRV9fICovIGwoMiwgKGUsIHQpID0+IEFycmF5LmlzQXJyYXkodCkgPyBHYShlLCBDZCguLi50KSkgOiBSJCh0KSA/IEdhKGUsIHQpIDogU20odCkgPyBjbyhlLCB0KSA6IHIkIGluIHQgPyBtKHQucnVudGltZUVmZmVjdCwgKG4pID0+IFlhKGUsIG4pKSA6IFlhKGUsIHQpKSwgekUgPSBMZSwgQkUgPSBvZCwgVkUgPSBjbiwgS0UgPSBMLCBXRSA9IHgsIEpFID0gWiwgSEUgPSBxYywgR0UgPSBjYiwgWUUgPSBUMCwgUUUgPSBTLCBaRSA9IE4sIFhFID0geSwgZUkgPSBLLCB0SSA9IFpyLCBuSSA9IFBmLCBySSA9IEYwLCBzSSA9IE8wLCBjSSA9IHgwLCBpSSA9IFF5LCBvSSA9IEppLCBhSSA9IEtzLCB1SSA9IEVlLCBsSSA9IEUwLCBmSSA9IGZlLCBoSSA9IG50LCBRYSA9IFQsIGRJID0gSGksIGdJID0gVnMsIG1JID0gTXcsIHBJID0gQ2YsIF9JID0gSG4sIHlJID0gZmQsIGJJID0gbGQsIFNJID0gZnIsIGtJID0gJG8sIHZJID0gUU8sIHdJID0gQiQsIE9JID0gRWgsICRJID0gbm4sIEVJID0gWWUsIElJID0gWnksIEZJID0gTDAsIFJJID0gbSwgTUkgPSBqdCwgVEkgPSB6cywgQ0kgPSBLdywgTkkgPSBkZCwgQUkgPSBHaSwgUEkgPSBQMCwgeEkgPSBKTywgakkgPSAkaCwgTEkgPSBqZiwgREkgPSBTZSwgcUkgPSB5JCwgVUkgPSBZTywgekkgPSBTJCwgQkkgPSBrJCwgVkkgPSB2JCwgS0kgPSB3JCwgV0kgPSBMdywgSkkgPSBEdywgSEkgPSBxdywgR0kgPSBfciwgWUkgPSBEMCwgViQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIG5ldyBQcm94eShlLCB7XG4gICAgZ2V0KG4sIHIsIHMpIHtcbiAgICAgIGlmIChyIGluIG4pXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChuLCByLCBzKTtcbiAgICAgIGlmICh0LmhhcyhyKSlcbiAgICAgICAgcmV0dXJuIHQuZ2V0KHIpO1xuICAgICAgY29uc3QgYyA9ICguLi5vKSA9PiBqdChuLCAoYSkgPT4gdHlwZW9mIGFbcl0gPT0gXCJmdW5jdGlvblwiID8gKHQuc2V0KHIsICguLi5oKSA9PiBqdChuLCAoZCkgPT4gZFtyXSguLi5oKSkpLCBhW3JdKC4uLm8pKSA6ICh0LnNldChyLCBqdChuLCAoaCkgPT4gaFtyXSkpLCBhW3JdKSksIGkgPSBqdChuLCAobykgPT4gb1tyXSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjLCBpKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKGMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihpKSksIHQuc2V0KHIsIGMpLCBjO1xuICAgIH1cbiAgfSk7XG59LCBRSSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgW2UsIHRdID0gYXJndW1lbnRzLCBuID0gXCJhY2Nlc3NvcnNcIiBpbiB0ID8gdC5hY2Nlc3NvcnMgOiAhMSwgciA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAyO1xuICAgIGNvbnN0IHMgPSBuZXcgRXJyb3IoKTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSByO1xuICAgIGxldCBjID0gXCJ1bmNoZWNrZWRcIjtcbiAgICBjb25zdCBpID0gZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKGMgPT09IFwidW5jaGVja2VkXCIpIHtcbiAgICAgICAgY29uc3QgZyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkKTtcbiAgICAgICAgaWYgKGcgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgZyA9PT0gbnVsbClcbiAgICAgICAgICBjID0gXCJwbGFpblwiO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwLCBnKSwgYyA9IFwicGF0Y2hlZFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gXCJwbGFpblwiKVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGQpO1xuICAgICAgZWxzZSBpZiAoYyA9PT0gXCJwYXRjaGVkXCIpXG4gICAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKSwgZDtcbiAgICB9O1xuICAgIGkucHJvdG90eXBlLl90YWcgPSBlLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJtYWtlXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIChkKSA9PiBuZXcgdGhpcyhkKTtcbiAgICAgIH1cbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwidXNlXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIChkKSA9PiBqdCh0aGlzLCBkKTtcbiAgICAgIH1cbiAgICB9KSwgaS5rZXkgPSBlLCBPYmplY3QuYXNzaWduKGksIElzKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwic3RhY2tcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gcy5zdGFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvID0gXCJkZXBlbmRlbmNpZXNcIiBpbiB0ICYmIHQuZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDAsIGEgPSBvID8gXCJEZWZhdWx0V2l0aG91dERlcGVuZGVuY2llc1wiIDogXCJEZWZhdWx0XCI7XG4gICAgbGV0IGg7XG4gICAgaWYgKFwiZWZmZWN0XCIgaW4gdCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBhLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBoID8/IChoID0gUCQoaSwgUWEodC5lZmZlY3QsIChkKSA9PiBuZXcgdGhpcyhkKSkpKTtcbiAgICAgIH1cbiAgICB9KSA6IFwic2NvcGVkXCIgaW4gdCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBhLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBoID8/IChoID0gaiQoaSwgUWEodC5zY29wZWQsIChkKSA9PiBuZXcgdGhpcyhkKSkpKTtcbiAgICAgIH1cbiAgICB9KSA6IFwic3luY1wiIGluIHQgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgYSwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaCA/PyAoaCA9IHEkKGksICgpID0+IG5ldyB0aGlzKHQuc3luYygpKSkpO1xuICAgICAgfVxuICAgIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIGEsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGggPz8gKGggPSBEJChpLCBuZXcgdGhpcyh0LnN1Y2NlZWQpKSk7XG4gICAgICB9XG4gICAgfSksIG8pIHtcbiAgICAgIGxldCBkO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiRGVmYXVsdFwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZCA/PyAoZCA9IFUkKHRoaXMuRGVmYXVsdFdpdGhvdXREZXBlbmRlbmNpZXMsIHQuZGVwZW5kZW5jaWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbiA9PT0gITAgPyBWJChpKSA6IGk7XG4gIH07XG59O1xuZXhwb3J0IHtcbiAgTUUgYXMgJCxcbiAga2MgYXMgQSxcbiAgVyQgYXMgQixcbiAgSiQgYXMgQyxcbiAgQmQgYXMgRCxcbiAgdGwgYXMgRSxcbiAgeWUgYXMgRixcbiAgZGUgYXMgRyxcbiAgdUUgYXMgSCxcbiAgSSxcbiAgdiBhcyBKLFxuICB0dCBhcyBLLFxuICBibCBhcyBMLFxuICBmRSBhcyBNLFxuICBDIGFzIE4sXG4gIFNpIGFzIE8sXG4gIFpnIGFzIFAsXG4gIE5yIGFzIFEsXG4gIFdyIGFzIFIsXG4gIE9zIGFzIFMsXG4gIFNFIGFzIFQsXG4gIF9FIGFzIFUsXG4gIHBFIGFzIFYsXG4gICRnIGFzIFcsXG4gIHhuIGFzIFgsXG4gIEhmIGFzIFksXG4gIG5tIGFzIFosXG4gIFRFIGFzIF8sXG4gIEtJIGFzIGEsXG4gIEFiIGFzIGEkLFxuICBGbiBhcyBhMCxcbiAgdG8gYXMgYTEsXG4gIE5FIGFzIGEyLFxuICBqIGFzIGEzLFxuICBBIGFzIGE0LFxuICBObiBhcyBhNSxcbiAgTmUgYXMgYTYsXG4gIGRjIGFzIGE3LFxuICBDRSBhcyBhOCxcbiAgaGEgYXMgYTksXG4gIHpJIGFzIGFBLFxuICBUayBhcyBhQixcbiAga2cgYXMgYUMsXG4gIHRJIGFzIGFELFxuICBWRSBhcyBhRSxcbiAgRGcgYXMgYUYsXG4gIHNFIGFzIGFHLFxuICBnSSBhcyBhSCxcbiAgZEUgYXMgYUksXG4gIHpFIGFzIGFKLFxuICByRSBhcyBhSyxcbiAgZEkgYXMgYUwsXG4gIGFFIGFzIGFNLFxuICB0RSBhcyBhTixcbiAgWWcgYXMgYU8sXG4gIFokIGFzIGFQLFxuICBTcyBhcyBhUSxcbiAgUSQgYXMgYVIsXG4gIEgkIGFzIGFTLFxuICBnRSBhcyBhVCxcbiAgWSQgYXMgYVUsXG4gIEckIGFzIGFWLFxuICBtRSBhcyBhVyxcbiAgb0UgYXMgYVgsXG4gIFcgYXMgYVksXG4gIFNsIGFzIGFaLFxuICBiRSBhcyBhXyxcbiAgRkUgYXMgYWEsXG4gIGFyIGFzIGFiLFxuICBCbiBhcyBhYyxcbiAgQ3kgYXMgYWQsXG4gIE15IGFzIGFlLFxuICBPZSBhcyBhZixcbiAgJHkgYXMgYWcsXG4gIEl5IGFzIGFoLFxuICBUZSBhcyBhaSxcbiAgUkUgYXMgYWosXG4gIHdnIGFzIGFrLFxuICBVIGFzIGFsLFxuICBpRSBhcyBhbSxcbiAgY0UgYXMgYW4sXG4gIFFhIGFzIGFvLFxuICBpdCBhcyBhcCxcbiAgWHUgYXMgYXEsXG4gIFB0IGFzIGFyLFxuICBaRSBhcyBhcyxcbiAgZUUgYXMgYXQsXG4gIGF0IGFzIGF1LFxuICBSSSBhcyBhdixcbiAgJEkgYXMgYXcsXG4gIGVJIGFzIGF4LFxuICB5RSBhcyBheSxcbiAgbGUgYXMgYXosXG4gIFlFIGFzIGIsXG4gIEpJIGFzIGIkLFxuICBQRSBhcyBiMCxcbiAgTGIgYXMgYjEsXG4gIHJvIGFzIGIyLFxuICBqYiBhcyBiMyxcbiAgViBhcyBiNCxcbiAgUSBhcyBiNSxcbiAgYmUgYXMgYjYsXG4gIEFlIGFzIGI3LFxuICB5dCBhcyBiOCxcbiAgSmMgYXMgYjksXG4gIHogYXMgYkEsXG4gIEJ0IGFzIGJCLFxuICBIZyBhcyBiQyxcbiAgVG0gYXMgYkQsXG4gIFlmIGFzIGJFLFxuICBEZiBhcyBiRixcbiAgUGwgYXMgYkcsXG4gIFFmIGFzIGJILFxuICB2RSBhcyBiSSxcbiAgdmUgYXMgYkosXG4gIE1tIGFzIGJLLFxuICBLIGFzIGJMLFxuICBXaSBhcyBiTSxcbiAgckkgYXMgYk4sXG4gIEdJIGFzIGJPLFxuICBFSSBhcyBiUCxcbiAgdUkgYXMgYlEsXG4gIEJFIGFzIGJSLFxuICB3TyBhcyBiUyxcbiAgR2MgYXMgYlQsXG4gIHBJIGFzIGJVLFxuICB2SSBhcyBiVixcbiAgSEkgYXMgYlcsXG4gIFpsIGFzIGJYLFxuICBFRSBhcyBiWSxcbiAgWEUgYXMgYlosXG4gIElJIGFzIGJfLFxuICBtdCBhcyBiYSxcbiAgJGEgYXMgYmIsXG4gIHkwIGFzIGJjLFxuICB4RSBhcyBiZCxcbiAgakUgYXMgYmUsXG4gIGVzIGFzIGJmLFxuICB6ZiBhcyBiZyxcbiAgZnMgYXMgYmgsXG4gIG0gYXMgYmksXG4gIHkgYXMgYmosXG4gIFQgYXMgYmssXG4gIFBzIGFzIGJsLFxuICBhbyBhcyBibSxcbiAgTiBhcyBibixcbiAgWnIgYXMgYm8sXG4gIFF5IGFzIGJwLFxuICBaZSBhcyBicSxcbiAgS3MgYXMgYnIsXG4gIEwgYXMgYnMsXG4gIHhzIGFzIGJ0LFxuICBudCBhcyBidSxcbiAgcmIgYXMgYnYsXG4gIG9lIGFzIGJ3LFxuICBwdCBhcyBieCxcbiAgQUUgYXMgYnksXG4gIFMgYXMgYnosXG4gIE1JIGFzIGMsXG4gIFBJIGFzIGMwLFxuICBMRSBhcyBjMSxcbiAgSkUgYXMgYzIsXG4gIHdJIGFzIGMzLFxuICBESSBhcyBjNCxcbiAga0kgYXMgYzUsXG4gIG9JIGFzIGM2LFxuICBfSSBhcyBjNyxcbiAgYUkgYXMgYzgsXG4gIFdJIGFzIGM5LFxuICB3RSBhcyBjQSxcbiAgaWUgYXMgY0IsXG4gIGpJIGFzIGNDLFxuICBPRSBhcyBjRCxcbiAgUUkgYXMgY0UsXG4gIGhFIGFzIGNGLFxuICBsRSBhcyBjRyxcbiAgRXMgYXMgY0gsXG4gIGtFIGFzIGNJLFxuICBIRSBhcyBjYSxcbiAgbkkgYXMgY2IsXG4gIFRJIGFzIGNjLFxuICBTSSBhcyBjZCxcbiAgaUkgYXMgY2UsXG4gIExJIGFzIGNmLFxuICBiSSBhcyBjZyxcbiAgaHQgYXMgY2gsXG4gIE8gYXMgY2ksXG4gIFVFIGFzIGNqLFxuICBxRSBhcyBjayxcbiAgdk8gYXMgY2wsXG4gIFNjIGFzIGNtLFxuICB5SSBhcyBjbixcbiAgVUkgYXMgY28sXG4gIE5JIGFzIGNwLFxuICBGSSBhcyBjcSxcbiAgQ0kgYXMgY3IsXG4gIGZJIGFzIGNzLFxuICB4SSBhcyBjdCxcbiAgaEkgYXMgY3UsXG4gIEtFIGFzIGN2LFxuICBxSSBhcyBjdyxcbiAgREUgYXMgY3gsXG4gIFdFIGFzIGN5LFxuICBtSSBhcyBjeixcbiAgbCBhcyBkLFxuICBjSSBhcyBlLFxuICBZSSBhcyBmLFxuICBHRSBhcyBnLFxuICBPSSBhcyBoLFxuICBlbCBhcyBpLFxuICBWSSBhcyBqLFxuICBzSSBhcyBrLFxuICBsSSBhcyBsLFxuICBRRSBhcyBtLFxuICAkZSBhcyBuLFxuICBuRSBhcyBvLFxuICBmIGFzIHAsXG4gIFAgYXMgcSxcbiAgQkkgYXMgcixcbiAgSUUgYXMgcyxcbiAgQUkgYXMgdCxcbiAgYWUgYXMgdSxcbiAgdyBhcyB2LFxuICBYJCBhcyB3LFxuICAkIGFzIHgsXG4gIFpuIGFzIHksXG4gIHpkIGFzIHpcbn07XG4iXSwibmFtZXMiOlsiUGQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIk5vIiwiZSIsIlR5cGVFcnJvciIsInhkIiwidCIsIm4iLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInUiLCJBbyIsImhhcyIsIlBvIiwiY2FsbCIsImdldCIsInhvIiwiV2Vha1NldCIsImFkZCIsInNldCIsImpvIiwiciIsImpkIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiUmFuZ2VFcnJvciIsImxlbmd0aCIsInMiLCJjIiwiaSIsIm8iLCJQIiwiUW4iLCJMbyIsImJjIiwiTGQiLCJadSIsIlNjIiwiZiIsImEiLCJoIiwiZCIsInlzIiwiRGQiLCJxZCIsIlVkIiwiYnMiLCJPciIsInduIiwiQyIsImdsb2JhbFRoaXMiLCJNYXAiLCJ6ZCIsImtjIiwiVyQiLCJCZCIsIkokIiwiWm4iLCJIJCIsIkckIiwiWSQiLCJRJCIsIlh1IiwiU3MiLCIkIiwiZWwiLCJfdGFnIiwiVHQiLCJaJCIsIlgkIiwiRGF0ZSIsInRsIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlRSIsIkFycmF5IiwiaXNBcnJheSIsIm5sIiwidGhlbiIsImtzIiwicmwiLCJzbCIsIm5leHQiLCJjYWxsZWQiLCJkb25lIiwic2VsZiIsInJldHVybiIsInRocm93IiwiY29uc3RydWN0b3IiLCJWZCIsIktkIiwiV2QiLCJKZCIsIkhkIiwiR2QiLCJZZCIsImdldFN0YXRlIiwiX3N0YXRlIiwic2V0U3RhdGUiLCJpbnRlZ2VyIiwiTWF0aCIsInJvdW5kIiwibnVtYmVyIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIl9uZXh0IiwiUWQiLCJEbyIsInJhbmRvbSIsIkludDMyQXJyYXkiLCJpbXVsIiwidmMiLCJmb3IiLCJZbiIsIlhuIiwiV2Vha01hcCIsIlpkIiwiRXJyb3IiLCJwZSIsImVuYWJsZWQiLCJ0ZXN0ZXIiLCJYZCIsImVlIiwiaWMiLCJGIiwiayIsImRpIiwiQiIsInRvU3RyaW5nIiwiU3RyaW5nIiwidG9JU09TdHJpbmciLCJVUkwiLCJocmVmIiwiZWciLCJoaSIsImZsb29yIiwiUiIsInZzIiwiY2hhckNvZGVBdCIsInRnIiwiY2wiLCJrZXlzIiwiZXIiLCJxIiwiRSIsIk8iLCJxciIsIlVyIiwiZXZlcnkiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImdpIiwiVSIsIlYiLCJ0b0pTT04iLCJtYXAiLCJyZyIsIlEiLCJKU09OIiwic3RyaW5naWZ5IiwiVXQiLCJpbCIsImluY2x1ZGVzIiwicHVzaCIsImx0IiwiZmliZXJSZWZzIiwib2wiLCJtaSIsIm5nIiwidyIsIlJuIiwid3MiLCJ0ZSIsIlRyIiwienIiLCJCciIsIm5lIiwiYWwiLCJzZyIsInVuIiwiVnIiLCJNbiIsInVsIiwiQ3IiLCJwaSIsImNnIiwiaWciLCJvZyIsImFnIiwienQiLCJfUiIsIl9FIiwiX0EiLCJfViIsInVnIiwiX0luIiwiX0wiLCJsZyIsIl9FbnYiLCJfSW5FcnIiLCJfSW5FbGVtIiwiX0luRG9uZSIsIl9PdXRFcnIiLCJfT3V0RWxlbSIsIl9PdXREb25lIiwidHIiLCJwaXBlIiwiT3MiLCJuciIsIl9vcCIsImZnIiwiaGciLCJsbCIsImZsIiwiZGciLCJhc3NpZ24iLCJjcmVhdGUiLCJfaSIsImRsIiwiX2lkIiwiZ2ciLCJtZyIsImhsIiwiJHMiLCJQbiIsImdsIiwibWwiLCJwZyIsInlpIiwicGwiLCJyaWdodCIsIl9nIiwiYmkiLCJsZWZ0IiwieWciLCJiZyIsIlNnIiwiYWUiLCIkZSIsInRFIiwidHJ5IiwiY2F0Y2giLCJuRSIsImF0IiwiUHQiLCJyRSIsIm9uTGVmdCIsIm9uUmlnaHQiLCJzRSIsImNFIiwia2ciLCJ2ZyIsIndnIiwiaUUiLCJfbCIsInlsIiwiT2ciLCIkZyIsIkVnIiwidiIsIkkiLCJvRSIsIlciLCJ5ZSIsInR0Iiwib25Ob25lIiwib25Tb21lIiwiYUUiLCJkZSIsInVFIiwiSWciLCJFcyIsImxFIiwiaXQiLCJmRSIsIkZnIiwiaEUiLCJOciIsImJsIiwiZEUiLCJSZyIsImdFIiwibUUiLCJNZyIsIlRnIiwiQ2ciLCJwRSIsIk5nIiwiU2kiLCJBZyIsIm1heCIsInoiLCJmcm9tIiwiUGciLCJvbkVtcHR5Iiwib25Ob25FbXB0eSIsImxlIiwidWUiLCJfdCIsIktyIiwieGciLCJTbCIsImNvbmNhdCIsInlFIiwiamciLCJMZyIsIkRnIiwia2wiLCJxZyIsIm1pbiIsIlVnIiwidmwiLCJUbiIsInpnIiwid2wiLCJzbGljZSIsIkJnIiwiVmciLCJIZyIsIktnIiwicW8iLCJyZXZlcnNlIiwiV3IiLCJzb3J0IiwiVW8iLCJXZyIsIkpnIiwiR2ciLCJZZyIsIlFnIiwiT2wiLCJBciIsIkJ0Iiwia2UiLCJmdCIsIlpnIiwiWGciLCJiRSIsImVtIiwia2kiLCJyZWR1Y2UiLCJ6byIsInZpIiwidG0iLCJsbiIsImpvaW4iLCJ4biIsIm5tIiwicmVwbGFjZSIsIiRsIiwiSnIiLCJybSIsInNtIiwiSXMiLCJfU2VydmljZSIsIl9JZGVudGlmaWVyIiwia2V5Iiwic3RhY2siLCJvZiIsImNvbnRleHQiLCJGbCIsImNtIiwiaW0iLCJzdGFja1RyYWNlTGltaXQiLCJvbSIsInNldFByb3RvdHlwZU9mIiwiYW0iLCJkZWZhdWx0VmFsdWUiLCJFbCIsInVtIiwiX1NlcnZpY2VzIiwiSWwiLCJ1bnNhZmVNYXAiLCJzaXplIiwic2VydmljZXMiLCJWdCIsImxtIiwic3BsaXQiLCJtYXRjaCIsIm1lc3NhZ2UiLCJzcGxpY2UiLCJmbSIsImhtIiwiZG0iLCJnbSIsIm1tIiwib2MiLCJ3aSIsInBtIiwiUmwiLCJfbSIsInltIiwiYm0iLCJJdCIsIlNtIiwiRnMiLCJPaSIsInJyIiwiQXQiLCJNbCIsIlRsIiwic3IiLCJmbiIsIlNFIiwiJGkiLCJDbCIsImttIiwiTmwiLCJ2bSIsIldlIiwiaHQiLCJ3bSIsIk9tIiwidmFsdWVzIiwiQWwiLCJiYWNraW5nIiwiYXJyYXkiLCJHIiwiZGVwdGgiLCJNZSIsImNodW5rIiwiQWUiLCJhYyIsIlJtIiwiaWUiLCJQbCIsImhuIiwid2MiLCIkbSIsImtFIiwiRW0iLCJJbSIsInl0IiwiRm0iLCJvZmZzZXQiLCJNbSIsInZlIiwiYmUiLCJPYyIsImFicyIsInZFIiwiVG0iLCJIZSIsInhsIiwiamwiLCJDZSIsIndFIiwiVmUiLCJPRSIsIiRjIiwiTGwiLCJCaWdJbnQiLCJCbyIsIiRyIiwiRWMiLCJWbyIsIktvIiwiQ20iLCJQZSIsIkRsIiwiSHIiLCJ1YyIsImlzTmFOIiwicWwiLCJ4bSIsImV4ZWMiLCJqbSIsIkxtIiwiRG0iLCJxbSIsIlVtIiwiem0iLCJXbyIsIm1pbGxpcyIsIk5tIiwiQW0iLCJHbSIsIlFtIiwiaHJ0aW1lIiwiVm0iLCJqZSIsImlzRmluaXRlIiwiaXNJbnRlZ2VyIiwibmFub3MiLCJQbSIsIkljIiwiS20iLCJvbk1pbGxpcyIsIm9uTmFub3MiLCJCbSIsIkVpIiwiV20iLCJKbSIsIkhtIiwiWW0iLCJkYXlzIiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsImJ0IiwiSWkiLCJwb3ciLCJabSIsIlhtIiwiZXAiLCJ0cCIsIkt0IiwieHQiLCJVbCIsIm5wIiwicHJldmlvdXMiLCJMdCIsInpsIiwicnAiLCJRZSIsIm1vZGlmeSIsImR0Iiwid2UiLCJzcCIsIlJzIiwiZWRpdCIsIkJsIiwiaGFzaCIsIkZpIiwidXBkYXRlQ29sbGlzaW9uTGlzdCIsImNoaWxkcmVuIiwiZyIsInAiLCJfIiwiV3QiLCJtYXNrIiwiSCIsImlwIiwiYiIsIk0iLCJEIiwiWCIsIlJpIiwiY3AiLCJvcCIsIlZsIiwiRmMiLCJhcCIsIk1zIiwiZnAiLCJfc2l6ZSIsIlRpIiwiTWkiLCJfZWRpdGFibGUiLCJfZWRpdCIsIl9yb290IiwiR3IiLCJjb250IiwiS2wiLCJXbCIsInVwIiwiVHMiLCJscCIsIkhsIiwiam4iLCJwcCIsImhwIiwiZHAiLCJncCIsIkNpIiwibXAiLCJKbCIsIlJjIiwiX3AiLCJOYU4iLCJKbyIsInlwIiwiQ3MiLCJicCIsInBvcCIsIkdsIiwiTWMiLCJTcCIsIl9rZXlNYXAiLCJrcCIsIk5zIiwidnAiLCJBcyIsIndwIiwiTmkiLCJMbiIsIkFpIiwiT3AiLCIkcCIsIkVwIiwiWWwiLCJRbCIsIklwIiwiRnAiLCJScCIsIk1wIiwiU3QiLCJUcCIsIlBpIiwiQ3AiLCJabCIsIkNuIiwiWGwiLCJIbyIsIkRuIiwicW4iLCJHbyIsIk5wIiwiY3VycmVudCIsIlBzIiwiQXAiLCJaZSIsInhzIiwianMiLCJrdCIsIkp0IiwiVGMiLCJDYyIsIlBwIiwiWmEiLCJ4cCIsInhpIiwiWGEiLCJqcCIsImlkIiwic3RhcnRUaW1lTWlsbGlzIiwiZXUiLCJMcCIsImVmIiwidGYiLCJEcCIsIk5jIiwiWW8iLCJuZiIsInFwIiwibm93IiwiSHQiLCJVcCIsIkVFIiwienAiLCJyZiIsImppIiwiQnAiLCJWcCIsInNmIiwiY2YiLCJLcCIsIldwIiwiYWYiLCJVbiIsIkFjIiwiSnAiLCJIcCIsIkdwIiwibGYiLCJoZWFkIiwidGFpbCIsIllyIiwiWXAiLCJRcCIsInVmIiwiSmUiLCJacCIsIlhwIiwidnQiLCJHdCIsIkxpIiwiZV8iLCJuXyIsInRfIiwicl8iLCJzXyIsIkRpIiwiSUUiLCJjXyIsIlFvIiwiY3IiLCJfVmFsdWUiLCJfUGF0Y2giLCJpXyIsIm9fIiwiZmYiLCJhXyIsInVfIiwiZmlyc3QiLCJzZWNvbmQiLCJsXyIsImZfIiwic2VydmljZSIsImhfIiwiZF8iLCJnXyIsIm1fIiwidXBkYXRlIiwicF8iLCJlbnRyaWVzIiwiZGVsZXRlIiwiUHIiLCJfXyIsInlfIiwibGMiLCJMcyIsIl9LZXkiLCJiXyIsIlNfIiwiaGYiLCJrXyIsInZfIiwid18iLCJPXyIsIiRfIiwiRV8iLCJJXyIsIlBjIiwiRl8iLCJSXyIsIlpvIiwiaXIiLCJNXyIsIlRfIiwiZGYiLCJDXyIsIk5fIiwiQV8iLCJQXyIsInhfIiwial8iLCJ1bnRpbCIsIkxfIiwiRF8iLCJpbmRleCIsInBhdGNoIiwicV8iLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwiZGlmZmVyIiwiZGlmZiIsImVtcHR5IiwieHIiLCJVXyIsInVuc2hpZnQiLCJ6XyIsIkJfIiwiX1AiLCJkbiIsImNvbWJpbmUiLCJWXyIsIktfIiwiV18iLCJnZiIsIkpfIiwiem4iLCJtZiIsInhjIiwiamMiLCJvciIsIkhfIiwiR18iLCJZXyIsIlFfIiwiWl8iLCJYXyIsImV5IiwiZ24iLCJ0eSIsInBmIiwiTGMiLCJfZiIsIm55IiwiRHMiLCJyeSIsIkdlIiwieWYiLCJjeSIsImJmIiwic3kiLCJYbyIsImd0IiwiRHQiLCJlYSIsIml5IiwiU2YiLCJ0YSIsImtmIiwiRXIiLCJveSIsInZmIiwiYXkiLCJkeSIsInV5IiwiaHkiLCJmYyIsImd5IiwiU3kiLCJteSIsImJ5IiwibHkiLCJmeSIsInR1IiwicWkiLCJkYXRhU291cmNlIiwiYmxvY2tlZFJlcXVlc3QiLCJ5eSIsInB5IiwiX3kiLCJudSIsIndmIiwia3kiLCJtbiIsInd0IiwiRnQiLCJwbiIsIll0IiwiUXQiLCJPZiIsIiRmIiwidnkiLCJfbiIsImp5Iiwid3kiLCJ4eSIsImRlZmVjdCIsImZpYmVySWQiLCJmYWlsdXJlIiwiZXJyb3IiLCJhciIsIlp0IiwiQm4iLCJPZSIsIlRlIiwiT3QiLCJzZSIsIk95IiwiRkUiLCIkeSIsIkV5IiwiWHQiLCJJeSIsIk55IiwiVWkiLCJWaSIsIkR5IiwiRnkiLCJSeSIsIk15IiwiVHkiLCJ6aSIsIkN5IiwibmEiLCJCaSIsIm9uRmFpbCIsIm9uRGllIiwib25JbnRlcnJ1cHQiLCJvblNlcXVlbnRpYWwiLCJvblBhcmFsbGVsIiwiQXkiLCJSRSIsIlB5IiwiRGMiLCJMeSIsImVtcHR5Q2FzZSIsImZhaWxDYXNlIiwiZGllQ2FzZSIsImludGVycnVwdENhc2UiLCJzZXF1ZW50aWFsQ2FzZSIsInBhcmFsbGVsQ2FzZSIsInJhIiwic2EiLCJJZiIsInJlbmRlckVycm9yQ2F1c2UiLCJjYXVzZSIsIkVmIiwiUXIiLCJxeSIsIm5hbWUiLCJlbiIsInNwYW4iLCJmb3JFYWNoIiwiQnkiLCJVeSIsInp5Iiwic3RhcnRzV2l0aCIsIm1hdGNoQWxsIiwicGFyZW50IiwidXIiLCJxcyIsIlZ5IiwiS3kiLCJXeSIsIkp5Iiwiam9pbmVycyIsIkZmIiwiZWZmZWN0IiwibHIiLCJSZiIsIkoiLCJlZmZlY3RfaW5zdHJ1Y3Rpb25faTAiLCJlZmZlY3RfaW5zdHJ1Y3Rpb25faTEiLCJIeSIsInRuIiwiR3kiLCJydSIsImVmZmVjdF9pbnN0cnVjdGlvbl9pMiIsInN1IiwiTWYiLCJlbyIsImN1IiwiVGYiLCJMZSIsIkwiLCJDZiIsIkVlIiwibSIsIlllIiwiTiIsIlNlIiwib25GYWlsdXJlIiwiWiIsIm9uU3VjY2VzcyIsImZlIiwiUyIsIm50IiwiTmYiLCJjb21taXQiLCJWbiIsIkRmIiwiSyIsIkFmIiwieGUiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJhYm9ydCIsIlBmIiwiWnIiLCJYZSIsImNhIiwiS2kiLCJQcm94eSIsIlhyIiwiaW8iLCJxYyIsInhmIiwiRmIiLCJubiIsImpmIiwiQSIsImoiLCJ4IiwiVXMiLCJ5IiwiV2kiLCJmciIsImp0IiwiR3MiLCJZeSIsInpzIiwiS2UiLCJZaSIsIndoaWxlIiwiYm9keSIsInN0ZXAiLCJCcyIsIlF5IiwiTGYiLCJKaSIsIlp5IiwieGIiLCJUIiwiSGkiLCJWcyIsInJuIiwib2UiLCJ0byIsIlh5IiwiZWIiLCJHaSIsInRiIiwiZ2V0RmliZXJSZWYiLCJ6YyIsInNjb3BlIiwiaHIiLCJLcyIsIm5iIiwicmIiLCJzYiIsImNiIiwiYmluZCIsImliIiwiUWkiLCJwcmlvcml0eSIsIk9iIiwicWYiLCJaaSIsIlVmIiwiemYiLCJlcyIsImludGVycnVwdEFzRm9yayIsImF3YWl0Iiwib2IiLCJzeXNsb2ciLCJsYWJlbCIsIm9yZGluYWwiLCJNSU5fU0FGRV9JTlRFR0VSIiwiYWIiLCJ1YiIsImxiIiwiQmYiLCJWZiIsImZiIiwiaGIiLCJkYiIsImdiIiwibWIiLCJYaSIsIldzIiwiaWEiLCJwYiIsInNldEZpYmVyUmVmIiwiX2IiLCJnZSIsInluIiwiZm9yayIsInliIiwiYmIiLCJLZiIsImluaXRpYWwiLCJTYiIsInJ0IiwiZHIiLCJXZiIsImtiIiwidmIiLCJ3YiIsIiRiIiwiRWIiLCJJYiIsIlVjIiwiSXIiLCJvYSIsImFhIiwiSmYiLCJhZGRGaW5hbGl6ZXIiLCJ0cyIsIkJjIiwiY2xvc2UiLCJKcyIsIkhmIiwiR2YiLCJ1YSIsIlJiIiwiTWIiLCJsYSIsIkhzIiwiZmEiLCJNRSIsIlRFIiwiVGIiLCJoYyIsIk5uIiwiTmIiLCJwYXJhbGxlbCIsIkZuIiwiaGEiLCJDYiIsImRjIiwiVmMiLCJOZSIsIkNFIiwibm8iLCJORSIsIllmIiwic3RhdGUiLCJybyIsImJsb2NraW5nT24iLCJBYiIsIlBiIiwiRGIiLCJZcyIsImpiIiwiQUUiLCJQRSIsIkxiIiwiUWYiLCJpbmRleE9mIiwicWIiLCJjdXJyZW50Q29udGV4dCIsIlpmIiwiYm4iLCJzbyIsImNvIiwiVWIiLCJjdXJyZW50U3BhbiIsImRhIiwiemIiLCJvbyIsImJ1Y2tldEl0ZXJhdG9yIiwicmVmZXJlbnRpYWxJdGVyYXRvciIsIkJiIiwiYnVja2V0cyIsInJlZmVyZW50aWFsIiwiY3VycmVudEJ1Y2tldCIsIlZiIiwiYnVja2V0c1NpemUiLCJvdCIsIktiIiwiT24iLCIkbiIsIldiIiwiSmIiLCJnYSIsIlFzIiwiSGIiLCJtYSIsInVuc2FmZVNjaGVkdWxlIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInBhIiwicGVyZm9ybWFuY2UiLCJ0aW1lT3JpZ2luIiwiR2IiLCJwcm9jZXNzIiwiYmlnaW50IiwiaXUiLCJZYiIsInVuc2FmZUN1cnJlbnRUaW1lTWlsbGlzIiwidW5zYWZlQ3VycmVudFRpbWVOYW5vcyIsInNjaGVkdWxlciIsInNsZWVwIiwiUWIiLCJYZiIsImVoIiwidGgiLCJuaCIsInJoIiwic2giLCJaYiIsIl9hIiwiU24iLCJjaCIsImloIiwiWGIiLCJwYXRoRGVsaW0iLCJwYXRoIiwiJHQiLCJlUyIsInRTIiwidXQiLCJuUyIsImdjIiwiclMiLCJzUyIsImNTIiwiaVMiLCJvUyIsImFTIiwidVMiLCJsUyIsImZTIiwiaFMiLCJkUyIsIm5zIiwiZ1MiLCJ5YSIsIm1TIiwicFMiLCJiYSIsIl9TIiwieVMiLCJsb2FkIiwiZW51bWVyYXRlQ2hpbGRyZW4iLCJiUyIsIl9lIiwiZmxhdHRlbmVkIiwiU1MiLCJzZXFEZWxpbSIsImVudiIsIiRTIiwidG9VcHBlckNhc2UiLCJmaWx0ZXIiLCJmbGF0TWFwIiwia1MiLCJ2UyIsImNvbmZpZyIsImNvbmRpdGlvbiIsIm9yaWdpbmFsIiwibWFwT3JGYWlsIiwiZGVzY3JpcHRpb24iLCJJUyIsInZhbHVlQ29uZmlnIiwiRVMiLCJ3UyIsInppcCIsIk9TIiwiUmVnRXhwIiwicGFyc2UiLCJ0cmltIiwiUlMiLCJGUyIsIk1TIiwicGFyc2VJbnQiLCJTYSIsIm9oIiwiVFMiLCJhc3NlcnQiLCJjb25zb2xlIiwiY2xlYXIiLCJjb3VudCIsImNvdW50UmVzZXQiLCJkZWJ1ZyIsImRpciIsImRpcnhtbCIsImdyb3VwIiwiY29sbGFwc2VkIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImluZm8iLCJsb2ciLCJ0YWJsZSIsInRpbWUiLCJ0aW1lRW5kIiwidGltZUxvZyIsInRyYWNlIiwid2FybiIsInVuc2FmZSIsIkNTIiwia2EiLCJOUyIsIm91IiwiQVMiLCJQUk5HIiwibmV4dEJvb2xlYW4iLCJuZXh0SW50IiwibmV4dFJhbmdlIiwibmV4dEludEJldHdlZW4iLCJzaHVmZmxlIiwiUFMiLCJzZWVkIiwieFMiLCJqUyIsInZhIiwiTFMiLCJhaCIsInVoIiwid2EiLCJjaGFyQXQiLCJEUyIsImVuZCIsInN0YXR1cyIsImVuZFRpbWUiLCJleGl0Iiwic3RhcnRUaW1lIiwiYXR0cmlidXRlIiwiYXR0cmlidXRlcyIsImV2ZW50IiwiZXZlbnRzIiwiYWRkTGlua3MiLCJsaW5rcyIsImtpbmQiLCJ0cmFjZUlkIiwic3BhbklkIiwicVMiLCJVUyIsInJzIiwielMiLCJsaCIsIkJTIiwiY3VycmVudERlZmF1bHRTZXJ2aWNlcyIsIlZTIiwiY3VycmVudFRpbWVNaWxsaXMiLCJLUyIsIldTIiwiSlMiLCJldCIsIkhTIiwiT2EiLCJhdSIsImxvY2FscyIsIkdTIiwiWVMiLCJRUyIsImZoIiwiaGgiLCJaUyIsIktuIiwiS2MiLCJmaWJlclJlZiIsIldjIiwiWFMiLCJmb3JrQXMiLCJlMCIsInQwIiwibjAiLCJyMCIsInMwIiwiYzAiLCJpMCIsIm8wIiwiYTAiLCJ1MCIsImwwIiwiZjAiLCJoMCIsImQwIiwiZGgiLCJnMCIsIm0wIiwicDAiLCJhbyIsInNzIiwiZ2giLCJtaCIsInV1IiwibHUiLCJmdSIsIl8wIiwicmVmIiwicGgiLCJKYyIsIm10IiwiY3MiLCJ5MCIsIiRhIiwiX2giLCJ5aCIsImJoIiwiU2giLCJraCIsImIwIiwidmgiLCJtYyIsIndoIiwiT2giLCJIYyIsImh1IiwiUzAiLCJfaGFzaCIsInYwIiwiazAiLCJ3MCIsIk8wIiwiJDAiLCJBMCIsIkkwIiwiRTAiLCIkaCIsImdldEZpYmVyUmVmcyIsIkYwIiwiRWEiLCJSMCIsIk0wIiwiajAiLCJUMCIsIkVoIiwiQzAiLCJOMCIsIlAwIiwieDAiLCJzZXRGaWJlclJlZnMiLCJMMCIsIkQwIiwiSWgiLCJGaCIsInEwIiwiWnMiLCJVMCIsInowIiwicGFyYWxsZWxpc20iLCJCMCIsIlYwIiwiR2MiLCJZYyIsIlFjIiwiV24iLCJKbiIsIlhzIiwiRXQiLCJpcyIsIklhIiwiRmEiLCJLMCIsImR1IiwiVzAiLCJ1byIsImd1IiwiSjAiLCJydW50aW1lRmxhZ3MiLCJtdSIsIkgwIiwiRzAiLCJZMCIsIlEwIiwiWjAiLCJYMCIsIlJoIiwiZWsiLCJ0ayIsIm5rIiwib3MiLCJSYSIsInJrIiwicHUiLCJNaCIsInRyYWNlcyIsInNrIiwiY2siLCJpayIsIm9rIiwiYWsiLCJNYSIsInVrIiwiX3UiLCJsayIsImdldFJlZiIsImFkZE9ic2VydmVyIiwiX2V4aXQiLCJfb2JzZXJ2ZXJzIiwidW5zYWZlSW50ZXJydXB0IiwiX2ludGVycnVwdGVkIiwiaW50ZXJydXB0aWJsZSIsImV2YWx1YXRlIiwibW8iLCJ1bnNhZmVQb2xsIiwiX3lpZWxkZWQiLCJydW5Mb29wIiwiRnIiLCJUYSIsImludGVycnVwdENoaWxkcmVuIiwidXMiLCJjdXJyZW50T3BDb3VudCIsInBvIiwic2hvdWxkWWllbGQiLCJtayIsIlpjIiwiWGMiLCJnZXRDb250IiwiX3N0YWNrIiwiYXMiLCJ5aWVsZFdpdGgiLCJfY2hpbGRyZW4iLCJTZXQiLCJUaCIsIlkiLCJzbiIsInF0IiwiZmsiLCJoayIsImFyZ3MiLCJkayIsImVjIiwiZXZhbCIsImNvbnRBIiwiY29udEUiLCJlbnN1cmUiLCJsbyIsInNpbmdsZSIsIkNoIiwicHJvcCIsInlrIiwiZm8iLCJOaCIsImdrIiwic2NoZWR1bGVUYXNrIiwiYmsiLCJwayIsImhvIiwiX2siLCJBaCIsImdvIiwiU2siLCJzZXRJbW1lZGlhdGUiLCJQaCIsInRhc2tzIiwicnVubmluZyIsImFmdGVyU2NoZWR1bGVkIiwicnVuVGFza3MiLCJ3ayIsImZsdXNoIiwia2siLCJFayIsInZrIiwiT2siLCIkayIsIkZrIiwieGgiLCJJayIsIlJrIiwiamgiLCJNayIsInN0YXJ2ZUludGVybmFsIiwic3RhcnZlIiwibWF4TmV4dFRpY2tCZWZvcmVUaW1lciIsIlByb21pc2UiLCJyZXNvbHZlIiwiTGgiLCJUayIsImRlZmVycmVkIiwiX28iLCJEaCIsIkNhIiwieW8iLCJibyIsIlNvIiwia28iLCJwYyIsImpyIiwib25GaWJlciIsIkN0IiwiQ2siLCJOayIsImxzIiwieXUiLCJBayIsInJvb3RzIiwiYnUiLCJQayIsInRlbGwiLCJhZGRDaGlsZCIsInJlbW92ZUNoaWxkIiwieGsiLCJ0YyIsImprIiwiTGsiLCJEayIsInFrIiwiVWsiLCJ4RSIsImpFIiwiaW5oZXJpdEFsbCIsImZzIiwiY3QiLCJ6ayIsIkJrIiwiVmsiLCJfTWVzc2FnZSIsIl9PdXRwdXQiLCJ2byIsIktrIiwiV2siLCJhbm5vdGF0aW9ucyIsImRhdGUiLCJsb2dMZXZlbCIsInNwYW5zIiwiZ2V0VGltZSIsIkprIiwiSGsiLCJHayIsInN0ZG91dCIsImlzVFRZIiwicWgiLCJlaSIsIlN1IiwiWWsiLCJRayIsIlprIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJYayIsInN0YXJ0IiwiZmFjdG9yIiwiZXYiLCJVaCIsInpoIiwidGkiLCJ0diIsIm52IiwicnYiLCJzdiIsIkJoIiwibmkiLCJjdiIsIml2IiwiVmgiLCJfT3V0Iiwia3UiLCJ2dSIsIm92IiwiS2giLCJpbmNyZW1lbnRhbCIsInd1IiwiT3UiLCJhdiIsIldoIiwiYm91bmRhcmllcyIsInV2IiwibHYiLCJmdiIsImh2IiwiZHYiLCJndiIsIkpoIiwibXYiLCJfVHlwZSIsInB2IiwiJHUiLCJ3byIsIl92Iiwia2V5VHlwZSIsInRhZ3MiLCJ5diIsImJ2IiwiU3YiLCJrdiIsImdyIiwiSGgiLCJyaSIsIkdoIiwic2kiLCJZaCIsImNpIiwiUWgiLCJpaSIsIlpoIiwib2kiLCJtciIsIkV1IiwiSXUiLCJ2diIsIk52Iiwid3YiLCJGdSIsIlJ1IiwiT3YiLCJvY2N1cnJlbmNlcyIsIkF2IiwiTXUiLCJUdSIsIiR2IiwiUHYiLCJDdSIsIk51IiwiRXYiLCJzdW0iLCJ4diIsIkF1IiwiUHUiLCJJdiIsInF1YW50aWxlcyIsImp2IiwiRnYiLCJSdiIsIk12IiwiVHYiLCJDdiIsIkx2IiwiRHYiLCJxdiIsInByIiwiTmEiLCJVdiIsInp2IiwicHJlcmVnaXN0ZXJlZFdvcmRzIiwiQnYiLCJWdiIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiTUFYX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiS3YiLCJtYXhBZ2UiLCJtYXhTaXplIiwiSWUiLCJEZSIsIld2IiwiQWEiLCJjb25zdW1lZCIsInJlc3QiLCJxdWFudGlsZSIsIk10IiwicWUiLCJrciIsIkp2IiwiSHYiLCJHdiIsIll2IiwibWV0cmljS2V5IiwibWV0cmljU3RhdGUiLCJRdiIsIlBhIiwieHUiLCJadiIsInNuYXBzaG90IiwiZ2V0Q291bnRlciIsImdldEdhdWdlIiwiZ2V0RnJlcXVlbmN5IiwiZ2V0SGlzdG9ncmFtIiwiZ2V0U3VtbWFyeSIsIlh2IiwiZXciLCJ0dyIsIm53IiwieGEiLCJYaCIsIml3IiwidW5zYWZlVXBkYXRlIiwidW5zYWZlVmFsdWUiLCJ1bnNhZmVNb2RpZnkiLCJyZWdpc3RlciIsIm5jIiwiZWQiLCJydyIsInN3IiwiY3ciLCJvdyIsImNvbXBsZXRlZCIsInJlc3VsdCIsImF3IiwicmMiLCJPbyIsIl9UIiwianUiLCJNbyIsInZhbHVlMCIsIm9uU3RhcnQiLCJ1bmRlcmx5aW5nIiwib25FbmQiLCJvbkVmZmVjdCIsIm9uU3VzcGVuZCIsIm9uUmVzdW1lIiwiZHMiLCJocyIsIkx1IiwiVG8iLCJ0ZCIsIkR1IiwidXciLCJvblJ1biIsImx3Iiwic2MiLCJmdyIsIm5kIiwicmQiLCJzZCIsImNkIiwiQW4iLCJMciIsImh3IiwiZHciLCJzdXBlcnZpc29yIiwiYWkiLCJncyIsImd3IiwibXciLCJwdyIsImphIiwiX3ciLCJ5dyIsImJ3IiwiRW4iLCJTdyIsIkxhIiwia3ciLCJSciIsInplIiwiQmUiLCJjdXJyZW50T3AiLCJJbiIsIk9uU3RlcCIsInBhdGNoUnVudGltZUZsYWdzIiwiY3VycmVudFJ1bnRpbWVGbGFncyIsImlzSW50ZXJydXB0ZWQiLCJnZXRJbnRlcnJ1cHRlZENhdXNlIiwicHVzaFN0YWNrIiwidnciLCJwcm9jZXNzTmV3SW50ZXJydXB0U2lnbmFsIiwid3ciLCJwdCIsInJlcXVlc3QiLCJmbGF0IiwiSnciLCJydW5BbGwiLCJsaXN0ZW5lcnMiLCJpbnRlcnJ1cHRlZCIsIk93IiwicXUiLCJVdSIsIl9maWJlcklkIiwicmVzdW1lIiwiYXNrIiwiZ2V0Q2hpbGRyZW4iLCJfcXVldWUiLCJfcnVubmluZyIsImRyYWluUXVldWVMYXRlck9uRXhlY3V0b3IiLCJfZXhpdFZhbHVlIiwicmVtb3ZlT2JzZXJ2ZXIiLCJ6YSIsInBvbGwiLCJ1bnNhZmVJbnRlcnJ1cHRBc0ZvcmsiLCJfZmliZXJSZWZzIiwidW5zYWZlRGVsZXRlRmliZXJSZWYiLCJyZWZyZXNoUmVmQ2FjaGUiLCJjdXJyZW50VHJhY2VyIiwiY3VycmVudFN1cGVydmlzb3IiLCJWdyIsImN1cnJlbnRTY2hlZHVsZXIiLCJ0cmFuc2ZlckNoaWxkcmVuIiwiZHJhaW5RdWV1ZU9uQ3VycmVudFRocmVhZCIsImV2YWx1YXRlTWVzc2FnZVdoaWxlU3VzcGVuZGVkIiwicnVuIiwiZHJhaW5RdWV1ZVdoaWxlUnVubmluZyIsImFkZEludGVycnVwdGVkQ2F1c2UiLCJzZW5kSW50ZXJydXB0U2lnbmFsVG9BbGxDaGlsZHJlbiIsImludGVycnVwdEFsbENoaWxkcmVuIiwicmVwb3J0RXhpdFZhbHVlIiwic2V0RXhpdFZhbHVlIiwiZ2V0TG9nZ2VycyIsIlJ3IiwiJHciLCJfYXN5bmNJbnRlcnJ1cHRvciIsIl9hc3luY0Jsb2NraW5nT24iLCJldmFsdWF0ZUVmZmVjdCIsInN0YXJ0Rm9yayIsImluaXRpYXRlQXN5bmMiLCJfc3RlcHMiLCJyZWZzIiwiZmxhZ3MiLCJwb3BTdGFjayIsImdldE5leHRTdWNjZXNzQ29udCIsImdldE5leHRGYWlsQ29udCIsIkxlZnQiLCJOb25lIiwiUmlnaHQiLCJTb21lIiwiTWljcm8iLCJCbG9ja2VkIiwiJG8iLCJSdW5CbG9ja2VkIiwiX2lzWWllbGRpbmciLCJFdyIsIkl3IiwiRnciLCJNdyIsIlR3IiwiZmQiLCJIbiIsIkN3IiwiTnciLCJjbiIsImNvbmN1cnJlbmN5IiwiYmF0Y2hpbmciLCJjb25jdXJyZW50RmluYWxpemVycyIsImRpc2NhcmQiLCJBdyIsIm9kIiwibW9kZSIsIk50IiwidWkiLCJhZCIsImNlIiwiaGUiLCJGZSIsInJlIiwiUHciLCJVZSIsInZyIiwibWUiLCJzdCIsIndyIiwiUmUiLCJrbiIsIkNvIiwiQWQiLCJ2biIsInh3IiwidWQiLCJtcyIsIkRhIiwiUnQiLCJzdHJhdGVneSIsInlyIiwicWEiLCJVYSIsImp3IiwibGQiLCJFbyIsIkx3IiwiX3IiLCJEdyIsImNvbmN1cnJlbnQiLCJxdyIsIlV3IiwiZmluYWxpemVycyIsInp3IiwiaGQiLCJCdyIsImRkIiwiV3ciLCJvblNlbGZXaW4iLCJvblNlbGZEb25lIiwib25PdGhlcldpbiIsIm9uT3RoZXJEb25lIiwiS3ciLCJzZWxmU2NvcGUiLCJvdGhlclNjb3BlIiwiQmEiLCJIdyIsInBzIiwiZ2QiLCJzdGFydE1pbGxpcyIsImVuZE1pbGxpcyIsIm1kIiwiR3ciLCJZdyIsIlF3IiwiWnciLCJYdyIsInBkIiwiZU8iLCJ0TyIsIm5PIiwick8iLCJzTyIsIlZhIiwiX2QiLCJpbnRlcnZhbHMiLCJjTyIsImlPIiwibGkiLCJvTyIsImFPIiwidU8iLCJsTyIsImZPIiwiaE8iLCJLYSIsImRPIiwiZ08iLCJJbyIsInlkIiwibU8iLCJwTyIsIl9PIiwieU8iLCJiTyIsIlNPIiwia08iLCJHbiIsIldhIiwiX3MiLCJMRSIsIkRFIiwidk8iLCJxRSIsIndPIiwiVUUiLCJPTyIsImJkIiwiJE8iLCJFTyIsIklPIiwiRk8iLCJSTyIsInp1IiwiTU8iLCJCdSIsIlRPIiwibGFzdCIsInJlc2V0Iiwic2NoZWR1bGUiLCJiciIsIkNPIiwiRm8iLCJOTyIsIkFPIiwiUE8iLCJmaSIsInhPIiwiak8iLCJMTyIsIkRPIiwiQk8iLCJrZCIsInFPIiwiVU8iLCJ6TyIsIkRyIiwiVnUiLCJWTyIsIktPIiwiSmEiLCJXTyIsIkhhIiwiSE8iLCJKTyIsInRpbWVzIiwiU2QiLCJHTyIsImZyZWUiLCJwZXJtaXRzIiwidGFrZW4iLCJ3YWl0ZXJzIiwidXBkYXRlVGFrZW4iLCJ0YWtlIiwicmVsZWFzZSIsInZkIiwiWU8iLCJRTyIsIlpPIiwiWE8iLCJlJCIsIkt1IiwiV3UiLCJKdSIsIkh1IiwidCQiLCJtb2RpZnlFZmZlY3QiLCJ3aXRoTG9jayIsIm4kIiwid2QiLCJ3aXRoUGVybWl0cyIsInIkIiwicyQiLCJjJCIsImkkIiwibyQiLCJhJCIsInUkIiwibCQiLCJTciIsIlJvIiwidXBkYXRlUmVmcyIsImltbWVkaWF0ZSIsImYkIiwibSQiLCJPZCIsImgkIiwiZmliZXIiLCJkJCIsIl9jIiwiTXIiLCJHdSIsIll1IiwiZyQiLCIkZCIsInAkIiwiRWQiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJJZCIsIl8kIiwieSQiLCJiJCIsIm9uIiwiUyQiLCJrJCIsInYkIiwidyQiLCJPJCIsIiQkIiwiRmQiLCJFJCIsIl9SSW4iLCJfUk91dCIsImFuIiwiSSQiLCJ5YyIsIkYkIiwiQyQiLCJSJCIsIk0kIiwiX29wX2xheWVyIiwiUXUiLCJSZCIsImdldE9yRWxzZU1lbW9pemUiLCJUZCIsIlQkIiwiTWQiLCJOJCIsImxheWVyIiwiZmFpbHVyZUsiLCJzdWNjZXNzSyIsInppcEsiLCJBJCIsImNjIiwiUCQiLCJ4JCIsInokIiwiQ2QiLCJqJCIsIkwkIiwiRCQiLCJOZCIsInEkIiwiVSQiLCJHYSIsIllhIiwiQiQiLCJydW50aW1lRWZmZWN0IiwiekUiLCJCRSIsIlZFIiwiS0UiLCJXRSIsIkpFIiwiSEUiLCJHRSIsIllFIiwiUUUiLCJaRSIsIlhFIiwiZUkiLCJ0SSIsIm5JIiwickkiLCJzSSIsImNJIiwiaUkiLCJvSSIsImFJIiwidUkiLCJsSSIsImZJIiwiaEkiLCJRYSIsImRJIiwiZ0kiLCJtSSIsInBJIiwiX0kiLCJ5SSIsImJJIiwiU0kiLCJrSSIsInZJIiwid0kiLCJPSSIsIiRJIiwiRUkiLCJJSSIsIkZJIiwiUkkiLCJNSSIsIlRJIiwiQ0kiLCJOSSIsIkFJIiwiUEkiLCJ4SSIsImpJIiwiTEkiLCJESSIsInFJIiwiVUkiLCJ6SSIsIkJJIiwiVkkiLCJLSSIsIldJIiwiSkkiLCJISSIsIkdJIiwiWUkiLCJWJCIsIlJlZmxlY3QiLCJRSSIsImFjY2Vzc29ycyIsImRlcGVuZGVuY2llcyIsInNjb3BlZCIsInN5bmMiLCJzdWNjZWVkIiwiRGVmYXVsdFdpdGhvdXREZXBlbmRlbmNpZXMiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhQSIsImFCIiwiYUMiLCJhRCIsImFGIiwiYUciLCJhSCIsImFKIiwiYUsiLCJhTCIsImFNIiwiYU4iLCJhUCIsImFRIiwiYVIiLCJhVCIsImFVIiwiYVYiLCJhVyIsImFYIiwiYVkiLCJhWiIsImFqIiwiYXEiLCJheCIsImF6IiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYkEiLCJiQiIsImJDIiwiYkQiLCJiRiIsImJHIiwiYkgiLCJiSiIsImJLIiwiYkwiLCJiTSIsImJOIiwiYlAiLCJiUSIsImJSIiwiYlQiLCJiVSIsImJWIiwiYlciLCJiWCIsImJZIiwiYloiLCJiaiIsImJxIiwiYngiLCJieiIsImMxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsImM3IiwiYzgiLCJjOSIsImNBIiwiY0IiLCJjQyIsImNEIiwiY0YiLCJjRyIsImNIIiwiY2oiLCJjcSIsImN4IiwiY3oiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../medfetch/dist/Effect-D4rBamoz.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../medfetch/dist/Match-CtupVYsT.mjs":
/*!*******************************************!*\
  !*** ../medfetch/dist/Match-CtupVYsT.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   d: () => (/* binding */ R),\n/* harmony export */   e: () => (/* binding */ $),\n/* harmony export */   o: () => (/* binding */ W),\n/* harmony export */   v: () => (/* binding */ k),\n/* harmony export */   w: () => (/* binding */ x)\n/* harmony export */ });\n/* harmony import */ var _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Effect-D4rBamoz.mjs */ \"(app-pages-browser)/../medfetch/dist/Effect-D4rBamoz.mjs\");\n\nconst _ = /* @__PURE__ */ Symbol.for(\"@effect/matcher/Matcher\"), m = {\n    [_]: {\n        _input: _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.q,\n        _filters: _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.q,\n        _result: _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.q,\n        _return: _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.q\n    },\n    _tag: \"ValueMatcher\",\n    add (e) {\n        return this.value._tag === \"Right\" ? this : e._tag === \"When\" && e.guard(this.provided) === !0 ? u(this.provided, (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(e.evaluate(this.provided))) : e._tag === \"Not\" && e.guard(this.provided) === !1 ? u(this.provided, (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(e.evaluate(this.provided))) : this;\n    },\n    pipe () {\n        return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this, arguments);\n    }\n};\nfunction u(e, a) {\n    const t = Object.create(m);\n    return t.provided = e, t.value = a, t;\n}\nconst y = (e, a)=>({\n        _tag: \"When\",\n        guard: e,\n        evaluate: a\n    }), c = (e)=>{\n    if (typeof e == \"function\") return e;\n    if (Array.isArray(e)) {\n        const a = e.map(c), t = a.length;\n        return (r)=>{\n            if (!Array.isArray(r)) return !1;\n            for(let s = 0; s < t; s++)if (a[s](r[s]) === !1) return !1;\n            return !0;\n        };\n    } else if (e !== null && typeof e == \"object\") {\n        const a = Object.entries(e).map((param)=>{\n            let [r, s] = param;\n            return [\n                r,\n                c(s)\n            ];\n        }), t = a.length;\n        return (r)=>{\n            if (typeof r != \"object\" || r === null) return !1;\n            for(let s = 0; s < t; s++){\n                const [l, g] = a[s];\n                if (!(l in r) || g(r[l]) === !1) return !1;\n            }\n            return !0;\n        };\n    }\n    return (a)=>a === e;\n}, E = (e)=>u(e, (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(e)), b = (e, a)=>(t)=>t.add(y(c(e), a)), p = (e)=>e != null, w = (e)=>(a)=>{\n        const t = d(a);\n        return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(t) ? t._tag === \"Right\" ? t.right : e(t.left) : (r)=>{\n            const s = t(r);\n            return s._tag === \"Right\" ? s.right : e(s.left);\n        };\n    }, d = (e)=>{\n    if (e._tag === \"ValueMatcher\") return e.value;\n    const a = e.cases.length;\n    if (a === 1) {\n        const t = e.cases[0];\n        return (r)=>t._tag === \"When\" && t.guard(r) === !0 ? (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(t.evaluate(r)) : t._tag === \"Not\" && t.guard(r) === !1 ? (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(t.evaluate(r)) : (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(r);\n    }\n    return (t)=>{\n        for(let r = 0; r < a; r++){\n            const s = e.cases[r];\n            if (s._tag === \"When\" && s.guard(t) === !0) return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(s.evaluate(t));\n            if (s._tag === \"Not\" && s.guard(t) === !1) return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(s.evaluate(t));\n        }\n        return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(t);\n    };\n}, h = \"effect/Match/exhaustive: absurd\", A = (e)=>{\n    const a = d(e);\n    if ((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(a)) {\n        if (a._tag === \"Right\") return a.right;\n        throw new Error(h);\n    }\n    return (t)=>{\n        const r = a(t);\n        if (r._tag === \"Right\") return r.right;\n        throw new Error(h);\n    };\n}, k = E, x = b, R = p, W = w, $ = A;\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9tZWRmZXRjaC9kaXN0L01hdGNoLUN0dXBWWXNULm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEU7QUFDMUUsTUFBTU8sSUFBSSxhQUFhLEdBQUdDLE9BQU9DLEdBQUcsQ0FBQyw0QkFBNEJDLElBQUk7SUFDbkUsQ0FBQ0gsRUFBRSxFQUFFO1FBQ0hJLFFBQVFQLG1EQUFDQTtRQUNUUSxVQUFVUixtREFBQ0E7UUFDWFMsU0FBU1QsbURBQUNBO1FBQ1ZVLFNBQVNWLG1EQUFDQTtJQUNaO0lBQ0FXLE1BQU07SUFDTkMsS0FBSUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNILElBQUksS0FBSyxVQUFVLElBQUksR0FBR0UsRUFBRUYsSUFBSSxLQUFLLFVBQVVFLEVBQUVFLEtBQUssQ0FBQyxJQUFJLENBQUNDLFFBQVEsTUFBTSxDQUFDLElBQUlmLEVBQUUsSUFBSSxDQUFDZSxRQUFRLEVBQUVwQix1REFBQ0EsQ0FBQ2lCLEVBQUVJLFFBQVEsQ0FBQyxJQUFJLENBQUNELFFBQVEsTUFBTUgsRUFBRUYsSUFBSSxLQUFLLFNBQVNFLEVBQUVFLEtBQUssQ0FBQyxJQUFJLENBQUNDLFFBQVEsTUFBTSxDQUFDLElBQUlmLEVBQUUsSUFBSSxDQUFDZSxRQUFRLEVBQUVwQix1REFBQ0EsQ0FBQ2lCLEVBQUVJLFFBQVEsQ0FBQyxJQUFJLENBQUNELFFBQVEsTUFBTSxJQUFJO0lBQzdQO0lBQ0FFO1FBQ0UsT0FBT2hCLHVEQUFDQSxDQUFDLElBQUksRUFBRWlCO0lBQ2pCO0FBQ0Y7QUFDQSxTQUFTbEIsRUFBRVksQ0FBQyxFQUFFTyxDQUFDO0lBQ2IsTUFBTUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDakI7SUFDeEIsT0FBT2UsRUFBRUwsUUFBUSxHQUFHSCxHQUFHUSxFQUFFUCxLQUFLLEdBQUdNLEdBQUdDO0FBQ3RDO0FBQ0EsTUFBTUcsSUFBSSxDQUFDWCxHQUFHTyxJQUFPO1FBQ25CVCxNQUFNO1FBQ05JLE9B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SyxVQUFVb0IsRUFBRWhCLEtBQUssQ0FBQ00sT0FBTyxDQUFDLEdBQ3ZDLE9BQU96Qix1REFBQ0EsQ0FBQ21DLEVBQUVkLFFBQVEsQ0FBQ0k7WUFDdEIsSUFBSVUsRUFBRXBCLElBQUksS0FBSyxTQUFTb0IsRUFBRWhCLEtBQUssQ0FBQ00sT0FBTyxDQUFDLEdBQ3RDLE9BQU96Qix1REFBQ0EsQ0FBQ21DLEVBQUVkLFFBQVEsQ0FBQ0k7UUFDeEI7UUFDQSxPQUFPeEIsdURBQUNBLENBQUN3QjtJQUNYO0FBQ0YsR0FBR3NCLElBQUksbUNBQW1DQyxJQUFJLENBQUMvQjtJQUM3QyxNQUFNTyxJQUFJbUIsRUFBRTFCO0lBQ1osSUFBSWYsdURBQUNBLENBQUNzQixJQUFJO1FBQ1IsSUFBSUEsRUFBRVQsSUFBSSxLQUFLLFNBQ2IsT0FBT1MsRUFBRW9CLEtBQUs7UUFDaEIsTUFBTSxJQUFJSyxNQUFNRjtJQUNsQjtJQUNBLE9BQU8sQ0FBQ3RCO1FBQ04sTUFBTVMsSUFBSVYsRUFBRUM7UUFDWixJQUFJUyxFQUFFbkIsSUFBSSxLQUFLLFNBQ2IsT0FBT21CLEVBQUVVLEtBQUs7UUFDaEIsTUFBTSxJQUFJSyxNQUFNRjtJQUNsQjtBQUNGLEdBQUdHLElBQUlYLEdBQUdZLElBQUlYLEdBQUdZLElBQUlYLEdBQUdZLElBQUlYLEdBQUdZLElBQUlOO0FBT2pDIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL21lZGZldGNoL2Rpc3QvTWF0Y2gtQ3R1cFZZc1QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG4gYXMgbywgbyBhcyBmLCBxIGFzIGksIHUgYXMgbiwgdiB9IGZyb20gXCIuL0VmZmVjdC1ENHJCYW1vei5tanNcIjtcbmNvbnN0IF8gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcIkBlZmZlY3QvbWF0Y2hlci9NYXRjaGVyXCIpLCBtID0ge1xuICBbX106IHtcbiAgICBfaW5wdXQ6IGksXG4gICAgX2ZpbHRlcnM6IGksXG4gICAgX3Jlc3VsdDogaSxcbiAgICBfcmV0dXJuOiBpXG4gIH0sXG4gIF90YWc6IFwiVmFsdWVNYXRjaGVyXCIsXG4gIGFkZChlKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuX3RhZyA9PT0gXCJSaWdodFwiID8gdGhpcyA6IGUuX3RhZyA9PT0gXCJXaGVuXCIgJiYgZS5ndWFyZCh0aGlzLnByb3ZpZGVkKSA9PT0gITAgPyB1KHRoaXMucHJvdmlkZWQsIG4oZS5ldmFsdWF0ZSh0aGlzLnByb3ZpZGVkKSkpIDogZS5fdGFnID09PSBcIk5vdFwiICYmIGUuZ3VhcmQodGhpcy5wcm92aWRlZCkgPT09ICExID8gdSh0aGlzLnByb3ZpZGVkLCBuKGUuZXZhbHVhdGUodGhpcy5wcm92aWRlZCkpKSA6IHRoaXM7XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHYodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHUoZSwgYSkge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShtKTtcbiAgcmV0dXJuIHQucHJvdmlkZWQgPSBlLCB0LnZhbHVlID0gYSwgdDtcbn1cbmNvbnN0IHkgPSAoZSwgYSkgPT4gKHtcbiAgX3RhZzogXCJXaGVuXCIsXG4gIGd1YXJkOiBlLFxuICBldmFsdWF0ZTogYVxufSksIGMgPSAoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlO1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgIGNvbnN0IGEgPSBlLm1hcChjKSwgdCA9IGEubGVuZ3RoO1xuICAgIHJldHVybiAocikgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHQ7IHMrKylcbiAgICAgICAgaWYgKGFbc10ocltzXSkgPT09ICExKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGUgIT09IG51bGwgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IGEgPSBPYmplY3QuZW50cmllcyhlKS5tYXAoKFtyLCBzXSkgPT4gW3IsIGMocyldKSwgdCA9IGEubGVuZ3RoO1xuICAgIHJldHVybiAocikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByICE9IFwib2JqZWN0XCIgfHwgciA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0OyBzKyspIHtcbiAgICAgICAgY29uc3QgW2wsIGddID0gYVtzXTtcbiAgICAgICAgaWYgKCEobCBpbiByKSB8fCBnKHJbbF0pID09PSAhMSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKGEpID0+IGEgPT09IGU7XG59LCBFID0gKGUpID0+IHUoZSwgbyhlKSksIGIgPSAoZSwgYSkgPT4gKHQpID0+IHQuYWRkKHkoYyhlKSwgYSkpLCBwID0gKGUpID0+IGUgIT0gbnVsbCwgdyA9IChlKSA9PiAoYSkgPT4ge1xuICBjb25zdCB0ID0gZChhKTtcbiAgcmV0dXJuIGYodCkgPyB0Ll90YWcgPT09IFwiUmlnaHRcIiA/IHQucmlnaHQgOiBlKHQubGVmdCkgOiAocikgPT4ge1xuICAgIGNvbnN0IHMgPSB0KHIpO1xuICAgIHJldHVybiBzLl90YWcgPT09IFwiUmlnaHRcIiA/IHMucmlnaHQgOiBlKHMubGVmdCk7XG4gIH07XG59LCBkID0gKGUpID0+IHtcbiAgaWYgKGUuX3RhZyA9PT0gXCJWYWx1ZU1hdGNoZXJcIilcbiAgICByZXR1cm4gZS52YWx1ZTtcbiAgY29uc3QgYSA9IGUuY2FzZXMubGVuZ3RoO1xuICBpZiAoYSA9PT0gMSkge1xuICAgIGNvbnN0IHQgPSBlLmNhc2VzWzBdO1xuICAgIHJldHVybiAocikgPT4gdC5fdGFnID09PSBcIldoZW5cIiAmJiB0Lmd1YXJkKHIpID09PSAhMCA/IG4odC5ldmFsdWF0ZShyKSkgOiB0Ll90YWcgPT09IFwiTm90XCIgJiYgdC5ndWFyZChyKSA9PT0gITEgPyBuKHQuZXZhbHVhdGUocikpIDogbyhyKTtcbiAgfVxuICByZXR1cm4gKHQpID0+IHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGE7IHIrKykge1xuICAgICAgY29uc3QgcyA9IGUuY2FzZXNbcl07XG4gICAgICBpZiAocy5fdGFnID09PSBcIldoZW5cIiAmJiBzLmd1YXJkKHQpID09PSAhMClcbiAgICAgICAgcmV0dXJuIG4ocy5ldmFsdWF0ZSh0KSk7XG4gICAgICBpZiAocy5fdGFnID09PSBcIk5vdFwiICYmIHMuZ3VhcmQodCkgPT09ICExKVxuICAgICAgICByZXR1cm4gbihzLmV2YWx1YXRlKHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG8odCk7XG4gIH07XG59LCBoID0gXCJlZmZlY3QvTWF0Y2gvZXhoYXVzdGl2ZTogYWJzdXJkXCIsIEEgPSAoZSkgPT4ge1xuICBjb25zdCBhID0gZChlKTtcbiAgaWYgKGYoYSkpIHtcbiAgICBpZiAoYS5fdGFnID09PSBcIlJpZ2h0XCIpXG4gICAgICByZXR1cm4gYS5yaWdodDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoaCk7XG4gIH1cbiAgcmV0dXJuICh0KSA9PiB7XG4gICAgY29uc3QgciA9IGEodCk7XG4gICAgaWYgKHIuX3RhZyA9PT0gXCJSaWdodFwiKVxuICAgICAgcmV0dXJuIHIucmlnaHQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKGgpO1xuICB9O1xufSwgayA9IEUsIHggPSBiLCBSID0gcCwgVyA9IHcsICQgPSBBO1xuZXhwb3J0IHtcbiAgUiBhcyBkLFxuICAkIGFzIGUsXG4gIFcgYXMgbyxcbiAgayBhcyB2LFxuICB4IGFzIHdcbn07XG4iXSwibmFtZXMiOlsibiIsIm8iLCJmIiwicSIsImkiLCJ1IiwidiIsIl8iLCJTeW1ib2wiLCJmb3IiLCJtIiwiX2lucHV0IiwiX2ZpbHRlcnMiLCJfcmVzdWx0IiwiX3JldHVybiIsIl90YWciLCJhZGQiLCJlIiwidmFsdWUiLCJndWFyZCIsInByb3ZpZGVkIiwiZXZhbHVhdGUiLCJwaXBlIiwiYXJndW1lbnRzIiwiYSIsInQiLCJPYmplY3QiLCJjcmVhdGUiLCJ5IiwiYyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImxlbmd0aCIsInIiLCJzIiwiZW50cmllcyIsImwiLCJnIiwiRSIsImIiLCJwIiwidyIsImQiLCJyaWdodCIsImxlZnQiLCJjYXNlcyIsImgiLCJBIiwiRXJyb3IiLCJrIiwieCIsIlIiLCJXIiwiJCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../medfetch/dist/Match-CtupVYsT.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../medfetch/dist/sqlite-wasm/worker1.mjs":
/*!************************************************!*\
  !*** ../medfetch/dist/sqlite-wasm/worker1.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Effect-D4rBamoz.mjs */ \"(app-pages-browser)/../medfetch/dist/Effect-D4rBamoz.mjs\");\n/* harmony import */ var _Data_CYZAqtZB_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data-CYZAqtZB.mjs */ \"(app-pages-browser)/../medfetch/dist/Data-CYZAqtZB.mjs\");\n/* harmony import */ var _sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sqlite.org/sqlite-wasm */ \"(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/index.mjs\");\n/* harmony import */ var _Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Match-CtupVYsT.mjs */ \"(app-pages-browser)/../medfetch/dist/Match-CtupVYsT.mjs\");\n\n\n\n\nclass t extends (0,_Data_CYZAqtZB_mjs__WEBPACK_IMPORTED_MODULE_1__.T)(\"sqlite-wasm/worker1\") {\n}\nclass m extends (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.T)(\"Sqlite3InitModule\")() {\n}\nfunction S(o) {\n    return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({\n        try: ()=>o({\n                print: console.log,\n                printErr: console.error\n            }),\n        catch: (e)=>e instanceof Error ? new t({\n                operation: \"bootstrap\",\n                message: e.message,\n                errorName: e.name\n            }) : new t({\n                operation: \"bootstrap\",\n                message: \"Unknown error \".concat(e, \" thrown while loading the wasm module\")\n            })\n    });\n}\n_c = S;\nconst $ = m.pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(S), (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.t)((o)=>o.initWorker1API())), D = (o)=>$.pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(m, o)), I = (o)=>(0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({\n        try: async ()=>await import(// so esbuild, rollup, and webpack static\n            // analyzers do not fail at runtime\n            /* @vite-ignore */ /* webpackIgnore: true */ o),\n        catch: (e)=>e instanceof Error ? new t({\n                operation: \"load-module\",\n                message: \"That path doesn't exist \".concat(o),\n                errorName: \"NO_SUCH_PATH\"\n            }) : new t({\n                operation: \"load-module\",\n                message: \"Unknown error occurred while loading dynamic import\",\n                errorName: \"UNKNOWN\"\n            })\n    });\nfunction R(o) {\n    return I(o).pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.c)((e)=>(0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.l)(e.default, (s)=>typeof s < \"u\", ()=>new t({\n                operation: \"load-module\",\n                message: \"No default export found\",\n                errorName: \"NO_DEFAULT_EXPORT\"\n            })))).pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.c)((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.l)((e)=>typeof e == \"function\" && e.length > 0, (e)=>new t({\n            operation: \"load-module\",\n            message: \"Expected a function with 2 args as the default export but got \".concat(typeof e, \" with \").concat(e.length, \" args\"),\n            errorName: \"TYPE_MISMATCH_DEFAULT_EXPORT\"\n        }))));\n}\n_c1 = R;\nfunction W(o, e, s) {\n    return R(e).pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.c)((r)=>(0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({\n            try: ()=>r(o, s),\n            catch: (l)=>new t({\n                    operation: \"load-module\",\n                    message: \"Unknown error while wrapping user vtable module (\".concat((r.name, l), \")\"),\n                    errorName: \"UNKNOWN\"\n                })\n        })));\n}\n_c2 = W;\nfunction H(o, e) {\n    return (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.v)(o).pipe((0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"open\"\n    }, e.onOpen), (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"close\"\n    }, e.onClose), (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"exec\"\n    }, e.onExec), (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"export\"\n    }, e.onExport), (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"config-get\"\n    }, e.onConfigGet), (0,_Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.w)({\n        type: \"load-module\"\n    }, e.onLoadModule), _Match_CtupVYsT_mjs__WEBPACK_IMPORTED_MODULE_3__.e);\n}\n_c3 = H;\nfunction K(o) {\n    return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(postMessage(o));\n}\n_c4 = K;\nfunction j(o, e, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"load-module\";\n    return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.k)({\n        try: ()=>o.oo1.DB.checkRc(e, s),\n        catch: (l)=>l instanceof o.SQLite3Error ? l : new t({\n                operation: r,\n                errorName: \"UNKNOWN\",\n                message: \"better-worker1.main.checkRc: (rc=\".concat(s, \") unknown error thrown injecting the module:\")\n            })\n    });\n}\nfunction F(o) {\n    return (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(o.split(\"@\"), (e)=>e[e.length - 1], Number);\n}\n_c5 = F;\nconst G = (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(function*() {\n    const o = yield* m, e = yield* D(o), s = yield* (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(self.onmessage), r = (a)=>s.call(self, a);\n    return {\n        onMessage: (a)=>H(a.data, {\n                onOpen: ()=>r(a),\n                onClose: ()=>r(a),\n                onExec: ()=>r(a),\n                onConfigGet: ()=>r(a),\n                onExport: ()=>r(a),\n                /* custom event handlers starts here */ onLoadModule: async (param)=>{\n                    let { dbId: d, args: n, messageId: M } = param;\n                    return await (0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(function*() {\n                        var y;\n                        if (!d) return yield* new t({\n                            operation: \"load-module\",\n                            message: \"you have no database opened lol\",\n                            errorName: \"BAD_CALL\"\n                        });\n                        if (n === void 0) return yield* new t({\n                            operation: \"load-module\",\n                            message: '\"message.args\" can\\'t be undefined when invoking load-module',\n                            errorName: \"BAD_CALL\"\n                        });\n                        const w = F(d);\n                        e.wasm.allocPtr(1);\n                        const E = yield* W(e, n.moduleURL, {\n                            aux: n.aux,\n                            transfer: a.ports\n                        }), b = e.vtab.setupModule({\n                            methods: E\n                        });\n                        let u = 0, p = 0;\n                        try {\n                            if (n.pAuxBytes) {\n                                const k = n.pAuxBytes.byteLength;\n                                if (p = e.wasm.alloc(k), p === 0) throw u = -1, new Error();\n                                new DataView(e.wasm.heap8u().buffer, p, 4).setInt32(0, n.pAuxBytes.byteLength, !0), e.wasm.heap8u().set(n.pAuxBytes, p + 4);\n                            }\n                            u = e.capi.sqlite3_create_module(w, n.moduleName, b.pointer, p);\n                        } finally{\n                            if (u === -1) return yield* new t({\n                                message: \"better-worker1.worker1: stack can't handle \".concat((y = n.pAuxBytes) == null ? void 0 : y.byteLength, \" more bytes\"),\n                                errorName: \"NO_MEM\",\n                                operation: \"load-module\"\n                            });\n                        }\n                        return yield* j(e, w, u), yield* K({\n                            type: \"exec\",\n                            dbId: d,\n                            messageId: M,\n                            result: {\n                                operation: \"load-module\",\n                                rc: u,\n                                moduleName: n.moduleName\n                            }\n                        });\n                    }).pipe(_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.r);\n                }\n            })\n    };\n}), X = G.pipe((0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.t)((param)=>{\n    let { onMessage: o } = param;\n    self.onmessage = o;\n})), z = _sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n(0,_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(X, m, z).pipe(_Effect_D4rBamoz_mjs__WEBPACK_IMPORTED_MODULE_0__.j);\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"S\");\n$RefreshReg$(_c1, \"R\");\n$RefreshReg$(_c2, \"W\");\n$RefreshReg$(_c3, \"H\");\n$RefreshReg$(_c4, \"K\");\n$RefreshReg$(_c5, \"F\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9tZWRmZXRjaC9kaXN0L3NxbGl0ZS13YXNtL3dvcmtlcjEubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJJO0FBQzdGO0FBQ047QUFDdUI7QUFDL0QsTUFBTUcsVUFBVWtCLHFEQUFDQSxDQUFDO0FBQ2xCO0FBQ0EsTUFBTUYsVUFBVWxCLHVEQUFDQSxDQUNmO0FBRUY7QUFDQSxTQUFTMEIsRUFBRUMsQ0FBQztJQUNWLE9BQU90Qix1REFBQ0EsQ0FBQztRQUNQdUIsS0FBSyxJQUFNRCxFQUFFO2dCQUNYRSxPQUFPQyxRQUFRQyxHQUFHO2dCQUNsQkMsVUFBVUYsUUFBUUcsS0FBSztZQUN6QjtRQUNBQyxPQUFPLENBQUM5QixJQUFNQSxhQUFhK0IsUUFBUSxJQUFJakMsRUFBRTtnQkFDdkNrQyxXQUFXO2dCQUNYQyxTQUFTakMsRUFBRWlDLE9BQU87Z0JBQ2xCQyxXQUFXbEMsRUFBRW1DLElBQUk7WUFDbkIsS0FBSyxJQUFJckMsRUFBRTtnQkFDVGtDLFdBQVc7Z0JBQ1hDLFNBQVMsaUJBQW1CLE9BQUZqQyxHQUFFO1lBQzlCO0lBQ0Y7QUFDRjtLQWZTc0I7QUFnQlQsTUFBTWMsSUFBSXRCLEVBQUV1QixJQUFJLENBQ2R4Qyx1REFBQ0EsQ0FBQ3lCLElBQ0Z2Qix1REFBQ0EsQ0FBQyxDQUFDd0IsSUFBTUEsRUFBRWUsY0FBYyxNQUN4QkMsSUFBSSxDQUFDaEIsSUFBTWEsRUFBRUMsSUFBSSxDQUFDbEMsdURBQUNBLENBQUNXLEdBQUdTLEtBQUtpQixJQUFJLENBQUNqQixJQUFNdEIsdURBQUNBLENBQUM7UUFDMUN1QixLQUFLLFVBQVksTUFBTSxNQUFNLENBQzNCLHlDQUF5QztZQUN6QyxtQ0FBbUM7WUFDbkMsZ0JBQWdCLEdBQ2hCLHVCQUF1QixHQUN2QkQ7UUFFRk8sT0FBTyxDQUFDOUIsSUFBTUEsYUFBYStCLFFBQVEsSUFBSWpDLEVBQUU7Z0JBQ3ZDa0MsV0FBVztnQkFDWEMsU0FBUywyQkFBNkIsT0FBRlY7Z0JBQ3BD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QUFDQSxDQUFDO1FBQUMsRUFBRXFFLFdBQVc3QyxDQUFDLEVBQUU7SUFDakJ5QyxLQUFLQyxTQUFTLEdBQUcxQztBQUNuQixLQUNDaUYsSUFBSXZGLCtEQUFDQTtBQUNSZCx1REFBQ0EsQ0FDQ29HLEdBQ0F6RixHQUNBMEYsR0FDQW5FLElBQUksQ0FBQzlCLG1EQUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9tZWRmZXRjaC9kaXN0L3NxbGl0ZS13YXNtL3dvcmtlcjEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFQgYXMgQSwgYywgdCBhcyBOLCBlIGFzIGYsIGggYXMgeCwgbCBhcyBnLCBnIGFzIGgsIGogYXMgXywgZiBhcyBULCByIGFzIEwsIHAgYXMgUCwgayBhcyBPLCBtIGFzIFUgfSBmcm9tIFwiLi4vRWZmZWN0LUQ0ckJhbW96Lm1qc1wiO1xuaW1wb3J0IHsgVCBhcyBCIH0gZnJvbSBcIi4uL0RhdGEtQ1laQXF0WkIubWpzXCI7XG5pbXBvcnQgQyBmcm9tIFwiQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc21cIjtcbmltcG9ydCB7IHYgYXMgcSwgdyBhcyBpLCBlIGFzIHYgfSBmcm9tIFwiLi4vTWF0Y2gtQ3R1cFZZc1QubWpzXCI7XG5jbGFzcyB0IGV4dGVuZHMgQihcInNxbGl0ZS13YXNtL3dvcmtlcjFcIikge1xufVxuY2xhc3MgbSBleHRlbmRzIEEoXG4gIFwiU3FsaXRlM0luaXRNb2R1bGVcIlxuKSgpIHtcbn1cbmZ1bmN0aW9uIFMobykge1xuICByZXR1cm4gZih7XG4gICAgdHJ5OiAoKSA9PiBvKHtcbiAgICAgIHByaW50OiBjb25zb2xlLmxvZyxcbiAgICAgIHByaW50RXJyOiBjb25zb2xlLmVycm9yXG4gICAgfSksXG4gICAgY2F0Y2g6IChlKSA9PiBlIGluc3RhbmNlb2YgRXJyb3IgPyBuZXcgdCh7XG4gICAgICBvcGVyYXRpb246IFwiYm9vdHN0cmFwXCIsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBlcnJvck5hbWU6IGUubmFtZVxuICAgIH0pIDogbmV3IHQoe1xuICAgICAgb3BlcmF0aW9uOiBcImJvb3RzdHJhcFwiLFxuICAgICAgbWVzc2FnZTogYFVua25vd24gZXJyb3IgJHtlfSB0aHJvd24gd2hpbGUgbG9hZGluZyB0aGUgd2FzbSBtb2R1bGVgXG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCAkID0gbS5waXBlKFxuICBjKFMpLFxuICBOKChvKSA9PiBvLmluaXRXb3JrZXIxQVBJKCkpXG4pLCBEID0gKG8pID0+ICQucGlwZSh4KG0sIG8pKSwgSSA9IChvKSA9PiBmKHtcbiAgdHJ5OiBhc3luYyAoKSA9PiBhd2FpdCBpbXBvcnQoXG4gICAgLy8gc28gZXNidWlsZCwgcm9sbHVwLCBhbmQgd2VicGFjayBzdGF0aWNcbiAgICAvLyBhbmFseXplcnMgZG8gbm90IGZhaWwgYXQgcnVudGltZVxuICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICBvXG4gICksXG4gIGNhdGNoOiAoZSkgPT4gZSBpbnN0YW5jZW9mIEVycm9yID8gbmV3IHQoe1xuICAgIG9wZXJhdGlvbjogXCJsb2FkLW1vZHVsZVwiLFxuICAgIG1lc3NhZ2U6IGBUaGF0IHBhdGggZG9lc24ndCBleGlzdCAke299YCxcbiAgICBlcnJvck5hbWU6IFwiTk9fU1VDSF9QQVRIXCJcbiAgfSkgOiBuZXcgdCh7XG4gICAgb3BlcmF0aW9uOiBcImxvYWQtbW9kdWxlXCIsXG4gICAgbWVzc2FnZTogXCJVbmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgZHluYW1pYyBpbXBvcnRcIixcbiAgICBlcnJvck5hbWU6IFwiVU5LTk9XTlwiXG4gIH0pXG59KTtcbmZ1bmN0aW9uIFIobykge1xuICByZXR1cm4gSShvKS5waXBlKFxuICAgIGMoXG4gICAgICAoZSkgPT4gZyhcbiAgICAgICAgZS5kZWZhdWx0LFxuICAgICAgICAocykgPT4gdHlwZW9mIHMgPCBcInVcIixcbiAgICAgICAgKCkgPT4gbmV3IHQoe1xuICAgICAgICAgIG9wZXJhdGlvbjogXCJsb2FkLW1vZHVsZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gZGVmYXVsdCBleHBvcnQgZm91bmRcIixcbiAgICAgICAgICBlcnJvck5hbWU6IFwiTk9fREVGQVVMVF9FWFBPUlRcIlxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcbiAgKS5waXBlKFxuICAgIGMoXG4gICAgICBnKFxuICAgICAgICAoZSkgPT4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIGUubGVuZ3RoID4gMCxcbiAgICAgICAgKGUpID0+IG5ldyB0KHtcbiAgICAgICAgICBvcGVyYXRpb246IFwibG9hZC1tb2R1bGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgYSBmdW5jdGlvbiB3aXRoIDIgYXJncyBhcyB0aGUgZGVmYXVsdCBleHBvcnQgYnV0IGdvdCAke3R5cGVvZiBlfSB3aXRoICR7ZS5sZW5ndGh9IGFyZ3NgLFxuICAgICAgICAgIGVycm9yTmFtZTogXCJUWVBFX01JU01BVENIX0RFRkFVTFRfRVhQT1JUXCJcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBXKG8sIGUsIHMpIHtcbiAgcmV0dXJuIFIoZSkucGlwZShcbiAgICBjKFxuICAgICAgKHIpID0+IGYoe1xuICAgICAgICB0cnk6ICgpID0+IHIobywgcyksXG4gICAgICAgIGNhdGNoOiAobCkgPT4gbmV3IHQoe1xuICAgICAgICAgIG9wZXJhdGlvbjogXCJsb2FkLW1vZHVsZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbmtub3duIGVycm9yIHdoaWxlIHdyYXBwaW5nIHVzZXIgdnRhYmxlIG1vZHVsZSAoJHtyLm5hbWUsIGx9KWAsXG4gICAgICAgICAgZXJyb3JOYW1lOiBcIlVOS05PV05cIlxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBIKG8sIGUpIHtcbiAgcmV0dXJuIHEobykucGlwZShcbiAgICBpKHsgdHlwZTogXCJvcGVuXCIgfSwgZS5vbk9wZW4pLFxuICAgIGkoeyB0eXBlOiBcImNsb3NlXCIgfSwgZS5vbkNsb3NlKSxcbiAgICBpKHsgdHlwZTogXCJleGVjXCIgfSwgZS5vbkV4ZWMpLFxuICAgIGkoeyB0eXBlOiBcImV4cG9ydFwiIH0sIGUub25FeHBvcnQpLFxuICAgIGkoeyB0eXBlOiBcImNvbmZpZy1nZXRcIiB9LCBlLm9uQ29uZmlnR2V0KSxcbiAgICBpKHsgdHlwZTogXCJsb2FkLW1vZHVsZVwiIH0sIGUub25Mb2FkTW9kdWxlKSxcbiAgICB2XG4gICk7XG59XG5mdW5jdGlvbiBLKG8pIHtcbiAgcmV0dXJuIFUocG9zdE1lc3NhZ2UobykpO1xufVxuZnVuY3Rpb24gaihvLCBlLCBzLCByID0gXCJsb2FkLW1vZHVsZVwiKSB7XG4gIHJldHVybiBPKHtcbiAgICB0cnk6ICgpID0+IG8ub28xLkRCLmNoZWNrUmMoZSwgcyksXG4gICAgY2F0Y2g6IChsKSA9PiBsIGluc3RhbmNlb2Ygby5TUUxpdGUzRXJyb3IgPyBsIDogbmV3IHQoe1xuICAgICAgb3BlcmF0aW9uOiByLFxuICAgICAgZXJyb3JOYW1lOiBcIlVOS05PV05cIixcbiAgICAgIG1lc3NhZ2U6IGBiZXR0ZXItd29ya2VyMS5tYWluLmNoZWNrUmM6IChyYz0ke3N9KSB1bmtub3duIGVycm9yIHRocm93biBpbmplY3RpbmcgdGhlIG1vZHVsZTpgXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBGKG8pIHtcbiAgcmV0dXJuIFAoby5zcGxpdChcIkBcIiksIChlKSA9PiBlW2UubGVuZ3RoIC0gMV0sIE51bWJlcik7XG59XG5jb25zdCBHID0gaChmdW5jdGlvbiogKCkge1xuICBjb25zdCBvID0geWllbGQqIG0sIGUgPSB5aWVsZCogRChvKSwgcyA9IHlpZWxkKiBUKHNlbGYub25tZXNzYWdlKSwgciA9IChhKSA9PiBzLmNhbGwoc2VsZiwgYSk7XG4gIHJldHVybiB7IG9uTWVzc2FnZTogKGEpID0+IEgoYS5kYXRhLCB7XG4gICAgb25PcGVuOiAoKSA9PiByKGEpLFxuICAgIG9uQ2xvc2U6ICgpID0+IHIoYSksXG4gICAgb25FeGVjOiAoKSA9PiByKGEpLFxuICAgIG9uQ29uZmlnR2V0OiAoKSA9PiByKGEpLFxuICAgIG9uRXhwb3J0OiAoKSA9PiByKGEpLFxuICAgIC8qIGN1c3RvbSBldmVudCBoYW5kbGVycyBzdGFydHMgaGVyZSAqL1xuICAgIG9uTG9hZE1vZHVsZTogYXN5bmMgKHsgZGJJZDogZCwgYXJnczogbiwgbWVzc2FnZUlkOiBNIH0pID0+IGF3YWl0IGgoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB5O1xuICAgICAgaWYgKCFkKVxuICAgICAgICByZXR1cm4geWllbGQqIG5ldyB0KHtcbiAgICAgICAgICBvcGVyYXRpb246IFwibG9hZC1tb2R1bGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBcInlvdSBoYXZlIG5vIGRhdGFiYXNlIG9wZW5lZCBsb2xcIixcbiAgICAgICAgICBlcnJvck5hbWU6IFwiQkFEX0NBTExcIlxuICAgICAgICB9KTtcbiAgICAgIGlmIChuID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiB5aWVsZCogbmV3IHQoe1xuICAgICAgICAgIG9wZXJhdGlvbjogXCJsb2FkLW1vZHVsZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBcIm1lc3NhZ2UuYXJnc1wiIGNhbid0IGJlIHVuZGVmaW5lZCB3aGVuIGludm9raW5nIGxvYWQtbW9kdWxlYCxcbiAgICAgICAgICBlcnJvck5hbWU6IFwiQkFEX0NBTExcIlxuICAgICAgICB9KTtcbiAgICAgIGNvbnN0IHcgPSBGKGQpO1xuICAgICAgZS53YXNtLmFsbG9jUHRyKDEpO1xuICAgICAgY29uc3QgRSA9IHlpZWxkKiBXKFxuICAgICAgICBlLFxuICAgICAgICBuLm1vZHVsZVVSTCxcbiAgICAgICAge1xuICAgICAgICAgIGF1eDogbi5hdXgsXG4gICAgICAgICAgdHJhbnNmZXI6IGEucG9ydHNcbiAgICAgICAgfVxuICAgICAgKSwgYiA9IGUudnRhYi5zZXR1cE1vZHVsZSh7XG4gICAgICAgIG1ldGhvZHM6IEVcbiAgICAgIH0pO1xuICAgICAgbGV0IHUgPSAwLCBwID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuLnBBdXhCeXRlcykge1xuICAgICAgICAgIGNvbnN0IGsgPSBuLnBBdXhCeXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmIChwID0gZS53YXNtLmFsbG9jKGspLCBwID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgdSA9IC0xLCBuZXcgRXJyb3IoKTtcbiAgICAgICAgICBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICBlLndhc20uaGVhcDh1KCkuYnVmZmVyLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIDRcbiAgICAgICAgICApLnNldEludDMyKDAsIG4ucEF1eEJ5dGVzLmJ5dGVMZW5ndGgsICEwKSwgZS53YXNtLmhlYXA4dSgpLnNldChuLnBBdXhCeXRlcywgcCArIDQpO1xuICAgICAgICB9XG4gICAgICAgIHUgPSBlLmNhcGkuc3FsaXRlM19jcmVhdGVfbW9kdWxlKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgbi5tb2R1bGVOYW1lLFxuICAgICAgICAgIGIucG9pbnRlcixcbiAgICAgICAgICBwXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodSA9PT0gLTEpXG4gICAgICAgICAgcmV0dXJuIHlpZWxkKiBuZXcgdCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgYmV0dGVyLXdvcmtlcjEud29ya2VyMTogc3RhY2sgY2FuJ3QgaGFuZGxlICR7KHkgPSBuLnBBdXhCeXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHkuYnl0ZUxlbmd0aH0gbW9yZSBieXRlc2AsXG4gICAgICAgICAgICBlcnJvck5hbWU6IFwiTk9fTUVNXCIsXG4gICAgICAgICAgICBvcGVyYXRpb246IFwibG9hZC1tb2R1bGVcIlxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkKiBqKGUsIHcsIHUpLCB5aWVsZCogSyh7XG4gICAgICAgIHR5cGU6IFwiZXhlY1wiLFxuICAgICAgICBkYklkOiBkLFxuICAgICAgICBtZXNzYWdlSWQ6IE0sXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIG9wZXJhdGlvbjogXCJsb2FkLW1vZHVsZVwiLFxuICAgICAgICAgIHJjOiB1LFxuICAgICAgICAgIG1vZHVsZU5hbWU6IG4ubW9kdWxlTmFtZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5waXBlKEwpXG4gIH0pIH07XG59KSwgWCA9IEcucGlwZShcbiAgTigoeyBvbk1lc3NhZ2U6IG8gfSkgPT4ge1xuICAgIHNlbGYub25tZXNzYWdlID0gbztcbiAgfSlcbiksIHogPSBDO1xueChcbiAgWCxcbiAgbSxcbiAgelxuKS5waXBlKF8pO1xuIl0sIm5hbWVzIjpbIlQiLCJBIiwiYyIsInQiLCJOIiwiZSIsImYiLCJoIiwieCIsImwiLCJnIiwiaiIsIl8iLCJyIiwiTCIsInAiLCJQIiwiayIsIk8iLCJtIiwiVSIsIkIiLCJDIiwidiIsInEiLCJ3IiwiaSIsIlMiLCJvIiwidHJ5IiwicHJpbnQiLCJjb25zb2xlIiwibG9nIiwicHJpbnRFcnIiLCJlcnJvciIsImNhdGNoIiwiRXJyb3IiLCJvcGVyYXRpb24iLCJtZXNzYWdlIiwiZXJyb3JOYW1lIiwibmFtZSIsIiQiLCJwaXBlIiwiaW5pdFdvcmtlcjFBUEkiLCJEIiwiSSIsIlIiLCJkZWZhdWx0IiwicyIsImxlbmd0aCIsIlciLCJIIiwidHlwZSIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkV4ZWMiLCJvbkV4cG9ydCIsIm9uQ29uZmlnR2V0Iiwib25Mb2FkTW9kdWxlIiwiSyIsInBvc3RNZXNzYWdlIiwib28xIiwiREIiLCJjaGVja1JjIiwiU1FMaXRlM0Vycm9yIiwiRiIsInNwbGl0IiwiTnVtYmVyIiwiRyIsInNlbGYiLCJvbm1lc3NhZ2UiLCJhIiwiY2FsbCIsIm9uTWVzc2FnZSIsImRhdGEiLCJkYklkIiwiZCIsImFyZ3MiLCJuIiwibWVzc2FnZUlkIiwiTSIsInkiLCJ3YXNtIiwiYWxsb2NQdHIiLCJFIiwibW9kdWxlVVJMIiwiYXV4IiwidHJhbnNmZXIiLCJwb3J0cyIsImIiLCJ2dGFiIiwic2V0dXBNb2R1bGUiLCJtZXRob2RzIiwidSIsInBBdXhCeXRlcyIsImJ5dGVMZW5ndGgiLCJhbGxvYyIsIkRhdGFWaWV3IiwiaGVhcDh1IiwiYnVmZmVyIiwic2V0SW50MzIiLCJzZXQiLCJjYXBpIiwic3FsaXRlM19jcmVhdGVfbW9kdWxlIiwibW9kdWxlTmFtZSIsInBvaW50ZXIiLCJyZXN1bHQiLCJyYyIsIlgiLCJ6Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../medfetch/dist/sqlite-wasm/worker1.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/index.mjs":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/index.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   sqlite3Worker1Promiser: () => (/* binding */ sqlite3Worker1Promiser)\n/* harmony export */ });\n/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs */ \"(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\");\n/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_worker1_promiser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs */ \"(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs\");\n\n\n\nconst sqlite3Worker1Promiser = globalThis.sqlite3Worker1Promiser;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNxbGl0ZS5vcmcrc3FsaXRlLXdhc21AMy40OS4xLWJ1aWxkMi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUc7QUFDdEM7O0FBRTNEOztBQUVBLGlFQUFlLHdGQUFpQixFQUFDO0FBQ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL0BzcWxpdGUub3JnK3NxbGl0ZS13YXNtQDMuNDkuMS1idWlsZDIvbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZhdWx0IGFzIHNxbGl0ZTNJbml0TW9kdWxlIH0gZnJvbSAnLi9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy1idW5kbGVyLWZyaWVuZGx5Lm1qcyc7XG5pbXBvcnQgJy4vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtd29ya2VyMS1wcm9taXNlci5tanMnO1xuXG5jb25zdCBzcWxpdGUzV29ya2VyMVByb21pc2VyID0gZ2xvYmFsVGhpcy5zcWxpdGUzV29ya2VyMVByb21pc2VyO1xuXG5leHBvcnQgZGVmYXVsdCBzcWxpdGUzSW5pdE1vZHVsZTtcbmV4cG9ydCB7IHNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs":
/*!********************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js\");\n/*\n ** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.\n **\n ** This bundle (typically released as sqlite3.js or sqlite3.mjs)\n ** is an amalgamation of JavaScript source code from two projects:\n **\n ** 1) https://emscripten.org: the Emscripten \"glue code\" is covered by\n **    the terms of the MIT license and University of Illinois/NCSA\n **    Open Source License, as described at:\n **\n **    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html\n **\n ** 2) https://sqlite.org: all code and documentation labeled as being\n **    from this source are released under the same terms as the sqlite3\n **    C library:\n **\n ** 2022-10-16\n **\n ** The author disclaims copyright to this source code.  In place of a\n ** legal notice, here is a blessing:\n **\n ** *   May you do good and not evil.\n ** *   May you find forgiveness for yourself and forgive others.\n ** *   May you share freely, never taking more than you give.\n */\n/*\n ** This code was built from sqlite3 version...\n **\n ** SQLITE_VERSION \"3.49.1\"\n ** SQLITE_VERSION_NUMBER 3049001\n ** SQLITE_SOURCE_ID \"2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\"\n **\n ** Using the Emscripten SDK version 3.1.70.\n */\n\nvar sqlite3InitModule = (() => {\n  var _scriptName = \"file:///Users/ethankim/Nestor/medfetch.js/node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\";\n\n  return function (moduleArg = {}) {\n    var moduleRtn;\n\n    var Module = moduleArg;\n\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n\n    var ENVIRONMENT_IS_WEB = typeof window == 'object';\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n\n    var ENVIRONMENT_IS_NODE =\n      typeof process == 'object' &&\n      typeof process.versions == 'object' &&\n      typeof process.versions.node == 'string' &&\n      process.type != 'renderer';\n    var ENVIRONMENT_IS_SHELL =\n      !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    const sqlite3InitModuleState =\n      globalThis.sqlite3InitModuleState ||\n      Object.assign(Object.create(null), {\n        debugModule: () => {},\n      });\n    delete globalThis.sqlite3InitModuleState;\n    sqlite3InitModuleState.debugModule(\n      'globalThis.location =',\n      globalThis.location,\n    );\n\n    var moduleOverrides = Object.assign({}, Module);\n\n    var arguments_ = [];\n    var thisProgram = './this.program';\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n\n    var scriptDirectory = '';\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    var readAsync, readBinary;\n\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n\n      if (scriptDirectory.startsWith('blob:')) {\n        scriptDirectory = '';\n      } else {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n        );\n      }\n\n      {\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n\n        readAsync = (url) => {\n          return fetch(url, { credentials: 'same-origin' }).then((response) => {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(\n              new Error(response.status + ' : ' + response.url),\n            );\n          });\n        };\n      }\n    } else {\n    }\n\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.error.bind(console);\n\n    Object.assign(Module, moduleOverrides);\n\n    moduleOverrides = null;\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\n    var wasmBinary = Module['wasmBinary'];\n\n    var wasmMemory;\n\n    var ABORT = false;\n\n    var EXITSTATUS;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(text);\n      }\n    }\n\n    var HEAP,\n      HEAP8,\n      HEAPU8,\n      HEAP16,\n      HEAPU16,\n      HEAP32,\n      HEAPU32,\n      HEAPF32,\n      HEAP64,\n      HEAPU64,\n      HEAPF64;\n\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n      Module['HEAP64'] = HEAP64 = new BigInt64Array(b);\n      Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);\n    }\n\n    if (Module['wasmMemory']) {\n      wasmMemory = Module['wasmMemory'];\n    } else {\n      var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\n\n      wasmMemory = new WebAssembly.Memory({\n        initial: INITIAL_MEMORY / 65536,\n\n        maximum: 32768,\n      });\n    }\n\n    updateMemoryViews();\n\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATEXIT__ = [];\n    var __ATPOSTRUN__ = [];\n\n    var runtimeInitialized = false;\n\n    function preRun() {\n      var preRuns = Module['preRun'];\n      if (preRuns) {\n        if (typeof preRuns == 'function') preRuns = [preRuns];\n        preRuns.forEach(addOnPreRun);\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      runtimeInitialized = true;\n\n      if (!Module['noFSInit'] && !FS.initialized) FS.init();\n      FS.ignorePermissions = false;\n\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      var postRuns = Module['postRun'];\n      if (postRuns) {\n        if (typeof postRuns == 'function') postRuns = [postRuns];\n        postRuns.forEach(addOnPostRun);\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    function abort(what) {\n      Module['onAbort']?.(what);\n\n      what = 'Aborted(' + what + ')';\n\n      err(what);\n\n      ABORT = true;\n\n      what += '. Build with -sASSERTIONS for more info.';\n\n      var e = new WebAssembly.RuntimeError(what);\n\n      readyPromiseReject(e);\n\n      throw e;\n    }\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n    var isFileURI = (filename) => filename.startsWith('file://');\n\n    function findWasmBinary() {\n      if (Module['locateFile']) {\n        var f = 'sqlite3.wasm';\n        if (!isDataURI(f)) {\n          return locateFile(f);\n        }\n        return f;\n      }\n\n      return /* asset import */ new __webpack_require__.U(__webpack_require__(/*! sqlite3.wasm */ \"(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm\")).href;\n    }\n\n    var wasmBinaryFile;\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary) {\n        return readAsync(binaryFile).then(\n          (response) => new Uint8Array(response),\n\n          () => getBinarySync(binaryFile),\n        );\n      }\n\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => {\n          return WebAssembly.instantiate(binary, imports);\n        })\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (\n        !binary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(binaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(binaryFile, { credentials: 'same-origin' }).then(\n          (response) => {\n            var result = WebAssembly.instantiateStreaming(response, imports);\n\n            return result.then(callback, function (reason) {\n              err(`wasm streaming compile failed: ${reason}`);\n              err('falling back to ArrayBuffer instantiation');\n              return instantiateArrayBuffer(binaryFile, imports, callback);\n            });\n          },\n        );\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    function getWasmImports() {\n      return {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports,\n      };\n    }\n\n    function createWasm() {\n      var info = getWasmImports();\n\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n\n        addOnInit(wasmExports['__wasm_call_ctors']);\n\n        removeRunDependency('wasm-instantiate');\n        return wasmExports;\n      }\n\n      addRunDependency('wasm-instantiate');\n\n      function receiveInstantiationResult(result) {\n        receiveInstance(result['instance']);\n      }\n\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n\n          readyPromiseReject(e);\n        }\n      }\n\n      wasmBinaryFile ??= findWasmBinary();\n\n      instantiateAsync(\n        wasmBinary,\n        wasmBinaryFile,\n        info,\n        receiveInstantiationResult,\n      ).catch(readyPromiseReject);\n      return {};\n    }\n\n    function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      callbacks.forEach((f) => f(Module));\n    };\n\n    function getValue(ptr, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr];\n        case 'i8':\n          return HEAP8[ptr];\n        case 'i16':\n          return HEAP16[ptr >> 1];\n        case 'i32':\n          return HEAP32[ptr >> 2];\n        case 'i64':\n          return HEAP64[ptr >> 3];\n        case 'float':\n          return HEAPF32[ptr >> 2];\n        case 'double':\n          return HEAPF64[ptr >> 3];\n        case '*':\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n\n    var noExitRuntime = Module['noExitRuntime'] || true;\n\n    function setValue(ptr, value, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr] = value;\n          break;\n        case 'i8':\n          HEAP8[ptr] = value;\n          break;\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n        case 'i64':\n          HEAP64[ptr >> 3] = BigInt(value);\n          break;\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case '*':\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n\n    var stackRestore = (val) => __emscripten_stack_restore(val);\n\n    var stackSave = () => _emscripten_stack_get_current();\n\n    var PATH = {\n      isAbs: (path) => path.charAt(0) === '/',\n      splitPath: (filename) => {\n        var splitPathRe =\n          /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n      normalize: (path) => {\n        var isAbsolute = PATH.isAbs(path),\n          trailingSlash = path.substr(-1) === '/';\n\n        path = PATH.normalizeArray(\n          path.split('/').filter((p) => !!p),\n          !isAbsolute,\n        ).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: (path) => {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          return '.';\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: (path) => {\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, '');\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: (...paths) => PATH.normalize(paths.join('/')),\n      join2: (l, r) => PATH.normalize(l + '/' + r),\n    };\n\n    var initRandomFill = () => {\n      if (\n        typeof crypto == 'object' &&\n        typeof crypto['getRandomValues'] == 'function'\n      ) {\n        return (view) => crypto.getRandomValues(view);\n      } else abort('initRandomDevice');\n    };\n    var randomFill = (view) => {\n      return (randomFill = initRandomFill())(view);\n    };\n\n    var PATH_FS = {\n      resolve: (...args) => {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? args[i] : FS.cwd();\n\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return '';\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n\n        resolvedPath = PATH.normalizeArray(\n          resolvedPath.split('/').filter((p) => !!p),\n          !resolvedAbsolute,\n        ).join('/');\n        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      },\n    };\n\n    var UTF8Decoder =\n      typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xe0) == 0xc0) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xf0) == 0xe0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          u0 =\n            ((u0 & 7) << 18) |\n            (u1 << 12) |\n            (u2 << 6) |\n            (heapOrArray[idx++] & 63);\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(\n            0xd800 | (ch >> 10),\n            0xdc00 | (ch & 0x3ff),\n          );\n        }\n      }\n      return str;\n    };\n\n    var FS_stdin_getChar_buffer = [];\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 0x7f) {\n          len++;\n        } else if (c <= 0x7ff) {\n          len += 2;\n        } else if (c >= 0xd800 && c <= 0xdfff) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      if (!(maxBytesToWrite > 0)) return 0;\n\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 0xd800 && u <= 0xdfff) {\n          var u1 = str.charCodeAt(++i);\n          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\n        }\n        if (u <= 0x7f) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7ff) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xc0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xffff) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xe0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 0xf0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(\n        stringy,\n        u8array,\n        0,\n        u8array.length,\n      );\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (\n          typeof window != 'undefined' &&\n          typeof window.prompt == 'function'\n        ) {\n          result = window.prompt('Input: ');\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else {\n        }\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {},\n      shutdown() {},\n      register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        },\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a,\n              0x00, 0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            ],\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        },\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n      },\n    };\n\n    var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n    };\n\n    var alignMemory = (size, alignment) => {\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (ptr) zeroMemory(ptr, size);\n      return ptr;\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table ||= {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n            },\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync,\n            },\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink,\n            },\n            stream: {},\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: FS.chrdev_stream_ops,\n          },\n        };\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray)\n          return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(\n          newCapacity,\n          (prevCapacity *\n            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>\n            0,\n        );\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0)\n          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(\n              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),\n            );\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = ['.', '..'];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        },\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++)\n              buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(\n                buffer.subarray(offset, offset + length),\n                position,\n              );\n              return length;\n            }\n          }\n\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(\n              buffer.subarray(offset, offset + length),\n              position,\n            );\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(\n            stream.node.usedBytes,\n            offset + length,\n          );\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(\n                    contents,\n                    position,\n                    position + length,\n                  );\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n\n          return 0;\n        },\n      },\n    };\n\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\n      readAsync(url).then(\n        (arrayBuffer) => {\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file \"${url}\" failed.`;\n          }\n        },\n      );\n      if (dep) addRunDependency(dep);\n    };\n\n    var FS_createDataFile = (\n      parent,\n      name,\n      fileData,\n      canRead,\n      canWrite,\n      canOwn,\n    ) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n\n    var preloadPlugins = Module['preloadPlugins'] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      if (typeof Browser != 'undefined') Browser.init();\n\n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin['canHandle'](fullname)) {\n          plugin['handle'](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (\n      parent,\n      name,\n      url,\n      canRead,\n      canWrite,\n      onload,\n      onerror,\n      dontCreateFile,\n      canOwn,\n      preFinish,\n    ) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\n      function processData(byteArray) {\n        function finish(byteArray) {\n          preFinish?.();\n          if (!dontCreateFile) {\n            FS_createDataFile(\n              parent,\n              name,\n              byteArray,\n              canRead,\n              canWrite,\n              canOwn,\n            );\n          }\n          onload?.();\n          removeRunDependency(dep);\n        }\n        if (\n          FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n            onerror?.();\n            removeRunDependency(dep);\n          })\n        ) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == 'string') {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n\n    var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        r: 0,\n        'r+': 2,\n        w: 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        a: 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2,\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: '/',\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: class {\n        constructor(errno) {\n          this.name = 'ErrnoError';\n          this.errno = errno;\n        }\n      },\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      readFiles: {},\n      FSStream: class {\n        constructor() {\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return this.flags & 1024;\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n      FSNode: class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n      lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n\n        if (!path) return { path: '', node: null };\n\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0,\n        };\n        opts = Object.assign(defaults, opts);\n\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n\n        var parts = path.split('/').filter((p) => !!p);\n\n        var current = FS.root;\n        var current_path = '/';\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count + 1,\n              });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n\n        return { path: current_path, node: current };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== '/'\n              ? `${mount}/${path}`\n              : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n\n        FS.hashAddNode(node);\n\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if (flag & 512) {\n          perms += 'w';\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, 'wx');\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: (fd) => FS.streams[fd],\n      createStream(stream, fd = -1) {\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream(origStream, fd = -1) {\n        var stream = FS.createStream(origStream, fd);\n        stream.stream_ops?.dup?.(stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n\n          stream.stream_ops = device.stream_ops;\n\n          stream.stream_ops.open?.(stream);\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        },\n      },\n      major: (dev) => dev >> 8,\n      minor: (dev) => dev & 0xff,\n      makedev: (ma, mi) => (ma << 8) | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: (dev) => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n\n          mounts.push(m);\n\n          check.push(...m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          err(\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`,\n          );\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n          mountpoint = lookup.path;\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: [],\n        };\n\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n\n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n\n        node.mounted = null;\n\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n\n        var lookup, old_dir, new_dir;\n\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n\n        var old_node = FS.lookupNode(old_dir, old_name);\n\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n\n        if (old_node === new_node) {\n          return;\n        }\n\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        errCode = new_node\n          ? FS.mayDelete(new_dir, new_name, isdir)\n          : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (\n          FS.isMountpoint(old_node) ||\n          (new_node && FS.isMountpoint(new_node))\n        ) {\n          throw new FS.ErrnoError(10);\n        }\n\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        FS.hashRemoveNode(old_node);\n\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(\n          FS.getPath(link.parent),\n          link.node_ops.readlink(link),\n        );\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now(),\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now(),\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now(),\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime),\n        });\n      },\n      open(path, flags, mode) {\n        if (path === '') {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == 'undefined' ? 438 : mode;\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072),\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n\n        flags &= ~(128 | 512 | 131072);\n\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n\n          ungotten: [],\n          error: false,\n        });\n\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n        );\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n          canOwn,\n        );\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        if (\n          (prot & 2) !== 0 &&\n          (flags & 2) === 0 &&\n          (stream.flags & 2097155) !== 2\n        ) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(\n          stream,\n          buffer,\n          offset,\n          length,\n          mmapFlags,\n        );\n      },\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n      createDefaultDevices() {\n        FS.mkdir('/dev');\n\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n\n        var randomBuffer = new Uint8Array(1024),\n          randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n      createSpecialDirectories() {\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount(\n          {\n            mount() {\n              var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);\n              node.node_ops = {\n                lookup(parent, name) {\n                  var fd = +name;\n                  var stream = FS.getStreamChecked(fd);\n                  var ret = {\n                    parent: null,\n                    mount: { mountpoint: 'fake' },\n                    node_ops: { readlink: () => stream.path },\n                  };\n                  ret.parent = ret;\n                  return ret;\n                },\n              };\n              return node;\n            },\n          },\n          {},\n          '/proc/self/fd',\n        );\n      },\n      createStandardStreams(input, output, error) {\n        if (input) {\n          FS.createDevice('/dev', 'stdin', input);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (output) {\n          FS.createDevice('/dev', 'stdout', null, output);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (error) {\n          FS.createDevice('/dev', 'stderr', null, error);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n      },\n      staticInit() {\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n\n        FS.nameTable = new Array(4096);\n\n        FS.mount(MEMFS, {}, '/');\n\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n\n        FS.filesystems = {\n          MEMFS: MEMFS,\n        };\n      },\n      init(input, output, error) {\n        FS.initialized = true;\n\n        input ??= Module['stdin'];\n        output ??= Module['stdout'];\n        error ??= Module['stderr'];\n\n        FS.createStandardStreams(input, output, error);\n      },\n      quit() {\n        FS.initialized = false;\n\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null,\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(\n          typeof parent == 'string' ? parent : FS.getPath(parent),\n          name,\n        );\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i)\n              arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice(parent, name, input, output) {\n        var path = PATH.join2(\n          typeof parent == 'string' ? parent : FS.getPath(parent),\n          name,\n        );\n        var mode = FS_getMode(!!input, !!output);\n        FS.createDevice.major ??= 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            if (output?.buffer?.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          },\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\n          return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\n            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',\n          );\n        } else {\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = [];\n          }\n          get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n              return undefined;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = (idx / this.chunkSize) | 0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            var xhr = new XMLHttpRequest();\n            xhr.open('HEAD', url, false);\n            xhr.send(null);\n            if (\n              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\n            )\n              throw new Error(\n                \"Couldn't load \" + url + '. Status: ' + xhr.status,\n              );\n            var datalength = Number(xhr.getResponseHeader('Content-length'));\n            var header;\n            var hasByteServing =\n              (header = xhr.getResponseHeader('Accept-Ranges')) &&\n              header === 'bytes';\n            var usesGzip =\n              (header = xhr.getResponseHeader('Content-Encoding')) &&\n              header === 'gzip';\n\n            var chunkSize = 1024 * 1024;\n\n            if (!hasByteServing) chunkSize = datalength;\n\n            var doXHR = (from, to) => {\n              if (from > to)\n                throw new Error(\n                  'invalid range (' +\n                    from +\n                    ', ' +\n                    to +\n                    ') or no bytes requested!',\n                );\n              if (to > datalength - 1)\n                throw new Error(\n                  'only ' + datalength + ' bytes available! programmer error!',\n                );\n\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', url, false);\n              if (datalength !== chunkSize)\n                xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);\n\n              xhr.responseType = 'arraybuffer';\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\n              }\n\n              xhr.send(null);\n              if (\n                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\n              )\n                throw new Error(\n                  \"Couldn't load \" + url + '. Status: ' + xhr.status,\n                );\n              if (xhr.response !== undefined) {\n                return new Uint8Array(xhr.response || []);\n              }\n              return intArrayFromString(xhr.responseText || '', true);\n            };\n            var lazyArray = this;\n            lazyArray.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum + 1) * chunkSize - 1;\n              end = Math.min(end, datalength - 1);\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined')\n                throw new Error('doXHR failed!');\n              return lazyArray.chunks[chunkNum];\n            });\n\n            if (usesGzip || !datalength) {\n              chunkSize = datalength = 1;\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out(\n                'LazyFiles on gzip forces download of the whole file when length is accessed',\n              );\n            }\n\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n\n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            },\n          },\n        });\n\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n    };\n\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[(buf + 4) >> 2] = stat.mode;\n        HEAPU32[(buf + 8) >> 2] = stat.nlink;\n        HEAP32[(buf + 12) >> 2] = stat.uid;\n        HEAP32[(buf + 16) >> 2] = stat.gid;\n        HEAP32[(buf + 20) >> 2] = stat.rdev;\n        HEAP64[(buf + 24) >> 3] = BigInt(stat.size);\n        HEAP32[(buf + 32) >> 2] = 4096;\n        HEAP32[(buf + 36) >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        HEAP64[(buf + 40) >> 3] = BigInt(Math.floor(atime / 1000));\n        HEAPU32[(buf + 48) >> 2] = (atime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 56) >> 3] = BigInt(Math.floor(mtime / 1000));\n        HEAPU32[(buf + 64) >> 2] = (mtime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 72) >> 3] = BigInt(Math.floor(ctime / 1000));\n        HEAPU32[(buf + 80) >> 2] = (ctime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 88) >> 3] = BigInt(stat.ino);\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: undefined,\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n    };\n    function ___syscall_chmod(path, mode) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.chmod(path, mode);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_faccessat(dirfd, path, amode, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (amode & ~7) {\n          return -28;\n        }\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node) {\n          return -44;\n        }\n        var perms = '';\n        if (amode & 4) perms += 'r';\n        if (amode & 2) perms += 'w';\n        if (amode & 1) perms += 'x';\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fchmod(fd, mode) {\n      try {\n        FS.fchmod(fd, mode);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fchown32(fd, owner, group) {\n      try {\n        FS.fchown(fd, owner, group);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function syscallGetVarargI() {\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = syscallGetVarargI();\n            if (arg < 0) {\n              return -28;\n            }\n            while (FS.streams[arg]) {\n              arg++;\n            }\n            var newStream;\n            newStream = FS.dupStream(stream, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0;\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = syscallGetVarargI();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = syscallGetVarargP();\n            var offset = 0;\n\n            HEAP16[(arg + offset) >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0;\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fstat64(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var INT53_MAX = 9007199254740992;\n\n    var INT53_MIN = -9007199254740992;\n    var bigintToI53Checked = (num) =>\n      num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\n    function ___syscall_ftruncate64(fd, length) {\n      length = bigintToI53Checked(length);\n\n      try {\n        if (isNaN(length)) return 61;\n        FS.ftruncate(fd, length);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    function ___syscall_getcwd(buf, size) {\n      try {\n        if (size === 0) return -28;\n        var cwd = FS.cwd();\n        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;\n        if (size < cwdLengthInBytes) return -68;\n        stringToUTF8(cwd, buf, size);\n        return cwdLengthInBytes;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21505: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcgets) {\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = termios.c_iflag || 0;\n              HEAP32[(argp + 4) >> 2] = termios.c_oflag || 0;\n              HEAP32[(argp + 8) >> 2] = termios.c_cflag || 0;\n              HEAP32[(argp + 12) >> 2] = termios.c_lflag || 0;\n              for (var i = 0; i < 32; i++) {\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n              }\n              return 0;\n            }\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcsets) {\n              var argp = syscallGetVarargP();\n              var c_iflag = HEAP32[argp >> 2];\n              var c_oflag = HEAP32[(argp + 4) >> 2];\n              var c_cflag = HEAP32[(argp + 8) >> 2];\n              var c_lflag = HEAP32[(argp + 12) >> 2];\n              var c_cc = [];\n              for (var i = 0; i < 32; i++) {\n                c_cc.push(HEAP8[argp + i + 17]);\n              }\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                c_iflag,\n                c_oflag,\n                c_cflag,\n                c_lflag,\n                c_cc,\n              });\n            }\n            return 0;\n          }\n          case 21519: {\n            if (!stream.tty) return -59;\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty) return -59;\n            return -28;\n          }\n          case 21531: {\n            var argp = syscallGetVarargP();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n              var argp = syscallGetVarargP();\n              HEAP16[argp >> 1] = winsize[0];\n              HEAP16[(argp + 2) >> 1] = winsize[1];\n            }\n            return 0;\n          }\n          case 21524: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21515: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          default:\n            return -28;\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_lstat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.lstat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_mkdirat(dirfd, path, mode) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === '/')\n          path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_newfstatat(dirfd, path, buf, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        var nofollow = flags & 256;\n        var allowEmpty = flags & 4096;\n        flags = flags & ~6400;\n        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (bufsize <= 0) return -28;\n        var ret = FS.readlink(path);\n\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n\n        HEAP8[buf + len] = endChar;\n        return len;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_rmdir(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.rmdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_stat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_unlinkat(dirfd, path, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (flags === 0) {\n          FS.unlink(path);\n        } else if (flags === 512) {\n          FS.rmdir(path);\n        } else {\n          abort('Invalid flags passed to unlinkat');\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var readI53FromI64 = (ptr) => {\n      return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;\n    };\n\n    function ___syscall_utimensat(dirfd, path, times, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path, true);\n        var now = Date.now(),\n          atime,\n          mtime;\n        if (!times) {\n          atime = now;\n          mtime = now;\n        } else {\n          var seconds = readI53FromI64(times);\n          var nanoseconds = HEAP32[(times + 8) >> 2];\n          if (nanoseconds == 1073741823) {\n            atime = now;\n          } else if (nanoseconds == 1073741822) {\n            atime = -1;\n          } else {\n            atime = seconds * 1000 + nanoseconds / (1000 * 1000);\n          }\n          times += 16;\n          seconds = readI53FromI64(times);\n          nanoseconds = HEAP32[(times + 8) >> 2];\n          if (nanoseconds == 1073741823) {\n            mtime = now;\n          } else if (nanoseconds == 1073741822) {\n            mtime = -1;\n          } else {\n            mtime = seconds * 1000 + nanoseconds / (1000 * 1000);\n          }\n        }\n\n        if (mtime != -1 || atime != -1) {\n          FS.utime(path, atime, mtime);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var nowIsMonotonic = 1;\n    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;\n\n    var isLeapYear = (year) =>\n      year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n\n    var MONTH_DAYS_LEAP_CUMULATIVE = [\n      0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,\n    ];\n\n    var MONTH_DAYS_REGULAR_CUMULATIVE = [\n      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,\n    ];\n    var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = leap\n        ? MONTH_DAYS_LEAP_CUMULATIVE\n        : MONTH_DAYS_REGULAR_CUMULATIVE;\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;\n\n      return yday;\n    };\n\n    function __localtime_js(time, tmPtr) {\n      time = bigintToI53Checked(time);\n\n      var date = new Date(time * 1000);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\n      HEAP32[(tmPtr + 8) >> 2] = date.getHours();\n      HEAP32[(tmPtr + 12) >> 2] = date.getDate();\n      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\n      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\n      HEAP32[(tmPtr + 24) >> 2] = date.getDay();\n\n      var yday = ydayFromDate(date) | 0;\n      HEAP32[(tmPtr + 28) >> 2] = yday;\n      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\n\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst =\n        (summerOffset != winterOffset &&\n          date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[(tmPtr + 32) >> 2] = dst;\n    }\n\n    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var res = FS.mmap(stream, len, offset, prot, flags);\n        var ptr = res.ptr;\n        HEAP32[allocated >> 2] = res.allocated;\n        HEAPU32[addr >> 2] = ptr;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function __munmap_js(addr, len, prot, flags, fd, offset) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if (prot & 2) {\n          SYSCALLS.doMsync(addr, stream, len, flags, offset);\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n\n      var extractZone = (timezoneOffset) => {\n        var sign = timezoneOffset >= 0 ? '-' : '+';\n\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, '0');\n        var minutes = String(absOffset % 60).padStart(2, '0');\n\n        return `UTC${sign}${hours}${minutes}`;\n      };\n\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      if (summerOffset < winterOffset) {\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n\n    var _emscripten_date_now = () => Date.now();\n\n    var _emscripten_get_now = () => performance.now();\n\n    var getHeapMax = () => 2147483648;\n\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = ((size - b.byteLength + 65535) / 65536) | 0;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {}\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n\n      requestedSize >>>= 0;\n\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n\n        overGrownHeapSize = Math.min(\n          overGrownHeapSize,\n          requestedSize + 100663296,\n        );\n\n        var newSize = Math.min(\n          maxHeapSize,\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536),\n        );\n\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    var ENV = {};\n\n    var getExecutableName = () => {\n      return thisProgram || './this.program';\n    };\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang =\n          (\n            (typeof navigator == 'object' &&\n              navigator.languages &&\n              navigator.languages[0]) ||\n            'C'\n          ).replace('-', '_') + '.UTF-8';\n        var env = {\n          USER: 'web_user',\n          LOGNAME: 'web_user',\n          PATH: '/',\n          PWD: '/',\n          HOME: '/home/web_user',\n          LANG: lang,\n          _: getExecutableName(),\n        };\n\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(__environ + i * 4) >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => (bufSize += string.length + 1));\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_fdstat_get(fd, pbuf) {\n      try {\n        var rightsBase = 0;\n        var rightsInheriting = 0;\n        var flags = 0;\n        {\n          var stream = SYSCALLS.getStreamFromFD(fd);\n\n          var type = stream.tty\n            ? 2\n            : FS.isDir(stream.mode)\n              ? 3\n              : FS.isLink(stream.mode)\n                ? 7\n                : 4;\n        }\n        HEAP8[pbuf] = type;\n        HEAP16[(pbuf + 2) >> 1] = flags;\n        HEAP64[(pbuf + 8) >> 3] = BigInt(rightsBase);\n        HEAP64[(pbuf + 16) >> 3] = BigInt(rightsInheriting);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break;\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_seek(fd, offset, whence, newOffset) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        HEAP64[newOffset >> 3] = BigInt(stream.position);\n        if (stream.getdents && offset === 0 && whence === 0)\n          stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_sync(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if (stream.stream_ops?.fsync) {\n          return stream.stream_ops.fsync(stream);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          break;\n        }\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n\n    var wasmImports = {\n      __syscall_chmod: ___syscall_chmod,\n\n      __syscall_faccessat: ___syscall_faccessat,\n\n      __syscall_fchmod: ___syscall_fchmod,\n\n      __syscall_fchown32: ___syscall_fchown32,\n\n      __syscall_fcntl64: ___syscall_fcntl64,\n\n      __syscall_fstat64: ___syscall_fstat64,\n\n      __syscall_ftruncate64: ___syscall_ftruncate64,\n\n      __syscall_getcwd: ___syscall_getcwd,\n\n      __syscall_ioctl: ___syscall_ioctl,\n\n      __syscall_lstat64: ___syscall_lstat64,\n\n      __syscall_mkdirat: ___syscall_mkdirat,\n\n      __syscall_newfstatat: ___syscall_newfstatat,\n\n      __syscall_openat: ___syscall_openat,\n\n      __syscall_readlinkat: ___syscall_readlinkat,\n\n      __syscall_rmdir: ___syscall_rmdir,\n\n      __syscall_stat64: ___syscall_stat64,\n\n      __syscall_unlinkat: ___syscall_unlinkat,\n\n      __syscall_utimensat: ___syscall_utimensat,\n\n      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n\n      _localtime_js: __localtime_js,\n\n      _mmap_js: __mmap_js,\n\n      _munmap_js: __munmap_js,\n\n      _tzset_js: __tzset_js,\n\n      emscripten_date_now: _emscripten_date_now,\n\n      emscripten_get_now: _emscripten_get_now,\n\n      emscripten_resize_heap: _emscripten_resize_heap,\n\n      environ_get: _environ_get,\n\n      environ_sizes_get: _environ_sizes_get,\n\n      fd_close: _fd_close,\n\n      fd_fdstat_get: _fd_fdstat_get,\n\n      fd_read: _fd_read,\n\n      fd_seek: _fd_seek,\n\n      fd_sync: _fd_sync,\n\n      fd_write: _fd_write,\n\n      memory: wasmMemory,\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = () =>\n      (___wasm_call_ctors = wasmExports['__wasm_call_ctors'])();\n    var _sqlite3_status64 = (Module['_sqlite3_status64'] = (a0, a1, a2, a3) =>\n      (_sqlite3_status64 = Module['_sqlite3_status64'] =\n        wasmExports['sqlite3_status64'])(a0, a1, a2, a3));\n    var _sqlite3_status = (Module['_sqlite3_status'] = (a0, a1, a2, a3) =>\n      (_sqlite3_status = Module['_sqlite3_status'] =\n        wasmExports['sqlite3_status'])(a0, a1, a2, a3));\n    var _sqlite3_db_status = (Module['_sqlite3_db_status'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_db_status = Module['_sqlite3_db_status'] =\n        wasmExports['sqlite3_db_status'])(a0, a1, a2, a3, a4));\n    var _sqlite3_msize = (Module['_sqlite3_msize'] = (a0) =>\n      (_sqlite3_msize = Module['_sqlite3_msize'] =\n        wasmExports['sqlite3_msize'])(a0));\n    var _sqlite3_vfs_find = (Module['_sqlite3_vfs_find'] = (a0) =>\n      (_sqlite3_vfs_find = Module['_sqlite3_vfs_find'] =\n        wasmExports['sqlite3_vfs_find'])(a0));\n    var _sqlite3_initialize = (Module['_sqlite3_initialize'] = () =>\n      (_sqlite3_initialize = Module['_sqlite3_initialize'] =\n        wasmExports['sqlite3_initialize'])());\n    var _sqlite3_malloc = (Module['_sqlite3_malloc'] = (a0) =>\n      (_sqlite3_malloc = Module['_sqlite3_malloc'] =\n        wasmExports['sqlite3_malloc'])(a0));\n    var _sqlite3_free = (Module['_sqlite3_free'] = (a0) =>\n      (_sqlite3_free = Module['_sqlite3_free'] = wasmExports['sqlite3_free'])(\n        a0,\n      ));\n    var _sqlite3_vfs_register = (Module['_sqlite3_vfs_register'] = (a0, a1) =>\n      (_sqlite3_vfs_register = Module['_sqlite3_vfs_register'] =\n        wasmExports['sqlite3_vfs_register'])(a0, a1));\n    var _sqlite3_vfs_unregister = (Module['_sqlite3_vfs_unregister'] = (a0) =>\n      (_sqlite3_vfs_unregister = Module['_sqlite3_vfs_unregister'] =\n        wasmExports['sqlite3_vfs_unregister'])(a0));\n    var _sqlite3_malloc64 = (Module['_sqlite3_malloc64'] = (a0) =>\n      (_sqlite3_malloc64 = Module['_sqlite3_malloc64'] =\n        wasmExports['sqlite3_malloc64'])(a0));\n    var _sqlite3_realloc = (Module['_sqlite3_realloc'] = (a0, a1) =>\n      (_sqlite3_realloc = Module['_sqlite3_realloc'] =\n        wasmExports['sqlite3_realloc'])(a0, a1));\n    var _sqlite3_realloc64 = (Module['_sqlite3_realloc64'] = (a0, a1) =>\n      (_sqlite3_realloc64 = Module['_sqlite3_realloc64'] =\n        wasmExports['sqlite3_realloc64'])(a0, a1));\n    var _sqlite3_value_text = (Module['_sqlite3_value_text'] = (a0) =>\n      (_sqlite3_value_text = Module['_sqlite3_value_text'] =\n        wasmExports['sqlite3_value_text'])(a0));\n    var _sqlite3_randomness = (Module['_sqlite3_randomness'] = (a0, a1) =>\n      (_sqlite3_randomness = Module['_sqlite3_randomness'] =\n        wasmExports['sqlite3_randomness'])(a0, a1));\n    var _sqlite3_stricmp = (Module['_sqlite3_stricmp'] = (a0, a1) =>\n      (_sqlite3_stricmp = Module['_sqlite3_stricmp'] =\n        wasmExports['sqlite3_stricmp'])(a0, a1));\n    var _sqlite3_strnicmp = (Module['_sqlite3_strnicmp'] = (a0, a1, a2) =>\n      (_sqlite3_strnicmp = Module['_sqlite3_strnicmp'] =\n        wasmExports['sqlite3_strnicmp'])(a0, a1, a2));\n    var _sqlite3_uri_parameter = (Module['_sqlite3_uri_parameter'] = (a0, a1) =>\n      (_sqlite3_uri_parameter = Module['_sqlite3_uri_parameter'] =\n        wasmExports['sqlite3_uri_parameter'])(a0, a1));\n    var _sqlite3_uri_boolean = (Module['_sqlite3_uri_boolean'] = (a0, a1, a2) =>\n      (_sqlite3_uri_boolean = Module['_sqlite3_uri_boolean'] =\n        wasmExports['sqlite3_uri_boolean'])(a0, a1, a2));\n    var _sqlite3_serialize = (Module['_sqlite3_serialize'] = (a0, a1, a2, a3) =>\n      (_sqlite3_serialize = Module['_sqlite3_serialize'] =\n        wasmExports['sqlite3_serialize'])(a0, a1, a2, a3));\n    var _sqlite3_prepare_v2 = (Module['_sqlite3_prepare_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_prepare_v2 = Module['_sqlite3_prepare_v2'] =\n        wasmExports['sqlite3_prepare_v2'])(a0, a1, a2, a3, a4));\n    var _sqlite3_step = (Module['_sqlite3_step'] = (a0) =>\n      (_sqlite3_step = Module['_sqlite3_step'] = wasmExports['sqlite3_step'])(\n        a0,\n      ));\n    var _sqlite3_column_int64 = (Module['_sqlite3_column_int64'] = (a0, a1) =>\n      (_sqlite3_column_int64 = Module['_sqlite3_column_int64'] =\n        wasmExports['sqlite3_column_int64'])(a0, a1));\n    var _sqlite3_reset = (Module['_sqlite3_reset'] = (a0) =>\n      (_sqlite3_reset = Module['_sqlite3_reset'] =\n        wasmExports['sqlite3_reset'])(a0));\n    var _sqlite3_exec = (Module['_sqlite3_exec'] = (a0, a1, a2, a3, a4) =>\n      (_sqlite3_exec = Module['_sqlite3_exec'] = wasmExports['sqlite3_exec'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n      ));\n    var _sqlite3_column_int = (Module['_sqlite3_column_int'] = (a0, a1) =>\n      (_sqlite3_column_int = Module['_sqlite3_column_int'] =\n        wasmExports['sqlite3_column_int'])(a0, a1));\n    var _sqlite3_finalize = (Module['_sqlite3_finalize'] = (a0) =>\n      (_sqlite3_finalize = Module['_sqlite3_finalize'] =\n        wasmExports['sqlite3_finalize'])(a0));\n    var _sqlite3_file_control = (Module['_sqlite3_file_control'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_file_control = Module['_sqlite3_file_control'] =\n        wasmExports['sqlite3_file_control'])(a0, a1, a2, a3));\n    var _sqlite3_column_name = (Module['_sqlite3_column_name'] = (a0, a1) =>\n      (_sqlite3_column_name = Module['_sqlite3_column_name'] =\n        wasmExports['sqlite3_column_name'])(a0, a1));\n    var _sqlite3_column_text = (Module['_sqlite3_column_text'] = (a0, a1) =>\n      (_sqlite3_column_text = Module['_sqlite3_column_text'] =\n        wasmExports['sqlite3_column_text'])(a0, a1));\n    var _sqlite3_column_type = (Module['_sqlite3_column_type'] = (a0, a1) =>\n      (_sqlite3_column_type = Module['_sqlite3_column_type'] =\n        wasmExports['sqlite3_column_type'])(a0, a1));\n    var _sqlite3_errmsg = (Module['_sqlite3_errmsg'] = (a0) =>\n      (_sqlite3_errmsg = Module['_sqlite3_errmsg'] =\n        wasmExports['sqlite3_errmsg'])(a0));\n    var _sqlite3_deserialize = (Module['_sqlite3_deserialize'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3_deserialize = Module['_sqlite3_deserialize'] =\n        wasmExports['sqlite3_deserialize'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_clear_bindings = (Module['_sqlite3_clear_bindings'] = (a0) =>\n      (_sqlite3_clear_bindings = Module['_sqlite3_clear_bindings'] =\n        wasmExports['sqlite3_clear_bindings'])(a0));\n    var _sqlite3_value_blob = (Module['_sqlite3_value_blob'] = (a0) =>\n      (_sqlite3_value_blob = Module['_sqlite3_value_blob'] =\n        wasmExports['sqlite3_value_blob'])(a0));\n    var _sqlite3_value_bytes = (Module['_sqlite3_value_bytes'] = (a0) =>\n      (_sqlite3_value_bytes = Module['_sqlite3_value_bytes'] =\n        wasmExports['sqlite3_value_bytes'])(a0));\n    var _sqlite3_value_double = (Module['_sqlite3_value_double'] = (a0) =>\n      (_sqlite3_value_double = Module['_sqlite3_value_double'] =\n        wasmExports['sqlite3_value_double'])(a0));\n    var _sqlite3_value_int = (Module['_sqlite3_value_int'] = (a0) =>\n      (_sqlite3_value_int = Module['_sqlite3_value_int'] =\n        wasmExports['sqlite3_value_int'])(a0));\n    var _sqlite3_value_int64 = (Module['_sqlite3_value_int64'] = (a0) =>\n      (_sqlite3_value_int64 = Module['_sqlite3_value_int64'] =\n        wasmExports['sqlite3_value_int64'])(a0));\n    var _sqlite3_value_subtype = (Module['_sqlite3_value_subtype'] = (a0) =>\n      (_sqlite3_value_subtype = Module['_sqlite3_value_subtype'] =\n        wasmExports['sqlite3_value_subtype'])(a0));\n    var _sqlite3_value_pointer = (Module['_sqlite3_value_pointer'] = (a0, a1) =>\n      (_sqlite3_value_pointer = Module['_sqlite3_value_pointer'] =\n        wasmExports['sqlite3_value_pointer'])(a0, a1));\n    var _sqlite3_value_type = (Module['_sqlite3_value_type'] = (a0) =>\n      (_sqlite3_value_type = Module['_sqlite3_value_type'] =\n        wasmExports['sqlite3_value_type'])(a0));\n    var _sqlite3_value_nochange = (Module['_sqlite3_value_nochange'] = (a0) =>\n      (_sqlite3_value_nochange = Module['_sqlite3_value_nochange'] =\n        wasmExports['sqlite3_value_nochange'])(a0));\n    var _sqlite3_value_frombind = (Module['_sqlite3_value_frombind'] = (a0) =>\n      (_sqlite3_value_frombind = Module['_sqlite3_value_frombind'] =\n        wasmExports['sqlite3_value_frombind'])(a0));\n    var _sqlite3_value_dup = (Module['_sqlite3_value_dup'] = (a0) =>\n      (_sqlite3_value_dup = Module['_sqlite3_value_dup'] =\n        wasmExports['sqlite3_value_dup'])(a0));\n    var _sqlite3_value_free = (Module['_sqlite3_value_free'] = (a0) =>\n      (_sqlite3_value_free = Module['_sqlite3_value_free'] =\n        wasmExports['sqlite3_value_free'])(a0));\n    var _sqlite3_result_blob = (Module['_sqlite3_result_blob'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_blob = Module['_sqlite3_result_blob'] =\n        wasmExports['sqlite3_result_blob'])(a0, a1, a2, a3));\n    var _sqlite3_result_error_toobig = (Module['_sqlite3_result_error_toobig'] =\n      (a0) =>\n        (_sqlite3_result_error_toobig = Module['_sqlite3_result_error_toobig'] =\n          wasmExports['sqlite3_result_error_toobig'])(a0));\n    var _sqlite3_result_error_nomem = (Module['_sqlite3_result_error_nomem'] = (\n      a0,\n    ) =>\n      (_sqlite3_result_error_nomem = Module['_sqlite3_result_error_nomem'] =\n        wasmExports['sqlite3_result_error_nomem'])(a0));\n    var _sqlite3_result_double = (Module['_sqlite3_result_double'] = (a0, a1) =>\n      (_sqlite3_result_double = Module['_sqlite3_result_double'] =\n        wasmExports['sqlite3_result_double'])(a0, a1));\n    var _sqlite3_result_error = (Module['_sqlite3_result_error'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_result_error = Module['_sqlite3_result_error'] =\n        wasmExports['sqlite3_result_error'])(a0, a1, a2));\n    var _sqlite3_result_int = (Module['_sqlite3_result_int'] = (a0, a1) =>\n      (_sqlite3_result_int = Module['_sqlite3_result_int'] =\n        wasmExports['sqlite3_result_int'])(a0, a1));\n    var _sqlite3_result_int64 = (Module['_sqlite3_result_int64'] = (a0, a1) =>\n      (_sqlite3_result_int64 = Module['_sqlite3_result_int64'] =\n        wasmExports['sqlite3_result_int64'])(a0, a1));\n    var _sqlite3_result_null = (Module['_sqlite3_result_null'] = (a0) =>\n      (_sqlite3_result_null = Module['_sqlite3_result_null'] =\n        wasmExports['sqlite3_result_null'])(a0));\n    var _sqlite3_result_pointer = (Module['_sqlite3_result_pointer'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_pointer = Module['_sqlite3_result_pointer'] =\n        wasmExports['sqlite3_result_pointer'])(a0, a1, a2, a3));\n    var _sqlite3_result_subtype = (Module['_sqlite3_result_subtype'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_subtype = Module['_sqlite3_result_subtype'] =\n        wasmExports['sqlite3_result_subtype'])(a0, a1));\n    var _sqlite3_result_text = (Module['_sqlite3_result_text'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_text = Module['_sqlite3_result_text'] =\n        wasmExports['sqlite3_result_text'])(a0, a1, a2, a3));\n    var _sqlite3_result_zeroblob = (Module['_sqlite3_result_zeroblob'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_zeroblob = Module['_sqlite3_result_zeroblob'] =\n        wasmExports['sqlite3_result_zeroblob'])(a0, a1));\n    var _sqlite3_result_zeroblob64 = (Module['_sqlite3_result_zeroblob64'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_zeroblob64 = Module['_sqlite3_result_zeroblob64'] =\n        wasmExports['sqlite3_result_zeroblob64'])(a0, a1));\n    var _sqlite3_result_error_code = (Module['_sqlite3_result_error_code'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_error_code = Module['_sqlite3_result_error_code'] =\n        wasmExports['sqlite3_result_error_code'])(a0, a1));\n    var _sqlite3_user_data = (Module['_sqlite3_user_data'] = (a0) =>\n      (_sqlite3_user_data = Module['_sqlite3_user_data'] =\n        wasmExports['sqlite3_user_data'])(a0));\n    var _sqlite3_context_db_handle = (Module['_sqlite3_context_db_handle'] = (\n      a0,\n    ) =>\n      (_sqlite3_context_db_handle = Module['_sqlite3_context_db_handle'] =\n        wasmExports['sqlite3_context_db_handle'])(a0));\n    var _sqlite3_vtab_nochange = (Module['_sqlite3_vtab_nochange'] = (a0) =>\n      (_sqlite3_vtab_nochange = Module['_sqlite3_vtab_nochange'] =\n        wasmExports['sqlite3_vtab_nochange'])(a0));\n    var _sqlite3_vtab_in_first = (Module['_sqlite3_vtab_in_first'] = (a0, a1) =>\n      (_sqlite3_vtab_in_first = Module['_sqlite3_vtab_in_first'] =\n        wasmExports['sqlite3_vtab_in_first'])(a0, a1));\n    var _sqlite3_vtab_in_next = (Module['_sqlite3_vtab_in_next'] = (a0, a1) =>\n      (_sqlite3_vtab_in_next = Module['_sqlite3_vtab_in_next'] =\n        wasmExports['sqlite3_vtab_in_next'])(a0, a1));\n    var _sqlite3_aggregate_context = (Module['_sqlite3_aggregate_context'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_aggregate_context = Module['_sqlite3_aggregate_context'] =\n        wasmExports['sqlite3_aggregate_context'])(a0, a1));\n    var _sqlite3_get_auxdata = (Module['_sqlite3_get_auxdata'] = (a0, a1) =>\n      (_sqlite3_get_auxdata = Module['_sqlite3_get_auxdata'] =\n        wasmExports['sqlite3_get_auxdata'])(a0, a1));\n    var _sqlite3_set_auxdata = (Module['_sqlite3_set_auxdata'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_set_auxdata = Module['_sqlite3_set_auxdata'] =\n        wasmExports['sqlite3_set_auxdata'])(a0, a1, a2, a3));\n    var _sqlite3_column_count = (Module['_sqlite3_column_count'] = (a0) =>\n      (_sqlite3_column_count = Module['_sqlite3_column_count'] =\n        wasmExports['sqlite3_column_count'])(a0));\n    var _sqlite3_data_count = (Module['_sqlite3_data_count'] = (a0) =>\n      (_sqlite3_data_count = Module['_sqlite3_data_count'] =\n        wasmExports['sqlite3_data_count'])(a0));\n    var _sqlite3_column_blob = (Module['_sqlite3_column_blob'] = (a0, a1) =>\n      (_sqlite3_column_blob = Module['_sqlite3_column_blob'] =\n        wasmExports['sqlite3_column_blob'])(a0, a1));\n    var _sqlite3_column_bytes = (Module['_sqlite3_column_bytes'] = (a0, a1) =>\n      (_sqlite3_column_bytes = Module['_sqlite3_column_bytes'] =\n        wasmExports['sqlite3_column_bytes'])(a0, a1));\n    var _sqlite3_column_double = (Module['_sqlite3_column_double'] = (a0, a1) =>\n      (_sqlite3_column_double = Module['_sqlite3_column_double'] =\n        wasmExports['sqlite3_column_double'])(a0, a1));\n    var _sqlite3_column_value = (Module['_sqlite3_column_value'] = (a0, a1) =>\n      (_sqlite3_column_value = Module['_sqlite3_column_value'] =\n        wasmExports['sqlite3_column_value'])(a0, a1));\n    var _sqlite3_column_decltype = (Module['_sqlite3_column_decltype'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_column_decltype = Module['_sqlite3_column_decltype'] =\n        wasmExports['sqlite3_column_decltype'])(a0, a1));\n    var _sqlite3_bind_blob = (Module['_sqlite3_bind_blob'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_blob = Module['_sqlite3_bind_blob'] =\n        wasmExports['sqlite3_bind_blob'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_double = (Module['_sqlite3_bind_double'] = (a0, a1, a2) =>\n      (_sqlite3_bind_double = Module['_sqlite3_bind_double'] =\n        wasmExports['sqlite3_bind_double'])(a0, a1, a2));\n    var _sqlite3_bind_int = (Module['_sqlite3_bind_int'] = (a0, a1, a2) =>\n      (_sqlite3_bind_int = Module['_sqlite3_bind_int'] =\n        wasmExports['sqlite3_bind_int'])(a0, a1, a2));\n    var _sqlite3_bind_int64 = (Module['_sqlite3_bind_int64'] = (a0, a1, a2) =>\n      (_sqlite3_bind_int64 = Module['_sqlite3_bind_int64'] =\n        wasmExports['sqlite3_bind_int64'])(a0, a1, a2));\n    var _sqlite3_bind_null = (Module['_sqlite3_bind_null'] = (a0, a1) =>\n      (_sqlite3_bind_null = Module['_sqlite3_bind_null'] =\n        wasmExports['sqlite3_bind_null'])(a0, a1));\n    var _sqlite3_bind_pointer = (Module['_sqlite3_bind_pointer'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_pointer = Module['_sqlite3_bind_pointer'] =\n        wasmExports['sqlite3_bind_pointer'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_text = (Module['_sqlite3_bind_text'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_text = Module['_sqlite3_bind_text'] =\n        wasmExports['sqlite3_bind_text'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_parameter_count = (Module[\n      '_sqlite3_bind_parameter_count'\n    ] = (a0) =>\n      (_sqlite3_bind_parameter_count = Module['_sqlite3_bind_parameter_count'] =\n        wasmExports['sqlite3_bind_parameter_count'])(a0));\n    var _sqlite3_bind_parameter_name = (Module['_sqlite3_bind_parameter_name'] =\n      (a0, a1) =>\n        (_sqlite3_bind_parameter_name = Module['_sqlite3_bind_parameter_name'] =\n          wasmExports['sqlite3_bind_parameter_name'])(a0, a1));\n    var _sqlite3_bind_parameter_index = (Module[\n      '_sqlite3_bind_parameter_index'\n    ] = (a0, a1) =>\n      (_sqlite3_bind_parameter_index = Module['_sqlite3_bind_parameter_index'] =\n        wasmExports['sqlite3_bind_parameter_index'])(a0, a1));\n    var _sqlite3_db_handle = (Module['_sqlite3_db_handle'] = (a0) =>\n      (_sqlite3_db_handle = Module['_sqlite3_db_handle'] =\n        wasmExports['sqlite3_db_handle'])(a0));\n    var _sqlite3_stmt_readonly = (Module['_sqlite3_stmt_readonly'] = (a0) =>\n      (_sqlite3_stmt_readonly = Module['_sqlite3_stmt_readonly'] =\n        wasmExports['sqlite3_stmt_readonly'])(a0));\n    var _sqlite3_stmt_isexplain = (Module['_sqlite3_stmt_isexplain'] = (a0) =>\n      (_sqlite3_stmt_isexplain = Module['_sqlite3_stmt_isexplain'] =\n        wasmExports['sqlite3_stmt_isexplain'])(a0));\n    var _sqlite3_stmt_explain = (Module['_sqlite3_stmt_explain'] = (a0, a1) =>\n      (_sqlite3_stmt_explain = Module['_sqlite3_stmt_explain'] =\n        wasmExports['sqlite3_stmt_explain'])(a0, a1));\n    var _sqlite3_stmt_busy = (Module['_sqlite3_stmt_busy'] = (a0) =>\n      (_sqlite3_stmt_busy = Module['_sqlite3_stmt_busy'] =\n        wasmExports['sqlite3_stmt_busy'])(a0));\n    var _sqlite3_stmt_status = (Module['_sqlite3_stmt_status'] = (a0, a1, a2) =>\n      (_sqlite3_stmt_status = Module['_sqlite3_stmt_status'] =\n        wasmExports['sqlite3_stmt_status'])(a0, a1, a2));\n    var _sqlite3_sql = (Module['_sqlite3_sql'] = (a0) =>\n      (_sqlite3_sql = Module['_sqlite3_sql'] = wasmExports['sqlite3_sql'])(a0));\n    var _sqlite3_expanded_sql = (Module['_sqlite3_expanded_sql'] = (a0) =>\n      (_sqlite3_expanded_sql = Module['_sqlite3_expanded_sql'] =\n        wasmExports['sqlite3_expanded_sql'])(a0));\n    var _sqlite3_preupdate_old = (Module['_sqlite3_preupdate_old'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_old = Module['_sqlite3_preupdate_old'] =\n        wasmExports['sqlite3_preupdate_old'])(a0, a1, a2));\n    var _sqlite3_preupdate_count = (Module['_sqlite3_preupdate_count'] = (a0) =>\n      (_sqlite3_preupdate_count = Module['_sqlite3_preupdate_count'] =\n        wasmExports['sqlite3_preupdate_count'])(a0));\n    var _sqlite3_preupdate_depth = (Module['_sqlite3_preupdate_depth'] = (a0) =>\n      (_sqlite3_preupdate_depth = Module['_sqlite3_preupdate_depth'] =\n        wasmExports['sqlite3_preupdate_depth'])(a0));\n    var _sqlite3_preupdate_blobwrite = (Module['_sqlite3_preupdate_blobwrite'] =\n      (a0) =>\n        (_sqlite3_preupdate_blobwrite = Module['_sqlite3_preupdate_blobwrite'] =\n          wasmExports['sqlite3_preupdate_blobwrite'])(a0));\n    var _sqlite3_preupdate_new = (Module['_sqlite3_preupdate_new'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_new = Module['_sqlite3_preupdate_new'] =\n        wasmExports['sqlite3_preupdate_new'])(a0, a1, a2));\n    var _sqlite3_value_numeric_type = (Module['_sqlite3_value_numeric_type'] = (\n      a0,\n    ) =>\n      (_sqlite3_value_numeric_type = Module['_sqlite3_value_numeric_type'] =\n        wasmExports['sqlite3_value_numeric_type'])(a0));\n    var _sqlite3_set_authorizer = (Module['_sqlite3_set_authorizer'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_set_authorizer = Module['_sqlite3_set_authorizer'] =\n        wasmExports['sqlite3_set_authorizer'])(a0, a1, a2));\n    var _sqlite3_strglob = (Module['_sqlite3_strglob'] = (a0, a1) =>\n      (_sqlite3_strglob = Module['_sqlite3_strglob'] =\n        wasmExports['sqlite3_strglob'])(a0, a1));\n    var _sqlite3_strlike = (Module['_sqlite3_strlike'] = (a0, a1, a2) =>\n      (_sqlite3_strlike = Module['_sqlite3_strlike'] =\n        wasmExports['sqlite3_strlike'])(a0, a1, a2));\n    var _sqlite3_auto_extension = (Module['_sqlite3_auto_extension'] = (a0) =>\n      (_sqlite3_auto_extension = Module['_sqlite3_auto_extension'] =\n        wasmExports['sqlite3_auto_extension'])(a0));\n    var _sqlite3_cancel_auto_extension = (Module[\n      '_sqlite3_cancel_auto_extension'\n    ] = (a0) =>\n      (_sqlite3_cancel_auto_extension = Module[\n        '_sqlite3_cancel_auto_extension'\n      ] =\n        wasmExports['sqlite3_cancel_auto_extension'])(a0));\n    var _sqlite3_reset_auto_extension = (Module[\n      '_sqlite3_reset_auto_extension'\n    ] = () =>\n      (_sqlite3_reset_auto_extension = Module['_sqlite3_reset_auto_extension'] =\n        wasmExports['sqlite3_reset_auto_extension'])());\n    var _sqlite3_prepare_v3 = (Module['_sqlite3_prepare_v3'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3_prepare_v3 = Module['_sqlite3_prepare_v3'] =\n        wasmExports['sqlite3_prepare_v3'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_create_module = (Module['_sqlite3_create_module'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_create_module = Module['_sqlite3_create_module'] =\n        wasmExports['sqlite3_create_module'])(a0, a1, a2, a3));\n    var _sqlite3_create_module_v2 = (Module['_sqlite3_create_module_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_create_module_v2 = Module['_sqlite3_create_module_v2'] =\n        wasmExports['sqlite3_create_module_v2'])(a0, a1, a2, a3, a4));\n    var _sqlite3_drop_modules = (Module['_sqlite3_drop_modules'] = (a0, a1) =>\n      (_sqlite3_drop_modules = Module['_sqlite3_drop_modules'] =\n        wasmExports['sqlite3_drop_modules'])(a0, a1));\n    var _sqlite3_declare_vtab = (Module['_sqlite3_declare_vtab'] = (a0, a1) =>\n      (_sqlite3_declare_vtab = Module['_sqlite3_declare_vtab'] =\n        wasmExports['sqlite3_declare_vtab'])(a0, a1));\n    var _sqlite3_vtab_on_conflict = (Module['_sqlite3_vtab_on_conflict'] = (\n      a0,\n    ) =>\n      (_sqlite3_vtab_on_conflict = Module['_sqlite3_vtab_on_conflict'] =\n        wasmExports['sqlite3_vtab_on_conflict'])(a0));\n    var _sqlite3_vtab_collation = (Module['_sqlite3_vtab_collation'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_vtab_collation = Module['_sqlite3_vtab_collation'] =\n        wasmExports['sqlite3_vtab_collation'])(a0, a1));\n    var _sqlite3_vtab_in = (Module['_sqlite3_vtab_in'] = (a0, a1, a2) =>\n      (_sqlite3_vtab_in = Module['_sqlite3_vtab_in'] =\n        wasmExports['sqlite3_vtab_in'])(a0, a1, a2));\n    var _sqlite3_vtab_rhs_value = (Module['_sqlite3_vtab_rhs_value'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_vtab_rhs_value = Module['_sqlite3_vtab_rhs_value'] =\n        wasmExports['sqlite3_vtab_rhs_value'])(a0, a1, a2));\n    var _sqlite3_vtab_distinct = (Module['_sqlite3_vtab_distinct'] = (a0) =>\n      (_sqlite3_vtab_distinct = Module['_sqlite3_vtab_distinct'] =\n        wasmExports['sqlite3_vtab_distinct'])(a0));\n    var _sqlite3_keyword_name = (Module['_sqlite3_keyword_name'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_keyword_name = Module['_sqlite3_keyword_name'] =\n        wasmExports['sqlite3_keyword_name'])(a0, a1, a2));\n    var _sqlite3_keyword_count = (Module['_sqlite3_keyword_count'] = () =>\n      (_sqlite3_keyword_count = Module['_sqlite3_keyword_count'] =\n        wasmExports['sqlite3_keyword_count'])());\n    var _sqlite3_keyword_check = (Module['_sqlite3_keyword_check'] = (a0, a1) =>\n      (_sqlite3_keyword_check = Module['_sqlite3_keyword_check'] =\n        wasmExports['sqlite3_keyword_check'])(a0, a1));\n    var _sqlite3_complete = (Module['_sqlite3_complete'] = (a0) =>\n      (_sqlite3_complete = Module['_sqlite3_complete'] =\n        wasmExports['sqlite3_complete'])(a0));\n    var _sqlite3_libversion = (Module['_sqlite3_libversion'] = () =>\n      (_sqlite3_libversion = Module['_sqlite3_libversion'] =\n        wasmExports['sqlite3_libversion'])());\n    var _sqlite3_libversion_number = (Module['_sqlite3_libversion_number'] =\n      () =>\n        (_sqlite3_libversion_number = Module['_sqlite3_libversion_number'] =\n          wasmExports['sqlite3_libversion_number'])());\n    var _sqlite3_shutdown = (Module['_sqlite3_shutdown'] = () =>\n      (_sqlite3_shutdown = Module['_sqlite3_shutdown'] =\n        wasmExports['sqlite3_shutdown'])());\n    var _sqlite3_last_insert_rowid = (Module['_sqlite3_last_insert_rowid'] = (\n      a0,\n    ) =>\n      (_sqlite3_last_insert_rowid = Module['_sqlite3_last_insert_rowid'] =\n        wasmExports['sqlite3_last_insert_rowid'])(a0));\n    var _sqlite3_set_last_insert_rowid = (Module[\n      '_sqlite3_set_last_insert_rowid'\n    ] = (a0, a1) =>\n      (_sqlite3_set_last_insert_rowid = Module[\n        '_sqlite3_set_last_insert_rowid'\n      ] =\n        wasmExports['sqlite3_set_last_insert_rowid'])(a0, a1));\n    var _sqlite3_changes64 = (Module['_sqlite3_changes64'] = (a0) =>\n      (_sqlite3_changes64 = Module['_sqlite3_changes64'] =\n        wasmExports['sqlite3_changes64'])(a0));\n    var _sqlite3_changes = (Module['_sqlite3_changes'] = (a0) =>\n      (_sqlite3_changes = Module['_sqlite3_changes'] =\n        wasmExports['sqlite3_changes'])(a0));\n    var _sqlite3_total_changes64 = (Module['_sqlite3_total_changes64'] = (a0) =>\n      (_sqlite3_total_changes64 = Module['_sqlite3_total_changes64'] =\n        wasmExports['sqlite3_total_changes64'])(a0));\n    var _sqlite3_total_changes = (Module['_sqlite3_total_changes'] = (a0) =>\n      (_sqlite3_total_changes = Module['_sqlite3_total_changes'] =\n        wasmExports['sqlite3_total_changes'])(a0));\n    var _sqlite3_txn_state = (Module['_sqlite3_txn_state'] = (a0, a1) =>\n      (_sqlite3_txn_state = Module['_sqlite3_txn_state'] =\n        wasmExports['sqlite3_txn_state'])(a0, a1));\n    var _sqlite3_close_v2 = (Module['_sqlite3_close_v2'] = (a0) =>\n      (_sqlite3_close_v2 = Module['_sqlite3_close_v2'] =\n        wasmExports['sqlite3_close_v2'])(a0));\n    var _sqlite3_busy_handler = (Module['_sqlite3_busy_handler'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_busy_handler = Module['_sqlite3_busy_handler'] =\n        wasmExports['sqlite3_busy_handler'])(a0, a1, a2));\n    var _sqlite3_progress_handler = (Module['_sqlite3_progress_handler'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_progress_handler = Module['_sqlite3_progress_handler'] =\n        wasmExports['sqlite3_progress_handler'])(a0, a1, a2, a3));\n    var _sqlite3_busy_timeout = (Module['_sqlite3_busy_timeout'] = (a0, a1) =>\n      (_sqlite3_busy_timeout = Module['_sqlite3_busy_timeout'] =\n        wasmExports['sqlite3_busy_timeout'])(a0, a1));\n    var _sqlite3_interrupt = (Module['_sqlite3_interrupt'] = (a0) =>\n      (_sqlite3_interrupt = Module['_sqlite3_interrupt'] =\n        wasmExports['sqlite3_interrupt'])(a0));\n    var _sqlite3_is_interrupted = (Module['_sqlite3_is_interrupted'] = (a0) =>\n      (_sqlite3_is_interrupted = Module['_sqlite3_is_interrupted'] =\n        wasmExports['sqlite3_is_interrupted'])(a0));\n    var _sqlite3_create_function = (Module['_sqlite3_create_function'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n    ) =>\n      (_sqlite3_create_function = Module['_sqlite3_create_function'] =\n        wasmExports['sqlite3_create_function'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n      ));\n    var _sqlite3_create_function_v2 = (Module['_sqlite3_create_function_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n    ) =>\n      (_sqlite3_create_function_v2 = Module['_sqlite3_create_function_v2'] =\n        wasmExports['sqlite3_create_function_v2'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3_create_window_function = (Module[\n      '_sqlite3_create_window_function'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) =>\n      (_sqlite3_create_window_function = Module[\n        '_sqlite3_create_window_function'\n      ] =\n        wasmExports['sqlite3_create_window_function'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n      ));\n    var _sqlite3_overload_function = (Module['_sqlite3_overload_function'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_overload_function = Module['_sqlite3_overload_function'] =\n        wasmExports['sqlite3_overload_function'])(a0, a1, a2));\n    var _sqlite3_trace_v2 = (Module['_sqlite3_trace_v2'] = (a0, a1, a2, a3) =>\n      (_sqlite3_trace_v2 = Module['_sqlite3_trace_v2'] =\n        wasmExports['sqlite3_trace_v2'])(a0, a1, a2, a3));\n    var _sqlite3_commit_hook = (Module['_sqlite3_commit_hook'] = (a0, a1, a2) =>\n      (_sqlite3_commit_hook = Module['_sqlite3_commit_hook'] =\n        wasmExports['sqlite3_commit_hook'])(a0, a1, a2));\n    var _sqlite3_update_hook = (Module['_sqlite3_update_hook'] = (a0, a1, a2) =>\n      (_sqlite3_update_hook = Module['_sqlite3_update_hook'] =\n        wasmExports['sqlite3_update_hook'])(a0, a1, a2));\n    var _sqlite3_rollback_hook = (Module['_sqlite3_rollback_hook'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_rollback_hook = Module['_sqlite3_rollback_hook'] =\n        wasmExports['sqlite3_rollback_hook'])(a0, a1, a2));\n    var _sqlite3_preupdate_hook = (Module['_sqlite3_preupdate_hook'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_hook = Module['_sqlite3_preupdate_hook'] =\n        wasmExports['sqlite3_preupdate_hook'])(a0, a1, a2));\n    var _sqlite3_error_offset = (Module['_sqlite3_error_offset'] = (a0) =>\n      (_sqlite3_error_offset = Module['_sqlite3_error_offset'] =\n        wasmExports['sqlite3_error_offset'])(a0));\n    var _sqlite3_errcode = (Module['_sqlite3_errcode'] = (a0) =>\n      (_sqlite3_errcode = Module['_sqlite3_errcode'] =\n        wasmExports['sqlite3_errcode'])(a0));\n    var _sqlite3_extended_errcode = (Module['_sqlite3_extended_errcode'] = (\n      a0,\n    ) =>\n      (_sqlite3_extended_errcode = Module['_sqlite3_extended_errcode'] =\n        wasmExports['sqlite3_extended_errcode'])(a0));\n    var _sqlite3_errstr = (Module['_sqlite3_errstr'] = (a0) =>\n      (_sqlite3_errstr = Module['_sqlite3_errstr'] =\n        wasmExports['sqlite3_errstr'])(a0));\n    var _sqlite3_limit = (Module['_sqlite3_limit'] = (a0, a1, a2) =>\n      (_sqlite3_limit = Module['_sqlite3_limit'] =\n        wasmExports['sqlite3_limit'])(a0, a1, a2));\n    var _sqlite3_open = (Module['_sqlite3_open'] = (a0, a1) =>\n      (_sqlite3_open = Module['_sqlite3_open'] = wasmExports['sqlite3_open'])(\n        a0,\n        a1,\n      ));\n    var _sqlite3_open_v2 = (Module['_sqlite3_open_v2'] = (a0, a1, a2, a3) =>\n      (_sqlite3_open_v2 = Module['_sqlite3_open_v2'] =\n        wasmExports['sqlite3_open_v2'])(a0, a1, a2, a3));\n    var _sqlite3_create_collation = (Module['_sqlite3_create_collation'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_create_collation = Module['_sqlite3_create_collation'] =\n        wasmExports['sqlite3_create_collation'])(a0, a1, a2, a3, a4));\n    var _sqlite3_create_collation_v2 = (Module['_sqlite3_create_collation_v2'] =\n      (a0, a1, a2, a3, a4, a5) =>\n        (_sqlite3_create_collation_v2 = Module['_sqlite3_create_collation_v2'] =\n          wasmExports['sqlite3_create_collation_v2'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_collation_needed = (Module['_sqlite3_collation_needed'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_collation_needed = Module['_sqlite3_collation_needed'] =\n        wasmExports['sqlite3_collation_needed'])(a0, a1, a2));\n    var _sqlite3_get_autocommit = (Module['_sqlite3_get_autocommit'] = (a0) =>\n      (_sqlite3_get_autocommit = Module['_sqlite3_get_autocommit'] =\n        wasmExports['sqlite3_get_autocommit'])(a0));\n    var _sqlite3_table_column_metadata = (Module[\n      '_sqlite3_table_column_metadata'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) =>\n      (_sqlite3_table_column_metadata = Module[\n        '_sqlite3_table_column_metadata'\n      ] =\n        wasmExports['sqlite3_table_column_metadata'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3_extended_result_codes = (Module[\n      '_sqlite3_extended_result_codes'\n    ] = (a0, a1) =>\n      (_sqlite3_extended_result_codes = Module[\n        '_sqlite3_extended_result_codes'\n      ] =\n        wasmExports['sqlite3_extended_result_codes'])(a0, a1));\n    var _sqlite3_uri_key = (Module['_sqlite3_uri_key'] = (a0, a1) =>\n      (_sqlite3_uri_key = Module['_sqlite3_uri_key'] =\n        wasmExports['sqlite3_uri_key'])(a0, a1));\n    var _sqlite3_uri_int64 = (Module['_sqlite3_uri_int64'] = (a0, a1, a2) =>\n      (_sqlite3_uri_int64 = Module['_sqlite3_uri_int64'] =\n        wasmExports['sqlite3_uri_int64'])(a0, a1, a2));\n    var _sqlite3_db_name = (Module['_sqlite3_db_name'] = (a0, a1) =>\n      (_sqlite3_db_name = Module['_sqlite3_db_name'] =\n        wasmExports['sqlite3_db_name'])(a0, a1));\n    var _sqlite3_db_filename = (Module['_sqlite3_db_filename'] = (a0, a1) =>\n      (_sqlite3_db_filename = Module['_sqlite3_db_filename'] =\n        wasmExports['sqlite3_db_filename'])(a0, a1));\n    var _sqlite3_db_readonly = (Module['_sqlite3_db_readonly'] = (a0, a1) =>\n      (_sqlite3_db_readonly = Module['_sqlite3_db_readonly'] =\n        wasmExports['sqlite3_db_readonly'])(a0, a1));\n    var _sqlite3_compileoption_used = (Module['_sqlite3_compileoption_used'] = (\n      a0,\n    ) =>\n      (_sqlite3_compileoption_used = Module['_sqlite3_compileoption_used'] =\n        wasmExports['sqlite3_compileoption_used'])(a0));\n    var _sqlite3_compileoption_get = (Module['_sqlite3_compileoption_get'] = (\n      a0,\n    ) =>\n      (_sqlite3_compileoption_get = Module['_sqlite3_compileoption_get'] =\n        wasmExports['sqlite3_compileoption_get'])(a0));\n    var _sqlite3session_diff = (Module['_sqlite3session_diff'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3session_diff = Module['_sqlite3session_diff'] =\n        wasmExports['sqlite3session_diff'])(a0, a1, a2, a3));\n    var _sqlite3session_attach = (Module['_sqlite3session_attach'] = (a0, a1) =>\n      (_sqlite3session_attach = Module['_sqlite3session_attach'] =\n        wasmExports['sqlite3session_attach'])(a0, a1));\n    var _sqlite3session_create = (Module['_sqlite3session_create'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_create = Module['_sqlite3session_create'] =\n        wasmExports['sqlite3session_create'])(a0, a1, a2));\n    var _sqlite3session_delete = (Module['_sqlite3session_delete'] = (a0) =>\n      (_sqlite3session_delete = Module['_sqlite3session_delete'] =\n        wasmExports['sqlite3session_delete'])(a0));\n    var _sqlite3session_table_filter = (Module['_sqlite3session_table_filter'] =\n      (a0, a1, a2) =>\n        (_sqlite3session_table_filter = Module['_sqlite3session_table_filter'] =\n          wasmExports['sqlite3session_table_filter'])(a0, a1, a2));\n    var _sqlite3session_changeset = (Module['_sqlite3session_changeset'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_changeset = Module['_sqlite3session_changeset'] =\n        wasmExports['sqlite3session_changeset'])(a0, a1, a2));\n    var _sqlite3session_changeset_strm = (Module[\n      '_sqlite3session_changeset_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_changeset_strm = Module[\n        '_sqlite3session_changeset_strm'\n      ] =\n        wasmExports['sqlite3session_changeset_strm'])(a0, a1, a2));\n    var _sqlite3session_patchset_strm = (Module[\n      '_sqlite3session_patchset_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_patchset_strm = Module['_sqlite3session_patchset_strm'] =\n        wasmExports['sqlite3session_patchset_strm'])(a0, a1, a2));\n    var _sqlite3session_patchset = (Module['_sqlite3session_patchset'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_patchset = Module['_sqlite3session_patchset'] =\n        wasmExports['sqlite3session_patchset'])(a0, a1, a2));\n    var _sqlite3session_enable = (Module['_sqlite3session_enable'] = (a0, a1) =>\n      (_sqlite3session_enable = Module['_sqlite3session_enable'] =\n        wasmExports['sqlite3session_enable'])(a0, a1));\n    var _sqlite3session_indirect = (Module['_sqlite3session_indirect'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3session_indirect = Module['_sqlite3session_indirect'] =\n        wasmExports['sqlite3session_indirect'])(a0, a1));\n    var _sqlite3session_isempty = (Module['_sqlite3session_isempty'] = (a0) =>\n      (_sqlite3session_isempty = Module['_sqlite3session_isempty'] =\n        wasmExports['sqlite3session_isempty'])(a0));\n    var _sqlite3session_memory_used = (Module['_sqlite3session_memory_used'] = (\n      a0,\n    ) =>\n      (_sqlite3session_memory_used = Module['_sqlite3session_memory_used'] =\n        wasmExports['sqlite3session_memory_used'])(a0));\n    var _sqlite3session_object_config = (Module[\n      '_sqlite3session_object_config'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_object_config = Module['_sqlite3session_object_config'] =\n        wasmExports['sqlite3session_object_config'])(a0, a1, a2));\n    var _sqlite3session_changeset_size = (Module[\n      '_sqlite3session_changeset_size'\n    ] = (a0) =>\n      (_sqlite3session_changeset_size = Module[\n        '_sqlite3session_changeset_size'\n      ] =\n        wasmExports['sqlite3session_changeset_size'])(a0));\n    var _sqlite3changeset_start = (Module['_sqlite3changeset_start'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_start = Module['_sqlite3changeset_start'] =\n        wasmExports['sqlite3changeset_start'])(a0, a1, a2));\n    var _sqlite3changeset_start_v2 = (Module['_sqlite3changeset_start_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3changeset_start_v2 = Module['_sqlite3changeset_start_v2'] =\n        wasmExports['sqlite3changeset_start_v2'])(a0, a1, a2, a3));\n    var _sqlite3changeset_start_strm = (Module['_sqlite3changeset_start_strm'] =\n      (a0, a1, a2) =>\n        (_sqlite3changeset_start_strm = Module['_sqlite3changeset_start_strm'] =\n          wasmExports['sqlite3changeset_start_strm'])(a0, a1, a2));\n    var _sqlite3changeset_start_v2_strm = (Module[\n      '_sqlite3changeset_start_v2_strm'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3changeset_start_v2_strm = Module[\n        '_sqlite3changeset_start_v2_strm'\n      ] =\n        wasmExports['sqlite3changeset_start_v2_strm'])(a0, a1, a2, a3));\n    var _sqlite3changeset_next = (Module['_sqlite3changeset_next'] = (a0) =>\n      (_sqlite3changeset_next = Module['_sqlite3changeset_next'] =\n        wasmExports['sqlite3changeset_next'])(a0));\n    var _sqlite3changeset_op = (Module['_sqlite3changeset_op'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3changeset_op = Module['_sqlite3changeset_op'] =\n        wasmExports['sqlite3changeset_op'])(a0, a1, a2, a3, a4));\n    var _sqlite3changeset_pk = (Module['_sqlite3changeset_pk'] = (a0, a1, a2) =>\n      (_sqlite3changeset_pk = Module['_sqlite3changeset_pk'] =\n        wasmExports['sqlite3changeset_pk'])(a0, a1, a2));\n    var _sqlite3changeset_old = (Module['_sqlite3changeset_old'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_old = Module['_sqlite3changeset_old'] =\n        wasmExports['sqlite3changeset_old'])(a0, a1, a2));\n    var _sqlite3changeset_new = (Module['_sqlite3changeset_new'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_new = Module['_sqlite3changeset_new'] =\n        wasmExports['sqlite3changeset_new'])(a0, a1, a2));\n    var _sqlite3changeset_conflict = (Module['_sqlite3changeset_conflict'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_conflict = Module['_sqlite3changeset_conflict'] =\n        wasmExports['sqlite3changeset_conflict'])(a0, a1, a2));\n    var _sqlite3changeset_fk_conflicts = (Module[\n      '_sqlite3changeset_fk_conflicts'\n    ] = (a0, a1) =>\n      (_sqlite3changeset_fk_conflicts = Module[\n        '_sqlite3changeset_fk_conflicts'\n      ] =\n        wasmExports['sqlite3changeset_fk_conflicts'])(a0, a1));\n    var _sqlite3changeset_finalize = (Module['_sqlite3changeset_finalize'] = (\n      a0,\n    ) =>\n      (_sqlite3changeset_finalize = Module['_sqlite3changeset_finalize'] =\n        wasmExports['sqlite3changeset_finalize'])(a0));\n    var _sqlite3changeset_invert = (Module['_sqlite3changeset_invert'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3changeset_invert = Module['_sqlite3changeset_invert'] =\n        wasmExports['sqlite3changeset_invert'])(a0, a1, a2, a3));\n    var _sqlite3changeset_invert_strm = (Module[\n      '_sqlite3changeset_invert_strm'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3changeset_invert_strm = Module['_sqlite3changeset_invert_strm'] =\n        wasmExports['sqlite3changeset_invert_strm'])(a0, a1, a2, a3));\n    var _sqlite3changeset_apply_v2 = (Module['_sqlite3changeset_apply_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n    ) =>\n      (_sqlite3changeset_apply_v2 = Module['_sqlite3changeset_apply_v2'] =\n        wasmExports['sqlite3changeset_apply_v2'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3changeset_apply = (Module['_sqlite3changeset_apply'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3changeset_apply = Module['_sqlite3changeset_apply'] =\n        wasmExports['sqlite3changeset_apply'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changeset_apply_v2_strm = (Module[\n      '_sqlite3changeset_apply_v2_strm'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) =>\n      (_sqlite3changeset_apply_v2_strm = Module[\n        '_sqlite3changeset_apply_v2_strm'\n      ] =\n        wasmExports['sqlite3changeset_apply_v2_strm'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3changeset_apply_strm = (Module['_sqlite3changeset_apply_strm'] =\n      (a0, a1, a2, a3, a4, a5) =>\n        (_sqlite3changeset_apply_strm = Module['_sqlite3changeset_apply_strm'] =\n          wasmExports['sqlite3changeset_apply_strm'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changegroup_new = (Module['_sqlite3changegroup_new'] = (a0) =>\n      (_sqlite3changegroup_new = Module['_sqlite3changegroup_new'] =\n        wasmExports['sqlite3changegroup_new'])(a0));\n    var _sqlite3changegroup_add = (Module['_sqlite3changegroup_add'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changegroup_add = Module['_sqlite3changegroup_add'] =\n        wasmExports['sqlite3changegroup_add'])(a0, a1, a2));\n    var _sqlite3changegroup_output = (Module['_sqlite3changegroup_output'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changegroup_output = Module['_sqlite3changegroup_output'] =\n        wasmExports['sqlite3changegroup_output'])(a0, a1, a2));\n    var _sqlite3changegroup_add_strm = (Module['_sqlite3changegroup_add_strm'] =\n      (a0, a1, a2) =>\n        (_sqlite3changegroup_add_strm = Module['_sqlite3changegroup_add_strm'] =\n          wasmExports['sqlite3changegroup_add_strm'])(a0, a1, a2));\n    var _sqlite3changegroup_output_strm = (Module[\n      '_sqlite3changegroup_output_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3changegroup_output_strm = Module[\n        '_sqlite3changegroup_output_strm'\n      ] =\n        wasmExports['sqlite3changegroup_output_strm'])(a0, a1, a2));\n    var _sqlite3changegroup_delete = (Module['_sqlite3changegroup_delete'] = (\n      a0,\n    ) =>\n      (_sqlite3changegroup_delete = Module['_sqlite3changegroup_delete'] =\n        wasmExports['sqlite3changegroup_delete'])(a0));\n    var _sqlite3changeset_concat = (Module['_sqlite3changeset_concat'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3changeset_concat = Module['_sqlite3changeset_concat'] =\n        wasmExports['sqlite3changeset_concat'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changeset_concat_strm = (Module[\n      '_sqlite3changeset_concat_strm'\n    ] = (a0, a1, a2, a3, a4, a5) =>\n      (_sqlite3changeset_concat_strm = Module['_sqlite3changeset_concat_strm'] =\n        wasmExports['sqlite3changeset_concat_strm'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3session_config = (Module['_sqlite3session_config'] = (a0, a1) =>\n      (_sqlite3session_config = Module['_sqlite3session_config'] =\n        wasmExports['sqlite3session_config'])(a0, a1));\n    var _sqlite3_sourceid = (Module['_sqlite3_sourceid'] = () =>\n      (_sqlite3_sourceid = Module['_sqlite3_sourceid'] =\n        wasmExports['sqlite3_sourceid'])());\n    var _sqlite3__wasm_pstack_ptr = (Module['_sqlite3__wasm_pstack_ptr'] = () =>\n      (_sqlite3__wasm_pstack_ptr = Module['_sqlite3__wasm_pstack_ptr'] =\n        wasmExports['sqlite3__wasm_pstack_ptr'])());\n    var _sqlite3__wasm_pstack_restore = (Module[\n      '_sqlite3__wasm_pstack_restore'\n    ] = (a0) =>\n      (_sqlite3__wasm_pstack_restore = Module['_sqlite3__wasm_pstack_restore'] =\n        wasmExports['sqlite3__wasm_pstack_restore'])(a0));\n    var _sqlite3__wasm_pstack_alloc = (Module['_sqlite3__wasm_pstack_alloc'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_pstack_alloc = Module['_sqlite3__wasm_pstack_alloc'] =\n        wasmExports['sqlite3__wasm_pstack_alloc'])(a0));\n    var _sqlite3__wasm_pstack_remaining = (Module[\n      '_sqlite3__wasm_pstack_remaining'\n    ] = () =>\n      (_sqlite3__wasm_pstack_remaining = Module[\n        '_sqlite3__wasm_pstack_remaining'\n      ] =\n        wasmExports['sqlite3__wasm_pstack_remaining'])());\n    var _sqlite3__wasm_pstack_quota = (Module['_sqlite3__wasm_pstack_quota'] =\n      () =>\n        (_sqlite3__wasm_pstack_quota = Module['_sqlite3__wasm_pstack_quota'] =\n          wasmExports['sqlite3__wasm_pstack_quota'])());\n    var _sqlite3__wasm_db_error = (Module['_sqlite3__wasm_db_error'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_db_error = Module['_sqlite3__wasm_db_error'] =\n        wasmExports['sqlite3__wasm_db_error'])(a0, a1, a2));\n    var _sqlite3__wasm_test_struct = (Module['_sqlite3__wasm_test_struct'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_struct = Module['_sqlite3__wasm_test_struct'] =\n        wasmExports['sqlite3__wasm_test_struct'])(a0));\n    var _sqlite3__wasm_enum_json = (Module['_sqlite3__wasm_enum_json'] = () =>\n      (_sqlite3__wasm_enum_json = Module['_sqlite3__wasm_enum_json'] =\n        wasmExports['sqlite3__wasm_enum_json'])());\n    var _sqlite3__wasm_vfs_unlink = (Module['_sqlite3__wasm_vfs_unlink'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_vfs_unlink = Module['_sqlite3__wasm_vfs_unlink'] =\n        wasmExports['sqlite3__wasm_vfs_unlink'])(a0, a1));\n    var _sqlite3__wasm_db_vfs = (Module['_sqlite3__wasm_db_vfs'] = (a0, a1) =>\n      (_sqlite3__wasm_db_vfs = Module['_sqlite3__wasm_db_vfs'] =\n        wasmExports['sqlite3__wasm_db_vfs'])(a0, a1));\n    var _sqlite3__wasm_db_reset = (Module['_sqlite3__wasm_db_reset'] = (a0) =>\n      (_sqlite3__wasm_db_reset = Module['_sqlite3__wasm_db_reset'] =\n        wasmExports['sqlite3__wasm_db_reset'])(a0));\n    var _sqlite3__wasm_db_export_chunked = (Module[\n      '_sqlite3__wasm_db_export_chunked'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_db_export_chunked = Module[\n        '_sqlite3__wasm_db_export_chunked'\n      ] =\n        wasmExports['sqlite3__wasm_db_export_chunked'])(a0, a1));\n    var _sqlite3__wasm_db_serialize = (Module['_sqlite3__wasm_db_serialize'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3__wasm_db_serialize = Module['_sqlite3__wasm_db_serialize'] =\n        wasmExports['sqlite3__wasm_db_serialize'])(a0, a1, a2, a3, a4));\n    var _sqlite3__wasm_vfs_create_file = (Module[\n      '_sqlite3__wasm_vfs_create_file'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3__wasm_vfs_create_file = Module[\n        '_sqlite3__wasm_vfs_create_file'\n      ] =\n        wasmExports['sqlite3__wasm_vfs_create_file'])(a0, a1, a2, a3));\n    var _sqlite3__wasm_posix_create_file = (Module[\n      '_sqlite3__wasm_posix_create_file'\n    ] = (a0, a1, a2) =>\n      (_sqlite3__wasm_posix_create_file = Module[\n        '_sqlite3__wasm_posix_create_file'\n      ] =\n        wasmExports['sqlite3__wasm_posix_create_file'])(a0, a1, a2));\n    var _sqlite3__wasm_kvvfsMakeKeyOnPstack = (Module[\n      '_sqlite3__wasm_kvvfsMakeKeyOnPstack'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module[\n        '_sqlite3__wasm_kvvfsMakeKeyOnPstack'\n      ] =\n        wasmExports['sqlite3__wasm_kvvfsMakeKeyOnPstack'])(a0, a1));\n    var _sqlite3__wasm_kvvfs_methods = (Module['_sqlite3__wasm_kvvfs_methods'] =\n      () =>\n        (_sqlite3__wasm_kvvfs_methods = Module['_sqlite3__wasm_kvvfs_methods'] =\n          wasmExports['sqlite3__wasm_kvvfs_methods'])());\n    var _sqlite3__wasm_vtab_config = (Module['_sqlite3__wasm_vtab_config'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_vtab_config = Module['_sqlite3__wasm_vtab_config'] =\n        wasmExports['sqlite3__wasm_vtab_config'])(a0, a1, a2));\n    var _sqlite3__wasm_db_config_ip = (Module['_sqlite3__wasm_db_config_ip'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3__wasm_db_config_ip = Module['_sqlite3__wasm_db_config_ip'] =\n        wasmExports['sqlite3__wasm_db_config_ip'])(a0, a1, a2, a3));\n    var _sqlite3__wasm_db_config_pii = (Module['_sqlite3__wasm_db_config_pii'] =\n      (a0, a1, a2, a3, a4) =>\n        (_sqlite3__wasm_db_config_pii = Module['_sqlite3__wasm_db_config_pii'] =\n          wasmExports['sqlite3__wasm_db_config_pii'])(a0, a1, a2, a3, a4));\n    var _sqlite3__wasm_db_config_s = (Module['_sqlite3__wasm_db_config_s'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_db_config_s = Module['_sqlite3__wasm_db_config_s'] =\n        wasmExports['sqlite3__wasm_db_config_s'])(a0, a1, a2));\n    var _sqlite3__wasm_config_i = (Module['_sqlite3__wasm_config_i'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_config_i = Module['_sqlite3__wasm_config_i'] =\n        wasmExports['sqlite3__wasm_config_i'])(a0, a1));\n    var _sqlite3__wasm_config_ii = (Module['_sqlite3__wasm_config_ii'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_config_ii = Module['_sqlite3__wasm_config_ii'] =\n        wasmExports['sqlite3__wasm_config_ii'])(a0, a1, a2));\n    var _sqlite3__wasm_config_j = (Module['_sqlite3__wasm_config_j'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_config_j = Module['_sqlite3__wasm_config_j'] =\n        wasmExports['sqlite3__wasm_config_j'])(a0, a1));\n    var _sqlite3__wasm_qfmt_token = (Module['_sqlite3__wasm_qfmt_token'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_qfmt_token = Module['_sqlite3__wasm_qfmt_token'] =\n        wasmExports['sqlite3__wasm_qfmt_token'])(a0, a1));\n    var _sqlite3__wasm_init_wasmfs = (Module['_sqlite3__wasm_init_wasmfs'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_init_wasmfs = Module['_sqlite3__wasm_init_wasmfs'] =\n        wasmExports['sqlite3__wasm_init_wasmfs'])(a0));\n    var _sqlite3__wasm_test_intptr = (Module['_sqlite3__wasm_test_intptr'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_intptr = Module['_sqlite3__wasm_test_intptr'] =\n        wasmExports['sqlite3__wasm_test_intptr'])(a0));\n    var _sqlite3__wasm_test_voidptr = (Module['_sqlite3__wasm_test_voidptr'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_voidptr = Module['_sqlite3__wasm_test_voidptr'] =\n        wasmExports['sqlite3__wasm_test_voidptr'])(a0));\n    var _sqlite3__wasm_test_int64_max = (Module[\n      '_sqlite3__wasm_test_int64_max'\n    ] = () =>\n      (_sqlite3__wasm_test_int64_max = Module['_sqlite3__wasm_test_int64_max'] =\n        wasmExports['sqlite3__wasm_test_int64_max'])());\n    var _sqlite3__wasm_test_int64_min = (Module[\n      '_sqlite3__wasm_test_int64_min'\n    ] = () =>\n      (_sqlite3__wasm_test_int64_min = Module['_sqlite3__wasm_test_int64_min'] =\n        wasmExports['sqlite3__wasm_test_int64_min'])());\n    var _sqlite3__wasm_test_int64_times2 = (Module[\n      '_sqlite3__wasm_test_int64_times2'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_int64_times2 = Module[\n        '_sqlite3__wasm_test_int64_times2'\n      ] =\n        wasmExports['sqlite3__wasm_test_int64_times2'])(a0));\n    var _sqlite3__wasm_test_int64_minmax = (Module[\n      '_sqlite3__wasm_test_int64_minmax'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_test_int64_minmax = Module[\n        '_sqlite3__wasm_test_int64_minmax'\n      ] =\n        wasmExports['sqlite3__wasm_test_int64_minmax'])(a0, a1));\n    var _sqlite3__wasm_test_int64ptr = (Module['_sqlite3__wasm_test_int64ptr'] =\n      (a0) =>\n        (_sqlite3__wasm_test_int64ptr = Module['_sqlite3__wasm_test_int64ptr'] =\n          wasmExports['sqlite3__wasm_test_int64ptr'])(a0));\n    var _sqlite3__wasm_test_stack_overflow = (Module[\n      '_sqlite3__wasm_test_stack_overflow'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_stack_overflow = Module[\n        '_sqlite3__wasm_test_stack_overflow'\n      ] =\n        wasmExports['sqlite3__wasm_test_stack_overflow'])(a0));\n    var _sqlite3__wasm_test_str_hello = (Module[\n      '_sqlite3__wasm_test_str_hello'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_str_hello = Module['_sqlite3__wasm_test_str_hello'] =\n        wasmExports['sqlite3__wasm_test_str_hello'])(a0));\n    var _sqlite3__wasm_SQLTester_strglob = (Module[\n      '_sqlite3__wasm_SQLTester_strglob'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_SQLTester_strglob = Module[\n        '_sqlite3__wasm_SQLTester_strglob'\n      ] =\n        wasmExports['sqlite3__wasm_SQLTester_strglob'])(a0, a1));\n    var _malloc = (Module['_malloc'] = (a0) =>\n      (_malloc = Module['_malloc'] = wasmExports['malloc'])(a0));\n    var _free = (Module['_free'] = (a0) =>\n      (_free = Module['_free'] = wasmExports['free'])(a0));\n    var _realloc = (Module['_realloc'] = (a0, a1) =>\n      (_realloc = Module['_realloc'] = wasmExports['realloc'])(a0, a1));\n    var _emscripten_builtin_memalign = (a0, a1) =>\n      (_emscripten_builtin_memalign =\n        wasmExports['emscripten_builtin_memalign'])(a0, a1);\n    var __emscripten_stack_restore = (a0) =>\n      (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(\n        a0,\n      );\n    var __emscripten_stack_alloc = (a0) =>\n      (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\n    var _emscripten_stack_get_current = () =>\n      (_emscripten_stack_get_current =\n        wasmExports['emscripten_stack_get_current'])();\n\n    Module['wasmMemory'] = wasmMemory;\n\n    var calledRun;\n    var calledPrerun;\n\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n\n      if (!calledPrerun) {\n        calledPrerun = 1;\n        preRun();\n\n        if (runDependencies > 0) {\n          return;\n        }\n      }\n\n      function doRun() {\n        if (calledRun) return;\n        calledRun = 1;\n        Module['calledRun'] = 1;\n\n        if (ABORT) return;\n\n        initRuntime();\n\n        readyPromiseResolve(Module);\n        Module['onRuntimeInitialized']?.();\n\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(() => {\n          setTimeout(() => Module['setStatus'](''), 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function')\n        Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    run();\n\n    Module.runSQLite3PostLoadInit = function (EmscriptenModule) {\n      'use strict';\n\n      'use strict';\n      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(\n        apiConfig = globalThis.sqlite3ApiConfig ||\n          sqlite3ApiBootstrap.defaultConfig,\n      ) {\n        if (sqlite3ApiBootstrap.sqlite3) {\n          (sqlite3ApiBootstrap.sqlite3.config || console).warn(\n            'sqlite3ApiBootstrap() called multiple times.',\n            'Config and external initializers are ignored on calls after the first.',\n          );\n          return sqlite3ApiBootstrap.sqlite3;\n        }\n        const config = Object.assign(\n          Object.create(null),\n          {\n            exports: undefined,\n            memory: undefined,\n            bigIntEnabled: (() => {\n              if ('undefined' !== typeof Module) {\n                if (!!Module.HEAPU64) return true;\n              }\n              return !!globalThis.BigInt64Array;\n            })(),\n            debug: console.debug.bind(console),\n            warn: console.warn.bind(console),\n            error: console.error.bind(console),\n            log: console.log.bind(console),\n            wasmfsOpfsDir: '/opfs',\n\n            useStdAlloc: false,\n          },\n          apiConfig || {},\n        );\n\n        Object.assign(\n          config,\n          {\n            allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',\n            deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',\n            reallocExportName: config.useStdAlloc\n              ? 'realloc'\n              : 'sqlite3_realloc',\n          },\n          config,\n        );\n\n        ['exports', 'memory', 'wasmfsOpfsDir'].forEach((k) => {\n          if ('function' === typeof config[k]) {\n            config[k] = config[k]();\n          }\n        });\n\n        delete globalThis.sqlite3ApiConfig;\n        delete sqlite3ApiBootstrap.defaultConfig;\n\n        const capi = Object.create(null);\n\n        const wasm = Object.create(null);\n\n        const __rcStr = (rc) => {\n          return (\n            (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc)) ||\n            'Unknown result code #' + rc\n          );\n        };\n\n        const __isInt = (n) => 'number' === typeof n && n === (n | 0);\n\n        class SQLite3Error extends Error {\n          constructor(...args) {\n            let rc;\n            if (args.length) {\n              if (__isInt(args[0])) {\n                rc = args[0];\n                if (1 === args.length) {\n                  super(__rcStr(args[0]));\n                } else {\n                  const rcStr = __rcStr(rc);\n                  if ('object' === typeof args[1]) {\n                    super(rcStr, args[1]);\n                  } else {\n                    args[0] = rcStr + ':';\n                    super(args.join(' '));\n                  }\n                }\n              } else {\n                if (2 === args.length && 'object' === typeof args[1]) {\n                  super(...args);\n                } else {\n                  super(args.join(' '));\n                }\n              }\n            }\n            this.resultCode = rc || capi.SQLITE_ERROR;\n            this.name = 'SQLite3Error';\n          }\n        }\n\n        SQLite3Error.toss = (...args) => {\n          throw new SQLite3Error(...args);\n        };\n        const toss3 = SQLite3Error.toss;\n\n        if (config.wasmfsOpfsDir && !/^\\/[^/]+$/.test(config.wasmfsOpfsDir)) {\n          toss3(\n            \"config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.\",\n          );\n        }\n\n        const isInt32 = (n) => {\n          return (\n            'bigint' !== typeof n &&\n            !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648)\n          );\n        };\n\n        const bigIntFits64 = function f(b) {\n          if (!f._max) {\n            f._max = BigInt('0x7fffffffffffffff');\n            f._min = ~f._max;\n          }\n          return b >= f._min && b <= f._max;\n        };\n\n        const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;\n\n        const bigIntFitsDouble = function f(b) {\n          if (!f._min) {\n            f._min = Number.MIN_SAFE_INTEGER;\n            f._max = Number.MAX_SAFE_INTEGER;\n          }\n          return b >= f._min && b <= f._max;\n        };\n\n        const isTypedArray = (v) => {\n          return v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)\n            ? v\n            : false;\n        };\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n\n        const isSharedTypedArray = (aTypedArray) =>\n          aTypedArray.buffer instanceof __SAB;\n\n        const typedArrayPart = (aTypedArray, begin, end) => {\n          return isSharedTypedArray(aTypedArray)\n            ? aTypedArray.slice(begin, end)\n            : aTypedArray.subarray(begin, end);\n        };\n\n        const isBindableTypedArray = (v) => {\n          return (\n            v &&\n            (v instanceof Uint8Array ||\n              v instanceof Int8Array ||\n              v instanceof ArrayBuffer)\n          );\n        };\n\n        const isSQLableTypedArray = (v) => {\n          return (\n            v &&\n            (v instanceof Uint8Array ||\n              v instanceof Int8Array ||\n              v instanceof ArrayBuffer)\n          );\n        };\n\n        const affirmBindableTypedArray = (v) => {\n          return (\n            isBindableTypedArray(v) ||\n            toss3('Value is not of a supported TypedArray type.')\n          );\n        };\n\n        const utf8Decoder = new TextDecoder('utf-8');\n\n        const typedArrayToString = function (typedArray, begin, end) {\n          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));\n        };\n\n        const flexibleString = function (v) {\n          if (isSQLableTypedArray(v)) {\n            return typedArrayToString(\n              v instanceof ArrayBuffer ? new Uint8Array(v) : v,\n            );\n          } else if (Array.isArray(v)) return v.join('');\n          else if (wasm.isPtr(v)) v = wasm.cstrToJs(v);\n          return v;\n        };\n\n        class WasmAllocError extends Error {\n          constructor(...args) {\n            if (2 === args.length && 'object' === typeof args[1]) {\n              super(...args);\n            } else if (args.length) {\n              super(args.join(' '));\n            } else {\n              super('Allocation failed.');\n            }\n            this.resultCode = capi.SQLITE_NOMEM;\n            this.name = 'WasmAllocError';\n          }\n        }\n\n        WasmAllocError.toss = (...args) => {\n          throw new WasmAllocError(...args);\n        };\n\n        Object.assign(capi, {\n          sqlite3_bind_blob: undefined,\n\n          sqlite3_bind_text: undefined,\n\n          sqlite3_create_function_v2: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n            xDestroy,\n          ) => {},\n\n          sqlite3_create_function: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n          ) => {},\n\n          sqlite3_create_window_function: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xStep,\n            xFinal,\n            xValue,\n            xInverse,\n            xDestroy,\n          ) => {},\n\n          sqlite3_prepare_v3: (\n            dbPtr,\n            sql,\n            sqlByteLen,\n            prepFlags,\n            stmtPtrPtr,\n            strPtrPtr,\n          ) => {},\n\n          sqlite3_prepare_v2: (\n            dbPtr,\n            sql,\n            sqlByteLen,\n            stmtPtrPtr,\n            strPtrPtr,\n          ) => {},\n\n          sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg) => {},\n\n          sqlite3_randomness: (n, outPtr) => {},\n        });\n\n        const util = {\n          affirmBindableTypedArray,\n          flexibleString,\n          bigIntFits32,\n          bigIntFits64,\n          bigIntFitsDouble,\n          isBindableTypedArray,\n          isInt32,\n          isSQLableTypedArray,\n          isTypedArray,\n          typedArrayToString,\n          isUIThread: () =>\n            globalThis.window === globalThis && !!globalThis.document,\n\n          isSharedTypedArray,\n          toss: function (...args) {\n            throw new Error(args.join(' '));\n          },\n          toss3,\n          typedArrayPart,\n\n          affirmDbHeader: function (bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            const header = 'SQLite format 3';\n            if (header.length > bytes.byteLength) {\n              toss3('Input does not contain an SQLite3 database header.');\n            }\n            for (let i = 0; i < header.length; ++i) {\n              if (header.charCodeAt(i) !== bytes[i]) {\n                toss3('Input does not contain an SQLite3 database header.');\n              }\n            }\n          },\n\n          affirmIsDb: function (bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            const n = bytes.byteLength;\n            if (n < 512 || n % 512 !== 0) {\n              toss3('Byte array size', n, 'is invalid for an SQLite3 db.');\n            }\n            util.affirmDbHeader(bytes);\n          },\n        };\n\n        Object.assign(wasm, {\n          ptrSizeof: config.wasmPtrSizeof || 4,\n\n          ptrIR: config.wasmPtrIR || 'i32',\n\n          bigIntEnabled: !!config.bigIntEnabled,\n\n          exports:\n            config.exports ||\n            toss3('Missing API config.exports (WASM module exports).'),\n\n          memory:\n            config.memory ||\n            config.exports['memory'] ||\n            toss3(\n              'API config object requires a WebAssembly.Memory object',\n              'in either config.exports.memory (exported)',\n              'or config.memory (imported).',\n            ),\n\n          alloc: undefined,\n\n          realloc: undefined,\n\n          dealloc: undefined,\n        });\n\n        wasm.allocFromTypedArray = function (srcTypedArray) {\n          if (srcTypedArray instanceof ArrayBuffer) {\n            srcTypedArray = new Uint8Array(srcTypedArray);\n          }\n          affirmBindableTypedArray(srcTypedArray);\n          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);\n          wasm\n            .heapForSize(srcTypedArray.constructor)\n            .set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);\n          return pRet;\n        };\n\n        {\n          const keyAlloc = config.allocExportName,\n            keyDealloc = config.deallocExportName,\n            keyRealloc = config.reallocExportName;\n          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {\n            const f = wasm.exports[key];\n            if (!(f instanceof Function))\n              toss3('Missing required exports[', key, '] function.');\n          }\n\n          wasm.alloc = function f(n) {\n            return (\n              f.impl(n) ||\n              WasmAllocError.toss('Failed to allocate', n, ' bytes.')\n            );\n          };\n          wasm.alloc.impl = wasm.exports[keyAlloc];\n          wasm.realloc = function f(m, n) {\n            const m2 = f.impl(m, n);\n            return n\n              ? m2 || WasmAllocError.toss('Failed to reallocate', n, ' bytes.')\n              : 0;\n          };\n          wasm.realloc.impl = wasm.exports[keyRealloc];\n          wasm.dealloc = wasm.exports[keyDealloc];\n        }\n\n        wasm.compileOptionUsed = function f(optName) {\n          if (!arguments.length) {\n            if (f._result) return f._result;\n            else if (!f._opt) {\n              f._rx = /^([^=]+)=(.+)/;\n              f._rxInt = /^-?\\d+$/;\n              f._opt = function (opt, rv) {\n                const m = f._rx.exec(opt);\n                rv[0] = m ? m[1] : opt;\n                rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;\n              };\n            }\n            const rc = {},\n              ov = [0, 0];\n            let i = 0,\n              k;\n            while ((k = capi.sqlite3_compileoption_get(i++))) {\n              f._opt(k, ov);\n              rc[ov[0]] = ov[1];\n            }\n            return (f._result = rc);\n          } else if (Array.isArray(optName)) {\n            const rc = {};\n            optName.forEach((v) => {\n              rc[v] = capi.sqlite3_compileoption_used(v);\n            });\n            return rc;\n          } else if ('object' === typeof optName) {\n            Object.keys(optName).forEach((k) => {\n              optName[k] = capi.sqlite3_compileoption_used(k);\n            });\n            return optName;\n          }\n          return 'string' === typeof optName\n            ? !!capi.sqlite3_compileoption_used(optName)\n            : false;\n        };\n\n        wasm.pstack = Object.assign(Object.create(null), {\n          restore: wasm.exports.sqlite3__wasm_pstack_restore,\n\n          alloc: function (n) {\n            if ('string' === typeof n && !(n = wasm.sizeofIR(n))) {\n              WasmAllocError.toss(\n                'Invalid value for pstack.alloc(',\n                arguments[0],\n                ')',\n              );\n            }\n            return (\n              wasm.exports.sqlite3__wasm_pstack_alloc(n) ||\n              WasmAllocError.toss(\n                'Could not allocate',\n                n,\n                'bytes from the pstack.',\n              )\n            );\n          },\n\n          allocChunks: function (n, sz) {\n            if ('string' === typeof sz && !(sz = wasm.sizeofIR(sz))) {\n              WasmAllocError.toss(\n                'Invalid size value for allocChunks(',\n                arguments[1],\n                ')',\n              );\n            }\n            const mem = wasm.pstack.alloc(n * sz);\n            const rc = [];\n            let i = 0,\n              offset = 0;\n            for (; i < n; ++i, offset += sz) rc.push(mem + offset);\n            return rc;\n          },\n\n          allocPtr: (n = 1, safePtrSize = true) => {\n            return 1 === n\n              ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)\n              : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);\n          },\n\n          call: function (f) {\n            const stackPos = wasm.pstack.pointer;\n            try {\n              return f(sqlite3);\n            } finally {\n              wasm.pstack.restore(stackPos);\n            }\n          },\n        });\n        Object.defineProperties(wasm.pstack, {\n          pointer: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_ptr,\n          },\n\n          quota: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_quota,\n          },\n\n          remaining: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_remaining,\n          },\n        });\n\n        capi.sqlite3_randomness = (...args) => {\n          if (\n            1 === args.length &&\n            util.isTypedArray(args[0]) &&\n            1 === args[0].BYTES_PER_ELEMENT\n          ) {\n            const ta = args[0];\n            if (0 === ta.byteLength) {\n              wasm.exports.sqlite3_randomness(0, 0);\n              return ta;\n            }\n            const stack = wasm.pstack.pointer;\n            try {\n              let n = ta.byteLength,\n                offset = 0;\n              const r = wasm.exports.sqlite3_randomness;\n              const heap = wasm.heap8u();\n              const nAlloc = n < 512 ? n : 512;\n              const ptr = wasm.pstack.alloc(nAlloc);\n              do {\n                const j = n > nAlloc ? nAlloc : n;\n                r(j, ptr);\n                ta.set(typedArrayPart(heap, ptr, ptr + j), offset);\n                n -= j;\n                offset += j;\n              } while (n > 0);\n            } catch (e) {\n              console.error(\n                'Highly unexpected (and ignored!) ' +\n                  'exception in sqlite3_randomness():',\n                e,\n              );\n            } finally {\n              wasm.pstack.restore(stack);\n            }\n            return ta;\n          }\n          wasm.exports.sqlite3_randomness(...args);\n        };\n\n        let __wasmfsOpfsDir = undefined;\n\n        capi.sqlite3_wasmfs_opfs_dir = function () {\n          if (undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;\n\n          const pdir = config.wasmfsOpfsDir;\n          if (\n            !pdir ||\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle\n          ) {\n            return (__wasmfsOpfsDir = '');\n          }\n          try {\n            if (\n              pdir &&\n              0 ===\n                wasm.xCallWrapped(\n                  'sqlite3__wasm_init_wasmfs',\n                  'i32',\n                  ['string'],\n                  pdir,\n                )\n            ) {\n              return (__wasmfsOpfsDir = pdir);\n            } else {\n              return (__wasmfsOpfsDir = '');\n            }\n          } catch (e) {\n            return (__wasmfsOpfsDir = '');\n          }\n        };\n\n        capi.sqlite3_wasmfs_filename_is_persistent = function (name) {\n          const p = capi.sqlite3_wasmfs_opfs_dir();\n          return p && name ? name.startsWith(p + '/') : false;\n        };\n\n        capi.sqlite3_js_db_uses_vfs = function (pDb, vfsName, dbName = 0) {\n          try {\n            const pK = capi.sqlite3_vfs_find(vfsName);\n            if (!pK) return false;\n            else if (!pDb) {\n              return pK === capi.sqlite3_vfs_find(0) ? pK : false;\n            } else {\n              return pK === capi.sqlite3_js_db_vfs(pDb, dbName) ? pK : false;\n            }\n          } catch (e) {\n            return false;\n          }\n        };\n\n        capi.sqlite3_js_vfs_list = function () {\n          const rc = [];\n          let pVfs = capi.sqlite3_vfs_find(0);\n          while (pVfs) {\n            const oVfs = new capi.sqlite3_vfs(pVfs);\n            rc.push(wasm.cstrToJs(oVfs.$zName));\n            pVfs = oVfs.$pNext;\n            oVfs.dispose();\n          }\n          return rc;\n        };\n\n        capi.sqlite3_js_db_export = function (pDb, schema = 0) {\n          pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);\n          if (!pDb) toss3('Invalid sqlite3* argument.');\n          if (!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');\n          const scope = wasm.scopedAllocPush();\n          let pOut;\n          try {\n            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);\n            const ppOut = pSize + 8;\n\n            const zSchema = schema\n              ? wasm.isPtr(schema)\n                ? schema\n                : wasm.scopedAllocCString('' + schema)\n              : 0;\n            let rc = wasm.exports.sqlite3__wasm_db_serialize(\n              pDb,\n              zSchema,\n              ppOut,\n              pSize,\n              0,\n            );\n            if (rc) {\n              toss3(\n                'Database serialization failed with code',\n                sqlite3.capi.sqlite3_js_rc_str(rc),\n              );\n            }\n            pOut = wasm.peekPtr(ppOut);\n            const nOut = wasm.peek(pSize, 'i64');\n            rc = nOut\n              ? wasm.heap8u().slice(pOut, pOut + Number(nOut))\n              : new Uint8Array();\n            return rc;\n          } finally {\n            if (pOut) wasm.exports.sqlite3_free(pOut);\n            wasm.scopedAllocPop(scope);\n          }\n        };\n\n        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) =>\n          util.sqlite3__wasm_db_vfs(dbPointer, dbName);\n\n        capi.sqlite3_js_aggregate_context = (pCtx, n) => {\n          return (\n            capi.sqlite3_aggregate_context(pCtx, n) ||\n            (n\n              ? WasmAllocError.toss(\n                  'Cannot allocate',\n                  n,\n                  'bytes for sqlite3_aggregate_context()',\n                )\n              : 0)\n          );\n        };\n\n        capi.sqlite3_js_posix_create_file = function (filename, data, dataLen) {\n          let pData;\n          if (data && wasm.isPtr(data)) {\n            pData = data;\n          } else if (\n            data instanceof ArrayBuffer ||\n            data instanceof Uint8Array\n          ) {\n            pData = wasm.allocFromTypedArray(data);\n            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {\n              dataLen = data.byteLength;\n            }\n          } else {\n            SQLite3Error.toss(\n              'Invalid 2nd argument for sqlite3_js_posix_create_file().',\n            );\n          }\n          try {\n            if (!util.isInt32(dataLen) || dataLen < 0) {\n              SQLite3Error.toss(\n                'Invalid 3rd argument for sqlite3_js_posix_create_file().',\n              );\n            }\n            const rc = util.sqlite3__wasm_posix_create_file(\n              filename,\n              pData,\n              dataLen,\n            );\n            if (rc)\n              SQLite3Error.toss(\n                'Creation of file failed with sqlite3 result code',\n                capi.sqlite3_js_rc_str(rc),\n              );\n          } finally {\n            wasm.dealloc(pData);\n          }\n        };\n\n        capi.sqlite3_js_vfs_create_file = function (\n          vfs,\n          filename,\n          data,\n          dataLen,\n        ) {\n          config.warn(\n            'sqlite3_js_vfs_create_file() is deprecated and',\n            'should be avoided because it can lead to C-level crashes.',\n            'See its documentation for alternative options.',\n          );\n          let pData;\n          if (data) {\n            if (wasm.isPtr(data)) {\n              pData = data;\n            } else if (data instanceof ArrayBuffer) {\n              data = new Uint8Array(data);\n            }\n            if (data instanceof Uint8Array) {\n              pData = wasm.allocFromTypedArray(data);\n              if (\n                arguments.length < 4 ||\n                !util.isInt32(dataLen) ||\n                dataLen < 0\n              ) {\n                dataLen = data.byteLength;\n              }\n            } else {\n              SQLite3Error.toss(\n                'Invalid 3rd argument type for sqlite3_js_vfs_create_file().',\n              );\n            }\n          } else {\n            pData = 0;\n          }\n          if (!util.isInt32(dataLen) || dataLen < 0) {\n            wasm.dealloc(pData);\n            SQLite3Error.toss(\n              'Invalid 4th argument for sqlite3_js_vfs_create_file().',\n            );\n          }\n          try {\n            const rc = util.sqlite3__wasm_vfs_create_file(\n              vfs,\n              filename,\n              pData,\n              dataLen,\n            );\n            if (rc)\n              SQLite3Error.toss(\n                'Creation of file failed with sqlite3 result code',\n                capi.sqlite3_js_rc_str(rc),\n              );\n          } finally {\n            wasm.dealloc(pData);\n          }\n        };\n\n        capi.sqlite3_js_sql_to_string = (sql) => {\n          if ('string' === typeof sql) {\n            return sql;\n          }\n          const x = flexibleString(v);\n          return x === v ? undefined : x;\n        };\n\n        if (util.isUIThread()) {\n          const __kvvfsInfo = function (which) {\n            const rc = Object.create(null);\n            rc.prefix = 'kvvfs-' + which;\n            rc.stores = [];\n            if ('session' === which || '' === which)\n              rc.stores.push(globalThis.sessionStorage);\n            if ('local' === which || '' === which)\n              rc.stores.push(globalThis.localStorage);\n            return rc;\n          };\n\n          capi.sqlite3_js_kvvfs_clear = function (which = '') {\n            let rc = 0;\n            const kvinfo = __kvvfsInfo(which);\n            kvinfo.stores.forEach((s) => {\n              const toRm = [];\n              let i;\n              for (i = 0; i < s.length; ++i) {\n                const k = s.key(i);\n                if (k.startsWith(kvinfo.prefix)) toRm.push(k);\n              }\n              toRm.forEach((kk) => s.removeItem(kk));\n              rc += toRm.length;\n            });\n            return rc;\n          };\n\n          capi.sqlite3_js_kvvfs_size = function (which = '') {\n            let sz = 0;\n            const kvinfo = __kvvfsInfo(which);\n            kvinfo.stores.forEach((s) => {\n              let i;\n              for (i = 0; i < s.length; ++i) {\n                const k = s.key(i);\n                if (k.startsWith(kvinfo.prefix)) {\n                  sz += k.length;\n                  sz += s.getItem(k).length;\n                }\n              }\n            });\n            return sz * 2;\n          };\n        }\n\n        capi.sqlite3_db_config = function (pDb, op, ...args) {\n          switch (op) {\n            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:\n            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:\n            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:\n            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:\n            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:\n            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:\n            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:\n            case capi.SQLITE_DBCONFIG_RESET_DATABASE:\n            case capi.SQLITE_DBCONFIG_DEFENSIVE:\n            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:\n            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:\n            case capi.SQLITE_DBCONFIG_DQS_DML:\n            case capi.SQLITE_DBCONFIG_DQS_DDL:\n            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:\n            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:\n            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:\n            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:\n            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:\n            case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE:\n            case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE:\n            case capi.SQLITE_DBCONFIG_ENABLE_COMMENTS:\n              if (!this.ip) {\n                this.ip = wasm.xWrap('sqlite3__wasm_db_config_ip', 'int', [\n                  'sqlite3*',\n                  'int',\n                  'int',\n                  '*',\n                ]);\n              }\n              return this.ip(pDb, op, args[0], args[1] || 0);\n            case capi.SQLITE_DBCONFIG_LOOKASIDE:\n              if (!this.pii) {\n                this.pii = wasm.xWrap('sqlite3__wasm_db_config_pii', 'int', [\n                  'sqlite3*',\n                  'int',\n                  '*',\n                  'int',\n                  'int',\n                ]);\n              }\n              return this.pii(pDb, op, args[0], args[1], args[2]);\n            case capi.SQLITE_DBCONFIG_MAINDBNAME:\n              if (!this.s) {\n                this.s = wasm.xWrap('sqlite3__wasm_db_config_s', 'int', [\n                  'sqlite3*',\n                  'int',\n                  'string:static',\n                ]);\n              }\n              return this.s(pDb, op, args[0]);\n            default:\n              return capi.SQLITE_MISUSE;\n          }\n        }.bind(Object.create(null));\n\n        capi.sqlite3_value_to_js = function (\n          pVal,\n          throwIfCannotConvert = true,\n        ) {\n          let arg;\n          const valType = capi.sqlite3_value_type(pVal);\n          switch (valType) {\n            case capi.SQLITE_INTEGER:\n              if (wasm.bigIntEnabled) {\n                arg = capi.sqlite3_value_int64(pVal);\n                if (util.bigIntFitsDouble(arg)) arg = Number(arg);\n              } else arg = capi.sqlite3_value_double(pVal);\n              break;\n            case capi.SQLITE_FLOAT:\n              arg = capi.sqlite3_value_double(pVal);\n              break;\n            case capi.SQLITE_TEXT:\n              arg = capi.sqlite3_value_text(pVal);\n              break;\n            case capi.SQLITE_BLOB: {\n              const n = capi.sqlite3_value_bytes(pVal);\n              const pBlob = capi.sqlite3_value_blob(pVal);\n              if (n && !pBlob)\n                sqlite3.WasmAllocError.toss(\n                  'Cannot allocate memory for blob argument of',\n                  n,\n                  'byte(s)',\n                );\n              arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;\n              break;\n            }\n            case capi.SQLITE_NULL:\n              arg = null;\n              break;\n            default:\n              if (throwIfCannotConvert) {\n                toss3(\n                  capi.SQLITE_MISMATCH,\n                  'Unhandled sqlite3_value_type():',\n                  valType,\n                );\n              }\n              arg = undefined;\n          }\n          return arg;\n        };\n\n        capi.sqlite3_values_to_js = function (\n          argc,\n          pArgv,\n          throwIfCannotConvert = true,\n        ) {\n          let i;\n          const tgt = [];\n          for (i = 0; i < argc; ++i) {\n            tgt.push(\n              capi.sqlite3_value_to_js(\n                wasm.peekPtr(pArgv + wasm.ptrSizeof * i),\n                throwIfCannotConvert,\n              ),\n            );\n          }\n          return tgt;\n        };\n\n        capi.sqlite3_result_error_js = function (pCtx, e) {\n          if (e instanceof WasmAllocError) {\n            capi.sqlite3_result_error_nomem(pCtx);\n          } else {\n            capi.sqlite3_result_error(pCtx, '' + e, -1);\n          }\n        };\n\n        capi.sqlite3_result_js = function (pCtx, val) {\n          if (val instanceof Error) {\n            capi.sqlite3_result_error_js(pCtx, val);\n            return;\n          }\n          try {\n            switch (typeof val) {\n              case 'undefined':\n                break;\n              case 'boolean':\n                capi.sqlite3_result_int(pCtx, val ? 1 : 0);\n                break;\n              case 'bigint':\n                if (util.bigIntFits32(val)) {\n                  capi.sqlite3_result_int(pCtx, Number(val));\n                } else if (util.bigIntFitsDouble(val)) {\n                  capi.sqlite3_result_double(pCtx, Number(val));\n                } else if (wasm.bigIntEnabled) {\n                  if (util.bigIntFits64(val))\n                    capi.sqlite3_result_int64(pCtx, val);\n                  else\n                    toss3(\n                      'BigInt value',\n                      val.toString(),\n                      'is too BigInt for int64.',\n                    );\n                } else {\n                  toss3('BigInt value', val.toString(), 'is too BigInt.');\n                }\n                break;\n              case 'number': {\n                let f;\n                if (util.isInt32(val)) {\n                  f = capi.sqlite3_result_int;\n                } else if (\n                  wasm.bigIntEnabled &&\n                  Number.isInteger(val) &&\n                  util.bigIntFits64(BigInt(val))\n                ) {\n                  f = capi.sqlite3_result_int64;\n                } else {\n                  f = capi.sqlite3_result_double;\n                }\n                f(pCtx, val);\n                break;\n              }\n              case 'string': {\n                const [p, n] = wasm.allocCString(val, true);\n                capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);\n                break;\n              }\n              case 'object':\n                if (null === val) {\n                  capi.sqlite3_result_null(pCtx);\n                  break;\n                } else if (util.isBindableTypedArray(val)) {\n                  const pBlob = wasm.allocFromTypedArray(val);\n                  capi.sqlite3_result_blob(\n                    pCtx,\n                    pBlob,\n                    val.byteLength,\n                    capi.SQLITE_WASM_DEALLOC,\n                  );\n                  break;\n                }\n\n              default:\n                toss3(\n                  \"Don't not how to handle this UDF result value:\",\n                  typeof val,\n                  val,\n                );\n            }\n          } catch (e) {\n            capi.sqlite3_result_error_js(pCtx, e);\n          }\n        };\n\n        capi.sqlite3_column_js = function (\n          pStmt,\n          iCol,\n          throwIfCannotConvert = true,\n        ) {\n          const v = capi.sqlite3_column_value(pStmt, iCol);\n          return 0 === v\n            ? undefined\n            : capi.sqlite3_value_to_js(v, throwIfCannotConvert);\n        };\n\n        const __newOldValue = function (pObj, iCol, impl) {\n          impl = capi[impl];\n          if (!this.ptr) this.ptr = wasm.allocPtr();\n          else wasm.pokePtr(this.ptr, 0);\n          const rc = impl(pObj, iCol, this.ptr);\n          if (rc)\n            return SQLite3Error.toss(\n              rc,\n              arguments[2] + '() failed with code ' + rc,\n            );\n          const pv = wasm.peekPtr(this.ptr);\n          return pv ? capi.sqlite3_value_to_js(pv, true) : undefined;\n        }.bind(Object.create(null));\n\n        capi.sqlite3_preupdate_new_js = (pDb, iCol) =>\n          __newOldValue(pDb, iCol, 'sqlite3_preupdate_new');\n\n        capi.sqlite3_preupdate_old_js = (pDb, iCol) =>\n          __newOldValue(pDb, iCol, 'sqlite3_preupdate_old');\n\n        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) =>\n          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_new');\n\n        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) =>\n          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_old');\n\n        const sqlite3 = {\n          WasmAllocError: WasmAllocError,\n          SQLite3Error: SQLite3Error,\n          capi,\n          util,\n          wasm,\n          config,\n\n          version: Object.create(null),\n\n          client: undefined,\n\n          asyncPostInit: async function ff() {\n            if (ff.isReady instanceof Promise) return ff.isReady;\n            let lia = sqlite3ApiBootstrap.initializersAsync;\n            delete sqlite3ApiBootstrap.initializersAsync;\n            const postInit = async () => {\n              if (!sqlite3.__isUnderTest) {\n                delete sqlite3.util;\n\n                delete sqlite3.StructBinder;\n              }\n              return sqlite3;\n            };\n            const catcher = (e) => {\n              config.error('an async sqlite3 initializer failed:', e);\n              throw e;\n            };\n            if (!lia || !lia.length) {\n              return (ff.isReady = postInit().catch(catcher));\n            }\n            lia = lia.map((f) => {\n              return f instanceof Function ? async (x) => f(sqlite3) : f;\n            });\n            lia.push(postInit);\n            let p = Promise.resolve(sqlite3);\n            while (lia.length) p = p.then(lia.shift());\n            return (ff.isReady = p.catch(catcher));\n          },\n\n          scriptInfo: undefined,\n        };\n        try {\n          sqlite3ApiBootstrap.initializers.forEach((f) => {\n            f(sqlite3);\n          });\n        } catch (e) {\n          console.error('sqlite3 bootstrap initializer threw:', e);\n          throw e;\n        }\n        delete sqlite3ApiBootstrap.initializers;\n        sqlite3ApiBootstrap.sqlite3 = sqlite3;\n        return sqlite3;\n      };\n\n      globalThis.sqlite3ApiBootstrap.initializers = [];\n\n      globalThis.sqlite3ApiBootstrap.initializersAsync = [];\n\n      globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);\n\n      globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;\n\n      globalThis.WhWasmUtilInstaller = function (target) {\n        'use strict';\n        if (undefined === target.bigIntEnabled) {\n          target.bigIntEnabled = !!globalThis['BigInt64Array'];\n        }\n\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n\n        if (!target.exports) {\n          Object.defineProperty(target, 'exports', {\n            enumerable: true,\n            configurable: true,\n            get: () => target.instance && target.instance.exports,\n          });\n        }\n\n        const ptrIR = target.pointerIR || 'i32';\n        const ptrSizeof = (target.ptrSizeof =\n          'i32' === ptrIR\n            ? 4\n            : 'i64' === ptrIR\n              ? 8\n              : toss('Unhandled ptrSizeof:', ptrIR));\n\n        const cache = Object.create(null);\n\n        cache.heapSize = 0;\n\n        cache.memory = null;\n\n        cache.freeFuncIndexes = [];\n\n        cache.scopedAlloc = [];\n\n        cache.utf8Decoder = new TextDecoder();\n        cache.utf8Encoder = new TextEncoder('utf-8');\n\n        target.sizeofIR = (n) => {\n          switch (n) {\n            case 'i8':\n              return 1;\n            case 'i16':\n              return 2;\n            case 'i32':\n            case 'f32':\n            case 'float':\n              return 4;\n            case 'i64':\n            case 'f64':\n            case 'double':\n              return 8;\n            case '*':\n              return ptrSizeof;\n            default:\n              return ('' + n).endsWith('*') ? ptrSizeof : undefined;\n          }\n        };\n\n        const heapWrappers = function () {\n          if (!cache.memory) {\n            cache.memory =\n              target.memory instanceof WebAssembly.Memory\n                ? target.memory\n                : target.exports.memory;\n          } else if (cache.heapSize === cache.memory.buffer.byteLength) {\n            return cache;\n          }\n\n          const b = cache.memory.buffer;\n          cache.HEAP8 = new Int8Array(b);\n          cache.HEAP8U = new Uint8Array(b);\n          cache.HEAP16 = new Int16Array(b);\n          cache.HEAP16U = new Uint16Array(b);\n          cache.HEAP32 = new Int32Array(b);\n          cache.HEAP32U = new Uint32Array(b);\n          if (target.bigIntEnabled) {\n            cache.HEAP64 = new BigInt64Array(b);\n            cache.HEAP64U = new BigUint64Array(b);\n          }\n          cache.HEAP32F = new Float32Array(b);\n          cache.HEAP64F = new Float64Array(b);\n          cache.heapSize = b.byteLength;\n          return cache;\n        };\n\n        target.heap8 = () => heapWrappers().HEAP8;\n\n        target.heap8u = () => heapWrappers().HEAP8U;\n\n        target.heap16 = () => heapWrappers().HEAP16;\n\n        target.heap16u = () => heapWrappers().HEAP16U;\n\n        target.heap32 = () => heapWrappers().HEAP32;\n\n        target.heap32u = () => heapWrappers().HEAP32U;\n\n        target.heapForSize = function (n, unsigned = true) {\n          let ctor;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          switch (n) {\n            case Int8Array:\n              return c.HEAP8;\n            case Uint8Array:\n              return c.HEAP8U;\n            case Int16Array:\n              return c.HEAP16;\n            case Uint16Array:\n              return c.HEAP16U;\n            case Int32Array:\n              return c.HEAP32;\n            case Uint32Array:\n              return c.HEAP32U;\n            case 8:\n              return unsigned ? c.HEAP8U : c.HEAP8;\n            case 16:\n              return unsigned ? c.HEAP16U : c.HEAP16;\n            case 32:\n              return unsigned ? c.HEAP32U : c.HEAP32;\n            case 64:\n              if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;\n              break;\n            default:\n              if (target.bigIntEnabled) {\n                if (n === globalThis['BigUint64Array']) return c.HEAP64U;\n                else if (n === globalThis['BigInt64Array']) return c.HEAP64;\n                break;\n              }\n          }\n          toss(\n            'Invalid heapForSize() size: expecting 8, 16, 32,',\n            'or (if BigInt is enabled) 64.',\n          );\n        };\n\n        target.functionTable = function () {\n          return target.exports.__indirect_function_table;\n        };\n\n        target.functionEntry = function (fptr) {\n          const ft = target.functionTable();\n          return fptr < ft.length ? ft.get(fptr) : undefined;\n        };\n\n        target.jsFuncToWasm = function f(func, sig) {\n          if (!f._) {\n            f._ = {\n              sigTypes: Object.assign(Object.create(null), {\n                i: 'i32',\n                p: 'i32',\n                P: 'i32',\n                s: 'i32',\n                j: 'i64',\n                f: 'f32',\n                d: 'f64',\n              }),\n\n              typeCodes: Object.assign(Object.create(null), {\n                f64: 0x7c,\n                f32: 0x7d,\n                i64: 0x7e,\n                i32: 0x7f,\n              }),\n\n              uleb128Encode: function (tgt, method, n) {\n                if (n < 128) tgt[method](n);\n                else tgt[method](n % 128 | 128, n >> 7);\n              },\n\n              rxJSig: /^(\\w)\\((\\w*)\\)$/,\n\n              sigParams: function (sig) {\n                const m = f._.rxJSig.exec(sig);\n                return m ? m[2] : sig.substr(1);\n              },\n\n              letterType: (x) =>\n                f._.sigTypes[x] || toss('Invalid signature letter:', x),\n\n              pushSigType: (dest, letter) =>\n                dest.push(f._.typeCodes[f._.letterType(letter)]),\n            };\n          }\n          if ('string' === typeof func) {\n            const x = sig;\n            sig = func;\n            func = x;\n          }\n          const sigParams = f._.sigParams(sig);\n          const wasmCode = [0x01, 0x60];\n          f._.uleb128Encode(wasmCode, 'push', sigParams.length);\n          for (const x of sigParams) f._.pushSigType(wasmCode, x);\n          if ('v' === sig[0]) wasmCode.push(0);\n          else {\n            wasmCode.push(1);\n            f._.pushSigType(wasmCode, sig[0]);\n          }\n          f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);\n          wasmCode.unshift(\n            0x00,\n            0x61,\n            0x73,\n            0x6d,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n          );\n          wasmCode.push(\n            0x02,\n            0x07,\n\n            0x01,\n            0x01,\n            0x65,\n            0x01,\n            0x66,\n            0x00,\n            0x00,\n            0x07,\n            0x05,\n\n            0x01,\n            0x01,\n            0x66,\n            0x00,\n            0x00,\n          );\n          return new WebAssembly.Instance(\n            new WebAssembly.Module(new Uint8Array(wasmCode)),\n            {\n              e: { f: func },\n            },\n          ).exports['f'];\n        };\n\n        const __installFunction = function f(func, sig, scoped) {\n          if (scoped && !cache.scopedAlloc.length) {\n            toss('No scopedAllocPush() scope is active.');\n          }\n          if ('string' === typeof func) {\n            const x = sig;\n            sig = func;\n            func = x;\n          }\n          if ('string' !== typeof sig || !(func instanceof Function)) {\n            toss(\n              'Invalid arguments: expecting (function,signature) ' +\n                'or (signature,function).',\n            );\n          }\n          const ft = target.functionTable();\n          const oldLen = ft.length;\n          let ptr;\n          while (cache.freeFuncIndexes.length) {\n            ptr = cache.freeFuncIndexes.pop();\n            if (ft.get(ptr)) {\n              ptr = null;\n              continue;\n            } else {\n              break;\n            }\n          }\n          if (!ptr) {\n            ptr = oldLen;\n            ft.grow(1);\n          }\n          try {\n            ft.set(ptr, func);\n            if (scoped) {\n              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);\n            }\n            return ptr;\n          } catch (e) {\n            if (!(e instanceof TypeError)) {\n              if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n              throw e;\n            }\n          }\n\n          try {\n            const fptr = target.jsFuncToWasm(func, sig);\n            ft.set(ptr, fptr);\n            if (scoped) {\n              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);\n            }\n          } catch (e) {\n            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n            throw e;\n          }\n          return ptr;\n        };\n\n        target.installFunction = (func, sig) =>\n          __installFunction(func, sig, false);\n\n        target.scopedInstallFunction = (func, sig) =>\n          __installFunction(func, sig, true);\n\n        target.uninstallFunction = function (ptr) {\n          if (!ptr && 0 !== ptr) return undefined;\n          const fi = cache.freeFuncIndexes;\n          const ft = target.functionTable();\n          fi.push(ptr);\n          const rc = ft.get(ptr);\n          ft.set(ptr, null);\n          return rc;\n        };\n\n        target.peek = function f(ptr, type = 'i8') {\n          if (type.endsWith('*')) type = ptrIR;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          const list = Array.isArray(ptr) ? [] : undefined;\n          let rc;\n          do {\n            if (list) ptr = arguments[0].shift();\n            switch (type) {\n              case 'i1':\n              case 'i8':\n                rc = c.HEAP8[ptr >> 0];\n                break;\n              case 'i16':\n                rc = c.HEAP16[ptr >> 1];\n                break;\n              case 'i32':\n                rc = c.HEAP32[ptr >> 2];\n                break;\n              case 'float':\n              case 'f32':\n                rc = c.HEAP32F[ptr >> 2];\n                break;\n              case 'double':\n              case 'f64':\n                rc = Number(c.HEAP64F[ptr >> 3]);\n                break;\n              case 'i64':\n                if (target.bigIntEnabled) {\n                  rc = BigInt(c.HEAP64[ptr >> 3]);\n                  break;\n                }\n\n              default:\n                toss('Invalid type for peek():', type);\n            }\n            if (list) list.push(rc);\n          } while (list && arguments[0].length);\n          return list || rc;\n        };\n\n        target.poke = function (ptr, value, type = 'i8') {\n          if (type.endsWith('*')) type = ptrIR;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          for (const p of Array.isArray(ptr) ? ptr : [ptr]) {\n            switch (type) {\n              case 'i1':\n              case 'i8':\n                c.HEAP8[p >> 0] = value;\n                continue;\n              case 'i16':\n                c.HEAP16[p >> 1] = value;\n                continue;\n              case 'i32':\n                c.HEAP32[p >> 2] = value;\n                continue;\n              case 'float':\n              case 'f32':\n                c.HEAP32F[p >> 2] = value;\n                continue;\n              case 'double':\n              case 'f64':\n                c.HEAP64F[p >> 3] = value;\n                continue;\n              case 'i64':\n                if (c.HEAP64) {\n                  c.HEAP64[p >> 3] = BigInt(value);\n                  continue;\n                }\n\n              default:\n                toss('Invalid type for poke(): ' + type);\n            }\n          }\n          return this;\n        };\n\n        target.peekPtr = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);\n\n        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);\n\n        target.peek8 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i8');\n\n        target.poke8 = (ptr, value) => target.poke(ptr, value, 'i8');\n\n        target.peek16 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i16');\n\n        target.poke16 = (ptr, value) => target.poke(ptr, value, 'i16');\n\n        target.peek32 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i32');\n\n        target.poke32 = (ptr, value) => target.poke(ptr, value, 'i32');\n\n        target.peek64 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i64');\n\n        target.poke64 = (ptr, value) => target.poke(ptr, value, 'i64');\n\n        target.peek32f = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f32');\n\n        target.poke32f = (ptr, value) => target.poke(ptr, value, 'f32');\n\n        target.peek64f = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f64');\n\n        target.poke64f = (ptr, value) => target.poke(ptr, value, 'f64');\n\n        target.getMemValue = target.peek;\n\n        target.getPtrValue = target.peekPtr;\n\n        target.setMemValue = target.poke;\n\n        target.setPtrValue = target.pokePtr;\n\n        target.isPtr32 = (ptr) =>\n          'number' === typeof ptr && ptr === (ptr | 0) && ptr >= 0;\n\n        target.isPtr = target.isPtr32;\n\n        target.cstrlen = function (ptr) {\n          if (!ptr || !target.isPtr(ptr)) return null;\n          const h = heapWrappers().HEAP8U;\n          let pos = ptr;\n          for (; h[pos] !== 0; ++pos) {}\n          return pos - ptr;\n        };\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n        const __utf8Decode = function (arrayBuffer, begin, end) {\n          return cache.utf8Decoder.decode(\n            arrayBuffer.buffer instanceof __SAB\n              ? arrayBuffer.slice(begin, end)\n              : arrayBuffer.subarray(begin, end),\n          );\n        };\n\n        target.cstrToJs = function (ptr) {\n          const n = target.cstrlen(ptr);\n          return n\n            ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n)\n            : null === n\n              ? n\n              : '';\n        };\n\n        target.jstrlen = function (str) {\n          if ('string' !== typeof str) return null;\n          const n = str.length;\n          let len = 0;\n          for (let i = 0; i < n; ++i) {\n            let u = str.charCodeAt(i);\n            if (u >= 0xd800 && u <= 0xdfff) {\n              u =\n                (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);\n            }\n            if (u <= 0x7f) ++len;\n            else if (u <= 0x7ff) len += 2;\n            else if (u <= 0xffff) len += 3;\n            else len += 4;\n          }\n          return len;\n        };\n\n        target.jstrcpy = function (\n          jstr,\n          tgt,\n          offset = 0,\n          maxBytes = -1,\n          addNul = true,\n        ) {\n          if (\n            !tgt ||\n            (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))\n          ) {\n            toss('jstrcpy() target must be an Int8Array or Uint8Array.');\n          }\n          if (maxBytes < 0) maxBytes = tgt.length - offset;\n          if (!(maxBytes > 0) || !(offset >= 0)) return 0;\n          let i = 0,\n            max = jstr.length;\n          const begin = offset,\n            end = offset + maxBytes - (addNul ? 1 : 0);\n          for (; i < max && offset < end; ++i) {\n            let u = jstr.charCodeAt(i);\n            if (u >= 0xd800 && u <= 0xdfff) {\n              u =\n                (0x10000 + ((u & 0x3ff) << 10)) |\n                (jstr.charCodeAt(++i) & 0x3ff);\n            }\n            if (u <= 0x7f) {\n              if (offset >= end) break;\n              tgt[offset++] = u;\n            } else if (u <= 0x7ff) {\n              if (offset + 1 >= end) break;\n              tgt[offset++] = 0xc0 | (u >> 6);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            } else if (u <= 0xffff) {\n              if (offset + 2 >= end) break;\n              tgt[offset++] = 0xe0 | (u >> 12);\n              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            } else {\n              if (offset + 3 >= end) break;\n              tgt[offset++] = 0xf0 | (u >> 18);\n              tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);\n              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            }\n          }\n          if (addNul) tgt[offset++] = 0;\n          return offset - begin;\n        };\n\n        target.cstrncpy = function (tgtPtr, srcPtr, n) {\n          if (!tgtPtr || !srcPtr)\n            toss('cstrncpy() does not accept NULL strings.');\n          if (n < 0) n = target.cstrlen(strPtr) + 1;\n          else if (!(n > 0)) return 0;\n          const heap = target.heap8u();\n          let i = 0,\n            ch;\n          for (; i < n && (ch = heap[srcPtr + i]); ++i) {\n            heap[tgtPtr + i] = ch;\n          }\n          if (i < n) heap[tgtPtr + i++] = 0;\n          return i;\n        };\n\n        target.jstrToUintArray = (str, addNul = false) => {\n          return cache.utf8Encoder.encode(addNul ? str + '\\0' : str);\n        };\n\n        const __affirmAlloc = (obj, funcName) => {\n          if (\n            !(obj.alloc instanceof Function) ||\n            !(obj.dealloc instanceof Function)\n          ) {\n            toss(\n              'Object is missing alloc() and/or dealloc() function(s)',\n              'required by',\n              funcName + '().',\n            );\n          }\n        };\n\n        const __allocCStr = function (\n          jstr,\n          returnWithLength,\n          allocator,\n          funcName,\n        ) {\n          __affirmAlloc(target, funcName);\n          if ('string' !== typeof jstr) return null;\n          if (false) {} else {\n            const u = cache.utf8Encoder.encode(jstr),\n              ptr = allocator(u.length + 1),\n              heap = heapWrappers().HEAP8U;\n            heap.set(u, ptr);\n            heap[ptr + u.length] = 0;\n            return returnWithLength ? [ptr, u.length] : ptr;\n          }\n        };\n\n        target.allocCString = (jstr, returnWithLength = false) =>\n          __allocCStr(jstr, returnWithLength, target.alloc, 'allocCString()');\n\n        target.scopedAllocPush = function () {\n          __affirmAlloc(target, 'scopedAllocPush');\n          const a = [];\n          cache.scopedAlloc.push(a);\n          return a;\n        };\n\n        target.scopedAllocPop = function (state) {\n          __affirmAlloc(target, 'scopedAllocPop');\n          const n = arguments.length\n            ? cache.scopedAlloc.indexOf(state)\n            : cache.scopedAlloc.length - 1;\n          if (n < 0) toss('Invalid state object for scopedAllocPop().');\n          if (0 === arguments.length) state = cache.scopedAlloc[n];\n          cache.scopedAlloc.splice(n, 1);\n          for (let p; (p = state.pop()); ) {\n            if (target.functionEntry(p)) {\n              target.uninstallFunction(p);\n            } else target.dealloc(p);\n          }\n        };\n\n        target.scopedAlloc = function (n) {\n          if (!cache.scopedAlloc.length) {\n            toss('No scopedAllocPush() scope is active.');\n          }\n          const p = target.alloc(n);\n          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);\n          return p;\n        };\n\n        Object.defineProperty(target.scopedAlloc, 'level', {\n          configurable: false,\n          enumerable: false,\n          get: () => cache.scopedAlloc.length,\n          set: () => toss(\"The 'active' property is read-only.\"),\n        });\n\n        target.scopedAllocCString = (jstr, returnWithLength = false) =>\n          __allocCStr(\n            jstr,\n            returnWithLength,\n            target.scopedAlloc,\n            'scopedAllocCString()',\n          );\n\n        const __allocMainArgv = function (isScoped, list) {\n          const pList = target[isScoped ? 'scopedAlloc' : 'alloc'](\n            (list.length + 1) * target.ptrSizeof,\n          );\n          let i = 0;\n          list.forEach((e) => {\n            target.pokePtr(\n              pList + target.ptrSizeof * i++,\n              target[isScoped ? 'scopedAllocCString' : 'allocCString']('' + e),\n            );\n          });\n          target.pokePtr(pList + target.ptrSizeof * i, 0);\n          return pList;\n        };\n\n        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);\n\n        target.allocMainArgv = (list) => __allocMainArgv(false, list);\n\n        target.cArgvToJs = (argc, pArgv) => {\n          const list = [];\n          for (let i = 0; i < argc; ++i) {\n            const arg = target.peekPtr(pArgv + target.ptrSizeof * i);\n            list.push(arg ? target.cstrToJs(arg) : null);\n          }\n          return list;\n        };\n\n        target.scopedAllocCall = function (func) {\n          target.scopedAllocPush();\n          try {\n            return func();\n          } finally {\n            target.scopedAllocPop();\n          }\n        };\n\n        const __allocPtr = function (howMany, safePtrSize, method) {\n          __affirmAlloc(target, method);\n          const pIr = safePtrSize ? 'i64' : ptrIR;\n          let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));\n          target.poke(m, 0, pIr);\n          if (1 === howMany) {\n            return m;\n          }\n          const a = [m];\n          for (let i = 1; i < howMany; ++i) {\n            m += safePtrSize ? 8 : ptrSizeof;\n            a[i] = m;\n            target.poke(m, 0, pIr);\n          }\n          return a;\n        };\n\n        target.allocPtr = (howMany = 1, safePtrSize = true) =>\n          __allocPtr(howMany, safePtrSize, 'alloc');\n\n        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) =>\n          __allocPtr(howMany, safePtrSize, 'scopedAlloc');\n\n        target.xGet = function (name) {\n          return (\n            target.exports[name] || toss('Cannot find exported symbol:', name)\n          );\n        };\n\n        const __argcMismatch = (f, n) =>\n          toss(f + '() requires', n, 'argument(s).');\n\n        target.xCall = function (fname, ...args) {\n          const f = fname instanceof Function ? fname : target.xGet(fname);\n          if (!(f instanceof Function))\n            toss('Exported symbol', fname, 'is not a function.');\n          if (f.length !== args.length)\n            __argcMismatch(f === fname ? f.name : fname, f.length);\n          return 2 === arguments.length && Array.isArray(arguments[1])\n            ? f.apply(null, arguments[1])\n            : f.apply(null, args);\n        };\n\n        cache.xWrap = Object.create(null);\n        cache.xWrap.convert = Object.create(null);\n\n        cache.xWrap.convert.arg = new Map();\n\n        cache.xWrap.convert.result = new Map();\n        const xArg = cache.xWrap.convert.arg,\n          xResult = cache.xWrap.convert.result;\n\n        if (target.bigIntEnabled) {\n          xArg.set('i64', (i) => BigInt(i));\n        }\n        const __xArgPtr =\n          'i32' === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);\n        xArg\n          .set('i32', __xArgPtr)\n          .set('i16', (i) => (i | 0) & 0xffff)\n          .set('i8', (i) => (i | 0) & 0xff)\n          .set('f32', (i) => Number(i).valueOf())\n          .set('float', xArg.get('f32'))\n          .set('f64', xArg.get('f32'))\n          .set('double', xArg.get('f64'))\n          .set('int', xArg.get('i32'))\n          .set('null', (i) => i)\n          .set(null, xArg.get('null'))\n          .set('**', __xArgPtr)\n          .set('*', __xArgPtr);\n        xResult\n          .set('*', __xArgPtr)\n          .set('pointer', __xArgPtr)\n          .set('number', (v) => Number(v))\n          .set('void', (v) => undefined)\n          .set('null', (v) => v)\n          .set(null, xResult.get('null'));\n\n        {\n          const copyToResult = [\n            'i8',\n            'i16',\n            'i32',\n            'int',\n            'f32',\n            'float',\n            'f64',\n            'double',\n          ];\n          if (target.bigIntEnabled) copyToResult.push('i64');\n          const adaptPtr = xArg.get(ptrIR);\n          for (const t of copyToResult) {\n            xArg.set(t + '*', adaptPtr);\n            xResult.set(t + '*', adaptPtr);\n            xResult.set(t, xArg.get(t) || toss('Missing arg converter:', t));\n          }\n        }\n\n        const __xArgString = function (v) {\n          if ('string' === typeof v) return target.scopedAllocCString(v);\n          return v ? __xArgPtr(v) : null;\n        };\n        xArg\n          .set('string', __xArgString)\n          .set('utf8', __xArgString)\n          .set('pointer', __xArgString);\n\n        xResult\n          .set('string', (i) => target.cstrToJs(i))\n          .set('utf8', xResult.get('string'))\n          .set('string:dealloc', (i) => {\n            try {\n              return i ? target.cstrToJs(i) : null;\n            } finally {\n              target.dealloc(i);\n            }\n          })\n          .set('utf8:dealloc', xResult.get('string:dealloc'))\n          .set('json', (i) => JSON.parse(target.cstrToJs(i)))\n          .set('json:dealloc', (i) => {\n            try {\n              return i ? JSON.parse(target.cstrToJs(i)) : null;\n            } finally {\n              target.dealloc(i);\n            }\n          });\n\n        const AbstractArgAdapter = class {\n          constructor(opt) {\n            this.name = opt.name || 'unnamed adapter';\n          }\n\n          convertArg(v, argv, argIndex) {\n            toss('AbstractArgAdapter must be subclassed.');\n          }\n        };\n\n        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {\n          constructor(opt) {\n            super(opt);\n            if (xArg.FuncPtrAdapter.warnOnUse) {\n              console.warn(\n                'xArg.FuncPtrAdapter is an internal-only API',\n                'and is not intended to be invoked from',\n                'client-level code. Invoked with:',\n                opt,\n              );\n            }\n            this.name = opt.name || 'unnamed';\n            this.signature = opt.signature;\n            if (opt.contextKey instanceof Function) {\n              this.contextKey = opt.contextKey;\n              if (!opt.bindScope) opt.bindScope = 'context';\n            }\n            this.bindScope =\n              opt.bindScope ||\n              toss(\n                'FuncPtrAdapter options requires a bindScope (explicit or implied).',\n              );\n            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {\n              toss(\n                'Invalid options.bindScope (' +\n                  opt.bindMod +\n                  ') for FuncPtrAdapter. ' +\n                  'Expecting one of: (' +\n                  FuncPtrAdapter.bindScopes.join(', ') +\n                  ')',\n              );\n            }\n            this.isTransient = 'transient' === this.bindScope;\n            this.isContext = 'context' === this.bindScope;\n            this.isPermanent = 'permanent' === this.bindScope;\n            this.singleton = 'singleton' === this.bindScope ? [] : undefined;\n\n            this.callProxy =\n              opt.callProxy instanceof Function ? opt.callProxy : undefined;\n          }\n\n          contextKey(argv, argIndex) {\n            return this;\n          }\n\n          contextMap(key) {\n            const cm = this.__cmap || (this.__cmap = new Map());\n            let rc = cm.get(key);\n            if (undefined === rc) cm.set(key, (rc = []));\n            return rc;\n          }\n\n          convertArg(v, argv, argIndex) {\n            let pair = this.singleton;\n            if (!pair && this.isContext) {\n              pair = this.contextMap(this.contextKey(argv, argIndex));\n            }\n            if (pair && pair[0] === v) return pair[1];\n            if (v instanceof Function) {\n              if (this.callProxy) v = this.callProxy(v);\n              const fp = __installFunction(v, this.signature, this.isTransient);\n              if (FuncPtrAdapter.debugFuncInstall) {\n                FuncPtrAdapter.debugOut(\n                  'FuncPtrAdapter installed',\n                  this,\n                  this.contextKey(argv, argIndex),\n                  '@' + fp,\n                  v,\n                );\n              }\n              if (pair) {\n                if (pair[1]) {\n                  if (FuncPtrAdapter.debugFuncInstall) {\n                    FuncPtrAdapter.debugOut(\n                      'FuncPtrAdapter uninstalling',\n                      this,\n                      this.contextKey(argv, argIndex),\n                      '@' + pair[1],\n                      v,\n                    );\n                  }\n                  try {\n                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(\n                      pair[1],\n                    );\n                  } catch (e) {}\n                }\n                pair[0] = v;\n                pair[1] = fp;\n              }\n              return fp;\n            } else if (target.isPtr(v) || null === v || undefined === v) {\n              if (pair && pair[1] && pair[1] !== v) {\n                if (FuncPtrAdapter.debugFuncInstall) {\n                  FuncPtrAdapter.debugOut(\n                    'FuncPtrAdapter uninstalling',\n                    this,\n                    this.contextKey(argv, argIndex),\n                    '@' + pair[1],\n                    v,\n                  );\n                }\n                try {\n                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);\n                } catch (e) {}\n                pair[0] = pair[1] = v | 0;\n              }\n              return v || 0;\n            } else {\n              throw new TypeError(\n                'Invalid FuncPtrAdapter argument type. ' +\n                  'Expecting a function pointer or a ' +\n                  (this.name ? this.name + ' ' : '') +\n                  'function matching signature ' +\n                  this.signature +\n                  '.',\n              );\n            }\n          }\n        };\n\n        xArg.FuncPtrAdapter.warnOnUse = false;\n\n        xArg.FuncPtrAdapter.debugFuncInstall = false;\n\n        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);\n\n        xArg.FuncPtrAdapter.bindScopes = [\n          'transient',\n          'context',\n          'singleton',\n          'permanent',\n        ];\n\n        const __xArgAdapterCheck = (t) =>\n          xArg.get(t) || toss('Argument adapter not found:', t);\n\n        const __xResultAdapterCheck = (t) =>\n          xResult.get(t) || toss('Result adapter not found:', t);\n\n        cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);\n\n        cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);\n\n        cache.xWrap.convertResult = (t, v) =>\n          null === t ? v : t ? __xResultAdapterCheck(t)(v) : undefined;\n\n        cache.xWrap.convertResultNoCheck = (t, v) =>\n          null === t ? v : t ? xResult.get(t)(v) : undefined;\n\n        target.xWrap = function (fArg, resultType, ...argTypes) {\n          if (3 === arguments.length && Array.isArray(arguments[2])) {\n            argTypes = arguments[2];\n          }\n          if (target.isPtr(fArg)) {\n            fArg =\n              target.functionEntry(fArg) ||\n              toss('Function pointer not found in WASM function table.');\n          }\n          const fIsFunc = fArg instanceof Function;\n          const xf = fIsFunc ? fArg : target.xGet(fArg);\n          if (fIsFunc) fArg = xf.name || 'unnamed function';\n          if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);\n          if (null === resultType && 0 === xf.length) {\n            return xf;\n          }\n          if (undefined !== resultType && null !== resultType)\n            __xResultAdapterCheck(resultType);\n          for (const t of argTypes) {\n            if (t instanceof AbstractArgAdapter)\n              xArg.set(t, (...args) => t.convertArg(...args));\n            else __xArgAdapterCheck(t);\n          }\n          const cxw = cache.xWrap;\n          if (0 === xf.length) {\n            return (...args) =>\n              args.length\n                ? __argcMismatch(fArg, xf.length)\n                : cxw.convertResult(resultType, xf.call(null));\n          }\n          return function (...args) {\n            if (args.length !== xf.length) __argcMismatch(fArg, xf.length);\n            const scope = target.scopedAllocPush();\n            try {\n              let i = 0;\n              for (; i < args.length; ++i)\n                args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);\n              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));\n            } finally {\n              target.scopedAllocPop(scope);\n            }\n          };\n        };\n\n        const __xAdapter = function (\n          func,\n          argc,\n          typeName,\n          adapter,\n          modeName,\n          xcvPart,\n        ) {\n          if ('string' === typeof typeName) {\n            if (1 === argc) return xcvPart.get(typeName);\n            else if (2 === argc) {\n              if (!adapter) {\n                xcvPart.delete(typeName);\n                return func;\n              } else if (!(adapter instanceof Function)) {\n                toss(modeName, 'requires a function argument.');\n              }\n              xcvPart.set(typeName, adapter);\n              return func;\n            }\n          }\n          toss('Invalid arguments to', modeName);\n        };\n\n        target.xWrap.resultAdapter = function f(typeName, adapter) {\n          return __xAdapter(\n            f,\n            arguments.length,\n            typeName,\n            adapter,\n            'resultAdapter()',\n            xResult,\n          );\n        };\n\n        target.xWrap.argAdapter = function f(typeName, adapter) {\n          return __xAdapter(\n            f,\n            arguments.length,\n            typeName,\n            adapter,\n            'argAdapter()',\n            xArg,\n          );\n        };\n\n        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;\n\n        target.xCallWrapped = function (fArg, resultType, argTypes, ...args) {\n          if (Array.isArray(arguments[3])) args = arguments[3];\n          return target\n            .xWrap(fArg, resultType, argTypes || [])\n            .apply(null, args || []);\n        };\n\n        target.xWrap.testConvertArg = cache.xWrap.convertArg;\n\n        target.xWrap.testConvertResult = cache.xWrap.convertResult;\n\n        return target;\n      };\n\n      globalThis.WhWasmUtilInstaller.yawl = function (config) {\n        const wfetch = () => fetch(config.uri, { credentials: 'same-origin' });\n        const wui = this;\n        const finalThen = function (arg) {\n          if (config.wasmUtilTarget) {\n            const toss = (...args) => {\n              throw new Error(args.join(' '));\n            };\n            const tgt = config.wasmUtilTarget;\n            tgt.module = arg.module;\n            tgt.instance = arg.instance;\n\n            if (!tgt.instance.exports.memory) {\n              tgt.memory =\n                (config.imports &&\n                  config.imports.env &&\n                  config.imports.env.memory) ||\n                toss(\"Missing 'memory' object!\");\n            }\n            if (!tgt.alloc && arg.instance.exports.malloc) {\n              const exports = arg.instance.exports;\n              tgt.alloc = function (n) {\n                return (\n                  exports.malloc(n) || toss('Allocation of', n, 'bytes failed.')\n                );\n              };\n              tgt.dealloc = function (m) {\n                exports.free(m);\n              };\n            }\n            wui(tgt);\n          }\n          if (config.onload) config.onload(arg, config);\n          return arg;\n        };\n        const loadWasm = WebAssembly.instantiateStreaming\n          ? function loadWasmStreaming() {\n              return WebAssembly.instantiateStreaming(\n                wfetch(),\n                config.imports || {},\n              ).then(finalThen);\n            }\n          : function loadWasmOldSchool() {\n              return wfetch()\n                .then((response) => response.arrayBuffer())\n                .then((bytes) =>\n                  WebAssembly.instantiate(bytes, config.imports || {}),\n                )\n                .then(finalThen);\n            };\n        return loadWasm;\n      }.bind(globalThis.WhWasmUtilInstaller);\n\n      ('use strict');\n      globalThis.Jaccwabyt = function StructBinderFactory(config) {\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n\n        if (\n          !(config.heap instanceof WebAssembly.Memory) &&\n          !(config.heap instanceof Function)\n        ) {\n          toss(\n            'config.heap must be WebAssembly.Memory instance or a function.',\n          );\n        }\n        ['alloc', 'dealloc'].forEach(function (k) {\n          config[k] instanceof Function ||\n            toss(\"Config option '\" + k + \"' must be a function.\");\n        });\n        const SBF = StructBinderFactory;\n        const heap =\n            config.heap instanceof Function\n              ? config.heap\n              : () => new Uint8Array(config.heap.buffer),\n          alloc = config.alloc,\n          dealloc = config.dealloc,\n          log = config.log || console.log.bind(console),\n          memberPrefix = config.memberPrefix || '',\n          memberSuffix = config.memberSuffix || '',\n          bigIntEnabled =\n            undefined === config.bigIntEnabled\n              ? !!globalThis['BigInt64Array']\n              : !!config.bigIntEnabled,\n          BigInt = globalThis['BigInt'],\n          BigInt64Array = globalThis['BigInt64Array'],\n          ptrSizeof = config.ptrSizeof || 4,\n          ptrIR = config.ptrIR || 'i32';\n        if (!SBF.debugFlags) {\n          SBF.__makeDebugFlags = function (deriveFrom = null) {\n            if (deriveFrom && deriveFrom.__flags)\n              deriveFrom = deriveFrom.__flags;\n            const f = function f(flags) {\n              if (0 === arguments.length) {\n                return f.__flags;\n              }\n              if (flags < 0) {\n                delete f.__flags.getter;\n                delete f.__flags.setter;\n                delete f.__flags.alloc;\n                delete f.__flags.dealloc;\n              } else {\n                f.__flags.getter = 0 !== (0x01 & flags);\n                f.__flags.setter = 0 !== (0x02 & flags);\n                f.__flags.alloc = 0 !== (0x04 & flags);\n                f.__flags.dealloc = 0 !== (0x08 & flags);\n              }\n              return f._flags;\n            };\n            Object.defineProperty(f, '__flags', {\n              iterable: false,\n              writable: false,\n              value: Object.create(deriveFrom),\n            });\n            if (!deriveFrom) f(0);\n            return f;\n          };\n          SBF.debugFlags = SBF.__makeDebugFlags();\n        }\n\n        const isLittleEndian = (function () {\n          const buffer = new ArrayBuffer(2);\n          new DataView(buffer).setInt16(0, 256, true);\n\n          return new Int16Array(buffer)[0] === 256;\n        })();\n\n        const isFuncSig = (s) => '(' === s[1];\n\n        const isPtrSig = (s) => 'p' === s || 'P' === s;\n        const isAutoPtrSig = (s) => 'P' === s;\n        const sigLetter = (s) => (isFuncSig(s) ? 'p' : s[0]);\n\n        const sigIR = function (s) {\n          switch (sigLetter(s)) {\n            case 'c':\n            case 'C':\n              return 'i8';\n            case 'i':\n              return 'i32';\n            case 'p':\n            case 'P':\n            case 's':\n              return ptrIR;\n            case 'j':\n              return 'i64';\n            case 'f':\n              return 'float';\n            case 'd':\n              return 'double';\n          }\n          toss('Unhandled signature IR:', s);\n        };\n\n        const affirmBigIntArray = BigInt64Array\n          ? () => true\n          : () => toss('BigInt64Array is not available.');\n\n        const sigDVGetter = function (s) {\n          switch (sigLetter(s)) {\n            case 'p':\n            case 'P':\n            case 's': {\n              switch (ptrSizeof) {\n                case 4:\n                  return 'getInt32';\n                case 8:\n                  return affirmBigIntArray() && 'getBigInt64';\n              }\n              break;\n            }\n            case 'i':\n              return 'getInt32';\n            case 'c':\n              return 'getInt8';\n            case 'C':\n              return 'getUint8';\n            case 'j':\n              return affirmBigIntArray() && 'getBigInt64';\n            case 'f':\n              return 'getFloat32';\n            case 'd':\n              return 'getFloat64';\n          }\n          toss('Unhandled DataView getter for signature:', s);\n        };\n\n        const sigDVSetter = function (s) {\n          switch (sigLetter(s)) {\n            case 'p':\n            case 'P':\n            case 's': {\n              switch (ptrSizeof) {\n                case 4:\n                  return 'setInt32';\n                case 8:\n                  return affirmBigIntArray() && 'setBigInt64';\n              }\n              break;\n            }\n            case 'i':\n              return 'setInt32';\n            case 'c':\n              return 'setInt8';\n            case 'C':\n              return 'setUint8';\n            case 'j':\n              return affirmBigIntArray() && 'setBigInt64';\n            case 'f':\n              return 'setFloat32';\n            case 'd':\n              return 'setFloat64';\n          }\n          toss('Unhandled DataView setter for signature:', s);\n        };\n\n        const sigDVSetWrapper = function (s) {\n          switch (sigLetter(s)) {\n            case 'i':\n            case 'f':\n            case 'c':\n            case 'C':\n            case 'd':\n              return Number;\n            case 'j':\n              return affirmBigIntArray() && BigInt;\n            case 'p':\n            case 'P':\n            case 's':\n              switch (ptrSizeof) {\n                case 4:\n                  return Number;\n                case 8:\n                  return affirmBigIntArray() && BigInt;\n              }\n              break;\n          }\n          toss('Unhandled DataView set wrapper for signature:', s);\n        };\n\n        const sPropName = (s, k) => s + '::' + k;\n\n        const __propThrowOnSet = function (structName, propName) {\n          return () => toss(sPropName(structName, propName), 'is read-only.');\n        };\n\n        const __instancePointerMap = new WeakMap();\n\n        const xPtrPropName = '(pointer-is-external)';\n\n        const __freeStruct = function (ctor, obj, m) {\n          if (!m) m = __instancePointerMap.get(obj);\n          if (m) {\n            __instancePointerMap.delete(obj);\n            if (Array.isArray(obj.ondispose)) {\n              let x;\n              while ((x = obj.ondispose.shift())) {\n                try {\n                  if (x instanceof Function) x.call(obj);\n                  else if (x instanceof StructType) x.dispose();\n                  else if ('number' === typeof x) dealloc(x);\n                } catch (e) {\n                  console.warn(\n                    'ondispose() for',\n                    ctor.structName,\n                    '@',\n                    m,\n                    'threw. NOT propagating it.',\n                    e,\n                  );\n                }\n              }\n            } else if (obj.ondispose instanceof Function) {\n              try {\n                obj.ondispose();\n              } catch (e) {\n                console.warn(\n                  'ondispose() for',\n                  ctor.structName,\n                  '@',\n                  m,\n                  'threw. NOT propagating it.',\n                  e,\n                );\n              }\n            }\n            delete obj.ondispose;\n            if (ctor.debugFlags.__flags.dealloc) {\n              log(\n                'debug.dealloc:',\n                obj[xPtrPropName] ? 'EXTERNAL' : '',\n                ctor.structName,\n                'instance:',\n                ctor.structInfo.sizeof,\n                'bytes @' + m,\n              );\n            }\n            if (!obj[xPtrPropName]) dealloc(m);\n          }\n        };\n\n        const rop = (v) => {\n          return {\n            configurable: false,\n            writable: false,\n            iterable: false,\n            value: v,\n          };\n        };\n\n        const __allocStruct = function (ctor, obj, m) {\n          let fill = !m;\n          if (m) Object.defineProperty(obj, xPtrPropName, rop(m));\n          else {\n            m = alloc(ctor.structInfo.sizeof);\n            if (!m) toss('Allocation of', ctor.structName, 'structure failed.');\n          }\n          try {\n            if (ctor.debugFlags.__flags.alloc) {\n              log(\n                'debug.alloc:',\n                fill ? '' : 'EXTERNAL',\n                ctor.structName,\n                'instance:',\n                ctor.structInfo.sizeof,\n                'bytes @' + m,\n              );\n            }\n            if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);\n            __instancePointerMap.set(obj, m);\n          } catch (e) {\n            __freeStruct(ctor, obj, m);\n            throw e;\n          }\n        };\n\n        const __memoryDump = function () {\n          const p = this.pointer;\n          return p\n            ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof))\n            : null;\n        };\n\n        const __memberKey = (k) => memberPrefix + k + memberSuffix;\n        const __memberKeyProp = rop(__memberKey);\n\n        const __lookupMember = function (\n          structInfo,\n          memberName,\n          tossIfNotFound = true,\n        ) {\n          let m = structInfo.members[memberName];\n          if (!m && (memberPrefix || memberSuffix)) {\n            for (const v of Object.values(structInfo.members)) {\n              if (v.key === memberName) {\n                m = v;\n                break;\n              }\n            }\n            if (!m && tossIfNotFound) {\n              toss(\n                sPropName(structInfo.name, memberName),\n                'is not a mapped struct member.',\n              );\n            }\n          }\n          return m;\n        };\n\n        const __memberSignature = function f(\n          obj,\n          memberName,\n          emscriptenFormat = false,\n        ) {\n          if (!f._)\n            f._ = (x) =>\n              x.replace(/[^vipPsjrdcC]/g, '').replace(/[pPscC]/g, 'i');\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          return emscriptenFormat ? f._(m.signature) : m.signature;\n        };\n\n        const __ptrPropDescriptor = {\n          configurable: false,\n          enumerable: false,\n          get: function () {\n            return __instancePointerMap.get(this);\n          },\n          set: () => toss(\"Cannot assign the 'pointer' property of a struct.\"),\n        };\n\n        const __structMemberKeys = rop(function () {\n          const a = [];\n          for (const k of Object.keys(this.structInfo.members)) {\n            a.push(this.memberKey(k));\n          }\n          return a;\n        });\n\n        const __utf8Decoder = new TextDecoder('utf-8');\n        const __utf8Encoder = new TextEncoder();\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n        const __utf8Decode = function (arrayBuffer, begin, end) {\n          return __utf8Decoder.decode(\n            arrayBuffer.buffer instanceof __SAB\n              ? arrayBuffer.slice(begin, end)\n              : arrayBuffer.subarray(begin, end),\n          );\n        };\n\n        const __memberIsString = function (\n          obj,\n          memberName,\n          tossIfNotFound = false,\n        ) {\n          const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);\n          return m && 1 === m.signature.length && 's' === m.signature[0]\n            ? m\n            : false;\n        };\n\n        const __affirmCStringSignature = function (member) {\n          if ('s' === member.signature) return;\n          toss(\n            'Invalid member type signature for C-string value:',\n            JSON.stringify(member),\n          );\n        };\n\n        const __memberToJsString = function f(obj, memberName) {\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          __affirmCStringSignature(m);\n          const addr = obj[m.key];\n\n          if (!addr) return null;\n          let pos = addr;\n          const mem = heap();\n          for (; mem[pos] !== 0; ++pos) {}\n\n          return addr === pos ? '' : __utf8Decode(mem, addr, pos);\n        };\n\n        const __addOnDispose = function (obj, ...v) {\n          if (obj.ondispose) {\n            if (!Array.isArray(obj.ondispose)) {\n              obj.ondispose = [obj.ondispose];\n            }\n          } else {\n            obj.ondispose = [];\n          }\n          obj.ondispose.push(...v);\n        };\n\n        const __allocCString = function (str) {\n          const u = __utf8Encoder.encode(str);\n          const mem = alloc(u.length + 1);\n          if (!mem) toss('Allocation error while duplicating string:', str);\n          const h = heap();\n\n          h.set(u, mem);\n          h[mem + u.length] = 0;\n\n          return mem;\n        };\n\n        const __setMemberCString = function (obj, memberName, str) {\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          __affirmCStringSignature(m);\n\n          const mem = __allocCString(str);\n          obj[m.key] = mem;\n          __addOnDispose(obj, mem);\n          return obj;\n        };\n\n        const StructType = function ctor(structName, structInfo) {\n          if (arguments[2] !== rop) {\n            toss(\n              'Do not call the StructType constructor',\n              'from client-level code.',\n            );\n          }\n          Object.defineProperties(this, {\n            structName: rop(structName),\n            structInfo: rop(structInfo),\n          });\n        };\n\n        StructType.prototype = Object.create(null, {\n          dispose: rop(function () {\n            __freeStruct(this.constructor, this);\n          }),\n          lookupMember: rop(function (memberName, tossIfNotFound = true) {\n            return __lookupMember(this.structInfo, memberName, tossIfNotFound);\n          }),\n          memberToJsString: rop(function (memberName) {\n            return __memberToJsString(this, memberName);\n          }),\n          memberIsString: rop(function (memberName, tossIfNotFound = true) {\n            return __memberIsString(this, memberName, tossIfNotFound);\n          }),\n          memberKey: __memberKeyProp,\n          memberKeys: __structMemberKeys,\n          memberSignature: rop(function (memberName, emscriptenFormat = false) {\n            return __memberSignature(this, memberName, emscriptenFormat);\n          }),\n          memoryDump: rop(__memoryDump),\n          pointer: __ptrPropDescriptor,\n          setMemberCString: rop(function (memberName, str) {\n            return __setMemberCString(this, memberName, str);\n          }),\n        });\n\n        Object.assign(StructType.prototype, {\n          addOnDispose: function (...v) {\n            __addOnDispose(this, ...v);\n            return this;\n          },\n        });\n\n        Object.defineProperties(StructType, {\n          allocCString: rop(__allocCString),\n          isA: rop((v) => v instanceof StructType),\n          hasExternalPointer: rop(\n            (v) => v instanceof StructType && !!v[xPtrPropName],\n          ),\n          memberKey: __memberKeyProp,\n        });\n\n        const isNumericValue = (v) =>\n          Number.isFinite(v) || v instanceof (BigInt || Number);\n\n        const makeMemberWrapper = function f(ctor, name, descr) {\n          if (!f._) {\n            f._ = { getters: {}, setters: {}, sw: {} };\n            const a = ['i', 'c', 'C', 'p', 'P', 's', 'f', 'd', 'v()'];\n            if (bigIntEnabled) a.push('j');\n            a.forEach(function (v) {\n              f._.getters[v] = sigDVGetter(v);\n              f._.setters[v] = sigDVSetter(v);\n              f._.sw[v] = sigDVSetWrapper(v);\n            });\n            const rxSig1 = /^[ipPsjfdcC]$/,\n              rxSig2 = /^[vipPsjfdcC]\\([ipPsjfdcC]*\\)$/;\n            f.sigCheck = function (obj, name, key, sig) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                toss(obj.structName, 'already has a property named', key + '.');\n              }\n              rxSig1.test(sig) ||\n                rxSig2.test(sig) ||\n                toss(\n                  'Malformed signature for',\n                  sPropName(obj.structName, name) + ':',\n                  sig,\n                );\n            };\n          }\n          const key = ctor.memberKey(name);\n          f.sigCheck(ctor.prototype, name, key, descr.signature);\n          descr.key = key;\n          descr.name = name;\n          const sigGlyph = sigLetter(descr.signature);\n          const xPropName = sPropName(ctor.prototype.structName, key);\n          const dbg = ctor.prototype.debugFlags.__flags;\n\n          const prop = Object.create(null);\n          prop.configurable = false;\n          prop.enumerable = false;\n          prop.get = function () {\n            if (dbg.getter) {\n              log(\n                'debug.getter:',\n                f._.getters[sigGlyph],\n                'for',\n                sigIR(sigGlyph),\n                xPropName,\n                '@',\n                this.pointer,\n                '+',\n                descr.offset,\n                'sz',\n                descr.sizeof,\n              );\n            }\n            let rc = new DataView(\n              heap().buffer,\n              this.pointer + descr.offset,\n              descr.sizeof,\n            )[f._.getters[sigGlyph]](0, isLittleEndian);\n            if (dbg.getter) log('debug.getter:', xPropName, 'result =', rc);\n            return rc;\n          };\n          if (descr.readOnly) {\n            prop.set = __propThrowOnSet(ctor.prototype.structName, key);\n          } else {\n            prop.set = function (v) {\n              if (dbg.setter) {\n                log(\n                  'debug.setter:',\n                  f._.setters[sigGlyph],\n                  'for',\n                  sigIR(sigGlyph),\n                  xPropName,\n                  '@',\n                  this.pointer,\n                  '+',\n                  descr.offset,\n                  'sz',\n                  descr.sizeof,\n                  v,\n                );\n              }\n              if (!this.pointer) {\n                toss('Cannot set struct property on disposed instance.');\n              }\n              if (null === v) v = 0;\n              else\n                while (!isNumericValue(v)) {\n                  if (\n                    isAutoPtrSig(descr.signature) &&\n                    v instanceof StructType\n                  ) {\n                    v = v.pointer || 0;\n                    if (dbg.setter)\n                      log('debug.setter:', xPropName, 'resolved to', v);\n                    break;\n                  }\n                  toss('Invalid value for pointer-type', xPropName + '.');\n                }\n              new DataView(\n                heap().buffer,\n                this.pointer + descr.offset,\n                descr.sizeof,\n              )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);\n            };\n          }\n          Object.defineProperty(ctor.prototype, key, prop);\n        };\n\n        const StructBinder = function StructBinder(structName, structInfo) {\n          if (1 === arguments.length) {\n            structInfo = structName;\n            structName = structInfo.name;\n          } else if (!structInfo.name) {\n            structInfo.name = structName;\n          }\n          if (!structName) toss('Struct name is required.');\n          let lastMember = false;\n          Object.keys(structInfo.members).forEach((k) => {\n            const m = structInfo.members[k];\n            if (!m.sizeof) toss(structName, 'member', k, 'is missing sizeof.');\n            else if (m.sizeof === 1) {\n              m.signature === 'c' ||\n                m.signature === 'C' ||\n                toss(\n                  'Unexpected sizeof==1 member',\n                  sPropName(structInfo.name, k),\n                  'with signature',\n                  m.signature,\n                );\n            } else {\n              if (0 !== m.sizeof % 4) {\n                console.warn(\n                  'Invalid struct member description =',\n                  m,\n                  'from',\n                  structInfo,\n                );\n                toss(\n                  structName,\n                  'member',\n                  k,\n                  'sizeof is not aligned. sizeof=' + m.sizeof,\n                );\n              }\n              if (0 !== m.offset % 4) {\n                console.warn(\n                  'Invalid struct member description =',\n                  m,\n                  'from',\n                  structInfo,\n                );\n                toss(\n                  structName,\n                  'member',\n                  k,\n                  'offset is not aligned. offset=' + m.offset,\n                );\n              }\n            }\n            if (!lastMember || lastMember.offset < m.offset) lastMember = m;\n          });\n          if (!lastMember) toss('No member property descriptions found.');\n          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {\n            toss(\n              'Invalid struct config:',\n              structName,\n              'max member offset (' + lastMember.offset + ') ',\n              'extends past end of struct (sizeof=' + structInfo.sizeof + ').',\n            );\n          }\n          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));\n\n          const StructCtor = function StructCtor(externalMemory) {\n            if (!(this instanceof StructCtor)) {\n              toss(\n                'The',\n                structName,\n                \"constructor may only be called via 'new'.\",\n              );\n            } else if (arguments.length) {\n              if (\n                externalMemory !== (externalMemory | 0) ||\n                externalMemory <= 0\n              ) {\n                toss('Invalid pointer value for', structName, 'constructor.');\n              }\n              __allocStruct(StructCtor, this, externalMemory);\n            } else {\n              __allocStruct(StructCtor, this);\n            }\n          };\n          Object.defineProperties(StructCtor, {\n            debugFlags: debugFlags,\n            isA: rop((v) => v instanceof StructCtor),\n            memberKey: __memberKeyProp,\n            memberKeys: __structMemberKeys,\n            methodInfoForKey: rop(function (mKey) {}),\n            structInfo: rop(structInfo),\n            structName: rop(structName),\n          });\n          StructCtor.prototype = new StructType(structName, structInfo, rop);\n          Object.defineProperties(StructCtor.prototype, {\n            debugFlags: debugFlags,\n            constructor: rop(StructCtor),\n          });\n          Object.keys(structInfo.members).forEach((name) =>\n            makeMemberWrapper(StructCtor, name, structInfo.members[name]),\n          );\n          return StructCtor;\n        };\n        StructBinder.StructType = StructType;\n        StructBinder.config = config;\n        StructBinder.allocCString = __allocCString;\n        if (!StructBinder.debugFlags) {\n          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);\n        }\n        return StructBinder;\n      };\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        'use strict';\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n        const toss3 = sqlite3.SQLite3Error.toss;\n        const capi = sqlite3.capi,\n          wasm = sqlite3.wasm,\n          util = sqlite3.util;\n        globalThis.WhWasmUtilInstaller(wasm);\n        delete globalThis.WhWasmUtilInstaller;\n\n        if (false) {}\n\n        wasm.bindingSignatures = [\n          ['sqlite3_aggregate_context', 'void*', 'sqlite3_context*', 'int'],\n\n          ['sqlite3_bind_double', 'int', 'sqlite3_stmt*', 'int', 'f64'],\n          ['sqlite3_bind_int', 'int', 'sqlite3_stmt*', 'int', 'int'],\n          ['sqlite3_bind_null', undefined, 'sqlite3_stmt*', 'int'],\n          ['sqlite3_bind_parameter_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_bind_parameter_index', 'int', 'sqlite3_stmt*', 'string'],\n          ['sqlite3_bind_parameter_name', 'string', 'sqlite3_stmt*', 'int'],\n          [\n            'sqlite3_bind_pointer',\n            'int',\n            'sqlite3_stmt*',\n            'int',\n            '*',\n            'string:static',\n            '*',\n          ],\n          [\n            'sqlite3_busy_handler',\n            'int',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: 'i(pi)',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_busy_timeout', 'int', 'sqlite3*', 'int'],\n\n          ['sqlite3_changes', 'int', 'sqlite3*'],\n          ['sqlite3_clear_bindings', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_collation_needed', 'int', 'sqlite3*', '*', '*'],\n          ['sqlite3_column_blob', '*', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_bytes', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_column_decltype', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_double', 'f64', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_int', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_name', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_text', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_type', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_value', 'sqlite3_value*', 'sqlite3_stmt*', 'int'],\n          [\n            'sqlite3_commit_hook',\n            'void*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_commit_hook',\n                signature: 'i(p)',\n                contextKey: (argv) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_compileoption_get', 'string', 'int'],\n          ['sqlite3_compileoption_used', 'int', 'string'],\n          ['sqlite3_complete', 'int', 'string:flexible'],\n          ['sqlite3_context_db_handle', 'sqlite3*', 'sqlite3_context*'],\n\n          ['sqlite3_data_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_db_filename', 'string', 'sqlite3*', 'string'],\n          ['sqlite3_db_handle', 'sqlite3*', 'sqlite3_stmt*'],\n          ['sqlite3_db_name', 'string', 'sqlite3*', 'int'],\n          ['sqlite3_db_readonly', 'int', 'sqlite3*', 'string'],\n          ['sqlite3_db_status', 'int', 'sqlite3*', 'int', '*', '*', 'int'],\n          ['sqlite3_errcode', 'int', 'sqlite3*'],\n          ['sqlite3_errmsg', 'string', 'sqlite3*'],\n          ['sqlite3_error_offset', 'int', 'sqlite3*'],\n          ['sqlite3_errstr', 'string', 'int'],\n          [\n            'sqlite3_exec',\n            'int',\n            [\n              'sqlite3*',\n              'string:flexible',\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: 'i(pipp)',\n                bindScope: 'transient',\n                callProxy: (callback) => {\n                  let aNames;\n                  return (pVoid, nCols, pColVals, pColNames) => {\n                    try {\n                      const aVals = wasm.cArgvToJs(nCols, pColVals);\n                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);\n                      return callback(aVals, aNames) | 0;\n                    } catch (e) {\n                      return e.resultCode || capi.SQLITE_ERROR;\n                    }\n                  };\n                },\n              }),\n              '*',\n              '**',\n            ],\n          ],\n          ['sqlite3_expanded_sql', 'string', 'sqlite3_stmt*'],\n          ['sqlite3_extended_errcode', 'int', 'sqlite3*'],\n          ['sqlite3_extended_result_codes', 'int', 'sqlite3*', 'int'],\n          ['sqlite3_file_control', 'int', 'sqlite3*', 'string', 'int', '*'],\n          ['sqlite3_finalize', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_free', undefined, '*'],\n          ['sqlite3_get_autocommit', 'int', 'sqlite3*'],\n          ['sqlite3_get_auxdata', '*', 'sqlite3_context*', 'int'],\n          ['sqlite3_initialize', undefined],\n          ['sqlite3_interrupt', undefined, 'sqlite3*'],\n          ['sqlite3_is_interrupted', 'int', 'sqlite3*'],\n          ['sqlite3_keyword_count', 'int'],\n          ['sqlite3_keyword_name', 'int', ['int', '**', '*']],\n          ['sqlite3_keyword_check', 'int', ['string', 'int']],\n          ['sqlite3_libversion', 'string'],\n          ['sqlite3_libversion_number', 'int'],\n          ['sqlite3_limit', 'int', ['sqlite3*', 'int', 'int']],\n          ['sqlite3_malloc', '*', 'int'],\n          ['sqlite3_open', 'int', 'string', '*'],\n          ['sqlite3_open_v2', 'int', 'string', '*', 'int', 'string'],\n\n          ['sqlite3_realloc', '*', '*', 'int'],\n          ['sqlite3_reset', 'int', 'sqlite3_stmt*'],\n\n          [\n            'sqlite3_result_blob',\n            undefined,\n            'sqlite3_context*',\n            '*',\n            'int',\n            '*',\n          ],\n          ['sqlite3_result_double', undefined, 'sqlite3_context*', 'f64'],\n          [\n            'sqlite3_result_error',\n            undefined,\n            'sqlite3_context*',\n            'string',\n            'int',\n          ],\n          ['sqlite3_result_error_code', undefined, 'sqlite3_context*', 'int'],\n          ['sqlite3_result_error_nomem', undefined, 'sqlite3_context*'],\n          ['sqlite3_result_error_toobig', undefined, 'sqlite3_context*'],\n          ['sqlite3_result_int', undefined, 'sqlite3_context*', 'int'],\n          ['sqlite3_result_null', undefined, 'sqlite3_context*'],\n          [\n            'sqlite3_result_pointer',\n            undefined,\n            'sqlite3_context*',\n            '*',\n            'string:static',\n            '*',\n          ],\n          ['sqlite3_result_subtype', undefined, 'sqlite3_value*', 'int'],\n          [\n            'sqlite3_result_text',\n            undefined,\n            'sqlite3_context*',\n            'string',\n            'int',\n            '*',\n          ],\n          ['sqlite3_result_zeroblob', undefined, 'sqlite3_context*', 'int'],\n          [\n            'sqlite3_rollback_hook',\n            'void*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_rollback_hook',\n                signature: 'v(p)',\n                contextKey: (argv) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n\n          [\n            'sqlite3_set_auxdata',\n            undefined,\n            [\n              'sqlite3_context*',\n              'int',\n              '*',\n               true\n                ? '*'\n                : 0,\n            ],\n          ],\n          ['sqlite3_shutdown', undefined],\n          ['sqlite3_sourceid', 'string'],\n          ['sqlite3_sql', 'string', 'sqlite3_stmt*'],\n          ['sqlite3_status', 'int', 'int', '*', '*', 'int'],\n          ['sqlite3_step', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_busy', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_readonly', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_status', 'int', 'sqlite3_stmt*', 'int', 'int'],\n          ['sqlite3_strglob', 'int', 'string', 'string'],\n          ['sqlite3_stricmp', 'int', 'string', 'string'],\n          ['sqlite3_strlike', 'int', 'string', 'string', 'int'],\n          ['sqlite3_strnicmp', 'int', 'string', 'string', 'int'],\n          [\n            'sqlite3_table_column_metadata',\n            'int',\n            'sqlite3*',\n            'string',\n            'string',\n            'string',\n            '**',\n            '**',\n            '*',\n            '*',\n            '*',\n          ],\n          ['sqlite3_total_changes', 'int', 'sqlite3*'],\n          [\n            'sqlite3_trace_v2',\n            'int',\n            [\n              'sqlite3*',\n              'int',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_trace_v2::callback',\n                signature: 'i(ippp)',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_txn_state', 'int', ['sqlite3*', 'string']],\n\n          ['sqlite3_uri_boolean', 'int', 'sqlite3_filename', 'string', 'int'],\n          ['sqlite3_uri_key', 'string', 'sqlite3_filename', 'int'],\n          ['sqlite3_uri_parameter', 'string', 'sqlite3_filename', 'string'],\n          ['sqlite3_user_data', 'void*', 'sqlite3_context*'],\n          ['sqlite3_value_blob', '*', 'sqlite3_value*'],\n          ['sqlite3_value_bytes', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_double', 'f64', 'sqlite3_value*'],\n          ['sqlite3_value_dup', 'sqlite3_value*', 'sqlite3_value*'],\n          ['sqlite3_value_free', undefined, 'sqlite3_value*'],\n          ['sqlite3_value_frombind', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_int', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_nochange', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_numeric_type', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_pointer', '*', 'sqlite3_value*', 'string:static'],\n          ['sqlite3_value_subtype', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_text', 'string', 'sqlite3_value*'],\n          ['sqlite3_value_type', 'int', 'sqlite3_value*'],\n          ['sqlite3_vfs_find', '*', 'string'],\n          ['sqlite3_vfs_register', 'int', 'sqlite3_vfs*', 'int'],\n          ['sqlite3_vfs_unregister', 'int', 'sqlite3_vfs*'],\n        ];\n\n        if (!!wasm.exports.sqlite3_progress_handler) {\n          wasm.bindingSignatures.push([\n            'sqlite3_progress_handler',\n            undefined,\n            [\n              'sqlite3*',\n              'int',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xProgressHandler',\n                signature: 'i(p)',\n                bindScope: 'context',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ]);\n        }\n\n        if (!!wasm.exports.sqlite3_stmt_explain) {\n          wasm.bindingSignatures.push(\n            ['sqlite3_stmt_explain', 'int', 'sqlite3_stmt*', 'int'],\n            ['sqlite3_stmt_isexplain', 'int', 'sqlite3_stmt*'],\n          );\n        }\n\n        if (!!wasm.exports.sqlite3_set_authorizer) {\n          wasm.bindingSignatures.push([\n            'sqlite3_set_authorizer',\n            'int',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_set_authorizer::xAuth',\n                signature: 'i(pi' + 'ssss)',\n                contextKey: (argv, argIndex) => argv[0],\n                callProxy: (callback) => {\n                  return (pV, iCode, s0, s1, s2, s3) => {\n                    try {\n                      s0 = s0 && wasm.cstrToJs(s0);\n                      s1 = s1 && wasm.cstrToJs(s1);\n                      s2 = s2 && wasm.cstrToJs(s2);\n                      s3 = s3 && wasm.cstrToJs(s3);\n                      return callback(pV, iCode, s0, s1, s2, s3) || 0;\n                    } catch (e) {\n                      return e.resultCode || capi.SQLITE_ERROR;\n                    }\n                  };\n                },\n              }),\n              '*',\n            ],\n          ]);\n        }\n\n        if (false) {}\n\n        wasm.bindingSignatures.int64 = [\n          ['sqlite3_bind_int64', 'int', ['sqlite3_stmt*', 'int', 'i64']],\n          ['sqlite3_changes64', 'i64', ['sqlite3*']],\n          ['sqlite3_column_int64', 'i64', ['sqlite3_stmt*', 'int']],\n          [\n            'sqlite3_deserialize',\n            'int',\n            'sqlite3*',\n            'string',\n            '*',\n            'i64',\n            'i64',\n            'int',\n          ],\n          ['sqlite3_last_insert_rowid', 'i64', ['sqlite3*']],\n          ['sqlite3_malloc64', '*', 'i64'],\n          ['sqlite3_msize', 'i64', '*'],\n          ['sqlite3_overload_function', 'int', ['sqlite3*', 'string', 'int']],\n          ['sqlite3_realloc64', '*', '*', 'i64'],\n          ['sqlite3_result_int64', undefined, '*', 'i64'],\n          ['sqlite3_result_zeroblob64', 'int', '*', 'i64'],\n          ['sqlite3_serialize', '*', 'sqlite3*', 'string', '*', 'int'],\n          ['sqlite3_set_last_insert_rowid', undefined, ['sqlite3*', 'i64']],\n          ['sqlite3_status64', 'int', 'int', '*', '*', 'int'],\n          ['sqlite3_total_changes64', 'i64', ['sqlite3*']],\n          [\n            'sqlite3_update_hook',\n            '*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_update_hook',\n                signature: 'v(iippj)',\n                contextKey: (argv) => argv[0],\n                callProxy: (callback) => {\n                  return (p, op, z0, z1, rowid) => {\n                    callback(\n                      p,\n                      op,\n                      wasm.cstrToJs(z0),\n                      wasm.cstrToJs(z1),\n                      rowid,\n                    );\n                  };\n                },\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_uri_int64', 'i64', ['sqlite3_filename', 'string', 'i64']],\n          ['sqlite3_value_int64', 'i64', 'sqlite3_value*'],\n        ];\n\n        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_declare_vtab) {\n          wasm.bindingSignatures.int64.push(\n            [\n              'sqlite3_create_module',\n              'int',\n              ['sqlite3*', 'string', 'sqlite3_module*', '*'],\n            ],\n            [\n              'sqlite3_create_module_v2',\n              'int',\n              ['sqlite3*', 'string', 'sqlite3_module*', '*', '*'],\n            ],\n            ['sqlite3_declare_vtab', 'int', ['sqlite3*', 'string:flexible']],\n            ['sqlite3_drop_modules', 'int', ['sqlite3*', '**']],\n            ['sqlite3_vtab_collation', 'string', 'sqlite3_index_info*', 'int'],\n            ['sqlite3_vtab_distinct', 'int', 'sqlite3_index_info*'],\n            ['sqlite3_vtab_in', 'int', 'sqlite3_index_info*', 'int', 'int'],\n            ['sqlite3_vtab_in_first', 'int', 'sqlite3_value*', '**'],\n            ['sqlite3_vtab_in_next', 'int', 'sqlite3_value*', '**'],\n\n            ['sqlite3_vtab_nochange', 'int', 'sqlite3_context*'],\n            ['sqlite3_vtab_on_conflict', 'int', 'sqlite3*'],\n            [\n              'sqlite3_vtab_rhs_value',\n              'int',\n              'sqlite3_index_info*',\n              'int',\n              '**',\n            ],\n          );\n        }\n\n        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_preupdate_hook) {\n          wasm.bindingSignatures.int64.push(\n            ['sqlite3_preupdate_blobwrite', 'int', 'sqlite3*'],\n            ['sqlite3_preupdate_count', 'int', 'sqlite3*'],\n            ['sqlite3_preupdate_depth', 'int', 'sqlite3*'],\n            [\n              'sqlite3_preupdate_hook',\n              '*',\n              [\n                'sqlite3*',\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'sqlite3_preupdate_hook',\n                  signature: 'v(ppippjj)',\n                  contextKey: (argv) => argv[0],\n                  callProxy: (callback) => {\n                    return (p, db, op, zDb, zTbl, iKey1, iKey2) => {\n                      callback(\n                        p,\n                        db,\n                        op,\n                        wasm.cstrToJs(zDb),\n                        wasm.cstrToJs(zTbl),\n                        iKey1,\n                        iKey2,\n                      );\n                    };\n                  },\n                }),\n                '*',\n              ],\n            ],\n            ['sqlite3_preupdate_new', 'int', ['sqlite3*', 'int', '**']],\n            ['sqlite3_preupdate_old', 'int', ['sqlite3*', 'int', '**']],\n          );\n        }\n\n        if (\n          wasm.bigIntEnabled &&\n          !!wasm.exports.sqlite3changegroup_add &&\n          !!wasm.exports.sqlite3session_create &&\n          !!wasm.exports.sqlite3_preupdate_hook\n        ) {\n          const __ipsProxy = {\n            signature: 'i(ps)',\n            callProxy: (callback) => {\n              return (p, s) => {\n                try {\n                  return callback(p, wasm.cstrToJs(s)) | 0;\n                } catch (e) {\n                  return e.resultCode || capi.SQLITE_ERROR;\n                }\n              };\n            },\n          };\n\n          wasm.bindingSignatures.int64.push(\n            ...[\n              [\n                'sqlite3changegroup_add',\n                'int',\n                ['sqlite3_changegroup*', 'int', 'void*'],\n              ],\n              [\n                'sqlite3changegroup_add_strm',\n                'int',\n                [\n                  'sqlite3_changegroup*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changegroup_delete',\n                undefined,\n                ['sqlite3_changegroup*'],\n              ],\n              ['sqlite3changegroup_new', 'int', ['**']],\n              [\n                'sqlite3changegroup_output',\n                'int',\n                ['sqlite3_changegroup*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changegroup_output_strm',\n                'int',\n                [\n                  'sqlite3_changegroup*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply',\n                'int',\n                [\n                  'sqlite3*',\n                  'int',\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_strm',\n                'int',\n                [\n                  'sqlite3*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_v2',\n                'int',\n                [\n                  'sqlite3*',\n                  'int',\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  '**',\n                  'int*',\n                  'int',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_v2_strm',\n                'int',\n                [\n                  'sqlite3*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  '**',\n                  'int*',\n                  'int',\n                ],\n              ],\n              [\n                'sqlite3changeset_concat',\n                'int',\n                ['int', 'void*', 'int', 'void*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changeset_concat_strm',\n                'int',\n                [\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInputA',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInputB',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_conflict',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],\n              [\n                'sqlite3changeset_fk_conflicts',\n                'int',\n                ['sqlite3_changeset_iter*', 'int*'],\n              ],\n              [\n                'sqlite3changeset_invert',\n                'int',\n                ['int', 'void*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changeset_invert_strm',\n                'int',\n                [\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_new',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],\n              [\n                'sqlite3changeset_old',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              [\n                'sqlite3changeset_op',\n                'int',\n                ['sqlite3_changeset_iter*', '**', 'int*', 'int*', 'int*'],\n              ],\n              [\n                'sqlite3changeset_pk',\n                'int',\n                ['sqlite3_changeset_iter*', '**', 'int*'],\n              ],\n              ['sqlite3changeset_start', 'int', ['**', 'int', '*']],\n              [\n                'sqlite3changeset_start_strm',\n                'int',\n                [\n                  '**',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],\n              [\n                'sqlite3changeset_start_v2_strm',\n                'int',\n                [\n                  '**',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  'int',\n                ],\n              ],\n              ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],\n              [\n                'sqlite3session_changeset',\n                'int',\n                ['sqlite3_session*', 'int*', '**'],\n              ],\n              ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],\n              [\n                'sqlite3session_changeset_strm',\n                'int',\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              ['sqlite3session_config', 'int', ['int', 'void*']],\n              ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],\n\n              [\n                'sqlite3session_diff',\n                'int',\n                ['sqlite3_session*', 'string', 'string', '**'],\n              ],\n              ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],\n              ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],\n              ['sqlite3session_isempty', 'int', ['sqlite3_session*']],\n              ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],\n              [\n                'sqlite3session_object_config',\n                'int',\n                ['sqlite3_session*', 'int', 'void*'],\n              ],\n              [\n                'sqlite3session_patchset',\n                'int',\n                ['sqlite3_session*', '*', '**'],\n              ],\n              [\n                'sqlite3session_patchset_strm',\n                'int',\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3session_table_filter',\n                undefined,\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    ...__ipsProxy,\n                    contextKey: (argv, argIndex) => argv[0],\n                  }),\n                  '*',\n                ],\n              ],\n            ],\n          );\n        }\n\n        wasm.bindingSignatures.wasmInternal = [\n          ['sqlite3__wasm_db_reset', 'int', 'sqlite3*'],\n          ['sqlite3__wasm_db_vfs', 'sqlite3_vfs*', 'sqlite3*', 'string'],\n          [\n            'sqlite3__wasm_vfs_create_file',\n            'int',\n            'sqlite3_vfs*',\n            'string',\n            '*',\n            'int',\n          ],\n          ['sqlite3__wasm_posix_create_file', 'int', 'string', '*', 'int'],\n          ['sqlite3__wasm_vfs_unlink', 'int', 'sqlite3_vfs*', 'string'],\n          ['sqlite3__wasm_qfmt_token', 'string:dealloc', 'string', 'int'],\n        ];\n\n        sqlite3.StructBinder = globalThis.Jaccwabyt({\n          heap:  false ? 0 : wasm.heap8u,\n          alloc: wasm.alloc,\n          dealloc: wasm.dealloc,\n          bigIntEnabled: wasm.bigIntEnabled,\n          memberPrefix: '$',\n        });\n        delete globalThis.Jaccwabyt;\n\n        {\n          const __xString = wasm.xWrap.argAdapter('string');\n          wasm.xWrap.argAdapter('string:flexible', (v) =>\n            __xString(util.flexibleString(v)),\n          );\n\n          wasm.xWrap.argAdapter(\n            'string:static',\n            function (v) {\n              if (wasm.isPtr(v)) return v;\n              v = '' + v;\n              let rc = this[v];\n              return rc || (this[v] = wasm.allocCString(v));\n            }.bind(Object.create(null)),\n          );\n\n          const __xArgPtr = wasm.xWrap.argAdapter('*');\n          const nilType = function () {};\n          wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)(\n            'sqlite3_context*',\n            __xArgPtr,\n          )('sqlite3_value*', __xArgPtr)('void*', __xArgPtr)(\n            'sqlite3_changegroup*',\n            __xArgPtr,\n          )('sqlite3_changeset_iter*', __xArgPtr)(\n            'sqlite3_session*',\n            __xArgPtr,\n          )('sqlite3_stmt*', (v) =>\n            __xArgPtr(\n              v instanceof (sqlite3?.oo1?.Stmt || nilType) ? v.pointer : v,\n            ),\n          )('sqlite3*', (v) =>\n            __xArgPtr(\n              v instanceof (sqlite3?.oo1?.DB || nilType) ? v.pointer : v,\n            ),\n          )('sqlite3_vfs*', (v) => {\n            if ('string' === typeof v) {\n              return (\n                capi.sqlite3_vfs_find(v) ||\n                sqlite3.SQLite3Error.toss(\n                  capi.SQLITE_NOTFOUND,\n                  'Unknown sqlite3_vfs name:',\n                  v,\n                )\n              );\n            }\n            return __xArgPtr(\n              v instanceof (capi.sqlite3_vfs || nilType) ? v.pointer : v,\n            );\n          });\n          if (wasm.exports.sqlite3_declare_vtab) {\n            wasm.xWrap.argAdapter('sqlite3_index_info*', (v) =>\n              __xArgPtr(\n                v instanceof (capi.sqlite3_index_info || nilType)\n                  ? v.pointer\n                  : v,\n              ),\n            )('sqlite3_module*', (v) =>\n              __xArgPtr(\n                v instanceof (capi.sqlite3_module || nilType) ? v.pointer : v,\n              ),\n            );\n          }\n\n          const __xRcPtr = wasm.xWrap.resultAdapter('*');\n          wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)(\n            'sqlite3_context*',\n            __xRcPtr,\n          )('sqlite3_stmt*', __xRcPtr)('sqlite3_value*', __xRcPtr)(\n            'sqlite3_vfs*',\n            __xRcPtr,\n          )('void*', __xRcPtr);\n\n          if (0 === wasm.exports.sqlite3_step.length) {\n            wasm.xWrap.doArgcCheck = false;\n            sqlite3.config.warn(\n              'Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks.',\n            );\n          }\n          for (const e of wasm.bindingSignatures) {\n            capi[e[0]] = wasm.xWrap.apply(null, e);\n          }\n          for (const e of wasm.bindingSignatures.wasmInternal) {\n            util[e[0]] = wasm.xWrap.apply(null, e);\n          }\n\n          const fI64Disabled = function (fname) {\n            return () =>\n              toss(\n                fname + '() is unavailable due to lack',\n                'of BigInt support in this build.',\n              );\n          };\n          for (const e of wasm.bindingSignatures.int64) {\n            capi[e[0]] = wasm.bigIntEnabled\n              ? wasm.xWrap.apply(null, e)\n              : fI64Disabled(e[0]);\n          }\n\n          delete wasm.bindingSignatures;\n\n          if (wasm.exports.sqlite3__wasm_db_error) {\n            const __db_err = wasm.xWrap(\n              'sqlite3__wasm_db_error',\n              'int',\n              'sqlite3*',\n              'int',\n              'string',\n            );\n\n            util.sqlite3__wasm_db_error = function (pDb, resultCode, message) {\n              if (resultCode instanceof sqlite3.WasmAllocError) {\n                resultCode = capi.SQLITE_NOMEM;\n                message = 0;\n              } else if (resultCode instanceof Error) {\n                message = message || '' + resultCode;\n                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;\n              }\n              return pDb ? __db_err(pDb, resultCode, message) : resultCode;\n            };\n          } else {\n            util.sqlite3__wasm_db_error = function (pDb, errCode, msg) {\n              console.warn(\n                'sqlite3__wasm_db_error() is not exported.',\n                arguments,\n              );\n              return errCode;\n            };\n          }\n        }\n\n        {\n          const cJson = wasm.xCall('sqlite3__wasm_enum_json');\n          if (!cJson) {\n            toss(\n              \"Maintenance required: increase sqlite3__wasm_enum_json()'s\",\n              'static buffer size!',\n            );\n          }\n\n          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));\n\n          const defineGroups = [\n            'access',\n            'authorizer',\n            'blobFinalizers',\n            'changeset',\n            'config',\n            'dataTypes',\n            'dbConfig',\n            'dbStatus',\n            'encodings',\n            'fcntl',\n            'flock',\n            'ioCap',\n            'limits',\n            'openFlags',\n            'prepareFlags',\n            'resultCodes',\n            'sqlite3Status',\n            'stmtStatus',\n            'syncFlags',\n            'trace',\n            'txnState',\n            'udfFlags',\n            'version',\n          ];\n          if (wasm.bigIntEnabled) {\n            defineGroups.push('serialize', 'session', 'vtab');\n          }\n          for (const t of defineGroups) {\n            for (const e of Object.entries(wasm.ctype[t])) {\n              capi[e[0]] = e[1];\n            }\n          }\n          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {\n            toss(\n              'Internal error: cannot resolve exported function',\n              'entry SQLITE_WASM_DEALLOC (==' + capi.SQLITE_WASM_DEALLOC + ').',\n            );\n          }\n          const __rcMap = Object.create(null);\n          for (const t of ['resultCodes']) {\n            for (const e of Object.entries(wasm.ctype[t])) {\n              __rcMap[e[1]] = e[0];\n            }\n          }\n\n          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];\n\n          const notThese = Object.assign(Object.create(null), {\n            WasmTestStruct: true,\n\n            sqlite3_kvvfs_methods: !util.isUIThread(),\n\n            sqlite3_index_info: !wasm.bigIntEnabled,\n            sqlite3_index_constraint: !wasm.bigIntEnabled,\n            sqlite3_index_orderby: !wasm.bigIntEnabled,\n            sqlite3_index_constraint_usage: !wasm.bigIntEnabled,\n          });\n          for (const s of wasm.ctype.structs) {\n            if (!notThese[s.name]) {\n              capi[s.name] = sqlite3.StructBinder(s);\n            }\n          }\n          if (capi.sqlite3_index_info) {\n            for (const k of [\n              'sqlite3_index_constraint',\n              'sqlite3_index_orderby',\n              'sqlite3_index_constraint_usage',\n            ]) {\n              capi.sqlite3_index_info[k] = capi[k];\n              delete capi[k];\n            }\n            capi.sqlite3_vtab_config = wasm.xWrap(\n              'sqlite3__wasm_vtab_config',\n              'int',\n              ['sqlite3*', 'int', 'int'],\n            );\n          }\n        }\n\n        const __dbArgcMismatch = (pDb, f, n) => {\n          return util.sqlite3__wasm_db_error(\n            pDb,\n            capi.SQLITE_MISUSE,\n            f + '() requires ' + n + ' argument' + (1 === n ? '' : 's') + '.',\n          );\n        };\n\n        const __errEncoding = (pDb) => {\n          return util.sqlite3__wasm_db_error(\n            pDb,\n            capi.SQLITE_FORMAT,\n            'SQLITE_UTF8 is the only supported encoding.',\n          );\n        };\n\n        const __argPDb = (pDb) => wasm.xWrap.argAdapter('sqlite3*')(pDb);\n        const __argStr = (str) => (wasm.isPtr(str) ? wasm.cstrToJs(str) : str);\n        const __dbCleanupMap = function (pDb, mode) {\n          pDb = __argPDb(pDb);\n          let m = this.dbMap.get(pDb);\n          if (!mode) {\n            this.dbMap.delete(pDb);\n            return m;\n          } else if (!m && mode > 0) {\n            this.dbMap.set(pDb, (m = Object.create(null)));\n          }\n          return m;\n        }.bind(\n          Object.assign(Object.create(null), {\n            dbMap: new Map(),\n          }),\n        );\n\n        __dbCleanupMap.addCollation = function (pDb, name) {\n          const m = __dbCleanupMap(pDb, 1);\n          if (!m.collation) m.collation = new Set();\n          m.collation.add(__argStr(name).toLowerCase());\n        };\n\n        __dbCleanupMap._addUDF = function (pDb, name, arity, map) {\n          name = __argStr(name).toLowerCase();\n          let u = map.get(name);\n          if (!u) map.set(name, (u = new Set()));\n          u.add(arity < 0 ? -1 : arity);\n        };\n\n        __dbCleanupMap.addFunction = function (pDb, name, arity) {\n          const m = __dbCleanupMap(pDb, 1);\n          if (!m.udf) m.udf = new Map();\n          this._addUDF(pDb, name, arity, m.udf);\n        };\n\n        if (wasm.exports.sqlite3_create_window_function) {\n          __dbCleanupMap.addWindowFunc = function (pDb, name, arity) {\n            const m = __dbCleanupMap(pDb, 1);\n            if (!m.wudf) m.wudf = new Map();\n            this._addUDF(pDb, name, arity, m.wudf);\n          };\n        }\n\n        __dbCleanupMap.cleanup = function (pDb) {\n          pDb = __argPDb(pDb);\n\n          const closeArgs = [pDb];\n          for (const name of [\n            'sqlite3_busy_handler',\n            'sqlite3_commit_hook',\n            'sqlite3_preupdate_hook',\n            'sqlite3_progress_handler',\n            'sqlite3_rollback_hook',\n            'sqlite3_set_authorizer',\n            'sqlite3_trace_v2',\n            'sqlite3_update_hook',\n          ]) {\n            const x = wasm.exports[name];\n            if (!x) {\n              continue;\n            }\n            closeArgs.length = x.length;\n            try {\n              capi[name](...closeArgs);\n            } catch (e) {\n              sqlite3.config.warn(\n                'close-time call of',\n                name + '(',\n                closeArgs,\n                ') threw:',\n                e,\n              );\n            }\n          }\n          const m = __dbCleanupMap(pDb, 0);\n          if (!m) return;\n          if (m.collation) {\n            for (const name of m.collation) {\n              try {\n                capi.sqlite3_create_collation_v2(\n                  pDb,\n                  name,\n                  capi.SQLITE_UTF8,\n                  0,\n                  0,\n                  0,\n                );\n              } catch (e) {}\n            }\n            delete m.collation;\n          }\n          let i;\n          for (i = 0; i < 2; ++i) {\n            const fmap = i ? m.wudf : m.udf;\n            if (!fmap) continue;\n            const func = i\n              ? capi.sqlite3_create_window_function\n              : capi.sqlite3_create_function_v2;\n            for (const e of fmap) {\n              const name = e[0],\n                arities = e[1];\n              const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];\n              if (i) fargs.push(0);\n              for (const arity of arities) {\n                try {\n                  fargs[2] = arity;\n                  func.apply(null, fargs);\n                } catch (e) {}\n              }\n              arities.clear();\n            }\n            fmap.clear();\n          }\n          delete m.udf;\n          delete m.wudf;\n        };\n\n        {\n          const __sqlite3CloseV2 = wasm.xWrap(\n            'sqlite3_close_v2',\n            'int',\n            'sqlite3*',\n          );\n          capi.sqlite3_close_v2 = function (pDb) {\n            if (1 !== arguments.length)\n              return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);\n            if (pDb) {\n              try {\n                __dbCleanupMap.cleanup(pDb);\n              } catch (e) {}\n            }\n            return __sqlite3CloseV2(pDb);\n          };\n        }\n\n        if (capi.sqlite3session_create) {\n          const __sqlite3SessionDelete = wasm.xWrap(\n            'sqlite3session_delete',\n            undefined,\n            ['sqlite3_session*'],\n          );\n          capi.sqlite3session_delete = function (pSession) {\n            if (1 !== arguments.length) {\n              return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);\n            } else if (pSession) {\n              capi.sqlite3session_table_filter(pSession, 0, 0);\n            }\n            __sqlite3SessionDelete(pSession);\n          };\n        }\n\n        {\n          const contextKey = (argv, argIndex) => {\n            return (\n              'argv[' +\n              argIndex +\n              ']:' +\n              argv[0] +\n              ':' +\n              wasm.cstrToJs(argv[1]).toLowerCase()\n            );\n          };\n          const __sqlite3CreateCollationV2 = wasm.xWrap(\n            'sqlite3_create_collation_v2',\n            'int',\n            [\n              'sqlite3*',\n              'string',\n              'int',\n              '*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xCompare',\n                signature: 'i(pipip)',\n                contextKey,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xDestroy',\n                signature: 'v(p)',\n                contextKey,\n              }),\n            ],\n          );\n\n          capi.sqlite3_create_collation_v2 = function (\n            pDb,\n            zName,\n            eTextRep,\n            pArg,\n            xCompare,\n            xDestroy,\n          ) {\n            if (6 !== arguments.length)\n              return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);\n            else if (0 === (eTextRep & 0xf)) {\n              eTextRep |= capi.SQLITE_UTF8;\n            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n              return __errEncoding(pDb);\n            }\n            try {\n              const rc = __sqlite3CreateCollationV2(\n                pDb,\n                zName,\n                eTextRep,\n                pArg,\n                xCompare,\n                xDestroy,\n              );\n              if (0 === rc && xCompare instanceof Function) {\n                __dbCleanupMap.addCollation(pDb, zName);\n              }\n              return rc;\n            } catch (e) {\n              return util.sqlite3__wasm_db_error(pDb, e);\n            }\n          };\n\n          capi.sqlite3_create_collation = (\n            pDb,\n            zName,\n            eTextRep,\n            pArg,\n            xCompare,\n          ) => {\n            return 5 === arguments.length\n              ? capi.sqlite3_create_collation_v2(\n                  pDb,\n                  zName,\n                  eTextRep,\n                  pArg,\n                  xCompare,\n                  0,\n                )\n              : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);\n          };\n        }\n\n        {\n          const contextKey = function (argv, argIndex) {\n            return (\n              argv[0] +\n              ':' +\n              (argv[2] < 0 ? -1 : argv[2]) +\n              ':' +\n              argIndex +\n              ':' +\n              wasm.cstrToJs(argv[1]).toLowerCase()\n            );\n          };\n\n          const __cfProxy = Object.assign(Object.create(null), {\n            xInverseAndStep: {\n              signature: 'v(pip)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx, argc, pArgv) => {\n                  try {\n                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xFinalAndValue: {\n              signature: 'v(p)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx) => {\n                  try {\n                    capi.sqlite3_result_js(pCtx, callback(pCtx));\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xFunc: {\n              signature: 'v(pip)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx, argc, pArgv) => {\n                  try {\n                    capi.sqlite3_result_js(\n                      pCtx,\n                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)),\n                    );\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xDestroy: {\n              signature: 'v(p)',\n              contextKey,\n\n              callProxy: (callback) => {\n                return (pVoid) => {\n                  try {\n                    callback(pVoid);\n                  } catch (e) {\n                    console.error('UDF xDestroy method threw:', e);\n                  }\n                };\n              },\n            },\n          });\n\n          const __sqlite3CreateFunction = wasm.xWrap(\n            'sqlite3_create_function_v2',\n            'int',\n            [\n              'sqlite3*',\n              'string',\n              'int',\n              'int',\n              '*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xFunc',\n                ...__cfProxy.xFunc,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xStep',\n                ...__cfProxy.xInverseAndStep,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xFinal',\n                ...__cfProxy.xFinalAndValue,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xDestroy',\n                ...__cfProxy.xDestroy,\n              }),\n            ],\n          );\n\n          const __sqlite3CreateWindowFunction = wasm.exports\n            .sqlite3_create_window_function\n            ? wasm.xWrap('sqlite3_create_window_function', 'int', [\n                'sqlite3*',\n                'string',\n                'int',\n                'int',\n                '*',\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xStep',\n                  ...__cfProxy.xInverseAndStep,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xFinal',\n                  ...__cfProxy.xFinalAndValue,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xValue',\n                  ...__cfProxy.xFinalAndValue,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xInverse',\n                  ...__cfProxy.xInverseAndStep,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xDestroy',\n                  ...__cfProxy.xDestroy,\n                }),\n              ])\n            : undefined;\n\n          capi.sqlite3_create_function_v2 = function f(\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                pDb,\n                'sqlite3_create_function_v2',\n                f.length,\n              );\n            } else if (0 === (eTextRep & 0xf)) {\n              eTextRep |= capi.SQLITE_UTF8;\n            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n              return __errEncoding(pDb);\n            }\n            try {\n              const rc = __sqlite3CreateFunction(\n                pDb,\n                funcName,\n                nArg,\n                eTextRep,\n                pApp,\n                xFunc,\n                xStep,\n                xFinal,\n                xDestroy,\n              );\n              if (\n                0 === rc &&\n                (xFunc instanceof Function ||\n                  xStep instanceof Function ||\n                  xFinal instanceof Function ||\n                  xDestroy instanceof Function)\n              ) {\n                __dbCleanupMap.addFunction(pDb, funcName, nArg);\n              }\n              return rc;\n            } catch (e) {\n              console.error('sqlite3_create_function_v2() setup threw:', e);\n              return util.sqlite3__wasm_db_error(\n                pDb,\n                e,\n                'Creation of UDF threw: ' + e,\n              );\n            }\n          };\n\n          capi.sqlite3_create_function = function f(\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n          ) {\n            return f.length === arguments.length\n              ? capi.sqlite3_create_function_v2(\n                  pDb,\n                  funcName,\n                  nArg,\n                  eTextRep,\n                  pApp,\n                  xFunc,\n                  xStep,\n                  xFinal,\n                  0,\n                )\n              : __dbArgcMismatch(pDb, 'sqlite3_create_function', f.length);\n          };\n\n          if (__sqlite3CreateWindowFunction) {\n            capi.sqlite3_create_window_function = function f(\n              pDb,\n              funcName,\n              nArg,\n              eTextRep,\n              pApp,\n              xStep,\n              xFinal,\n              xValue,\n              xInverse,\n              xDestroy,\n            ) {\n              if (f.length !== arguments.length) {\n                return __dbArgcMismatch(\n                  pDb,\n                  'sqlite3_create_window_function',\n                  f.length,\n                );\n              } else if (0 === (eTextRep & 0xf)) {\n                eTextRep |= capi.SQLITE_UTF8;\n              } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n                return __errEncoding(pDb);\n              }\n              try {\n                const rc = __sqlite3CreateWindowFunction(\n                  pDb,\n                  funcName,\n                  nArg,\n                  eTextRep,\n                  pApp,\n                  xStep,\n                  xFinal,\n                  xValue,\n                  xInverse,\n                  xDestroy,\n                );\n                if (\n                  0 === rc &&\n                  (xStep instanceof Function ||\n                    xFinal instanceof Function ||\n                    xValue instanceof Function ||\n                    xInverse instanceof Function ||\n                    xDestroy instanceof Function)\n                ) {\n                  __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);\n                }\n                return rc;\n              } catch (e) {\n                console.error(\n                  'sqlite3_create_window_function() setup threw:',\n                  e,\n                );\n                return util.sqlite3__wasm_db_error(\n                  pDb,\n                  e,\n                  'Creation of UDF threw: ' + e,\n                );\n              }\n            };\n          } else {\n            delete capi.sqlite3_create_window_function;\n          }\n\n          capi.sqlite3_create_function_v2.udfSetResult =\n            capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfSetResult =\n              capi.sqlite3_result_js;\n          }\n\n          capi.sqlite3_create_function_v2.udfConvertArgs =\n            capi.sqlite3_create_function.udfConvertArgs =\n              capi.sqlite3_values_to_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfConvertArgs =\n              capi.sqlite3_values_to_js;\n          }\n\n          capi.sqlite3_create_function_v2.udfSetError =\n            capi.sqlite3_create_function.udfSetError =\n              capi.sqlite3_result_error_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfSetError =\n              capi.sqlite3_result_error_js;\n          }\n        }\n\n        {\n          const __flexiString = (v, n) => {\n            if ('string' === typeof v) {\n              n = -1;\n            } else if (util.isSQLableTypedArray(v)) {\n              n = v.byteLength;\n              v = util.typedArrayToString(\n                v instanceof ArrayBuffer ? new Uint8Array(v) : v,\n              );\n            } else if (Array.isArray(v)) {\n              v = v.join('');\n              n = -1;\n            }\n            return [v, n];\n          };\n\n          const __prepare = {\n            basic: wasm.xWrap('sqlite3_prepare_v3', 'int', [\n              'sqlite3*',\n              'string',\n              'int',\n              'int',\n              '**',\n              '**',\n            ]),\n\n            full: wasm.xWrap('sqlite3_prepare_v3', 'int', [\n              'sqlite3*',\n              '*',\n              'int',\n              'int',\n              '**',\n              '**',\n            ]),\n          };\n\n          capi.sqlite3_prepare_v3 = function f(\n            pDb,\n            sql,\n            sqlLen,\n            prepFlags,\n            ppStmt,\n            pzTail,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(pDb, 'sqlite3_prepare_v3', f.length);\n            }\n            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);\n            switch (typeof xSql) {\n              case 'string':\n                return __prepare.basic(\n                  pDb,\n                  xSql,\n                  xSqlLen,\n                  prepFlags,\n                  ppStmt,\n                  null,\n                );\n              case 'number':\n                return __prepare.full(\n                  pDb,\n                  xSql,\n                  xSqlLen,\n                  prepFlags,\n                  ppStmt,\n                  pzTail,\n                );\n              default:\n                return util.sqlite3__wasm_db_error(\n                  pDb,\n                  capi.SQLITE_MISUSE,\n                  'Invalid SQL argument type for sqlite3_prepare_v2/v3().',\n                );\n            }\n          };\n\n          capi.sqlite3_prepare_v2 = function f(\n            pDb,\n            sql,\n            sqlLen,\n            ppStmt,\n            pzTail,\n          ) {\n            return f.length === arguments.length\n              ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)\n              : __dbArgcMismatch(pDb, 'sqlite3_prepare_v2', f.length);\n          };\n        }\n\n        {\n          const __bindText = wasm.xWrap('sqlite3_bind_text', 'int', [\n            'sqlite3_stmt*',\n            'int',\n            'string',\n            'int',\n            '*',\n          ]);\n          const __bindBlob = wasm.xWrap('sqlite3_bind_blob', 'int', [\n            'sqlite3_stmt*',\n            'int',\n            '*',\n            'int',\n            '*',\n          ]);\n\n          capi.sqlite3_bind_text = function f(\n            pStmt,\n            iCol,\n            text,\n            nText,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                capi.sqlite3_db_handle(pStmt),\n                'sqlite3_bind_text',\n                f.length,\n              );\n            } else if (wasm.isPtr(text) || null === text) {\n              return __bindText(pStmt, iCol, text, nText, xDestroy);\n            } else if (text instanceof ArrayBuffer) {\n              text = new Uint8Array(text);\n            } else if (Array.isArray(pMem)) {\n              text = pMem.join('');\n            }\n            let p, n;\n            try {\n              if (util.isSQLableTypedArray(text)) {\n                p = wasm.allocFromTypedArray(text);\n                n = text.byteLength;\n              } else if ('string' === typeof text) {\n                [p, n] = wasm.allocCString(text);\n              } else {\n                return util.sqlite3__wasm_db_error(\n                  capi.sqlite3_db_handle(pStmt),\n                  capi.SQLITE_MISUSE,\n                  'Invalid 3rd argument type for sqlite3_bind_text().',\n                );\n              }\n              return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n            } catch (e) {\n              wasm.dealloc(p);\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                e,\n              );\n            }\n          };\n\n          capi.sqlite3_bind_blob = function f(\n            pStmt,\n            iCol,\n            pMem,\n            nMem,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                capi.sqlite3_db_handle(pStmt),\n                'sqlite3_bind_blob',\n                f.length,\n              );\n            } else if (wasm.isPtr(pMem) || null === pMem) {\n              return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);\n            } else if (pMem instanceof ArrayBuffer) {\n              pMem = new Uint8Array(pMem);\n            } else if (Array.isArray(pMem)) {\n              pMem = pMem.join('');\n            }\n            let p, n;\n            try {\n              if (util.isBindableTypedArray(pMem)) {\n                p = wasm.allocFromTypedArray(pMem);\n                n = nMem >= 0 ? nMem : pMem.byteLength;\n              } else if ('string' === typeof pMem) {\n                [p, n] = wasm.allocCString(pMem);\n              } else {\n                return util.sqlite3__wasm_db_error(\n                  capi.sqlite3_db_handle(pStmt),\n                  capi.SQLITE_MISUSE,\n                  'Invalid 3rd argument type for sqlite3_bind_blob().',\n                );\n              }\n              return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n            } catch (e) {\n              wasm.dealloc(p);\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                e,\n              );\n            }\n          };\n        }\n\n        {\n          capi.sqlite3_config = function (op, ...args) {\n            if (arguments.length < 2) return capi.SQLITE_MISUSE;\n            switch (op) {\n              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:\n              case capi.SQLITE_CONFIG_MEMSTATUS:\n              case capi.SQLITE_CONFIG_SMALL_MALLOC:\n              case capi.SQLITE_CONFIG_SORTERREF_SIZE:\n              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:\n              case capi.SQLITE_CONFIG_URI:\n                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);\n              case capi.SQLITE_CONFIG_LOOKASIDE:\n                return wasm.exports.sqlite3__wasm_config_ii(\n                  op,\n                  args[0],\n                  args[1],\n                );\n              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:\n                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);\n              case capi.SQLITE_CONFIG_GETMALLOC:\n              case capi.SQLITE_CONFIG_GETMUTEX:\n              case capi.SQLITE_CONFIG_GETPCACHE2:\n              case capi.SQLITE_CONFIG_GETPCACHE:\n              case capi.SQLITE_CONFIG_HEAP:\n              case capi.SQLITE_CONFIG_LOG:\n              case capi.SQLITE_CONFIG_MALLOC:\n              case capi.SQLITE_CONFIG_MMAP_SIZE:\n              case capi.SQLITE_CONFIG_MULTITHREAD:\n              case capi.SQLITE_CONFIG_MUTEX:\n              case capi.SQLITE_CONFIG_PAGECACHE:\n              case capi.SQLITE_CONFIG_PCACHE2:\n              case capi.SQLITE_CONFIG_PCACHE:\n              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:\n              case capi.SQLITE_CONFIG_PMASZ:\n              case capi.SQLITE_CONFIG_SERIALIZED:\n              case capi.SQLITE_CONFIG_SINGLETHREAD:\n              case capi.SQLITE_CONFIG_SQLLOG:\n              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:\n              default:\n                return capi.SQLITE_NOTFOUND;\n            }\n          };\n        }\n\n        {\n          const __autoExtFptr = new Set();\n\n          capi.sqlite3_auto_extension = function (fPtr) {\n            if (fPtr instanceof Function) {\n              fPtr = wasm.installFunction('i(ppp)', fPtr);\n            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {\n              return capi.SQLITE_MISUSE;\n            }\n            const rc = wasm.exports.sqlite3_auto_extension(fPtr);\n            if (fPtr !== arguments[0]) {\n              if (0 === rc) __autoExtFptr.add(fPtr);\n              else wasm.uninstallFunction(fPtr);\n            }\n            return rc;\n          };\n\n          capi.sqlite3_cancel_auto_extension = function (fPtr) {\n            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;\n            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);\n          };\n\n          capi.sqlite3_reset_auto_extension = function () {\n            wasm.exports.sqlite3_reset_auto_extension();\n            for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);\n            __autoExtFptr.clear();\n          };\n        }\n\n        const pKvvfs = capi.sqlite3_vfs_find('kvvfs');\n        if (pKvvfs) {\n          if (util.isUIThread()) {\n            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(\n              wasm.exports.sqlite3__wasm_kvvfs_methods(),\n            );\n            delete capi.sqlite3_kvvfs_methods;\n\n            const kvvfsMakeKey =\n                wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack,\n              pstack = wasm.pstack;\n\n            const kvvfsStorage = (zClass) =>\n              115 === wasm.peek(zClass) ? sessionStorage : localStorage;\n\n            const kvvfsImpls = {\n              xRead: (zClass, zKey, zBuf, nBuf) => {\n                const stack = pstack.pointer,\n                  astack = wasm.scopedAllocPush();\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return -3;\n                  const jKey = wasm.cstrToJs(zXKey);\n                  const jV = kvvfsStorage(zClass).getItem(jKey);\n                  if (!jV) return -1;\n                  const nV = jV.length;\n                  if (nBuf <= 0) return nV;\n                  else if (1 === nBuf) {\n                    wasm.poke(zBuf, 0);\n                    return nV;\n                  }\n                  const zV = wasm.scopedAllocCString(jV);\n                  if (nBuf > nV + 1) nBuf = nV + 1;\n                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);\n                  wasm.poke(zBuf + nBuf - 1, 0);\n                  return nBuf - 1;\n                } catch (e) {\n                  console.error('kvstorageRead()', e);\n                  return -2;\n                } finally {\n                  pstack.restore(stack);\n                  wasm.scopedAllocPop(astack);\n                }\n              },\n              xWrite: (zClass, zKey, zData) => {\n                const stack = pstack.pointer;\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return 1;\n                  const jKey = wasm.cstrToJs(zXKey);\n                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));\n                  return 0;\n                } catch (e) {\n                  console.error('kvstorageWrite()', e);\n                  return capi.SQLITE_IOERR;\n                } finally {\n                  pstack.restore(stack);\n                }\n              },\n              xDelete: (zClass, zKey) => {\n                const stack = pstack.pointer;\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return 1;\n                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));\n                  return 0;\n                } catch (e) {\n                  console.error('kvstorageDelete()', e);\n                  return capi.SQLITE_IOERR;\n                } finally {\n                  pstack.restore(stack);\n                }\n              },\n            };\n            for (const k of Object.keys(kvvfsImpls)) {\n              kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(\n                kvvfsMethods.memberSignature(k),\n                kvvfsImpls[k],\n              );\n            }\n          } else {\n            capi.sqlite3_vfs_unregister(pKvvfs);\n          }\n        }\n\n        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;\n\n        const StructBinder = sqlite3.StructBinder;\n        const installMethod = function callee(\n          tgt,\n          name,\n          func,\n          applyArgcCheck = callee.installMethodArgcCheck,\n        ) {\n          if (!(tgt instanceof StructBinder.StructType)) {\n            toss('Usage error: target object is-not-a StructType.');\n          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {\n            toss('Usage errror: expecting a Function or WASM pointer to one.');\n          }\n          if (1 === arguments.length) {\n            return (n, f) => callee(tgt, n, f, applyArgcCheck);\n          }\n          if (!callee.argcProxy) {\n            callee.argcProxy = function (tgt, funcName, func, sig) {\n              return function (...args) {\n                if (func.length !== arguments.length) {\n                  toss(\n                    'Argument mismatch for',\n                    tgt.structInfo.name +\n                      '::' +\n                      funcName +\n                      ': Native signature is:',\n                    sig,\n                  );\n                }\n                return func.apply(this, args);\n              };\n            };\n\n            callee.removeFuncList = function () {\n              if (this.ondispose.__removeFuncList) {\n                this.ondispose.__removeFuncList.forEach((v, ndx) => {\n                  if ('number' === typeof v) {\n                    try {\n                      wasm.uninstallFunction(v);\n                    } catch (e) {}\n                  }\n                });\n                delete this.ondispose.__removeFuncList;\n              }\n            };\n          }\n          const sigN = tgt.memberSignature(name);\n          if (sigN.length < 2) {\n            toss(\n              'Member',\n              name,\n              'does not have a function pointer signature:',\n              sigN,\n            );\n          }\n          const memKey = tgt.memberKey(name);\n          const fProxy =\n            applyArgcCheck && !wasm.isPtr(func)\n              ? callee.argcProxy(tgt, memKey, func, sigN)\n              : func;\n          if (wasm.isPtr(fProxy)) {\n            if (fProxy && !wasm.functionEntry(fProxy)) {\n              toss('Pointer', fProxy, 'is not a WASM function table entry.');\n            }\n            tgt[memKey] = fProxy;\n          } else {\n            const pFunc = wasm.installFunction(\n              fProxy,\n              tgt.memberSignature(name, true),\n            );\n            tgt[memKey] = pFunc;\n            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {\n              tgt.addOnDispose(\n                'ondispose.__removeFuncList handler',\n                callee.removeFuncList,\n              );\n              tgt.ondispose.__removeFuncList = [];\n            }\n            tgt.ondispose.__removeFuncList.push(memKey, pFunc);\n          }\n          return (n, f) => callee(tgt, n, f, applyArgcCheck);\n        };\n        installMethod.installMethodArgcCheck = false;\n\n        const installMethods = function (\n          structInstance,\n          methods,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          const seen = new Map();\n          for (const k of Object.keys(methods)) {\n            const m = methods[k];\n            const prior = seen.get(m);\n            if (prior) {\n              const mkey = structInstance.memberKey(k);\n              structInstance[mkey] =\n                structInstance[structInstance.memberKey(prior)];\n            } else {\n              installMethod(structInstance, k, m, applyArgcCheck);\n              seen.set(m, k);\n            }\n          }\n          return structInstance;\n        };\n\n        StructBinder.StructType.prototype.installMethod = function callee(\n          name,\n          func,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          return arguments.length < 3 && name && 'object' === typeof name\n            ? installMethods(this, ...arguments)\n            : installMethod(this, ...arguments);\n        };\n\n        StructBinder.StructType.prototype.installMethods = function (\n          methods,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          return installMethods(this, methods, applyArgcCheck);\n        };\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        sqlite3.version = {\n          libVersion: '3.49.1',\n          libVersionNumber: 3049001,\n          sourceId:\n            '2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70',\n          downloadVersion: 3490100,\n        };\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n        const toss3 = (...args) => {\n          throw new sqlite3.SQLite3Error(...args);\n        };\n\n        const capi = sqlite3.capi,\n          wasm = sqlite3.wasm,\n          util = sqlite3.util;\n\n        const __ptrMap = new WeakMap();\n\n        const __stmtMap = new WeakMap();\n\n        const getOwnOption = (opts, p, dflt) => {\n          const d = Object.getOwnPropertyDescriptor(opts, p);\n          return d ? d.value : dflt;\n        };\n\n        const checkSqlite3Rc = function (dbPtr, sqliteResultCode) {\n          if (sqliteResultCode) {\n            if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;\n            toss3(\n              sqliteResultCode,\n              'sqlite3 result code',\n              sqliteResultCode + ':',\n              dbPtr\n                ? capi.sqlite3_errmsg(dbPtr)\n                : capi.sqlite3_errstr(sqliteResultCode),\n            );\n          }\n          return arguments[0];\n        };\n\n        const __dbTraceToConsole = wasm.installFunction(\n          'i(ippp)',\n          function (t, c, p, x) {\n            if (capi.SQLITE_TRACE_STMT === t) {\n              console.log(\n                'SQL TRACE #' + ++this.counter + ' via sqlite3@' + c + ':',\n                wasm.cstrToJs(x),\n              );\n            }\n          }.bind({ counter: 0 }),\n        );\n\n        const __vfsPostOpenCallback = Object.create(null);\n\n        const dbCtorHelper = function ctor(...args) {\n          if (!ctor._name2vfs) {\n            ctor._name2vfs = Object.create(null);\n            const isWorkerThread =\n              'function' === typeof importScripts\n                ? (n) =>\n                    toss3(\n                      'The VFS for',\n                      n,\n                      'is only available in the main window thread.',\n                    )\n                : false;\n            ctor._name2vfs[':localStorage:'] = {\n              vfs: 'kvvfs',\n              filename: isWorkerThread || (() => 'local'),\n            };\n            ctor._name2vfs[':sessionStorage:'] = {\n              vfs: 'kvvfs',\n              filename: isWorkerThread || (() => 'session'),\n            };\n          }\n          const opt = ctor.normalizeArgs(...args);\n          let fn = opt.filename,\n            vfsName = opt.vfs,\n            flagsStr = opt.flags;\n          if (\n            ('string' !== typeof fn && 'number' !== typeof fn) ||\n            'string' !== typeof flagsStr ||\n            (vfsName &&\n              'string' !== typeof vfsName &&\n              'number' !== typeof vfsName)\n          ) {\n            sqlite3.config.error('Invalid DB ctor args', opt, arguments);\n            toss3('Invalid arguments for DB constructor.');\n          }\n          let fnJs = 'number' === typeof fn ? wasm.cstrToJs(fn) : fn;\n          const vfsCheck = ctor._name2vfs[fnJs];\n          if (vfsCheck) {\n            vfsName = vfsCheck.vfs;\n            fn = fnJs = vfsCheck.filename(fnJs);\n          }\n          let pDb,\n            oflags = 0;\n          if (flagsStr.indexOf('c') >= 0) {\n            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;\n          }\n          if (flagsStr.indexOf('w') >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;\n          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;\n          oflags |= capi.SQLITE_OPEN_EXRESCODE;\n          const stack = wasm.pstack.pointer;\n          try {\n            const pPtr = wasm.pstack.allocPtr();\n            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);\n            pDb = wasm.peekPtr(pPtr);\n            checkSqlite3Rc(pDb, rc);\n            capi.sqlite3_extended_result_codes(pDb, 1);\n            if (flagsStr.indexOf('t') >= 0) {\n              capi.sqlite3_trace_v2(\n                pDb,\n                capi.SQLITE_TRACE_STMT,\n                __dbTraceToConsole,\n                pDb,\n              );\n            }\n          } catch (e) {\n            if (pDb) capi.sqlite3_close_v2(pDb);\n            throw e;\n          } finally {\n            wasm.pstack.restore(stack);\n          }\n          this.filename = fnJs;\n          __ptrMap.set(this, pDb);\n          __stmtMap.set(this, Object.create(null));\n          try {\n            const pVfs =\n              capi.sqlite3_js_db_vfs(pDb) ||\n              toss3('Internal error: cannot get VFS for new db handle.');\n            const postInitSql = __vfsPostOpenCallback[pVfs];\n            if (postInitSql) {\n              if (postInitSql instanceof Function) {\n                postInitSql(this, sqlite3);\n              } else {\n                checkSqlite3Rc(\n                  pDb,\n                  capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0),\n                );\n              }\n            }\n          } catch (e) {\n            this.close();\n            throw e;\n          }\n        };\n\n        dbCtorHelper.setVfsPostOpenCallback = function (pVfs, callback) {\n          if (!(callback instanceof Function)) {\n            toss3(\n              'dbCtorHelper.setVfsPostOpenCallback() should not be used with ' +\n                'a non-function argument.',\n              arguments,\n            );\n          }\n          __vfsPostOpenCallback[pVfs] = callback;\n        };\n\n        dbCtorHelper.normalizeArgs = function (\n          filename = ':memory:',\n          flags = 'c',\n          vfs = null,\n        ) {\n          const arg = {};\n          if (\n            1 === arguments.length &&\n            arguments[0] &&\n            'object' === typeof arguments[0]\n          ) {\n            Object.assign(arg, arguments[0]);\n            if (undefined === arg.flags) arg.flags = 'c';\n            if (undefined === arg.vfs) arg.vfs = null;\n            if (undefined === arg.filename) arg.filename = ':memory:';\n          } else {\n            arg.filename = filename;\n            arg.flags = flags;\n            arg.vfs = vfs;\n          }\n          return arg;\n        };\n\n        const DB = function (...args) {\n          dbCtorHelper.apply(this, args);\n        };\n        DB.dbCtorHelper = dbCtorHelper;\n\n        const BindTypes = {\n          null: 1,\n          number: 2,\n          string: 3,\n          boolean: 4,\n          blob: 5,\n        };\n        BindTypes['undefined'] == BindTypes.null;\n        if (wasm.bigIntEnabled) {\n          BindTypes.bigint = BindTypes.number;\n        }\n\n        const Stmt = function () {\n          if (BindTypes !== arguments[2]) {\n            toss3(\n              capi.SQLITE_MISUSE,\n              'Do not call the Stmt constructor directly. Use DB.prepare().',\n            );\n          }\n          this.db = arguments[0];\n          __ptrMap.set(this, arguments[1]);\n          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);\n        };\n\n        const affirmDbOpen = function (db) {\n          if (!db.pointer) toss3('DB has been closed.');\n          return db;\n        };\n\n        const affirmColIndex = function (stmt, ndx) {\n          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {\n            toss3('Column index', ndx, 'is out of range.');\n          }\n          return stmt;\n        };\n\n        const parseExecArgs = function (db, args) {\n          const out = Object.create(null);\n          out.opt = Object.create(null);\n          switch (args.length) {\n            case 1:\n              if (\n                'string' === typeof args[0] ||\n                util.isSQLableTypedArray(args[0])\n              ) {\n                out.sql = args[0];\n              } else if (Array.isArray(args[0])) {\n                out.sql = args[0];\n              } else if (args[0] && 'object' === typeof args[0]) {\n                out.opt = args[0];\n                out.sql = out.opt.sql;\n              }\n              break;\n            case 2:\n              out.sql = args[0];\n              out.opt = args[1];\n              break;\n            default:\n              toss3('Invalid argument count for exec().');\n          }\n          out.sql = util.flexibleString(out.sql);\n          if ('string' !== typeof out.sql) {\n            toss3('Missing SQL argument or unsupported SQL value type.');\n          }\n          const opt = out.opt;\n          switch (opt.returnValue) {\n            case 'resultRows':\n              if (!opt.resultRows) opt.resultRows = [];\n              out.returnVal = () => opt.resultRows;\n              break;\n            case 'saveSql':\n              if (!opt.saveSql) opt.saveSql = [];\n              out.returnVal = () => opt.saveSql;\n              break;\n            case undefined:\n            case 'this':\n              out.returnVal = () => db;\n              break;\n            default:\n              toss3('Invalid returnValue value:', opt.returnValue);\n          }\n          if (!opt.callback && !opt.returnValue && undefined !== opt.rowMode) {\n            if (!opt.resultRows) opt.resultRows = [];\n            out.returnVal = () => opt.resultRows;\n          }\n          if (opt.callback || opt.resultRows) {\n            switch (undefined === opt.rowMode ? 'array' : opt.rowMode) {\n              case 'object':\n                out.cbArg = (stmt, cache) => {\n                  if (!cache.columnNames)\n                    cache.columnNames = stmt.getColumnNames([]);\n\n                  const row = stmt.get([]);\n                  const rv = Object.create(null);\n                  for (const i in cache.columnNames)\n                    rv[cache.columnNames[i]] = row[i];\n                  return rv;\n                };\n                break;\n              case 'array':\n                out.cbArg = (stmt) => stmt.get([]);\n                break;\n              case 'stmt':\n                if (Array.isArray(opt.resultRows)) {\n                  toss3(\n                    'exec(): invalid rowMode for a resultRows array: must',\n                    \"be one of 'array', 'object',\",\n                    'a result column number, or column name reference.',\n                  );\n                }\n                out.cbArg = (stmt) => stmt;\n                break;\n              default:\n                if (util.isInt32(opt.rowMode)) {\n                  out.cbArg = (stmt) => stmt.get(opt.rowMode);\n                  break;\n                } else if (\n                  'string' === typeof opt.rowMode &&\n                  opt.rowMode.length > 1 &&\n                  '$' === opt.rowMode[0]\n                ) {\n                  const $colName = opt.rowMode.substr(1);\n                  out.cbArg = (stmt) => {\n                    const rc = stmt.get(Object.create(null))[$colName];\n                    return undefined === rc\n                      ? toss3(\n                          capi.SQLITE_NOTFOUND,\n                          'exec(): unknown result column:',\n                          $colName,\n                        )\n                      : rc;\n                  };\n                  break;\n                }\n                toss3('Invalid rowMode:', opt.rowMode);\n            }\n          }\n          return out;\n        };\n\n        const __selectFirstRow = (db, sql, bind, ...getArgs) => {\n          const stmt = db.prepare(sql);\n          try {\n            const rc = stmt.bind(bind).step()\n              ? stmt.get(...getArgs)\n              : undefined;\n            stmt.reset();\n            return rc;\n          } finally {\n            stmt.finalize();\n          }\n        };\n\n        const __selectAll = (db, sql, bind, rowMode) =>\n          db.exec({\n            sql,\n            bind,\n            rowMode,\n            returnValue: 'resultRows',\n          });\n\n        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);\n\n        DB.prototype = {\n          isOpen: function () {\n            return !!this.pointer;\n          },\n\n          affirmOpen: function () {\n            return affirmDbOpen(this);\n          },\n\n          close: function () {\n            if (this.pointer) {\n              if (this.onclose && this.onclose.before instanceof Function) {\n                try {\n                  this.onclose.before(this);\n                } catch (e) {}\n              }\n              const pDb = this.pointer;\n              Object.keys(__stmtMap.get(this)).forEach((k, s) => {\n                if (s && s.pointer) {\n                  try {\n                    s.finalize();\n                  } catch (e) {}\n                }\n              });\n              __ptrMap.delete(this);\n              __stmtMap.delete(this);\n              capi.sqlite3_close_v2(pDb);\n              if (this.onclose && this.onclose.after instanceof Function) {\n                try {\n                  this.onclose.after(this);\n                } catch (e) {}\n              }\n              delete this.filename;\n            }\n          },\n\n          changes: function (total = false, sixtyFour = false) {\n            const p = affirmDbOpen(this).pointer;\n            if (total) {\n              return sixtyFour\n                ? capi.sqlite3_total_changes64(p)\n                : capi.sqlite3_total_changes(p);\n            } else {\n              return sixtyFour\n                ? capi.sqlite3_changes64(p)\n                : capi.sqlite3_changes(p);\n            }\n          },\n\n          dbFilename: function (dbName = 'main') {\n            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);\n          },\n\n          dbName: function (dbNumber = 0) {\n            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);\n          },\n\n          dbVfsName: function (dbName = 0) {\n            let rc;\n            const pVfs = capi.sqlite3_js_db_vfs(\n              affirmDbOpen(this).pointer,\n              dbName,\n            );\n            if (pVfs) {\n              const v = new capi.sqlite3_vfs(pVfs);\n              try {\n                rc = wasm.cstrToJs(v.$zName);\n              } finally {\n                v.dispose();\n              }\n            }\n            return rc;\n          },\n\n          prepare: function (sql) {\n            affirmDbOpen(this);\n            const stack = wasm.pstack.pointer;\n            let ppStmt, pStmt;\n            try {\n              ppStmt = wasm.pstack.alloc(8);\n              DB.checkRc(\n                this,\n                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null),\n              );\n              pStmt = wasm.peekPtr(ppStmt);\n            } finally {\n              wasm.pstack.restore(stack);\n            }\n            if (!pStmt) toss3('Cannot prepare empty SQL.');\n            const stmt = new Stmt(this, pStmt, BindTypes);\n            __stmtMap.get(this)[pStmt] = stmt;\n            return stmt;\n          },\n\n          exec: function () {\n            affirmDbOpen(this);\n            const arg = parseExecArgs(this, arguments);\n            if (!arg.sql) {\n              return toss3('exec() requires an SQL string.');\n            }\n            const opt = arg.opt;\n            const callback = opt.callback;\n            const resultRows = Array.isArray(opt.resultRows)\n              ? opt.resultRows\n              : undefined;\n            let stmt;\n            let bind = opt.bind;\n            let evalFirstResult = !!(\n              arg.cbArg ||\n              opt.columnNames ||\n              resultRows\n            );\n            const stack = wasm.scopedAllocPush();\n            const saveSql = Array.isArray(opt.saveSql)\n              ? opt.saveSql\n              : undefined;\n            try {\n              const isTA = util.isSQLableTypedArray(arg.sql);\n              let sqlByteLen = isTA\n                ? arg.sql.byteLength\n                : wasm.jstrlen(arg.sql);\n              const ppStmt = wasm.scopedAlloc(\n                2 * wasm.ptrSizeof + (sqlByteLen + 1),\n              );\n              const pzTail = ppStmt + wasm.ptrSizeof;\n              let pSql = pzTail + wasm.ptrSizeof;\n              const pSqlEnd = pSql + sqlByteLen;\n              if (isTA) wasm.heap8().set(arg.sql, pSql);\n              else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);\n              wasm.poke(pSql + sqlByteLen, 0);\n              while (pSql && wasm.peek(pSql, 'i8')) {\n                wasm.pokePtr([ppStmt, pzTail], 0);\n                DB.checkRc(\n                  this,\n                  capi.sqlite3_prepare_v3(\n                    this.pointer,\n                    pSql,\n                    sqlByteLen,\n                    0,\n                    ppStmt,\n                    pzTail,\n                  ),\n                );\n                const pStmt = wasm.peekPtr(ppStmt);\n                pSql = wasm.peekPtr(pzTail);\n                sqlByteLen = pSqlEnd - pSql;\n                if (!pStmt) continue;\n                if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());\n                stmt = new Stmt(this, pStmt, BindTypes);\n                if (bind && stmt.parameterCount) {\n                  stmt.bind(bind);\n                  bind = null;\n                }\n                if (evalFirstResult && stmt.columnCount) {\n                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;\n                  evalFirstResult = false;\n                  if (arg.cbArg || resultRows) {\n                    const cbArgCache = Object.create(null);\n                    for (; stmt.step(); stmt._lockedByExec = false) {\n                      if (0 === gotColNames++) {\n                        stmt.getColumnNames(\n                          (cbArgCache.columnNames = opt.columnNames || []),\n                        );\n                      }\n                      stmt._lockedByExec = true;\n                      const row = arg.cbArg(stmt, cbArgCache);\n                      if (resultRows) resultRows.push(row);\n                      if (callback && false === callback.call(opt, row, stmt)) {\n                        break;\n                      }\n                    }\n                    stmt._lockedByExec = false;\n                  }\n                  if (0 === gotColNames) {\n                    stmt.getColumnNames(opt.columnNames);\n                  }\n                } else {\n                  stmt.step();\n                }\n                stmt.reset().finalize();\n                stmt = null;\n              }\n            } finally {\n              wasm.scopedAllocPop(stack);\n              if (stmt) {\n                delete stmt._lockedByExec;\n                stmt.finalize();\n              }\n            }\n            return arg.returnVal();\n          },\n\n          createFunction: function f(name, xFunc, opt) {\n            const isFunc = (f) => f instanceof Function;\n            switch (arguments.length) {\n              case 1:\n                opt = name;\n                name = opt.name;\n                xFunc = opt.xFunc || 0;\n                break;\n              case 2:\n                if (!isFunc(xFunc)) {\n                  opt = xFunc;\n                  xFunc = opt.xFunc || 0;\n                }\n                break;\n              case 3:\n                break;\n              default:\n                break;\n            }\n            if (!opt) opt = {};\n            if ('string' !== typeof name) {\n              toss3('Invalid arguments: missing function name.');\n            }\n            let xStep = opt.xStep || 0;\n            let xFinal = opt.xFinal || 0;\n            const xValue = opt.xValue || 0;\n            const xInverse = opt.xInverse || 0;\n            let isWindow = undefined;\n            if (isFunc(xFunc)) {\n              isWindow = false;\n              if (isFunc(xStep) || isFunc(xFinal)) {\n                toss3('Ambiguous arguments: scalar or aggregate?');\n              }\n              xStep = xFinal = null;\n            } else if (isFunc(xStep)) {\n              if (!isFunc(xFinal)) {\n                toss3('Missing xFinal() callback for aggregate or window UDF.');\n              }\n              xFunc = null;\n            } else if (isFunc(xFinal)) {\n              toss3('Missing xStep() callback for aggregate or window UDF.');\n            } else {\n              toss3('Missing function-type properties.');\n            }\n            if (false === isWindow) {\n              if (isFunc(xValue) || isFunc(xInverse)) {\n                toss3(\n                  'xValue and xInverse are not permitted for non-window UDFs.',\n                );\n              }\n            } else if (isFunc(xValue)) {\n              if (!isFunc(xInverse)) {\n                toss3('xInverse must be provided if xValue is.');\n              }\n              isWindow = true;\n            } else if (isFunc(xInverse)) {\n              toss3('xValue must be provided if xInverse is.');\n            }\n            const pApp = opt.pApp;\n            if (\n              undefined !== pApp &&\n              null !== pApp &&\n              ('number' !== typeof pApp || !util.isInt32(pApp))\n            ) {\n              toss3(\n                'Invalid value for pApp property. Must be a legal WASM pointer value.',\n              );\n            }\n            const xDestroy = opt.xDestroy || 0;\n            if (xDestroy && !isFunc(xDestroy)) {\n              toss3('xDestroy property must be a function.');\n            }\n            let fFlags = 0;\n            if (getOwnOption(opt, 'deterministic'))\n              fFlags |= capi.SQLITE_DETERMINISTIC;\n            if (getOwnOption(opt, 'directOnly'))\n              fFlags |= capi.SQLITE_DIRECTONLY;\n            if (getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;\n            name = name.toLowerCase();\n            const xArity = xFunc || xStep;\n            const arity = getOwnOption(opt, 'arity');\n            const arityArg =\n              'number' === typeof arity\n                ? arity\n                : xArity.length\n                  ? xArity.length - 1\n                  : 0;\n            let rc;\n            if (isWindow) {\n              rc = capi.sqlite3_create_window_function(\n                this.pointer,\n                name,\n                arityArg,\n                capi.SQLITE_UTF8 | fFlags,\n                pApp || 0,\n                xStep,\n                xFinal,\n                xValue,\n                xInverse,\n                xDestroy,\n              );\n            } else {\n              rc = capi.sqlite3_create_function_v2(\n                this.pointer,\n                name,\n                arityArg,\n                capi.SQLITE_UTF8 | fFlags,\n                pApp || 0,\n                xFunc,\n                xStep,\n                xFinal,\n                xDestroy,\n              );\n            }\n            DB.checkRc(this, rc);\n            return this;\n          },\n\n          selectValue: function (sql, bind, asType) {\n            return __selectFirstRow(this, sql, bind, 0, asType);\n          },\n\n          selectValues: function (sql, bind, asType) {\n            const stmt = this.prepare(sql),\n              rc = [];\n            try {\n              stmt.bind(bind);\n              while (stmt.step()) rc.push(stmt.get(0, asType));\n              stmt.reset();\n            } finally {\n              stmt.finalize();\n            }\n            return rc;\n          },\n\n          selectArray: function (sql, bind) {\n            return __selectFirstRow(this, sql, bind, []);\n          },\n\n          selectObject: function (sql, bind) {\n            return __selectFirstRow(this, sql, bind, {});\n          },\n\n          selectArrays: function (sql, bind) {\n            return __selectAll(this, sql, bind, 'array');\n          },\n\n          selectObjects: function (sql, bind) {\n            return __selectAll(this, sql, bind, 'object');\n          },\n\n          openStatementCount: function () {\n            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;\n          },\n\n          transaction: function (callback) {\n            let opener = 'BEGIN';\n            if (arguments.length > 1) {\n              if (/[^a-zA-Z]/.test(arguments[0])) {\n                toss3(\n                  capi.SQLITE_MISUSE,\n                  'Invalid argument for BEGIN qualifier.',\n                );\n              }\n              opener += ' ' + arguments[0];\n              callback = arguments[1];\n            }\n            affirmDbOpen(this).exec(opener);\n            try {\n              const rc = callback(this);\n              this.exec('COMMIT');\n              return rc;\n            } catch (e) {\n              this.exec('ROLLBACK');\n              throw e;\n            }\n          },\n\n          savepoint: function (callback) {\n            affirmDbOpen(this).exec('SAVEPOINT oo1');\n            try {\n              const rc = callback(this);\n              this.exec('RELEASE oo1');\n              return rc;\n            } catch (e) {\n              this.exec('ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1');\n              throw e;\n            }\n          },\n\n          checkRc: function (resultCode) {\n            return checkSqlite3Rc(this, resultCode);\n          },\n        };\n\n        const affirmStmtOpen = function (stmt) {\n          if (!stmt.pointer) toss3('Stmt has been closed.');\n          return stmt;\n        };\n\n        const isSupportedBindType = function (v) {\n          let t = BindTypes[null === v || undefined === v ? 'null' : typeof v];\n          switch (t) {\n            case BindTypes.boolean:\n            case BindTypes.null:\n            case BindTypes.number:\n            case BindTypes.string:\n              return t;\n            case BindTypes.bigint:\n              if (wasm.bigIntEnabled) return t;\n\n            default:\n              return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;\n          }\n        };\n\n        const affirmSupportedBindType = function (v) {\n          return (\n            isSupportedBindType(v) ||\n            toss3('Unsupported bind() argument type:', typeof v)\n          );\n        };\n\n        const affirmParamIndex = function (stmt, key) {\n          const n =\n            'number' === typeof key\n              ? key\n              : capi.sqlite3_bind_parameter_index(stmt.pointer, key);\n          if (0 === n || !util.isInt32(n)) {\n            toss3('Invalid bind() parameter name: ' + key);\n          } else if (n < 1 || n > stmt.parameterCount)\n            toss3('Bind index', key, 'is out of range.');\n          return n;\n        };\n\n        const affirmNotLockedByExec = function (stmt, currentOpName) {\n          if (stmt._lockedByExec) {\n            toss3(\n              'Operation is illegal when statement is locked:',\n              currentOpName,\n            );\n          }\n          return stmt;\n        };\n\n        const bindOne = function f(stmt, ndx, bindType, val) {\n          affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');\n          if (!f._) {\n            f._tooBigInt = (v) =>\n              toss3(\n                'BigInt value is too big to store without precision loss:',\n                v,\n              );\n            f._ = {\n              string: function (stmt, ndx, val, asBlob) {\n                const [pStr, n] = wasm.allocCString(val, true);\n                const f = asBlob\n                  ? capi.sqlite3_bind_blob\n                  : capi.sqlite3_bind_text;\n                return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);\n              },\n            };\n          }\n          affirmSupportedBindType(val);\n          ndx = affirmParamIndex(stmt, ndx);\n          let rc = 0;\n          switch (\n            null === val || undefined === val ? BindTypes.null : bindType\n          ) {\n            case BindTypes.null:\n              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);\n              break;\n            case BindTypes.string:\n              rc = f._.string(stmt, ndx, val, false);\n              break;\n            case BindTypes.number: {\n              let m;\n              if (util.isInt32(val)) m = capi.sqlite3_bind_int;\n              else if ('bigint' === typeof val) {\n                if (!util.bigIntFits64(val)) {\n                  f._tooBigInt(val);\n                } else if (wasm.bigIntEnabled) {\n                  m = capi.sqlite3_bind_int64;\n                } else if (util.bigIntFitsDouble(val)) {\n                  val = Number(val);\n                  m = capi.sqlite3_bind_double;\n                } else {\n                  f._tooBigInt(val);\n                }\n              } else {\n                val = Number(val);\n                if (wasm.bigIntEnabled && Number.isInteger(val)) {\n                  m = capi.sqlite3_bind_int64;\n                } else {\n                  m = capi.sqlite3_bind_double;\n                }\n              }\n              rc = m(stmt.pointer, ndx, val);\n              break;\n            }\n            case BindTypes.boolean:\n              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);\n              break;\n            case BindTypes.blob: {\n              if ('string' === typeof val) {\n                rc = f._.string(stmt, ndx, val, true);\n                break;\n              } else if (val instanceof ArrayBuffer) {\n                val = new Uint8Array(val);\n              } else if (!util.isBindableTypedArray(val)) {\n                toss3(\n                  'Binding a value as a blob requires',\n                  'that it be a string, Uint8Array, Int8Array, or ArrayBuffer.',\n                );\n              }\n              const pBlob = wasm.alloc(val.byteLength || 1);\n              wasm.heap8().set(val.byteLength ? val : [0], pBlob);\n              rc = capi.sqlite3_bind_blob(\n                stmt.pointer,\n                ndx,\n                pBlob,\n                val.byteLength,\n                capi.SQLITE_WASM_DEALLOC,\n              );\n              break;\n            }\n            default:\n              sqlite3.config.warn('Unsupported bind() argument type:', val);\n              toss3('Unsupported bind() argument type: ' + typeof val);\n          }\n          if (rc) DB.checkRc(stmt.db.pointer, rc);\n          stmt._mayGet = false;\n          return stmt;\n        };\n\n        Stmt.prototype = {\n          finalize: function () {\n            if (this.pointer) {\n              affirmNotLockedByExec(this, 'finalize()');\n              const rc = capi.sqlite3_finalize(this.pointer);\n              delete __stmtMap.get(this.db)[this.pointer];\n              __ptrMap.delete(this);\n              delete this._mayGet;\n              delete this.parameterCount;\n              delete this._lockedByExec;\n              delete this.db;\n              return rc;\n            }\n          },\n\n          clearBindings: function () {\n            affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()');\n            capi.sqlite3_clear_bindings(this.pointer);\n            this._mayGet = false;\n            return this;\n          },\n\n          reset: function (alsoClearBinds) {\n            affirmNotLockedByExec(this, 'reset()');\n            if (alsoClearBinds) this.clearBindings();\n            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);\n            this._mayGet = false;\n            checkSqlite3Rc(this.db, rc);\n            return this;\n          },\n\n          bind: function () {\n            affirmStmtOpen(this);\n            let ndx, arg;\n            switch (arguments.length) {\n              case 1:\n                ndx = 1;\n                arg = arguments[0];\n                break;\n              case 2:\n                ndx = arguments[0];\n                arg = arguments[1];\n                break;\n              default:\n                toss3('Invalid bind() arguments.');\n            }\n            if (undefined === arg) {\n              return this;\n            } else if (!this.parameterCount) {\n              toss3('This statement has no bindable parameters.');\n            }\n            this._mayGet = false;\n            if (null === arg) {\n              return bindOne(this, ndx, BindTypes.null, arg);\n            } else if (Array.isArray(arg)) {\n              if (1 !== arguments.length) {\n                toss3(\n                  'When binding an array, an index argument is not permitted.',\n                );\n              }\n              arg.forEach((v, i) =>\n                bindOne(this, i + 1, affirmSupportedBindType(v), v),\n              );\n              return this;\n            } else if (arg instanceof ArrayBuffer) {\n              arg = new Uint8Array(arg);\n            }\n            if ('object' === typeof arg && !util.isBindableTypedArray(arg)) {\n              if (1 !== arguments.length) {\n                toss3(\n                  'When binding an object, an index argument is not permitted.',\n                );\n              }\n              Object.keys(arg).forEach((k) =>\n                bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k]),\n              );\n              return this;\n            } else {\n              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);\n            }\n            toss3('Should not reach this point.');\n          },\n\n          bindAsBlob: function (ndx, arg) {\n            affirmStmtOpen(this);\n            if (1 === arguments.length) {\n              arg = ndx;\n              ndx = 1;\n            }\n            const t = affirmSupportedBindType(arg);\n            if (\n              BindTypes.string !== t &&\n              BindTypes.blob !== t &&\n              BindTypes.null !== t\n            ) {\n              toss3('Invalid value type for bindAsBlob()');\n            }\n            return bindOne(this, ndx, BindTypes.blob, arg);\n          },\n\n          step: function () {\n            affirmNotLockedByExec(this, 'step()');\n            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);\n            switch (rc) {\n              case capi.SQLITE_DONE:\n                return (this._mayGet = false);\n              case capi.SQLITE_ROW:\n                return (this._mayGet = true);\n              default:\n                this._mayGet = false;\n                sqlite3.config.warn(\n                  'sqlite3_step() rc=',\n                  rc,\n                  capi.sqlite3_js_rc_str(rc),\n                  'SQL =',\n                  capi.sqlite3_sql(this.pointer),\n                );\n                DB.checkRc(this.db.pointer, rc);\n            }\n          },\n\n          stepReset: function () {\n            this.step();\n            return this.reset();\n          },\n\n          stepFinalize: function () {\n            try {\n              const rc = this.step();\n              this.reset();\n              return rc;\n            } finally {\n              try {\n                this.finalize();\n              } catch (e) {}\n            }\n          },\n\n          get: function (ndx, asType) {\n            if (!affirmStmtOpen(this)._mayGet) {\n              toss3('Stmt.step() has not (recently) returned true.');\n            }\n            if (Array.isArray(ndx)) {\n              let i = 0;\n              const n = this.columnCount;\n              while (i < n) {\n                ndx[i] = this.get(i++);\n              }\n              return ndx;\n            } else if (ndx && 'object' === typeof ndx) {\n              let i = 0;\n              const n = this.columnCount;\n              while (i < n) {\n                ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);\n              }\n              return ndx;\n            }\n            affirmColIndex(this, ndx);\n            switch (\n              undefined === asType\n                ? capi.sqlite3_column_type(this.pointer, ndx)\n                : asType\n            ) {\n              case capi.SQLITE_NULL:\n                return null;\n              case capi.SQLITE_INTEGER: {\n                if (wasm.bigIntEnabled) {\n                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);\n                  if (\n                    rc >= Number.MIN_SAFE_INTEGER &&\n                    rc <= Number.MAX_SAFE_INTEGER\n                  ) {\n                    return Number(rc).valueOf();\n                  }\n                  return rc;\n                } else {\n                  const rc = capi.sqlite3_column_double(this.pointer, ndx);\n                  if (\n                    rc > Number.MAX_SAFE_INTEGER ||\n                    rc < Number.MIN_SAFE_INTEGER\n                  ) {\n                    toss3(\n                      'Integer is out of range for JS integer range: ' + rc,\n                    );\n                  }\n\n                  return util.isInt32(rc) ? rc | 0 : rc;\n                }\n              }\n              case capi.SQLITE_FLOAT:\n                return capi.sqlite3_column_double(this.pointer, ndx);\n              case capi.SQLITE_TEXT:\n                return capi.sqlite3_column_text(this.pointer, ndx);\n              case capi.SQLITE_BLOB: {\n                const n = capi.sqlite3_column_bytes(this.pointer, ndx),\n                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),\n                  rc = new Uint8Array(n);\n\n                if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);\n\n                if (n && this.db._blobXfer instanceof Array) {\n                  this.db._blobXfer.push(rc.buffer);\n                }\n                return rc;\n              }\n              default:\n                toss3(\n                  \"Don't know how to translate\",\n                  'type of result column #' + ndx + '.',\n                );\n            }\n            toss3('Not reached.');\n          },\n\n          getInt: function (ndx) {\n            return this.get(ndx, capi.SQLITE_INTEGER);\n          },\n\n          getFloat: function (ndx) {\n            return this.get(ndx, capi.SQLITE_FLOAT);\n          },\n\n          getString: function (ndx) {\n            return this.get(ndx, capi.SQLITE_TEXT);\n          },\n\n          getBlob: function (ndx) {\n            return this.get(ndx, capi.SQLITE_BLOB);\n          },\n\n          getJSON: function (ndx) {\n            const s = this.get(ndx, capi.SQLITE_STRING);\n            return null === s ? s : JSON.parse(s);\n          },\n\n          getColumnName: function (ndx) {\n            return capi.sqlite3_column_name(\n              affirmColIndex(affirmStmtOpen(this), ndx).pointer,\n              ndx,\n            );\n          },\n\n          getColumnNames: function (tgt = []) {\n            affirmColIndex(affirmStmtOpen(this), 0);\n            const n = this.columnCount;\n            for (let i = 0; i < n; ++i) {\n              tgt.push(capi.sqlite3_column_name(this.pointer, i));\n            }\n            return tgt;\n          },\n\n          getParamIndex: function (name) {\n            return affirmStmtOpen(this).parameterCount\n              ? capi.sqlite3_bind_parameter_index(this.pointer, name)\n              : undefined;\n          },\n\n          getParamName: function (ndx) {\n            return affirmStmtOpen(this).parameterCount\n              ? capi.sqlite3_bind_parameter_name(this.pointer, ndx)\n              : undefined;\n          },\n\n          isBusy: function () {\n            return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));\n          },\n\n          isReadOnly: function () {\n            return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));\n          },\n        };\n\n        {\n          const prop = {\n            enumerable: true,\n            get: function () {\n              return __ptrMap.get(this);\n            },\n            set: () => toss3('The pointer property is read-only.'),\n          };\n          Object.defineProperty(Stmt.prototype, 'pointer', prop);\n          Object.defineProperty(DB.prototype, 'pointer', prop);\n        }\n\n        Object.defineProperty(Stmt.prototype, 'columnCount', {\n          enumerable: false,\n          get: function () {\n            return capi.sqlite3_column_count(this.pointer);\n          },\n          set: () => toss3('The columnCount property is read-only.'),\n        });\n\n        sqlite3.oo1 = {\n          DB,\n          Stmt,\n        };\n\n        if (util.isUIThread()) {\n          sqlite3.oo1.JsStorageDb = function (storageName = 'session') {\n            const opt = dbCtorHelper.normalizeArgs(...arguments);\n            storageName = opt.filename;\n            if ('session' !== storageName && 'local' !== storageName) {\n              toss3(\"JsStorageDb db name must be one of 'session' or 'local'.\");\n            }\n            opt.vfs = 'kvvfs';\n            dbCtorHelper.call(this, opt);\n          };\n          const jdb = sqlite3.oo1.JsStorageDb;\n          jdb.prototype = Object.create(DB.prototype);\n\n          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;\n\n          jdb.prototype.clearStorage = function () {\n            return jdb.clearStorage(affirmDbOpen(this).filename);\n          };\n\n          jdb.storageSize = capi.sqlite3_js_kvvfs_size;\n\n          jdb.prototype.storageSize = function () {\n            return jdb.storageSize(affirmDbOpen(this).filename);\n          };\n        }\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const util = sqlite3.util;\n        sqlite3.initWorker1API = function () {\n          'use strict';\n          const toss = (...args) => {\n            throw new Error(args.join(' '));\n          };\n          if (!(globalThis.WorkerGlobalScope instanceof Function)) {\n            toss('initWorker1API() must be run from a Worker thread.');\n          }\n          const sqlite3 = this.sqlite3 || toss('Missing this.sqlite3 object.');\n          const DB = sqlite3.oo1.DB;\n\n          const getDbId = function (db) {\n            let id = wState.idMap.get(db);\n            if (id) return id;\n            id = 'db#' + ++wState.idSeq + '@' + db.pointer;\n\n            wState.idMap.set(db, id);\n            return id;\n          };\n\n          const wState = {\n            dbList: [],\n\n            idSeq: 0,\n\n            idMap: new WeakMap(),\n\n            xfer: [],\n            open: function (opt) {\n              const db = new DB(opt);\n              this.dbs[getDbId(db)] = db;\n              if (this.dbList.indexOf(db) < 0) this.dbList.push(db);\n              return db;\n            },\n            close: function (db, alsoUnlink) {\n              if (db) {\n                delete this.dbs[getDbId(db)];\n                const filename = db.filename;\n                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);\n                db.close();\n                const ddNdx = this.dbList.indexOf(db);\n                if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);\n                if (alsoUnlink && filename && pVfs) {\n                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);\n                }\n              }\n            },\n\n            post: function (msg, xferList) {\n              if (xferList && xferList.length) {\n                globalThis.postMessage(msg, Array.from(xferList));\n                xferList.length = 0;\n              } else {\n                globalThis.postMessage(msg);\n              }\n            },\n\n            dbs: Object.create(null),\n\n            getDb: function (id, require = true) {\n              return (\n                this.dbs[id] ||\n                (require ? toss('Unknown (or closed) DB ID:', id) : undefined)\n              );\n            },\n          };\n\n          const affirmDbOpen = function (db = wState.dbList[0]) {\n            return db && db.pointer ? db : toss('DB is not opened.');\n          };\n\n          const getMsgDb = function (msgData, affirmExists = true) {\n            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];\n            return affirmExists ? affirmDbOpen(db) : db;\n          };\n\n          const getDefaultDbId = function () {\n            return wState.dbList[0] && getDbId(wState.dbList[0]);\n          };\n\n          const isSpecialDbFilename = (n) => {\n            return '' === n || ':' === n[0];\n          };\n\n          const wMsgHandler = {\n            open: function (ev) {\n              const oargs = Object.create(null),\n                args = ev.args || Object.create(null);\n              if (args.simulateError) {\n                toss('Throwing because of simulateError flag.');\n              }\n              const rc = Object.create(null);\n              oargs.vfs = args.vfs;\n              oargs.filename = args.filename || '';\n              const db = wState.open(oargs);\n              rc.filename = db.filename;\n              rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(\n                db.pointer,\n                'opfs',\n              );\n              rc.dbId = getDbId(db);\n              rc.vfs = db.dbVfsName();\n              return rc;\n            },\n\n            close: function (ev) {\n              const db = getMsgDb(ev, false);\n              const response = {\n                filename: db && db.filename,\n              };\n              if (db) {\n                const doUnlink =\n                  ev.args && 'object' === typeof ev.args\n                    ? !!ev.args.unlink\n                    : false;\n                wState.close(db, doUnlink);\n              }\n              return response;\n            },\n\n            exec: function (ev) {\n              const rc =\n                'string' === typeof ev.args\n                  ? { sql: ev.args }\n                  : ev.args || Object.create(null);\n              if ('stmt' === rc.rowMode) {\n                toss(\n                  \"Invalid rowMode for 'exec': stmt mode\",\n                  'does not work in the Worker API.',\n                );\n              } else if (!rc.sql) {\n                toss(\"'exec' requires input SQL.\");\n              }\n              const db = getMsgDb(ev);\n              if (rc.callback || Array.isArray(rc.resultRows)) {\n                db._blobXfer = wState.xfer;\n              }\n              const theCallback = rc.callback;\n              let rowNumber = 0;\n              const hadColNames = !!rc.columnNames;\n              if ('string' === typeof theCallback) {\n                if (!hadColNames) rc.columnNames = [];\n\n                rc.callback = function (row, stmt) {\n                  wState.post(\n                    {\n                      type: theCallback,\n                      columnNames: rc.columnNames,\n                      rowNumber: ++rowNumber,\n                      row: row,\n                    },\n                    wState.xfer,\n                  );\n                };\n              }\n              try {\n                const changeCount = !!rc.countChanges\n                  ? db.changes(true, 64 === rc.countChanges)\n                  : undefined;\n                db.exec(rc);\n                if (undefined !== changeCount) {\n                  rc.changeCount =\n                    db.changes(true, 64 === rc.countChanges) - changeCount;\n                }\n                if (rc.callback instanceof Function) {\n                  rc.callback = theCallback;\n\n                  wState.post({\n                    type: theCallback,\n                    columnNames: rc.columnNames,\n                    rowNumber: null,\n                    row: undefined,\n                  });\n                }\n              } finally {\n                delete db._blobXfer;\n                if (rc.callback) rc.callback = theCallback;\n              }\n              return rc;\n            },\n\n            'config-get': function () {\n              const rc = Object.create(null),\n                src = sqlite3.config;\n              ['bigIntEnabled'].forEach(function (k) {\n                if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];\n              });\n              rc.version = sqlite3.version;\n              rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();\n              return rc;\n            },\n\n            export: function (ev) {\n              const db = getMsgDb(ev);\n              const response = {\n                byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),\n                filename: db.filename,\n                mimetype: 'application/x-sqlite3',\n              };\n              wState.xfer.push(response.byteArray.buffer);\n              return response;\n            },\n\n            toss: function (ev) {\n              toss('Testing worker exception');\n            },\n          };\n\n          globalThis.onmessage = async function (ev) {\n            ev = ev.data;\n            let result,\n              dbId = ev.dbId,\n              evType = ev.type;\n            const arrivalTime = performance.now();\n            try {\n              if (\n                wMsgHandler.hasOwnProperty(evType) &&\n                wMsgHandler[evType] instanceof Function\n              ) {\n                result = await wMsgHandler[evType](ev);\n              } else {\n                toss('Unknown db worker message type:', ev.type);\n              }\n            } catch (err) {\n              evType = 'error';\n              result = {\n                operation: ev.type,\n                message: err.message,\n                errorClass: err.name,\n                input: ev,\n              };\n              if (err.stack) {\n                result.stack =\n                  'string' === typeof err.stack\n                    ? err.stack.split(/\\n\\s*/)\n                    : err.stack;\n              }\n              if (false)\n                {}\n            }\n            if (!dbId) {\n              dbId = result.dbId || getDefaultDbId();\n            }\n\n            wState.post(\n              {\n                type: evType,\n                dbId: dbId,\n                messageId: ev.messageId,\n                workerReceivedTime: arrivalTime,\n                workerRespondTime: performance.now(),\n                departureTime: ev.departureTime,\n\n                result: result,\n              },\n              wState.xfer,\n            );\n          };\n          globalThis.postMessage({\n            type: 'sqlite3-api',\n            result: 'worker1-ready',\n          });\n        }.bind({ sqlite3 });\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const wasm = sqlite3.wasm,\n          capi = sqlite3.capi,\n          toss = sqlite3.util.toss3;\n        const vfs = Object.create(null);\n        sqlite3.vfs = vfs;\n\n        capi.sqlite3_vfs.prototype.registerVfs = function (asDefault = false) {\n          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {\n            toss('Expecting a sqlite3_vfs-type argument.');\n          }\n          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);\n          if (rc) {\n            toss('sqlite3_vfs_register(', this, ') failed with rc', rc);\n          }\n          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {\n            toss(\n              'BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS',\n              this,\n            );\n          }\n          return this;\n        };\n\n        vfs.installVfs = function (opt) {\n          let count = 0;\n          const propList = ['io', 'vfs'];\n          for (const key of propList) {\n            const o = opt[key];\n            if (o) {\n              ++count;\n              o.struct.installMethods(o.methods, !!o.applyArgcCheck);\n              if ('vfs' === key) {\n                if (!o.struct.$zName && 'string' === typeof o.name) {\n                  o.struct.addOnDispose(\n                    (o.struct.$zName = wasm.allocCString(o.name)),\n                  );\n                }\n                o.struct.registerVfs(!!o.asDefault);\n              }\n            }\n          }\n          if (!count)\n            toss(\n              'Misuse: installVfs() options object requires at least',\n              'one of:',\n              propList,\n            );\n          return this;\n        };\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        if (!sqlite3.wasm.exports.sqlite3_declare_vtab) {\n          return;\n        }\n        const wasm = sqlite3.wasm,\n          capi = sqlite3.capi,\n          toss = sqlite3.util.toss3;\n        const vtab = Object.create(null);\n        sqlite3.vtab = vtab;\n\n        const sii = capi.sqlite3_index_info;\n\n        sii.prototype.nthConstraint = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nConstraint) return false;\n          const ptr =\n            this.$aConstraint +\n            sii.sqlite3_index_constraint.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);\n        };\n\n        sii.prototype.nthConstraintUsage = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nConstraint) return false;\n          const ptr =\n            this.$aConstraintUsage +\n            sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);\n        };\n\n        sii.prototype.nthOrderBy = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nOrderBy) return false;\n          const ptr =\n            this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);\n        };\n\n        const __xWrapFactory = function (methodName, StructType) {\n          return function (ptr, removeMapping = false) {\n            if (0 === arguments.length) ptr = new StructType();\n            if (ptr instanceof StructType) {\n              this.set(ptr.pointer, ptr);\n              return ptr;\n            } else if (!wasm.isPtr(ptr)) {\n              sqlite3.SQLite3Error.toss(\n                'Invalid argument to',\n                methodName + '()',\n              );\n            }\n            let rc = this.get(ptr);\n            if (removeMapping) this.delete(ptr);\n            return rc;\n          }.bind(new Map());\n        };\n\n        const StructPtrMapper = function (name, StructType) {\n          const __xWrap = __xWrapFactory(name, StructType);\n\n          return Object.assign(Object.create(null), {\n            StructType,\n\n            create: (ppOut) => {\n              const rc = __xWrap();\n              wasm.pokePtr(ppOut, rc.pointer);\n              return rc;\n            },\n\n            get: (pCObj) => __xWrap(pCObj),\n\n            unget: (pCObj) => __xWrap(pCObj, true),\n\n            dispose: (pCObj) => {\n              const o = __xWrap(pCObj, true);\n              if (o) o.dispose();\n            },\n          });\n        };\n\n        vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);\n\n        vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);\n\n        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);\n\n        vtab.xError = function f(methodName, err, defaultRc) {\n          if (f.errorReporter instanceof Function) {\n            try {\n              f.errorReporter(\n                'sqlite3_module::' + methodName + '(): ' + err.message,\n              );\n            } catch (e) {}\n          }\n          let rc;\n          if (err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;\n          else if (arguments.length > 2) rc = defaultRc;\n          else if (err instanceof sqlite3.SQLite3Error) rc = err.resultCode;\n          return rc || capi.SQLITE_ERROR;\n        };\n        vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;\n\n        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, 'i64');\n\n        vtab.setupModule = function (opt) {\n          let createdMod = false;\n          const mod =\n            this instanceof capi.sqlite3_module\n              ? this\n              : opt.struct || (createdMod = new capi.sqlite3_module());\n          try {\n            const methods = opt.methods || toss(\"Missing 'methods' object.\");\n            for (const e of Object.entries({\n              xConnect: 'xCreate',\n              xDisconnect: 'xDestroy',\n            })) {\n              const k = e[0],\n                v = e[1];\n              if (true === methods[k]) methods[k] = methods[v];\n              else if (true === methods[v]) methods[v] = methods[k];\n            }\n            if (opt.catchExceptions) {\n              const fwrap = function (methodName, func) {\n                if (['xConnect', 'xCreate'].indexOf(methodName) >= 0) {\n                  return function (pDb, pAux, argc, argv, ppVtab, pzErr) {\n                    try {\n                      return func(...arguments) || 0;\n                    } catch (e) {\n                      if (!(e instanceof sqlite3.WasmAllocError)) {\n                        wasm.dealloc(wasm.peekPtr(pzErr));\n                        wasm.pokePtr(pzErr, wasm.allocCString(e.message));\n                      }\n                      return vtab.xError(methodName, e);\n                    }\n                  };\n                } else {\n                  return function (...args) {\n                    try {\n                      return func(...args) || 0;\n                    } catch (e) {\n                      return vtab.xError(methodName, e);\n                    }\n                  };\n                }\n              };\n              const mnames = [\n                'xCreate',\n                'xConnect',\n                'xBestIndex',\n                'xDisconnect',\n                'xDestroy',\n                'xOpen',\n                'xClose',\n                'xFilter',\n                'xNext',\n                'xEof',\n                'xColumn',\n                'xRowid',\n                'xUpdate',\n                'xBegin',\n                'xSync',\n                'xCommit',\n                'xRollback',\n                'xFindFunction',\n                'xRename',\n                'xSavepoint',\n                'xRelease',\n                'xRollbackTo',\n                'xShadowName',\n              ];\n              const remethods = Object.create(null);\n              for (const k of mnames) {\n                const m = methods[k];\n                if (!(m instanceof Function)) continue;\n                else if ('xConnect' === k && methods.xCreate === m) {\n                  remethods[k] = methods.xCreate;\n                } else if ('xCreate' === k && methods.xConnect === m) {\n                  remethods[k] = methods.xConnect;\n                } else {\n                  remethods[k] = fwrap(k, m);\n                }\n              }\n              mod.installMethods(remethods, false);\n            } else {\n              mod.installMethods(methods, !!opt.applyArgcCheck);\n            }\n            if (0 === mod.$iVersion) {\n              let v;\n              if ('number' === typeof opt.iVersion) v = opt.iVersion;\n              else if (mod.$xShadowName) v = 3;\n              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)\n                v = 2;\n              else v = 1;\n              mod.$iVersion = v;\n            }\n          } catch (e) {\n            if (createdMod) createdMod.dispose();\n            throw e;\n          }\n          return mod;\n        };\n\n        capi.sqlite3_module.prototype.setupModule = function (opt) {\n          return vtab.setupModule.call(this, opt);\n        };\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const installOpfsVfs = function callee(options) {\n          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {\n            return Promise.reject(\n              new Error(\n                'Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. ' +\n                  'The server must emit the COOP/COEP response headers to enable those. ' +\n                  'See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep',\n              ),\n            );\n          } else if ('undefined' === typeof WorkerGlobalScope) {\n            return Promise.reject(\n              new Error(\n                'The OPFS sqlite3_vfs cannot run in the main thread ' +\n                  'because it requires Atomics.wait().',\n              ),\n            );\n          } else if (\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle ||\n            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||\n            !navigator?.storage?.getDirectory\n          ) {\n            return Promise.reject(new Error('Missing required OPFS APIs.'));\n          }\n          if (!options || 'object' !== typeof options) {\n            options = Object.create(null);\n          }\n          const urlParams = new URL(globalThis.location.href).searchParams;\n          if (urlParams.has('opfs-disable')) {\n            return Promise.resolve(sqlite3);\n          }\n          if (undefined === options.verbose) {\n            options.verbose = urlParams.has('opfs-verbose')\n              ? +urlParams.get('opfs-verbose') || 2\n              : 1;\n          }\n          if (undefined === options.sanityChecks) {\n            options.sanityChecks = urlParams.has('opfs-sanity-check');\n          }\n          if (undefined === options.proxyUri) {\n            options.proxyUri = callee.defaultProxyUri;\n          }\n\n          if ('function' === typeof options.proxyUri) {\n            options.proxyUri = options.proxyUri();\n          }\n          const thePromise = new Promise(function (\n            promiseResolve_,\n            promiseReject_,\n          ) {\n            const loggers = [\n              sqlite3.config.error,\n              sqlite3.config.warn,\n              sqlite3.config.log,\n            ];\n            const logImpl = (level, ...args) => {\n              if (options.verbose > level)\n                loggers[level]('OPFS syncer:', ...args);\n            };\n            const log = (...args) => logImpl(2, ...args);\n            const warn = (...args) => logImpl(1, ...args);\n            const error = (...args) => logImpl(0, ...args);\n            const toss = sqlite3.util.toss;\n            const capi = sqlite3.capi;\n            const util = sqlite3.util;\n            const wasm = sqlite3.wasm;\n            const sqlite3_vfs = capi.sqlite3_vfs;\n            const sqlite3_file = capi.sqlite3_file;\n            const sqlite3_io_methods = capi.sqlite3_io_methods;\n\n            const opfsUtil = Object.create(null);\n\n            const thisThreadHasOPFS = () => {\n              return (\n                globalThis.FileSystemHandle &&\n                globalThis.FileSystemDirectoryHandle &&\n                globalThis.FileSystemFileHandle &&\n                globalThis.FileSystemFileHandle.prototype\n                  .createSyncAccessHandle &&\n                navigator?.storage?.getDirectory\n              );\n            };\n\n            opfsUtil.metrics = {\n              dump: function () {\n                let k,\n                  n = 0,\n                  t = 0,\n                  w = 0;\n                for (k in state.opIds) {\n                  const m = metrics[k];\n                  n += m.count;\n                  t += m.time;\n                  w += m.wait;\n                  m.avgTime = m.count && m.time ? m.time / m.count : 0;\n                  m.avgWait = m.count && m.wait ? m.wait / m.count : 0;\n                }\n                sqlite3.config.log(\n                  globalThis.location.href,\n                  'metrics for',\n                  globalThis.location.href,\n                  ':',\n                  metrics,\n                  '\\nTotal of',\n                  n,\n                  'op(s) for',\n                  t,\n                  'ms (incl. ' + w + ' ms of waiting on the async side)',\n                );\n                sqlite3.config.log('Serialization metrics:', metrics.s11n);\n                W.postMessage({ type: 'opfs-async-metrics' });\n              },\n              reset: function () {\n                let k;\n                const r = (m) => (m.count = m.time = m.wait = 0);\n                for (k in state.opIds) {\n                  r((metrics[k] = Object.create(null)));\n                }\n                let s = (metrics.s11n = Object.create(null));\n                s = s.serialize = Object.create(null);\n                s.count = s.time = 0;\n                s = metrics.s11n.deserialize = Object.create(null);\n                s.count = s.time = 0;\n              },\n            };\n            const opfsIoMethods = new sqlite3_io_methods();\n            const opfsVfs = new sqlite3_vfs().addOnDispose(() =>\n              opfsIoMethods.dispose(),\n            );\n            let promiseWasRejected = undefined;\n            const promiseReject = (err) => {\n              promiseWasRejected = true;\n              opfsVfs.dispose();\n              return promiseReject_(err);\n            };\n            const promiseResolve = () => {\n              promiseWasRejected = false;\n              return promiseResolve_(sqlite3);\n            };\n            const W = new Worker(\n              __webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"_app-pages-browser_node_modules_pnpm_sqlite_org_sqlite-wasm_3_49_1-build2_node_modules_sqlite-84e6ae\"), __webpack_require__.b)),\n            );\n            setTimeout(() => {\n              if (undefined === promiseWasRejected) {\n                promiseReject(\n                  new Error(\n                    'Timeout while waiting for OPFS async proxy worker.',\n                  ),\n                );\n              }\n            }, 4000);\n            W._originalOnError = W.onerror;\n            W.onerror = function (err) {\n              error('Error initializing OPFS asyncer:', err);\n              promiseReject(\n                new Error(\n                  'Loading OPFS async Worker failed for unknown reasons.',\n                ),\n              );\n            };\n            const pDVfs = capi.sqlite3_vfs_find(null);\n            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;\n            opfsIoMethods.$iVersion = 1;\n            opfsVfs.$iVersion = 2;\n            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n            opfsVfs.$mxPathname = 1024;\n            opfsVfs.$zName = wasm.allocCString('opfs');\n\n            opfsVfs.$xDlOpen =\n              opfsVfs.$xDlError =\n              opfsVfs.$xDlSym =\n              opfsVfs.$xDlClose =\n                null;\n            opfsVfs.addOnDispose(\n              '$zName',\n              opfsVfs.$zName,\n              'cleanup default VFS wrapper',\n              () => (dVfs ? dVfs.dispose() : null),\n            );\n\n            const state = Object.create(null);\n            state.verbose = options.verbose;\n            state.littleEndian = (() => {\n              const buffer = new ArrayBuffer(2);\n              new DataView(buffer).setInt16(0, 256, true);\n\n              return new Int16Array(buffer)[0] === 256;\n            })();\n\n            state.asyncIdleWaitTime = 150;\n\n            state.asyncS11nExceptions = 1;\n\n            state.fileBufferSize = 1024 * 64;\n            state.sabS11nOffset = state.fileBufferSize;\n\n            state.sabS11nSize = opfsVfs.$mxPathname * 2;\n\n            state.sabIO = new SharedArrayBuffer(\n              state.fileBufferSize + state.sabS11nSize,\n            );\n            state.opIds = Object.create(null);\n            const metrics = Object.create(null);\n            {\n              let i = 0;\n\n              state.opIds.whichOp = i++;\n\n              state.opIds.rc = i++;\n\n              state.opIds.xAccess = i++;\n              state.opIds.xClose = i++;\n              state.opIds.xDelete = i++;\n              state.opIds.xDeleteNoWait = i++;\n              state.opIds.xFileSize = i++;\n              state.opIds.xLock = i++;\n              state.opIds.xOpen = i++;\n              state.opIds.xRead = i++;\n              state.opIds.xSleep = i++;\n              state.opIds.xSync = i++;\n              state.opIds.xTruncate = i++;\n              state.opIds.xUnlock = i++;\n              state.opIds.xWrite = i++;\n              state.opIds.mkdir = i++;\n              state.opIds['opfs-async-metrics'] = i++;\n              state.opIds['opfs-async-shutdown'] = i++;\n\n              state.opIds.retry = i++;\n              state.sabOP = new SharedArrayBuffer(i * 4);\n              opfsUtil.metrics.reset();\n            }\n\n            state.sq3Codes = Object.create(null);\n            [\n              'SQLITE_ACCESS_EXISTS',\n              'SQLITE_ACCESS_READWRITE',\n              'SQLITE_BUSY',\n              'SQLITE_CANTOPEN',\n              'SQLITE_ERROR',\n              'SQLITE_IOERR',\n              'SQLITE_IOERR_ACCESS',\n              'SQLITE_IOERR_CLOSE',\n              'SQLITE_IOERR_DELETE',\n              'SQLITE_IOERR_FSYNC',\n              'SQLITE_IOERR_LOCK',\n              'SQLITE_IOERR_READ',\n              'SQLITE_IOERR_SHORT_READ',\n              'SQLITE_IOERR_TRUNCATE',\n              'SQLITE_IOERR_UNLOCK',\n              'SQLITE_IOERR_WRITE',\n              'SQLITE_LOCK_EXCLUSIVE',\n              'SQLITE_LOCK_NONE',\n              'SQLITE_LOCK_PENDING',\n              'SQLITE_LOCK_RESERVED',\n              'SQLITE_LOCK_SHARED',\n              'SQLITE_LOCKED',\n              'SQLITE_MISUSE',\n              'SQLITE_NOTFOUND',\n              'SQLITE_OPEN_CREATE',\n              'SQLITE_OPEN_DELETEONCLOSE',\n              'SQLITE_OPEN_MAIN_DB',\n              'SQLITE_OPEN_READONLY',\n            ].forEach((k) => {\n              if (undefined === (state.sq3Codes[k] = capi[k])) {\n                toss('Maintenance required: not found:', k);\n              }\n            });\n            state.opfsFlags = Object.assign(Object.create(null), {\n              OPFS_UNLOCK_ASAP: 0x01,\n\n              OPFS_UNLINK_BEFORE_OPEN: 0x02,\n\n              defaultUnlockAsap: false,\n            });\n\n            const opRun = (op, ...args) => {\n              const opNdx = state.opIds[op] || toss('Invalid op ID:', op);\n              state.s11n.serialize(...args);\n              Atomics.store(state.sabOPView, state.opIds.rc, -1);\n              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);\n              Atomics.notify(state.sabOPView, state.opIds.whichOp);\n              const t = performance.now();\n              while (\n                'not-equal' !==\n                Atomics.wait(state.sabOPView, state.opIds.rc, -1)\n              ) {}\n\n              const rc = Atomics.load(state.sabOPView, state.opIds.rc);\n              metrics[op].wait += performance.now() - t;\n              if (rc && state.asyncS11nExceptions) {\n                const err = state.s11n.deserialize();\n                if (err) error(op + '() async error:', ...err);\n              }\n              return rc;\n            };\n\n            opfsUtil.debug = {\n              asyncShutdown: () => {\n                warn(\n                  'Shutting down OPFS async listener. The OPFS VFS will no longer work.',\n                );\n                opRun('opfs-async-shutdown');\n              },\n              asyncRestart: () => {\n                warn(\n                  'Attempting to restart OPFS VFS async listener. Might work, might not.',\n                );\n                W.postMessage({ type: 'opfs-async-restart' });\n              },\n            };\n\n            const initS11n = () => {\n              if (state.s11n) return state.s11n;\n              const textDecoder = new TextDecoder(),\n                textEncoder = new TextEncoder('utf-8'),\n                viewU8 = new Uint8Array(\n                  state.sabIO,\n                  state.sabS11nOffset,\n                  state.sabS11nSize,\n                ),\n                viewDV = new DataView(\n                  state.sabIO,\n                  state.sabS11nOffset,\n                  state.sabS11nSize,\n                );\n              state.s11n = Object.create(null);\n\n              const TypeIds = Object.create(null);\n              TypeIds.number = {\n                id: 1,\n                size: 8,\n                getter: 'getFloat64',\n                setter: 'setFloat64',\n              };\n              TypeIds.bigint = {\n                id: 2,\n                size: 8,\n                getter: 'getBigInt64',\n                setter: 'setBigInt64',\n              };\n              TypeIds.boolean = {\n                id: 3,\n                size: 4,\n                getter: 'getInt32',\n                setter: 'setInt32',\n              };\n              TypeIds.string = { id: 4 };\n\n              const getTypeId = (v) =>\n                TypeIds[typeof v] ||\n                toss(\n                  'Maintenance required: this value type cannot be serialized.',\n                  v,\n                );\n              const getTypeIdById = (tid) => {\n                switch (tid) {\n                  case TypeIds.number.id:\n                    return TypeIds.number;\n                  case TypeIds.bigint.id:\n                    return TypeIds.bigint;\n                  case TypeIds.boolean.id:\n                    return TypeIds.boolean;\n                  case TypeIds.string.id:\n                    return TypeIds.string;\n                  default:\n                    toss('Invalid type ID:', tid);\n                }\n              };\n\n              state.s11n.deserialize = function (clear = false) {\n                ++metrics.s11n.deserialize.count;\n                const t = performance.now();\n                const argc = viewU8[0];\n                const rc = argc ? [] : null;\n                if (argc) {\n                  const typeIds = [];\n                  let offset = 1,\n                    i,\n                    n,\n                    v;\n                  for (i = 0; i < argc; ++i, ++offset) {\n                    typeIds.push(getTypeIdById(viewU8[offset]));\n                  }\n                  for (i = 0; i < argc; ++i) {\n                    const t = typeIds[i];\n                    if (t.getter) {\n                      v = viewDV[t.getter](offset, state.littleEndian);\n                      offset += t.size;\n                    } else {\n                      n = viewDV.getInt32(offset, state.littleEndian);\n                      offset += 4;\n                      v = textDecoder.decode(viewU8.slice(offset, offset + n));\n                      offset += n;\n                    }\n                    rc.push(v);\n                  }\n                }\n                if (clear) viewU8[0] = 0;\n\n                metrics.s11n.deserialize.time += performance.now() - t;\n                return rc;\n              };\n\n              state.s11n.serialize = function (...args) {\n                const t = performance.now();\n                ++metrics.s11n.serialize.count;\n                if (args.length) {\n                  const typeIds = [];\n                  let i = 0,\n                    offset = 1;\n                  viewU8[0] = args.length & 0xff;\n                  for (; i < args.length; ++i, ++offset) {\n                    typeIds.push(getTypeId(args[i]));\n                    viewU8[offset] = typeIds[i].id;\n                  }\n                  for (i = 0; i < args.length; ++i) {\n                    const t = typeIds[i];\n                    if (t.setter) {\n                      viewDV[t.setter](offset, args[i], state.littleEndian);\n                      offset += t.size;\n                    } else {\n                      const s = textEncoder.encode(args[i]);\n                      viewDV.setInt32(offset, s.byteLength, state.littleEndian);\n                      offset += 4;\n                      viewU8.set(s, offset);\n                      offset += s.byteLength;\n                    }\n                  }\n                } else {\n                  viewU8[0] = 0;\n                }\n                metrics.s11n.serialize.time += performance.now() - t;\n              };\n              return state.s11n;\n            };\n\n            const randomFilename = function f(len = 16) {\n              if (!f._chars) {\n                f._chars =\n                  'abcdefghijklmnopqrstuvwxyz' +\n                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n                  '012346789';\n                f._n = f._chars.length;\n              }\n              const a = [];\n              let i = 0;\n              for (; i < len; ++i) {\n                const ndx = (Math.random() * (f._n * 64)) % f._n | 0;\n                a[i] = f._chars[ndx];\n              }\n              return a.join('');\n            };\n\n            const __openFiles = Object.create(null);\n\n            const opTimer = Object.create(null);\n            opTimer.op = undefined;\n            opTimer.start = undefined;\n            const mTimeStart = (op) => {\n              opTimer.start = performance.now();\n              opTimer.op = op;\n              ++metrics[op].count;\n            };\n            const mTimeEnd = () =>\n              (metrics[opTimer.op].time += performance.now() - opTimer.start);\n\n            const ioSyncWrappers = {\n              xCheckReservedLock: function (pFile, pOut) {\n                wasm.poke(pOut, 0, 'i32');\n                return 0;\n              },\n              xClose: function (pFile) {\n                mTimeStart('xClose');\n                let rc = 0;\n                const f = __openFiles[pFile];\n                if (f) {\n                  delete __openFiles[pFile];\n                  rc = opRun('xClose', pFile);\n                  if (f.sq3File) f.sq3File.dispose();\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xDeviceCharacteristics: function (pFile) {\n                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n              },\n              xFileControl: function (pFile, opId, pArg) {\n                return capi.SQLITE_NOTFOUND;\n              },\n              xFileSize: function (pFile, pSz64) {\n                mTimeStart('xFileSize');\n                let rc = opRun('xFileSize', pFile);\n                if (0 == rc) {\n                  try {\n                    const sz = state.s11n.deserialize()[0];\n                    wasm.poke(pSz64, sz, 'i64');\n                  } catch (e) {\n                    error('Unexpected error reading xFileSize() result:', e);\n                    rc = state.sq3Codes.SQLITE_IOERR;\n                  }\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xLock: function (pFile, lockType) {\n                mTimeStart('xLock');\n                const f = __openFiles[pFile];\n                let rc = 0;\n\n                if (!f.lockType) {\n                  rc = opRun('xLock', pFile, lockType);\n                  if (0 === rc) f.lockType = lockType;\n                } else {\n                  f.lockType = lockType;\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xRead: function (pFile, pDest, n, offset64) {\n                mTimeStart('xRead');\n                const f = __openFiles[pFile];\n                let rc;\n                try {\n                  rc = opRun('xRead', pFile, n, Number(offset64));\n                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {\n                    wasm.heap8u().set(f.sabView.subarray(0, n), pDest);\n                  }\n                } catch (e) {\n                  error('xRead(', arguments, ') failed:', e, f);\n                  rc = capi.SQLITE_IOERR_READ;\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xSync: function (pFile, flags) {\n                mTimeStart('xSync');\n                ++metrics.xSync.count;\n                const rc = opRun('xSync', pFile, flags);\n                mTimeEnd();\n                return rc;\n              },\n              xTruncate: function (pFile, sz64) {\n                mTimeStart('xTruncate');\n                const rc = opRun('xTruncate', pFile, Number(sz64));\n                mTimeEnd();\n                return rc;\n              },\n              xUnlock: function (pFile, lockType) {\n                mTimeStart('xUnlock');\n                const f = __openFiles[pFile];\n                let rc = 0;\n                if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {\n                  rc = opRun('xUnlock', pFile, lockType);\n                }\n                if (0 === rc) f.lockType = lockType;\n                mTimeEnd();\n                return rc;\n              },\n              xWrite: function (pFile, pSrc, n, offset64) {\n                mTimeStart('xWrite');\n                const f = __openFiles[pFile];\n                let rc;\n                try {\n                  f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));\n                  rc = opRun('xWrite', pFile, n, Number(offset64));\n                } catch (e) {\n                  error('xWrite(', arguments, ') failed:', e, f);\n                  rc = capi.SQLITE_IOERR_WRITE;\n                }\n                mTimeEnd();\n                return rc;\n              },\n            };\n\n            const vfsSyncWrappers = {\n              xAccess: function (pVfs, zName, flags, pOut) {\n                mTimeStart('xAccess');\n                const rc = opRun('xAccess', wasm.cstrToJs(zName));\n                wasm.poke(pOut, rc ? 0 : 1, 'i32');\n                mTimeEnd();\n                return 0;\n              },\n              xCurrentTime: function (pVfs, pOut) {\n                wasm.poke(\n                  pOut,\n                  2440587.5 + new Date().getTime() / 86400000,\n                  'double',\n                );\n                return 0;\n              },\n              xCurrentTimeInt64: function (pVfs, pOut) {\n                wasm.poke(\n                  pOut,\n                  2440587.5 * 86400000 + new Date().getTime(),\n                  'i64',\n                );\n                return 0;\n              },\n              xDelete: function (pVfs, zName, doSyncDir) {\n                mTimeStart('xDelete');\n                const rc = opRun(\n                  'xDelete',\n                  wasm.cstrToJs(zName),\n                  doSyncDir,\n                  false,\n                );\n                mTimeEnd();\n                return rc;\n              },\n              xFullPathname: function (pVfs, zName, nOut, pOut) {\n                const i = wasm.cstrncpy(pOut, zName, nOut);\n                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n              },\n              xGetLastError: function (pVfs, nOut, pOut) {\n                warn('OPFS xGetLastError() has nothing sensible to return.');\n                return 0;\n              },\n\n              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n                mTimeStart('xOpen');\n                let opfsFlags = 0;\n                if (0 === zName) {\n                  zName = randomFilename();\n                } else if (wasm.isPtr(zName)) {\n                  if (capi.sqlite3_uri_boolean(zName, 'opfs-unlock-asap', 0)) {\n                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;\n                  }\n                  if (\n                    capi.sqlite3_uri_boolean(zName, 'delete-before-open', 0)\n                  ) {\n                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;\n                  }\n                  zName = wasm.cstrToJs(zName);\n                }\n                const fh = Object.create(null);\n                fh.fid = pFile;\n                fh.filename = zName;\n                fh.sab = new SharedArrayBuffer(state.fileBufferSize);\n                fh.flags = flags;\n                fh.readOnly =\n                  !(sqlite3.SQLITE_OPEN_CREATE & flags) &&\n                  !!(flags & capi.SQLITE_OPEN_READONLY);\n                const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);\n                if (!rc) {\n                  if (fh.readOnly) {\n                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');\n                  }\n                  __openFiles[pFile] = fh;\n                  fh.sabView = state.sabFileBufView;\n                  fh.sq3File = new sqlite3_file(pFile);\n                  fh.sq3File.$pMethods = opfsIoMethods.pointer;\n                  fh.lockType = capi.SQLITE_LOCK_NONE;\n                }\n                mTimeEnd();\n                return rc;\n              },\n            };\n\n            if (dVfs) {\n              opfsVfs.$xRandomness = dVfs.$xRandomness;\n              opfsVfs.$xSleep = dVfs.$xSleep;\n            }\n            if (!opfsVfs.$xRandomness) {\n              vfsSyncWrappers.xRandomness = function (pVfs, nOut, pOut) {\n                const heap = wasm.heap8u();\n                let i = 0;\n                for (; i < nOut; ++i)\n                  heap[pOut + i] = (Math.random() * 255000) & 0xff;\n                return i;\n              };\n            }\n            if (!opfsVfs.$xSleep) {\n              vfsSyncWrappers.xSleep = function (pVfs, ms) {\n                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);\n                return 0;\n              };\n            }\n\n            opfsUtil.getResolvedPath = function (filename, splitIt) {\n              const p = new URL(filename, 'file://irrelevant').pathname;\n              return splitIt ? p.split('/').filter((v) => !!v) : p;\n            };\n\n            opfsUtil.getDirForFilename = async function f(\n              absFilename,\n              createDirs = false,\n            ) {\n              const path = opfsUtil.getResolvedPath(absFilename, true);\n              const filename = path.pop();\n              let dh = opfsUtil.rootDirectory;\n              for (const dirName of path) {\n                if (dirName) {\n                  dh = await dh.getDirectoryHandle(dirName, {\n                    create: !!createDirs,\n                  });\n                }\n              }\n              return [dh, filename];\n            };\n\n            opfsUtil.mkdir = async function (absDirName) {\n              try {\n                await opfsUtil.getDirForFilename(\n                  absDirName + '/filepart',\n                  true,\n                );\n                return true;\n              } catch (e) {\n                return false;\n              }\n            };\n\n            opfsUtil.entryExists = async function (fsEntryName) {\n              try {\n                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);\n                await dh.getFileHandle(fn);\n                return true;\n              } catch (e) {\n                return false;\n              }\n            };\n\n            opfsUtil.randomFilename = randomFilename;\n\n            opfsUtil.treeList = async function () {\n              const doDir = async function callee(dirHandle, tgt) {\n                tgt.name = dirHandle.name;\n                tgt.dirs = [];\n                tgt.files = [];\n                for await (const handle of dirHandle.values()) {\n                  if ('directory' === handle.kind) {\n                    const subDir = Object.create(null);\n                    tgt.dirs.push(subDir);\n                    await callee(handle, subDir);\n                  } else {\n                    tgt.files.push(handle.name);\n                  }\n                }\n              };\n              const root = Object.create(null);\n              await doDir(opfsUtil.rootDirectory, root);\n              return root;\n            };\n\n            opfsUtil.rmfr = async function () {\n              const dir = opfsUtil.rootDirectory,\n                opt = { recurse: true };\n              for await (const handle of dir.values()) {\n                dir.removeEntry(handle.name, opt);\n              }\n            };\n\n            opfsUtil.unlink = async function (\n              fsEntryName,\n              recursive = false,\n              throwOnError = false,\n            ) {\n              try {\n                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(\n                  fsEntryName,\n                  false,\n                );\n                await hDir.removeEntry(filenamePart, { recursive });\n                return true;\n              } catch (e) {\n                if (throwOnError) {\n                  throw new Error(\n                    'unlink(',\n                    arguments[0],\n                    ') failed: ' + e.message,\n                    {\n                      cause: e,\n                    },\n                  );\n                }\n                return false;\n              }\n            };\n\n            opfsUtil.traverse = async function (opt) {\n              const defaultOpt = {\n                recursive: true,\n                directory: opfsUtil.rootDirectory,\n              };\n              if ('function' === typeof opt) {\n                opt = { callback: opt };\n              }\n              opt = Object.assign(defaultOpt, opt || {});\n              const doDir = async function callee(dirHandle, depth) {\n                for await (const handle of dirHandle.values()) {\n                  if (false === opt.callback(handle, dirHandle, depth))\n                    return false;\n                  else if (opt.recursive && 'directory' === handle.kind) {\n                    if (false === (await callee(handle, depth + 1))) break;\n                  }\n                }\n              };\n              doDir(opt.directory, 0);\n            };\n\n            const importDbChunked = async function (filename, callback) {\n              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n                filename,\n                true,\n              );\n              const hFile = await hDir.getFileHandle(fnamePart, {\n                create: true,\n              });\n              let sah = await hFile.createSyncAccessHandle();\n              let nWrote = 0,\n                chunk,\n                checkedHeader = false,\n                err = false;\n              try {\n                sah.truncate(0);\n                while (undefined !== (chunk = await callback())) {\n                  if (chunk instanceof ArrayBuffer)\n                    chunk = new Uint8Array(chunk);\n                  if (0 === nWrote && chunk.byteLength >= 15) {\n                    util.affirmDbHeader(chunk);\n                    checkedHeader = true;\n                  }\n                  sah.write(chunk, { at: nWrote });\n                  nWrote += chunk.byteLength;\n                }\n                if (nWrote < 512 || 0 !== nWrote % 512) {\n                  toss(\n                    'Input size',\n                    nWrote,\n                    'is not correct for an SQLite database.',\n                  );\n                }\n                if (!checkedHeader) {\n                  const header = new Uint8Array(20);\n                  sah.read(header, { at: 0 });\n                  util.affirmDbHeader(header);\n                }\n                sah.write(new Uint8Array([1, 1]), { at: 18 });\n                return nWrote;\n              } catch (e) {\n                await sah.close();\n                sah = undefined;\n                await hDir.removeEntry(fnamePart).catch(() => {});\n                throw e;\n              } finally {\n                if (sah) await sah.close();\n              }\n            };\n\n            opfsUtil.importDb = async function (filename, bytes) {\n              if (bytes instanceof Function) {\n                return importDbChunked(filename, bytes);\n              }\n              if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n              util.affirmIsDb(bytes);\n              const n = bytes.byteLength;\n              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n                filename,\n                true,\n              );\n              let sah,\n                err,\n                nWrote = 0;\n              try {\n                const hFile = await hDir.getFileHandle(fnamePart, {\n                  create: true,\n                });\n                sah = await hFile.createSyncAccessHandle();\n                sah.truncate(0);\n                nWrote = sah.write(bytes, { at: 0 });\n                if (nWrote != n) {\n                  toss(\n                    'Expected to write ' +\n                      n +\n                      ' bytes but wrote ' +\n                      nWrote +\n                      '.',\n                  );\n                }\n                sah.write(new Uint8Array([1, 1]), { at: 18 });\n                return nWrote;\n              } catch (e) {\n                if (sah) {\n                  await sah.close();\n                  sah = undefined;\n                }\n                await hDir.removeEntry(fnamePart).catch(() => {});\n                throw e;\n              } finally {\n                if (sah) await sah.close();\n              }\n            };\n\n            if (sqlite3.oo1) {\n              const OpfsDb = function (...args) {\n                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);\n                opt.vfs = opfsVfs.$zName;\n                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);\n              };\n              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);\n              sqlite3.oo1.OpfsDb = OpfsDb;\n              OpfsDb.importDb = opfsUtil.importDb;\n              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(\n                opfsVfs.pointer,\n                function (oo1Db, sqlite3) {\n                  sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);\n                },\n              );\n            }\n\n            const sanityCheck = function () {\n              const scope = wasm.scopedAllocPush();\n              const sq3File = new sqlite3_file();\n              try {\n                const fid = sq3File.pointer;\n                const openFlags =\n                  capi.SQLITE_OPEN_CREATE |\n                  capi.SQLITE_OPEN_READWRITE |\n                  capi.SQLITE_OPEN_MAIN_DB;\n                const pOut = wasm.scopedAlloc(8);\n                const dbFile = '/sanity/check/file' + randomFilename(8);\n                const zDbFile = wasm.scopedAllocCString(dbFile);\n                let rc;\n                state.s11n.serialize('This is  string.');\n                rc = state.s11n.deserialize();\n                log('deserialize() says:', rc);\n                if ('This is  string.' !== rc[0]) toss('String d13n error.');\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                log('xAccess(', dbFile, ') exists ?=', rc);\n                rc = vfsSyncWrappers.xOpen(\n                  opfsVfs.pointer,\n                  zDbFile,\n                  fid,\n                  openFlags,\n                  pOut,\n                );\n                log(\n                  'open rc =',\n                  rc,\n                  'state.sabOPView[xOpen] =',\n                  state.sabOPView[state.opIds.xOpen],\n                );\n                if (0 !== rc) {\n                  error('open failed with code', rc);\n                  return;\n                }\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                if (!rc) toss('xAccess() failed to detect file.');\n                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);\n                if (rc) toss('sync failed w/ rc', rc);\n                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);\n                if (rc) toss('truncate failed w/ rc', rc);\n                wasm.poke(pOut, 0, 'i64');\n                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);\n                if (rc) toss('xFileSize failed w/ rc', rc);\n                log('xFileSize says:', wasm.peek(pOut, 'i64'));\n                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);\n                if (rc) toss('xWrite() failed!');\n                const readBuf = wasm.scopedAlloc(16);\n                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);\n                wasm.poke(readBuf + 6, 0);\n                let jRead = wasm.cstrToJs(readBuf);\n                log('xRead() got:', jRead);\n                if ('sanity' !== jRead) toss('Unexpected xRead() value.');\n                if (vfsSyncWrappers.xSleep) {\n                  log('xSleep()ing before close()ing...');\n                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2000);\n                  log('waking up from xSleep()');\n                }\n                rc = ioSyncWrappers.xClose(fid);\n                log('xClose rc =', rc, 'sabOPView =', state.sabOPView);\n                log('Deleting file:', dbFile);\n                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                if (rc)\n                  toss(\n                    'Expecting 0 from xAccess(',\n                    dbFile,\n                    ') after xDelete().',\n                  );\n                warn('End of OPFS sanity checks.');\n              } finally {\n                sq3File.dispose();\n                wasm.scopedAllocPop(scope);\n              }\n            };\n\n            W.onmessage = function ({ data }) {\n              switch (data.type) {\n                case 'opfs-unavailable':\n                  promiseReject(new Error(data.payload.join(' ')));\n                  break;\n                case 'opfs-async-loaded':\n                  W.postMessage({ type: 'opfs-async-init', args: state });\n                  break;\n                case 'opfs-async-inited': {\n                  if (true === promiseWasRejected) {\n                    break;\n                  }\n                  try {\n                    sqlite3.vfs.installVfs({\n                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },\n                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers },\n                    });\n                    state.sabOPView = new Int32Array(state.sabOP);\n                    state.sabFileBufView = new Uint8Array(\n                      state.sabIO,\n                      0,\n                      state.fileBufferSize,\n                    );\n                    state.sabS11nView = new Uint8Array(\n                      state.sabIO,\n                      state.sabS11nOffset,\n                      state.sabS11nSize,\n                    );\n                    initS11n();\n                    if (options.sanityChecks) {\n                      warn(\n                        'Running sanity checks because of opfs-sanity-check URL arg...',\n                      );\n                      sanityCheck();\n                    }\n                    if (thisThreadHasOPFS()) {\n                      navigator.storage\n                        .getDirectory()\n                        .then((d) => {\n                          W.onerror = W._originalOnError;\n                          delete W._originalOnError;\n                          sqlite3.opfs = opfsUtil;\n                          opfsUtil.rootDirectory = d;\n                          log('End of OPFS sqlite3_vfs setup.', opfsVfs);\n                          promiseResolve();\n                        })\n                        .catch(promiseReject);\n                    } else {\n                      promiseResolve();\n                    }\n                  } catch (e) {\n                    error(e);\n                    promiseReject(e);\n                  }\n                  break;\n                }\n                default: {\n                  const errMsg =\n                    'Unexpected message from the OPFS async worker: ' +\n                    JSON.stringify(data);\n                  error(errMsg);\n                  promiseReject(new Error(errMsg));\n                  break;\n                }\n              }\n            };\n          });\n          return thePromise;\n        };\n        installOpfsVfs.defaultProxyUri = 'sqlite3-opfs-async-proxy.js';\n        globalThis.sqlite3ApiBootstrap.initializersAsync.push(\n          async (sqlite3) => {\n            try {\n              let proxyJs = installOpfsVfs.defaultProxyUri;\n              if (sqlite3.scriptInfo.sqlite3Dir) {\n                installOpfsVfs.defaultProxyUri =\n                  sqlite3.scriptInfo.sqlite3Dir + proxyJs;\n              }\n              return installOpfsVfs().catch((e) => {\n                sqlite3.config.warn(\n                  'Ignoring inability to install OPFS sqlite3_vfs:',\n                  e.message,\n                );\n              });\n            } catch (e) {\n              sqlite3.config.error('installOpfsVfs() exception:', e);\n              return Promise.reject(e);\n            }\n          },\n        );\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        'use strict';\n        const toss = sqlite3.util.toss;\n        const toss3 = sqlite3.util.toss3;\n        const initPromises = Object.create(null);\n        const capi = sqlite3.capi;\n        const util = sqlite3.util;\n        const wasm = sqlite3.wasm;\n\n        const SECTOR_SIZE = 4096;\n        const HEADER_MAX_PATH_SIZE = 512;\n        const HEADER_FLAGS_SIZE = 4;\n        const HEADER_DIGEST_SIZE = 8;\n        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;\n        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;\n        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;\n        const HEADER_OFFSET_DATA = SECTOR_SIZE;\n\n        const PERSISTENT_FILE_TYPES =\n          capi.SQLITE_OPEN_MAIN_DB |\n          capi.SQLITE_OPEN_MAIN_JOURNAL |\n          capi.SQLITE_OPEN_SUPER_JOURNAL |\n          capi.SQLITE_OPEN_WAL;\n\n        const OPAQUE_DIR_NAME = '.opaque';\n\n        const getRandomName = () => Math.random().toString(36).slice(2);\n\n        const textDecoder = new TextDecoder();\n        const textEncoder = new TextEncoder();\n\n        const optionDefaults = Object.assign(Object.create(null), {\n          name: 'opfs-sahpool',\n          directory: undefined,\n          initialCapacity: 6,\n          clearOnInit: false,\n\n          verbosity: 2,\n          forceReinitIfPreviouslyFailed: false,\n        });\n\n        const loggers = [\n          sqlite3.config.error,\n          sqlite3.config.warn,\n          sqlite3.config.log,\n        ];\n        const log = sqlite3.config.log;\n        const warn = sqlite3.config.warn;\n        const error = sqlite3.config.error;\n\n        const __mapVfsToPool = new Map();\n        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);\n        const setPoolForVfs = (pVfs, pool) => {\n          if (pool) __mapVfsToPool.set(pVfs, pool);\n          else __mapVfsToPool.delete(pVfs);\n        };\n\n        const __mapSqlite3File = new Map();\n        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);\n        const setPoolForPFile = (pFile, pool) => {\n          if (pool) __mapSqlite3File.set(pFile, pool);\n          else __mapSqlite3File.delete(pFile);\n        };\n\n        const ioMethods = {\n          xCheckReservedLock: function (pFile, pOut) {\n            const pool = getPoolForPFile(pFile);\n            pool.log('xCheckReservedLock');\n            pool.storeErr();\n            wasm.poke32(pOut, 1);\n            return 0;\n          },\n          xClose: function (pFile) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            if (file) {\n              try {\n                pool.log(`xClose ${file.path}`);\n                pool.mapS3FileToOFile(pFile, false);\n                file.sah.flush();\n                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {\n                  pool.deletePath(file.path);\n                }\n              } catch (e) {\n                return pool.storeErr(e, capi.SQLITE_IOERR);\n              }\n            }\n            return 0;\n          },\n          xDeviceCharacteristics: function (pFile) {\n            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n          },\n          xFileControl: function (pFile, opId, pArg) {\n            return capi.SQLITE_NOTFOUND;\n          },\n          xFileSize: function (pFile, pSz64) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xFileSize`);\n            const file = pool.getOFileForS3File(pFile);\n            const size = file.sah.getSize() - HEADER_OFFSET_DATA;\n\n            wasm.poke64(pSz64, BigInt(size));\n            return 0;\n          },\n          xLock: function (pFile, lockType) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xLock ${lockType}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            file.lockType = lockType;\n            return 0;\n          },\n          xRead: function (pFile, pDest, n, offset64) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            pool.log(`xRead ${file.path} ${n} @ ${offset64}`);\n            try {\n              const nRead = file.sah.read(\n                wasm.heap8u().subarray(pDest, pDest + n),\n                { at: HEADER_OFFSET_DATA + Number(offset64) },\n              );\n              if (nRead < n) {\n                wasm.heap8u().fill(0, pDest + nRead, pDest + n);\n                return capi.SQLITE_IOERR_SHORT_READ;\n              }\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xSectorSize: function (pFile) {\n            return SECTOR_SIZE;\n          },\n          xSync: function (pFile, flags) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xSync ${flags}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n\n            try {\n              file.sah.flush();\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xTruncate: function (pFile, sz64) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xTruncate ${sz64}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n\n            try {\n              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xUnlock: function (pFile, lockType) {\n            const pool = getPoolForPFile(pFile);\n            pool.log('xUnlock');\n            const file = pool.getOFileForS3File(pFile);\n            file.lockType = lockType;\n            return 0;\n          },\n          xWrite: function (pFile, pSrc, n, offset64) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            pool.log(`xWrite ${file.path} ${n} ${offset64}`);\n            try {\n              const nBytes = file.sah.write(\n                wasm.heap8u().subarray(pSrc, pSrc + n),\n                { at: HEADER_OFFSET_DATA + Number(offset64) },\n              );\n              return n === nBytes ? 0 : toss('Unknown write() failure.');\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n        };\n\n        const opfsIoMethods = new capi.sqlite3_io_methods();\n        opfsIoMethods.$iVersion = 1;\n        sqlite3.vfs.installVfs({\n          io: { struct: opfsIoMethods, methods: ioMethods },\n        });\n\n        const vfsMethods = {\n          xAccess: function (pVfs, zName, flags, pOut) {\n            const pool = getPoolForVfs(pVfs);\n            pool.storeErr();\n            try {\n              const name = pool.getPath(zName);\n              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);\n            } catch (e) {\n              wasm.poke32(pOut, 0);\n            }\n            return 0;\n          },\n          xCurrentTime: function (pVfs, pOut) {\n            wasm.poke(\n              pOut,\n              2440587.5 + new Date().getTime() / 86400000,\n              'double',\n            );\n            return 0;\n          },\n          xCurrentTimeInt64: function (pVfs, pOut) {\n            wasm.poke(pOut, 2440587.5 * 86400000 + new Date().getTime(), 'i64');\n            return 0;\n          },\n          xDelete: function (pVfs, zName, doSyncDir) {\n            const pool = getPoolForVfs(pVfs);\n            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);\n            pool.storeErr();\n            try {\n              pool.deletePath(pool.getPath(zName));\n              return 0;\n            } catch (e) {\n              pool.storeErr(e);\n              return capi.SQLITE_IOERR_DELETE;\n            }\n          },\n          xFullPathname: function (pVfs, zName, nOut, pOut) {\n            const i = wasm.cstrncpy(pOut, zName, nOut);\n            return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n          },\n          xGetLastError: function (pVfs, nOut, pOut) {\n            const pool = getPoolForVfs(pVfs);\n            const e = pool.popErr();\n            pool.log(`xGetLastError ${nOut} e =`, e);\n            if (e) {\n              const scope = wasm.scopedAllocPush();\n              try {\n                const [cMsg, n] = wasm.scopedAllocCString(e.message, true);\n                wasm.cstrncpy(pOut, cMsg, nOut);\n                if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);\n              } catch (e) {\n                return capi.SQLITE_NOMEM;\n              } finally {\n                wasm.scopedAllocPop(scope);\n              }\n            }\n            return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;\n          },\n\n          xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n            const pool = getPoolForVfs(pVfs);\n            try {\n              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);\n\n              const path =\n                zName && wasm.peek8(zName)\n                  ? pool.getPath(zName)\n                  : getRandomName();\n              let sah = pool.getSAHForPath(path);\n              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {\n                if (pool.getFileCount() < pool.getCapacity()) {\n                  sah = pool.nextAvailableSAH();\n                  pool.setAssociatedPath(sah, path, flags);\n                } else {\n                  toss('SAH pool is full. Cannot create file', path);\n                }\n              }\n              if (!sah) {\n                toss('file not found:', path);\n              }\n\n              const file = { path, flags, sah };\n              pool.mapS3FileToOFile(pFile, file);\n              file.lockType = capi.SQLITE_LOCK_NONE;\n              const sq3File = new capi.sqlite3_file(pFile);\n              sq3File.$pMethods = opfsIoMethods.pointer;\n              sq3File.dispose();\n              wasm.poke32(pOutFlags, flags);\n              return 0;\n            } catch (e) {\n              pool.storeErr(e);\n              return capi.SQLITE_CANTOPEN;\n            }\n          },\n        };\n\n        const createOpfsVfs = function (vfsName) {\n          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {\n            toss3('VFS name is already registered:', vfsName);\n          }\n          const opfsVfs = new capi.sqlite3_vfs();\n\n          const pDVfs = capi.sqlite3_vfs_find(null);\n          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;\n          opfsVfs.$iVersion = 2;\n          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;\n          opfsVfs.addOnDispose(\n            (opfsVfs.$zName = wasm.allocCString(vfsName)),\n            () => setPoolForVfs(opfsVfs.pointer, 0),\n          );\n\n          if (dVfs) {\n            opfsVfs.$xRandomness = dVfs.$xRandomness;\n            opfsVfs.$xSleep = dVfs.$xSleep;\n            dVfs.dispose();\n          }\n          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {\n            vfsMethods.xRandomness = function (pVfs, nOut, pOut) {\n              const heap = wasm.heap8u();\n              let i = 0;\n              for (; i < nOut; ++i)\n                heap[pOut + i] = (Math.random() * 255000) & 0xff;\n              return i;\n            };\n          }\n          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {\n            vfsMethods.xSleep = (pVfs, ms) => 0;\n          }\n          sqlite3.vfs.installVfs({\n            vfs: { struct: opfsVfs, methods: vfsMethods },\n          });\n          return opfsVfs;\n        };\n\n        class OpfsSAHPool {\n          vfsDir;\n\n          #dhVfsRoot;\n\n          #dhOpaque;\n\n          #dhVfsParent;\n\n          #mapSAHToName = new Map();\n\n          #mapFilenameToSAH = new Map();\n\n          #availableSAH = new Set();\n\n          #mapS3FileToOFile_ = new Map();\n\n          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);\n\n          #dvBody;\n\n          #cVfs;\n\n          #verbosity;\n\n          constructor(options = Object.create(null)) {\n            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;\n            this.vfsName = options.name || optionDefaults.name;\n            this.#cVfs = createOpfsVfs(this.vfsName);\n            setPoolForVfs(this.#cVfs.pointer, this);\n            this.vfsDir = options.directory || '.' + this.vfsName;\n            this.#dvBody = new DataView(\n              this.#apBody.buffer,\n              this.#apBody.byteOffset,\n            );\n            this.isReady = this.reset(\n              !!(options.clearOnInit ?? optionDefaults.clearOnInit),\n            ).then(() => {\n              if (this.$error) throw this.$error;\n              return this.getCapacity()\n                ? Promise.resolve(undefined)\n                : this.addCapacity(\n                    options.initialCapacity || optionDefaults.initialCapacity,\n                  );\n            });\n          }\n\n          #logImpl(level, ...args) {\n            if (this.#verbosity > level)\n              loggers[level](this.vfsName + ':', ...args);\n          }\n          log(...args) {\n            this.#logImpl(2, ...args);\n          }\n          warn(...args) {\n            this.#logImpl(1, ...args);\n          }\n          error(...args) {\n            this.#logImpl(0, ...args);\n          }\n\n          getVfs() {\n            return this.#cVfs;\n          }\n\n          getCapacity() {\n            return this.#mapSAHToName.size;\n          }\n\n          getFileCount() {\n            return this.#mapFilenameToSAH.size;\n          }\n\n          getFileNames() {\n            const rc = [];\n            const iter = this.#mapFilenameToSAH.keys();\n            for (const n of iter) rc.push(n);\n            return rc;\n          }\n\n          async addCapacity(n) {\n            for (let i = 0; i < n; ++i) {\n              const name = getRandomName();\n              const h = await this.#dhOpaque.getFileHandle(name, {\n                create: true,\n              });\n              const ah = await h.createSyncAccessHandle();\n              this.#mapSAHToName.set(ah, name);\n              this.setAssociatedPath(ah, '', 0);\n            }\n            return this.getCapacity();\n          }\n\n          async reduceCapacity(n) {\n            let nRm = 0;\n            for (const ah of Array.from(this.#availableSAH)) {\n              if (nRm === n || this.getFileCount() === this.getCapacity()) {\n                break;\n              }\n              const name = this.#mapSAHToName.get(ah);\n\n              ah.close();\n              await this.#dhOpaque.removeEntry(name);\n              this.#mapSAHToName.delete(ah);\n              this.#availableSAH.delete(ah);\n              ++nRm;\n            }\n            return nRm;\n          }\n\n          releaseAccessHandles() {\n            for (const ah of this.#mapSAHToName.keys()) ah.close();\n            this.#mapSAHToName.clear();\n            this.#mapFilenameToSAH.clear();\n            this.#availableSAH.clear();\n          }\n\n          async acquireAccessHandles(clearFiles) {\n            const files = [];\n            for await (const [name, h] of this.#dhOpaque) {\n              if ('file' === h.kind) {\n                files.push([name, h]);\n              }\n            }\n            return Promise.all(\n              files.map(async ([name, h]) => {\n                try {\n                  const ah = await h.createSyncAccessHandle();\n                  this.#mapSAHToName.set(ah, name);\n                  if (clearFiles) {\n                    ah.truncate(HEADER_OFFSET_DATA);\n                    this.setAssociatedPath(ah, '', 0);\n                  } else {\n                    const path = this.getAssociatedPath(ah);\n                    if (path) {\n                      this.#mapFilenameToSAH.set(path, ah);\n                    } else {\n                      this.#availableSAH.add(ah);\n                    }\n                  }\n                } catch (e) {\n                  this.storeErr(e);\n                  this.releaseAccessHandles();\n                  throw e;\n                }\n              }),\n            );\n          }\n\n          getAssociatedPath(sah) {\n            sah.read(this.#apBody, { at: 0 });\n\n            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);\n            if (\n              this.#apBody[0] &&\n              (flags & capi.SQLITE_OPEN_DELETEONCLOSE ||\n                (flags & PERSISTENT_FILE_TYPES) === 0)\n            ) {\n              warn(\n                `Removing file with unexpected flags ${flags.toString(16)}`,\n                this.#apBody,\n              );\n              this.setAssociatedPath(sah, '', 0);\n              return '';\n            }\n\n            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);\n            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });\n            const compDigest = this.computeDigest(this.#apBody);\n            if (fileDigest.every((v, i) => v === compDigest[i])) {\n              const pathBytes = this.#apBody.findIndex((v) => 0 === v);\n              if (0 === pathBytes) {\n                sah.truncate(HEADER_OFFSET_DATA);\n              }\n              return pathBytes\n                ? textDecoder.decode(this.#apBody.subarray(0, pathBytes))\n                : '';\n            } else {\n              warn('Disassociating file with bad digest.');\n              this.setAssociatedPath(sah, '', 0);\n              return '';\n            }\n          }\n\n          setAssociatedPath(sah, path, flags) {\n            const enc = textEncoder.encodeInto(path, this.#apBody);\n            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {\n              toss('Path too long:', path);\n            }\n            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);\n            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);\n\n            const digest = this.computeDigest(this.#apBody);\n            sah.write(this.#apBody, { at: 0 });\n            sah.write(digest, { at: HEADER_OFFSET_DIGEST });\n            sah.flush();\n\n            if (path) {\n              this.#mapFilenameToSAH.set(path, sah);\n              this.#availableSAH.delete(sah);\n            } else {\n              sah.truncate(HEADER_OFFSET_DATA);\n              this.#availableSAH.add(sah);\n            }\n          }\n\n          computeDigest(byteArray) {\n            let h1 = 0xdeadbeef;\n            let h2 = 0x41c6ce57;\n            for (const v of byteArray) {\n              h1 = 31 * h1 + v * 307;\n              h2 = 31 * h2 + v * 307;\n            }\n            return new Uint32Array([h1 >>> 0, h2 >>> 0]);\n          }\n\n          async reset(clearFiles) {\n            await this.isReady;\n            let h = await navigator.storage.getDirectory();\n            let prev, prevName;\n            for (const d of this.vfsDir.split('/')) {\n              if (d) {\n                prev = h;\n                h = await h.getDirectoryHandle(d, { create: true });\n              }\n            }\n            this.#dhVfsRoot = h;\n            this.#dhVfsParent = prev;\n            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(\n              OPAQUE_DIR_NAME,\n              { create: true },\n            );\n            this.releaseAccessHandles();\n            return this.acquireAccessHandles(clearFiles);\n          }\n\n          getPath(arg) {\n            if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);\n            return (\n              arg instanceof URL ? arg : new URL(arg, 'file://localhost/')\n            ).pathname;\n          }\n\n          deletePath(path) {\n            const sah = this.#mapFilenameToSAH.get(path);\n            if (sah) {\n              this.#mapFilenameToSAH.delete(path);\n              this.setAssociatedPath(sah, '', 0);\n            }\n            return !!sah;\n          }\n\n          storeErr(e, code) {\n            if (e) {\n              e.sqlite3Rc = code || capi.SQLITE_IOERR;\n              this.error(e);\n            }\n            this.$error = e;\n            return code;\n          }\n\n          popErr() {\n            const rc = this.$error;\n            this.$error = undefined;\n            return rc;\n          }\n\n          nextAvailableSAH() {\n            const [rc] = this.#availableSAH.keys();\n            return rc;\n          }\n\n          getOFileForS3File(pFile) {\n            return this.#mapS3FileToOFile_.get(pFile);\n          }\n\n          mapS3FileToOFile(pFile, file) {\n            if (file) {\n              this.#mapS3FileToOFile_.set(pFile, file);\n              setPoolForPFile(pFile, this);\n            } else {\n              this.#mapS3FileToOFile_.delete(pFile);\n              setPoolForPFile(pFile, false);\n            }\n          }\n\n          hasFilename(name) {\n            return this.#mapFilenameToSAH.has(name);\n          }\n\n          getSAHForPath(path) {\n            return this.#mapFilenameToSAH.get(path);\n          }\n\n          async removeVfs() {\n            if (!this.#cVfs.pointer || !this.#dhOpaque) return false;\n            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);\n            this.#cVfs.dispose();\n            delete initPromises[this.vfsName];\n            try {\n              this.releaseAccessHandles();\n              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {\n                recursive: true,\n              });\n              this.#dhOpaque = undefined;\n              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {\n                recursive: true,\n              });\n              this.#dhVfsRoot = this.#dhVfsParent = undefined;\n            } catch (e) {\n              sqlite3.config.error(this.vfsName, 'removeVfs() failed:', e);\n            }\n            return true;\n          }\n\n          exportFile(name) {\n            const sah =\n              this.#mapFilenameToSAH.get(name) || toss('File not found:', name);\n            const n = sah.getSize() - HEADER_OFFSET_DATA;\n            const b = new Uint8Array(n > 0 ? n : 0);\n            if (n > 0) {\n              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });\n              if (nRead != n) {\n                toss(\n                  'Expected to read ' + n + ' bytes but read ' + nRead + '.',\n                );\n              }\n            }\n            return b;\n          }\n\n          async importDbChunked(name, callback) {\n            const sah =\n              this.#mapFilenameToSAH.get(name) ||\n              this.nextAvailableSAH() ||\n              toss('No available handles to import to.');\n            sah.truncate(0);\n            let nWrote = 0,\n              chunk,\n              checkedHeader = false,\n              err = false;\n            try {\n              while (undefined !== (chunk = await callback())) {\n                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);\n                if (0 === nWrote && chunk.byteLength >= 15) {\n                  util.affirmDbHeader(chunk);\n                  checkedHeader = true;\n                }\n                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });\n                nWrote += chunk.byteLength;\n              }\n              if (nWrote < 512 || 0 !== nWrote % 512) {\n                toss(\n                  'Input size',\n                  nWrote,\n                  'is not correct for an SQLite database.',\n                );\n              }\n              if (!checkedHeader) {\n                const header = new Uint8Array(20);\n                sah.read(header, { at: 0 });\n                util.affirmDbHeader(header);\n              }\n              sah.write(new Uint8Array([1, 1]), {\n                at: HEADER_OFFSET_DATA + 18,\n              });\n            } catch (e) {\n              this.setAssociatedPath(sah, '', 0);\n              throw e;\n            }\n            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n            return nWrote;\n          }\n\n          importDb(name, bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            else if (bytes instanceof Function)\n              return this.importDbChunked(name, bytes);\n            const sah =\n              this.#mapFilenameToSAH.get(name) ||\n              this.nextAvailableSAH() ||\n              toss('No available handles to import to.');\n            const n = bytes.byteLength;\n            if (n < 512 || n % 512 != 0) {\n              toss('Byte array size is invalid for an SQLite db.');\n            }\n            const header = 'SQLite format 3';\n            for (let i = 0; i < header.length; ++i) {\n              if (header.charCodeAt(i) !== bytes[i]) {\n                toss('Input does not contain an SQLite database header.');\n              }\n            }\n            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });\n            if (nWrote != n) {\n              this.setAssociatedPath(sah, '', 0);\n              toss(\n                'Expected to write ' + n + ' bytes but wrote ' + nWrote + '.',\n              );\n            } else {\n              sah.write(new Uint8Array([1, 1]), {\n                at: HEADER_OFFSET_DATA + 18,\n              });\n              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n            }\n            return nWrote;\n          }\n        }\n\n        class OpfsSAHPoolUtil {\n          #p;\n\n          constructor(sahPool) {\n            this.#p = sahPool;\n            this.vfsName = sahPool.vfsName;\n          }\n\n          async addCapacity(n) {\n            return this.#p.addCapacity(n);\n          }\n\n          async reduceCapacity(n) {\n            return this.#p.reduceCapacity(n);\n          }\n\n          getCapacity() {\n            return this.#p.getCapacity(this.#p);\n          }\n\n          getFileCount() {\n            return this.#p.getFileCount();\n          }\n          getFileNames() {\n            return this.#p.getFileNames();\n          }\n\n          async reserveMinimumCapacity(min) {\n            const c = this.#p.getCapacity();\n            return c < min ? this.#p.addCapacity(min - c) : c;\n          }\n\n          exportFile(name) {\n            return this.#p.exportFile(name);\n          }\n\n          importDb(name, bytes) {\n            return this.#p.importDb(name, bytes);\n          }\n\n          async wipeFiles() {\n            return this.#p.reset(true);\n          }\n\n          unlink(filename) {\n            return this.#p.deletePath(filename);\n          }\n\n          async removeVfs() {\n            return this.#p.removeVfs();\n          }\n        }\n\n        const apiVersionCheck = async () => {\n          const dh = await navigator.storage.getDirectory();\n          const fn = '.opfs-sahpool-sync-check-' + getRandomName();\n          const fh = await dh.getFileHandle(fn, { create: true });\n          const ah = await fh.createSyncAccessHandle();\n          const close = ah.close();\n          await close;\n          await dh.removeEntry(fn);\n          if (close?.then) {\n            toss(\n              'The local OPFS API is too old for opfs-sahpool:',\n              'it has an async FileSystemSyncAccessHandle.close() method.',\n            );\n          }\n          return true;\n        };\n\n        sqlite3.installOpfsSAHPoolVfs = async function (\n          options = Object.create(null),\n        ) {\n          options = Object.assign(\n            Object.create(null),\n            optionDefaults,\n            options || {},\n          );\n          const vfsName = options.name;\n          if (options.$testThrowPhase1) {\n            throw options.$testThrowPhase1;\n          }\n          if (initPromises[vfsName]) {\n            try {\n              const p = await initPromises[vfsName];\n\n              return p;\n            } catch (e) {\n              if (options.forceReinitIfPreviouslyFailed) {\n                delete initPromises[vfsName];\n              } else {\n                throw e;\n              }\n            }\n          }\n          if (\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle ||\n            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||\n            !navigator?.storage?.getDirectory\n          ) {\n            return (initPromises[vfsName] = Promise.reject(\n              new Error('Missing required OPFS APIs.'),\n            ));\n          }\n\n          return (initPromises[vfsName] = apiVersionCheck()\n            .then(async function () {\n              if (options.$testThrowPhase2) {\n                throw options.$testThrowPhase2;\n              }\n              const thePool = new OpfsSAHPool(options);\n              return thePool.isReady\n                .then(async () => {\n                  const poolUtil = new OpfsSAHPoolUtil(thePool);\n                  if (sqlite3.oo1) {\n                    const oo1 = sqlite3.oo1;\n                    const theVfs = thePool.getVfs();\n                    const OpfsSAHPoolDb = function (...args) {\n                      const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);\n                      opt.vfs = theVfs.$zName;\n                      oo1.DB.dbCtorHelper.call(this, opt);\n                    };\n                    OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);\n                    poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;\n                  }\n                  thePool.log('VFS initialized.');\n                  return poolUtil;\n                })\n                .catch(async (e) => {\n                  await thePool.removeVfs().catch(() => {});\n                  throw e;\n                });\n            })\n            .catch((err) => {\n              return (initPromises[vfsName] = Promise.reject(err));\n            }));\n        };\n      });\n\n      ('use strict');\n      if ('undefined' !== typeof Module) {\n        const SABC = Object.assign(\n          Object.create(null),\n          {\n            exports:\n              'undefined' === typeof wasmExports ? Module['asm'] : wasmExports,\n            memory: Module.wasmMemory,\n          },\n          globalThis.sqlite3ApiConfig || {},\n        );\n\n        globalThis.sqlite3ApiConfig = SABC;\n        let sqlite3;\n        try {\n          sqlite3 = globalThis.sqlite3ApiBootstrap();\n        } catch (e) {\n          console.error('sqlite3ApiBootstrap() error:', e);\n          throw e;\n        } finally {\n          delete globalThis.sqlite3ApiBootstrap;\n          delete globalThis.sqlite3ApiConfig;\n        }\n\n        Module.sqlite3 = sqlite3;\n      } else {\n        console.warn(\n          'This is not running in an Emscripten module context, so',\n          'globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack',\n          'of config info for the WASM environment.',\n          'It must be called manually.',\n        );\n      }\n    };\n\n    moduleRtn = readyPromise;\n\n    return moduleRtn;\n  };\n})();\n\nconst toExportForESM = (function () {\n  const originalInit = sqlite3InitModule;\n  if (!originalInit) {\n    throw new Error(\n      'Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.',\n    );\n  }\n\n  const initModuleState = (globalThis.sqlite3InitModuleState = Object.assign(\n    Object.create(null),\n    {\n      moduleScript: globalThis?.document?.currentScript,\n      isWorker: 'undefined' !== typeof WorkerGlobalScope,\n      location: globalThis.location,\n      urlParams: globalThis?.location?.href\n        ? new URL(globalThis.location.href).searchParams\n        : new URLSearchParams(),\n    },\n  ));\n  initModuleState.debugModule = initModuleState.urlParams.has(\n    'sqlite3.debugModule',\n  )\n    ? (...args) => console.warn('sqlite3.debugModule:', ...args)\n    : () => {};\n\n  if (initModuleState.urlParams.has('sqlite3.dir')) {\n    initModuleState.sqlite3Dir =\n      initModuleState.urlParams.get('sqlite3.dir') + '/';\n  } else if (initModuleState.moduleScript) {\n    const li = initModuleState.moduleScript.src.split('/');\n    li.pop();\n    initModuleState.sqlite3Dir = li.join('/') + '/';\n  }\n\n  globalThis.sqlite3InitModule = function ff(...args) {\n    return originalInit(...args)\n      .then((EmscriptenModule) => {\n        EmscriptenModule.runSQLite3PostLoadInit(EmscriptenModule);\n        const s = EmscriptenModule.sqlite3;\n        s.scriptInfo = initModuleState;\n\n        if (ff.__isUnderTest) s.__isUnderTest = true;\n        const f = s.asyncPostInit;\n        delete s.asyncPostInit;\n        const rv = f();\n        return rv;\n      })\n      .catch((e) => {\n        console.error('Exception loading sqlite3 module:', e);\n        throw e;\n      });\n  };\n  globalThis.sqlite3InitModule.ready = originalInit.ready;\n\n  if (globalThis.sqlite3InitModuleState.moduleScript) {\n    const sim = globalThis.sqlite3InitModuleState;\n    let src = sim.moduleScript.src.split('/');\n    src.pop();\n    sim.scriptDir = src.join('/') + '/';\n  }\n  initModuleState.debugModule('sqlite3InitModuleState =', initModuleState);\n  if (false) {}\n  return globalThis.sqlite3InitModule;\n})();\nsqlite3InitModule = toExportForESM;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3InitModule);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNxbGl0ZS5vcmcrc3FsaXRlLXdhc21AMy40OS4xLWJ1aWxkMi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtYnVuZGxlci1mcmllbmRseS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5TEFBZTs7QUFFbkMsaUNBQWlDO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsTUFBTSxPQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDZPQUF3QztBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pELGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsVUFBVTtBQUNWLDZCQUE2QjtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EsWUFBWTtBQUNaLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUUsR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUMsRUFBRSxFQUtOLENBQUM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLEtBQUMsRUFBRSxFQWdCTjs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUk7QUFDbEI7QUFDQSxrQkFBa0IsQ0FJRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksS0FBMEQsRUFBRSxFQU0vRDs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsTUFBQyxHQUFHLENBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsWUFBWTtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsdURBQXVEO0FBQ3ZELFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBQztBQUNuQixnQkFBZ0IsRUFLRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLFFBQVEsU0FBUztBQUMxQixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUMsaUNBQWlDLENBQUs7O0FBRTNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBUSxnTUFBOEMsQ0FBQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUMsRUFBRSxFQVNOO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpRUFBZSxpQkFBaUIsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vQHNxbGl0ZS5vcmcrc3FsaXRlLXdhc21AMy40OS4xLWJ1aWxkMi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtYnVuZGxlci1mcmllbmRseS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqKiBMSUNFTlNFIGZvciB0aGUgc3FsaXRlMyBXZWJBc3NlbWJseS9KYXZhU2NyaXB0IEFQSXMuXG4gKipcbiAqKiBUaGlzIGJ1bmRsZSAodHlwaWNhbGx5IHJlbGVhc2VkIGFzIHNxbGl0ZTMuanMgb3Igc3FsaXRlMy5tanMpXG4gKiogaXMgYW4gYW1hbGdhbWF0aW9uIG9mIEphdmFTY3JpcHQgc291cmNlIGNvZGUgZnJvbSB0d28gcHJvamVjdHM6XG4gKipcbiAqKiAxKSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnOiB0aGUgRW1zY3JpcHRlbiBcImdsdWUgY29kZVwiIGlzIGNvdmVyZWQgYnlcbiAqKiAgICB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlIGFuZCBVbml2ZXJzaXR5IG9mIElsbGlub2lzL05DU0FcbiAqKiAgICBPcGVuIFNvdXJjZSBMaWNlbnNlLCBhcyBkZXNjcmliZWQgYXQ6XG4gKipcbiAqKiAgICBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvaW50cm9kdWNpbmdfZW1zY3JpcHRlbi9lbXNjcmlwdGVuX2xpY2Vuc2UuaHRtbFxuICoqXG4gKiogMikgaHR0cHM6Ly9zcWxpdGUub3JnOiBhbGwgY29kZSBhbmQgZG9jdW1lbnRhdGlvbiBsYWJlbGVkIGFzIGJlaW5nXG4gKiogICAgZnJvbSB0aGlzIHNvdXJjZSBhcmUgcmVsZWFzZWQgdW5kZXIgdGhlIHNhbWUgdGVybXMgYXMgdGhlIHNxbGl0ZTNcbiAqKiAgICBDIGxpYnJhcnk6XG4gKipcbiAqKiAyMDIyLTEwLTE2XG4gKipcbiAqKiBUaGUgYXV0aG9yIGRpc2NsYWltcyBjb3B5cmlnaHQgdG8gdGhpcyBzb3VyY2UgY29kZS4gIEluIHBsYWNlIG9mIGFcbiAqKiBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcbiAqKlxuICoqICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICoqICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbiAqKiAqICAgTWF5IHlvdSBzaGFyZSBmcmVlbHksIG5ldmVyIHRha2luZyBtb3JlIHRoYW4geW91IGdpdmUuXG4gKi9cbi8qXG4gKiogVGhpcyBjb2RlIHdhcyBidWlsdCBmcm9tIHNxbGl0ZTMgdmVyc2lvbi4uLlxuICoqXG4gKiogU1FMSVRFX1ZFUlNJT04gXCIzLjQ5LjFcIlxuICoqIFNRTElURV9WRVJTSU9OX05VTUJFUiAzMDQ5MDAxXG4gKiogU1FMSVRFX1NPVVJDRV9JRCBcIjIwMjUtMDItMTggMTM6Mzg6NTggODczZDRlMjc0YjQ5ODhkMjYwYmE4MzU0YTk3MTgzMjRhMWMyNjE4N2E0YWI0YzFjYzAyMjdjMDNkMGYxMGU3MFwiXG4gKipcbiAqKiBVc2luZyB0aGUgRW1zY3JpcHRlbiBTREsgdmVyc2lvbiAzLjEuNzAuXG4gKi9cblxudmFyIHNxbGl0ZTNJbml0TW9kdWxlID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHROYW1lID0gaW1wb3J0Lm1ldGEudXJsO1xuXG4gIHJldHVybiBmdW5jdGlvbiAobW9kdWxlQXJnID0ge30pIHtcbiAgICB2YXIgbW9kdWxlUnRuO1xuXG4gICAgdmFyIE1vZHVsZSA9IG1vZHVsZUFyZztcblxuICAgIHZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG4gICAgdmFyIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCc7XG4gICAgdmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09ICdmdW5jdGlvbic7XG5cbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9XG4gICAgICB0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT0gJ3N0cmluZycgJiZcbiAgICAgIHByb2Nlc3MudHlwZSAhPSAncmVuZGVyZXInO1xuICAgIHZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9XG4gICAgICAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbiAgICBjb25zdCBzcWxpdGUzSW5pdE1vZHVsZVN0YXRlID1cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSB8fFxuICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgIGRlYnVnTW9kdWxlOiAoKSA9PiB7fSxcbiAgICAgIH0pO1xuICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGU7XG4gICAgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZShcbiAgICAgICdnbG9iYWxUaGlzLmxvY2F0aW9uID0nLFxuICAgICAgZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICApO1xuXG4gICAgdmFyIG1vZHVsZU92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oe30sIE1vZHVsZSk7XG5cbiAgICB2YXIgYXJndW1lbnRzXyA9IFtdO1xuICAgIHZhciB0aGlzUHJvZ3JhbSA9ICcuL3RoaXMucHJvZ3JhbSc7XG4gICAgdmFyIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICAgICAgdGhyb3cgdG9UaHJvdztcbiAgICB9O1xuXG4gICAgdmFyIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICAgIGZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICAgICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIHJlYWRBc3luYywgcmVhZEJpbmFyeTtcblxuICAgIGlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2NyaXB0TmFtZSkge1xuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBfc2NyaXB0TmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcmlwdERpcmVjdG9yeS5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cihcbiAgICAgICAgICAwLFxuICAgICAgICAgIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCAnJykubGFzdEluZGV4T2YoJy8nKSArIDEsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgICAgICAgIHJlYWRCaW5hcnkgPSAodXJsKSA9PiB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWRBc3luYyA9ICh1cmwpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyAnIDogJyArIHJlc3BvbnNlLnVybCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9IE1vZHVsZVsncHJpbnQnXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIHZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuXG4gICAgT2JqZWN0LmFzc2lnbihNb2R1bGUsIG1vZHVsZU92ZXJyaWRlcyk7XG5cbiAgICBtb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuXG4gICAgaWYgKE1vZHVsZVsnYXJndW1lbnRzJ10pIGFyZ3VtZW50c18gPSBNb2R1bGVbJ2FyZ3VtZW50cyddO1xuXG4gICAgaWYgKE1vZHVsZVsndGhpc1Byb2dyYW0nXSkgdGhpc1Byb2dyYW0gPSBNb2R1bGVbJ3RoaXNQcm9ncmFtJ107XG5cbiAgICB2YXIgd2FzbUJpbmFyeSA9IE1vZHVsZVsnd2FzbUJpbmFyeSddO1xuXG4gICAgdmFyIHdhc21NZW1vcnk7XG5cbiAgICB2YXIgQUJPUlQgPSBmYWxzZTtcblxuICAgIHZhciBFWElUU1RBVFVTO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgYWJvcnQodGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEhFQVAsXG4gICAgICBIRUFQOCxcbiAgICAgIEhFQVBVOCxcbiAgICAgIEhFQVAxNixcbiAgICAgIEhFQVBVMTYsXG4gICAgICBIRUFQMzIsXG4gICAgICBIRUFQVTMyLFxuICAgICAgSEVBUEYzMixcbiAgICAgIEhFQVA2NCxcbiAgICAgIEhFQVBVNjQsXG4gICAgICBIRUFQRjY0O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gICAgICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuICAgICAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQVTgnXSA9IEhFQVBVOCA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQMzInXSA9IEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQVTMyJ10gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQRjMyJ10gPSBIRUFQRjMyID0gbmV3IEZsb2F0MzJBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVA2NCddID0gSEVBUDY0ID0gbmV3IEJpZ0ludDY0QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVNjQnXSA9IEhFQVBVNjQgPSBuZXcgQmlnVWludDY0QXJyYXkoYik7XG4gICAgfVxuXG4gICAgaWYgKE1vZHVsZVsnd2FzbU1lbW9yeSddKSB7XG4gICAgICB3YXNtTWVtb3J5ID0gTW9kdWxlWyd3YXNtTWVtb3J5J107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcblxuICAgICAgd2FzbU1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICAgICAgICBpbml0aWFsOiBJTklUSUFMX01FTU9SWSAvIDY1NTM2LFxuXG4gICAgICAgIG1heGltdW06IDMyNzY4LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcblxuICAgIHZhciBfX0FUUFJFUlVOX18gPSBbXTtcbiAgICB2YXIgX19BVElOSVRfXyA9IFtdO1xuICAgIHZhciBfX0FURVhJVF9fID0gW107XG4gICAgdmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxuICAgIHZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHByZVJ1bigpIHtcbiAgICAgIHZhciBwcmVSdW5zID0gTW9kdWxlWydwcmVSdW4nXTtcbiAgICAgIGlmIChwcmVSdW5zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlUnVucyA9PSAnZnVuY3Rpb24nKSBwcmVSdW5zID0gW3ByZVJ1bnNdO1xuICAgICAgICBwcmVSdW5zLmZvckVhY2goYWRkT25QcmVSdW4pO1xuICAgICAgfVxuICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiAgICAgIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIGlmICghTW9kdWxlWydub0ZTSW5pdCddICYmICFGUy5pbml0aWFsaXplZCkgRlMuaW5pdCgpO1xuICAgICAgRlMuaWdub3JlUGVybWlzc2lvbnMgPSBmYWxzZTtcblxuICAgICAgVFRZLmluaXQoKTtcbiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gICAgICB2YXIgcG9zdFJ1bnMgPSBNb2R1bGVbJ3Bvc3RSdW4nXTtcbiAgICAgIGlmIChwb3N0UnVucykge1xuICAgICAgICBpZiAodHlwZW9mIHBvc3RSdW5zID09ICdmdW5jdGlvbicpIHBvc3RSdW5zID0gW3Bvc3RSdW5zXTtcbiAgICAgICAgcG9zdFJ1bnMuZm9yRWFjaChhZGRPblBvc3RSdW4pO1xuICAgICAgfVxuXG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuICAgICAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuICAgICAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHt9XG5cbiAgICBmdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgICAgIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XG4gICAgfVxuXG4gICAgdmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG4gICAgdmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICB2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgICBydW5EZXBlbmRlbmNpZXMrKztcblxuICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10/LihydW5EZXBlbmRlbmNpZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXT8uKHJ1bkRlcGVuZGVuY2llcyk7XG5cbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPT0gMCkge1xuICAgICAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgICAgICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcbiAgICAgICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gICAgICBNb2R1bGVbJ29uQWJvcnQnXT8uKHdoYXQpO1xuXG4gICAgICB3aGF0ID0gJ0Fib3J0ZWQoJyArIHdoYXQgKyAnKSc7XG5cbiAgICAgIGVycih3aGF0KTtcblxuICAgICAgQUJPUlQgPSB0cnVlO1xuXG4gICAgICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcblxuICAgICAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbiAgICB2YXIgaXNEYXRhVVJJID0gKGZpbGVuYW1lKSA9PiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xuXG4gICAgdmFyIGlzRmlsZVVSSSA9IChmaWxlbmFtZSkgPT4gZmlsZW5hbWUuc3RhcnRzV2l0aCgnZmlsZTovLycpO1xuXG4gICAgZnVuY3Rpb24gZmluZFdhc21CaW5hcnkoKSB7XG4gICAgICBpZiAoTW9kdWxlWydsb2NhdGVGaWxlJ10pIHtcbiAgICAgICAgdmFyIGYgPSAnc3FsaXRlMy53YXNtJztcbiAgICAgICAgaWYgKCFpc0RhdGFVUkkoZikpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRlRmlsZShmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBVUkwoJ3NxbGl0ZTMud2FzbScsIGltcG9ydC5tZXRhLnVybCkuaHJlZjtcbiAgICB9XG5cbiAgICB2YXIgd2FzbUJpbmFyeUZpbGU7XG5cbiAgICBmdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpIHtcbiAgICAgIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyAnYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkge1xuICAgICAgaWYgKCF3YXNtQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiByZWFkQXN5bmMoYmluYXJ5RmlsZSkudGhlbihcbiAgICAgICAgICAocmVzcG9uc2UpID0+IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSxcblxuICAgICAgICAgICgpID0+IGdldEJpbmFyeVN5bmMoYmluYXJ5RmlsZSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGdldEJpbmFyeVN5bmMoYmluYXJ5RmlsZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpXG4gICAgICAgIC50aGVuKChiaW5hcnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbXBvcnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4ocmVjZWl2ZXIsIChyZWFzb24pID0+IHtcbiAgICAgICAgICBlcnIoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7cmVhc29ufWApO1xuXG4gICAgICAgICAgYWJvcnQocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksIGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFiaW5hcnkgJiZcbiAgICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIWlzRGF0YVVSSShiaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChiaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgZXJyKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXYXNtSW1wb3J0cygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudjogd2FzbUltcG9ydHMsXG4gICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IHdhc21JbXBvcnRzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXYXNtKCkge1xuICAgICAgdmFyIGluZm8gPSBnZXRXYXNtSW1wb3J0cygpO1xuXG4gICAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgICAgICB3YXNtRXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICAgICAgYWRkT25Jbml0KHdhc21FeHBvcnRzWydfX3dhc21fY2FsbF9jdG9ycyddKTtcblxuICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG4gICAgICAgIHJldHVybiB3YXNtRXhwb3J0cztcbiAgICAgIH1cblxuICAgICAgYWRkUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuXG4gICAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsnaW5zdGFuY2UnXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfWApO1xuXG4gICAgICAgICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdhc21CaW5hcnlGaWxlID8/PSBmaW5kV2FzbUJpbmFyeSgpO1xuXG4gICAgICBpbnN0YW50aWF0ZUFzeW5jKFxuICAgICAgICB3YXNtQmluYXJ5LFxuICAgICAgICB3YXNtQmluYXJ5RmlsZSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQsXG4gICAgICApLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHRoaXMubmFtZSA9ICdFeGl0U3RhdHVzJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IGBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7c3RhdHVzfSlgO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzID0gKGNhbGxiYWNrcykgPT4ge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goKGYpID0+IGYoTW9kdWxlKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIHJldHVybiBIRUFQOFtwdHJdO1xuICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgcmV0dXJuIEhFQVA4W3B0cl07XG4gICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgcmV0dXJuIEhFQVAxNltwdHIgPj4gMV07XG4gICAgICAgIGNhc2UgJ2kzMic6XG4gICAgICAgICAgcmV0dXJuIEhFQVAzMltwdHIgPj4gMl07XG4gICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgcmV0dXJuIEhFQVA2NFtwdHIgPj4gM107XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICByZXR1cm4gSEVBUEYzMltwdHIgPj4gMl07XG4gICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgcmV0dXJuIEhFQVBGNjRbcHRyID4+IDNdO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZXR1cm4gSEVBUFUzMltwdHIgPj4gMl07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYWJvcnQoYGludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jykge1xuICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpMSc6XG4gICAgICAgICAgSEVBUDhbcHRyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgSEVBUDhbcHRyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpMTYnOlxuICAgICAgICAgIEhFQVAxNltwdHIgPj4gMV0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICBIRUFQMzJbcHRyID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgSEVBUDY0W3B0ciA+PiAzXSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICBIRUFQRjMyW3B0ciA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIEhFQVBGNjRbcHRyID4+IDNdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIEhFQVBVMzJbcHRyID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYWJvcnQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhY2tSZXN0b3JlID0gKHZhbCkgPT4gX19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUodmFsKTtcblxuICAgIHZhciBzdGFja1NhdmUgPSAoKSA9PiBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCgpO1xuXG4gICAgdmFyIFBBVEggPSB7XG4gICAgICBpc0FiczogKHBhdGgpID0+IHBhdGguY2hhckF0KDApID09PSAnLycsXG4gICAgICBzcGxpdFBhdGg6IChmaWxlbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3BsaXRQYXRoUmUgPVxuICAgICAgICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xuICAgICAgICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplQXJyYXk6IChwYXJ0cywgYWxsb3dBYm92ZVJvb3QpID0+IHtcbiAgICAgICAgdmFyIHVwID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgZm9yICg7IHVwOyB1cC0tKSB7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCksXG4gICAgICAgICAgdHJhaWxpbmdTbGFzaCA9IHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nO1xuXG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxuICAgICAgICAgIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCksXG4gICAgICAgICAgIWlzQWJzb2x1dGUsXG4gICAgICAgICkuam9pbignLycpO1xuICAgICAgICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICBwYXRoID0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xuICAgICAgfSxcbiAgICAgIGRpcm5hbWU6IChwYXRoKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSxcbiAgICAgICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgICAgIGRpciA9IHJlc3VsdFsxXTtcbiAgICAgICAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCArIGRpcjtcbiAgICAgIH0sXG4gICAgICBiYXNlbmFtZTogKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICBpZiAobGFzdFNsYXNoID09PSAtMSkgcmV0dXJuIHBhdGg7XG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cihsYXN0U2xhc2ggKyAxKTtcbiAgICAgIH0sXG4gICAgICBqb2luOiAoLi4ucGF0aHMpID0+IFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oJy8nKSksXG4gICAgICBqb2luMjogKGwsIHIpID0+IFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKSxcbiAgICB9O1xuXG4gICAgdmFyIGluaXRSYW5kb21GaWxsID0gKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG9bJ2dldFJhbmRvbVZhbHVlcyddID09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gKHZpZXcpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldyk7XG4gICAgICB9IGVsc2UgYWJvcnQoJ2luaXRSYW5kb21EZXZpY2UnKTtcbiAgICB9O1xuICAgIHZhciByYW5kb21GaWxsID0gKHZpZXcpID0+IHtcbiAgICAgIHJldHVybiAocmFuZG9tRmlsbCA9IGluaXRSYW5kb21GaWxsKCkpKHZpZXcpO1xuICAgIH07XG5cbiAgICB2YXIgUEFUSF9GUyA9IHtcbiAgICAgIHJlc29sdmU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgICAgIHZhciBwYXRoID0gaSA+PSAwID8gYXJnc1tpXSA6IEZTLmN3ZCgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkoXG4gICAgICAgICAgcmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLFxuICAgICAgICAgICFyZXNvbHZlZEFic29sdXRlLFxuICAgICAgICApLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuIChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoIHx8ICcuJztcbiAgICAgIH0sXG4gICAgICByZWxhdGl2ZTogKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGZyb20gPSBQQVRIX0ZTLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICAgICAgICB0byA9IFBBVEhfRlMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuICAgICAgICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICB2YXIgVVRGOERlY29kZXIgPVxuICAgICAgdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgVVRGOEFycmF5VG9TdHJpbmcgPSAoaGVhcE9yQXJyYXksIGlkeCA9IDAsIG1heEJ5dGVzVG9SZWFkID0gTmFOKSA9PiB7XG4gICAgICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gICAgICB2YXIgZW5kUHRyID0gaWR4O1xuXG4gICAgICB3aGlsZSAoaGVhcE9yQXJyYXlbZW5kUHRyXSAmJiAhKGVuZFB0ciA+PSBlbmRJZHgpKSArK2VuZFB0cjtcblxuICAgICAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICAgICAgICBpZiAoISh1MCAmIDB4ODApKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhlMCkgPT0gMHhjMCkge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgodTAgJiAzMSkgPDwgNikgfCB1MSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICAgIGlmICgodTAgJiAweGYwKSA9PSAweGUwKSB7XG4gICAgICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHUwID1cbiAgICAgICAgICAgICgodTAgJiA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKHUxIDw8IDEyKSB8XG4gICAgICAgICAgICAodTIgPDwgNikgfFxuICAgICAgICAgICAgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgMHhkODAwIHwgKGNoID4+IDEwKSxcbiAgICAgICAgICAgIDB4ZGMwMCB8IChjaCAmIDB4M2ZmKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICB2YXIgRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIgPSBbXTtcblxuICAgIHZhciBsZW5ndGhCeXRlc1VURjggPSAoc3RyKSA9PiB7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDB4N2YpIHtcbiAgICAgICAgICBsZW4rKztcbiAgICAgICAgfSBlbHNlIGlmIChjIDw9IDB4N2ZmKSB7XG4gICAgICAgICAgbGVuICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICBsZW4gKz0gNDtcbiAgICAgICAgICArK2k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuICs9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfTtcblxuICAgIHZhciBzdHJpbmdUb1VURjhBcnJheSA9IChzdHIsIGhlYXAsIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgICBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG5cbiAgICAgIHZhciBzdGFydElkeCA9IG91dElkeDtcbiAgICAgIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKHUgPj0gMHhkODAwICYmIHUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgdmFyIHUxID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgICB1ID0gKDB4MTAwMDAgKyAoKHUgJiAweDNmZikgPDwgMTApKSB8ICh1MSAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSA8PSAweDdmKSB7XG4gICAgICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gdTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N2ZmKSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4YzAgfCAodSA+PiA2KTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4ZmZmZikge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweGUwIHwgKHUgPj4gMTIpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhmMCB8ICh1ID4+IDE4KTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gMTIpICYgNjMpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoZWFwW291dElkeF0gPSAwO1xuICAgICAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkgKyAxO1xuICAgICAgdmFyIHU4YXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShcbiAgICAgICAgc3RyaW5neSxcbiAgICAgICAgdThhcnJheSxcbiAgICAgICAgMCxcbiAgICAgICAgdThhcnJheS5sZW5ndGgsXG4gICAgICApO1xuICAgICAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcbiAgICAgIHJldHVybiB1OGFycmF5O1xuICAgIH1cbiAgICB2YXIgRlNfc3RkaW5fZ2V0Q2hhciA9ICgpID0+IHtcbiAgICAgIGlmICghRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpO1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlciA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZTX3N0ZGluX2dldENoYXJfYnVmZmVyLnNoaWZ0KCk7XG4gICAgfTtcbiAgICB2YXIgVFRZID0ge1xuICAgICAgdHR5czogW10sXG4gICAgICBpbml0KCkge30sXG4gICAgICBzaHV0ZG93bigpIHt9LFxuICAgICAgcmVnaXN0ZXIoZGV2LCBvcHMpIHtcbiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9O1xuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIFRUWS5zdHJlYW1fb3BzKTtcbiAgICAgIH0sXG4gICAgICBzdHJlYW1fb3BzOiB7XG4gICAgICAgIG9wZW4oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xuICAgICAgICAgIGlmICghdHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS50dHkgPSB0dHk7XG4gICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpO1xuICAgICAgICB9LFxuICAgICAgICBmc3luYyhzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICBieXRlc1JlYWQrKztcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLnB1dF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS50dHkub3BzLnB1dF9jaGFyKHN0cmVhbS50dHksIGJ1ZmZlcltvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0X3R0eV9vcHM6IHtcbiAgICAgICAgZ2V0X2NoYXIodHR5KSB7XG4gICAgICAgICAgcmV0dXJuIEZTX3N0ZGluX2dldENoYXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHV0X2NoYXIodHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmc3luYyh0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpb2N0bF90Y2dldHModHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNfaWZsYWc6IDI1ODU2LFxuICAgICAgICAgICAgY19vZmxhZzogNSxcbiAgICAgICAgICAgIGNfY2ZsYWc6IDE5MSxcbiAgICAgICAgICAgIGNfbGZsYWc6IDM1Mzg3LFxuICAgICAgICAgICAgY19jYzogW1xuICAgICAgICAgICAgICAweDAzLCAweDFjLCAweDdmLCAweDE1LCAweDA0LCAweDAwLCAweDAxLCAweDAwLCAweDExLCAweDEzLCAweDFhLFxuICAgICAgICAgICAgICAweDAwLCAweDEyLCAweDBmLCAweDE3LCAweDE2LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpb2N0bF90Y3NldHModHR5LCBvcHRpb25hbF9hY3Rpb25zLCBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGlvY3RsX3Rpb2Nnd2luc3oodHR5KSB7XG4gICAgICAgICAgcmV0dXJuIFsyNCwgODBdO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRfdHR5MV9vcHM6IHtcbiAgICAgICAgcHV0X2NoYXIodHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmc3luYyh0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIHplcm9NZW1vcnkgPSAoYWRkcmVzcywgc2l6ZSkgPT4ge1xuICAgICAgSEVBUFU4LmZpbGwoMCwgYWRkcmVzcywgYWRkcmVzcyArIHNpemUpO1xuICAgIH07XG5cbiAgICB2YXIgYWxpZ25NZW1vcnkgPSAoc2l6ZSwgYWxpZ25tZW50KSA9PiB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50O1xuICAgIH07XG4gICAgdmFyIG1tYXBBbGxvYyA9IChzaXplKSA9PiB7XG4gICAgICBzaXplID0gYWxpZ25NZW1vcnkoc2l6ZSwgNjU1MzYpO1xuICAgICAgdmFyIHB0ciA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24oNjU1MzYsIHNpemUpO1xuICAgICAgaWYgKHB0cikgemVyb01lbW9yeShwdHIsIHNpemUpO1xuICAgICAgcmV0dXJuIHB0cjtcbiAgICB9O1xuICAgIHZhciBNRU1GUyA9IHtcbiAgICAgIG9wc190YWJsZTogbnVsbCxcbiAgICAgIG1vdW50KG1vdW50KSB7XG4gICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsICcvJywgMTYzODQgfCA1MTEsIDApO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBNRU1GUy5vcHNfdGFibGUgfHw9IHtcbiAgICAgICAgICBkaXI6IHtcbiAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsXG4gICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgcmVuYW1lOiBNRU1GUy5ub2RlX29wcy5yZW5hbWUsXG4gICAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLFxuICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgIHJlYWRkaXI6IE1FTUZTLm5vZGVfb3BzLnJlYWRkaXIsXG4gICAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsXG4gICAgICAgICAgICAgIHdyaXRlOiBNRU1GUy5zdHJlYW1fb3BzLndyaXRlLFxuICAgICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxcbiAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLFxuICAgICAgICAgICAgICBtc3luYzogTUVNRlMuc3RyZWFtX29wcy5tc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW5rOiB7XG4gICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgIHJlYWRsaW5rOiBNRU1GUy5ub2RlX29wcy5yZWFkbGluayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJlYW06IHt9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hyZGV2OiB7XG4gICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiBGUy5jaHJkZXZfc3RyZWFtX29wcyxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUuc3RyZWFtO1xuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDtcblxuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LmNvbnRlbnRzW25hbWVdID0gbm9kZTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gbm9kZS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICAgICAgZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyk7XG4gICAgICB9LFxuICAgICAgZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgbmV3Q2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIHByZXZDYXBhY2l0eSA9IG5vZGUuY29udGVudHMgPyBub2RlLmNvbnRlbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgPj0gbmV3Q2FwYWNpdHkpIHJldHVybjtcblxuICAgICAgICB2YXIgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID0gMTAyNCAqIDEwMjQ7XG4gICAgICAgIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgoXG4gICAgICAgICAgbmV3Q2FwYWNpdHksXG4gICAgICAgICAgKHByZXZDYXBhY2l0eSAqXG4gICAgICAgICAgICAocHJldkNhcGFjaXR5IDwgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID8gMi4wIDogMS4xMjUpKSA+Pj5cbiAgICAgICAgICAgIDAsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgIT0gMCkgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgMjU2KTtcbiAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTtcbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMClcbiAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcyksIDApO1xuICAgICAgfSxcbiAgICAgIHJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID09IG5ld1NpemUpIHJldHVybjtcbiAgICAgICAgaWYgKG5ld1NpemUgPT0gMCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTtcbiAgICAgICAgICBpZiAob2xkQ29udGVudHMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KFxuICAgICAgICAgICAgICBvbGRDb250ZW50cy5zdWJhcnJheSgwLCBNYXRoLm1pbihuZXdTaXplLCBub2RlLnVzZWRCeXRlcykpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm9kZV9vcHM6IHtcbiAgICAgICAgZ2V0YXR0cihub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcblxuICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcbiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7XG4gICAgICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xuICAgICAgICAgIGF0dHIuZ2lkID0gMDtcbiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG5cbiAgICAgICAgICBhdHRyLmJsa3NpemUgPSA0MDk2O1xuICAgICAgICAgIGF0dHIuYmxvY2tzID0gTWF0aC5jZWlsKGF0dHIuc2l6ZSAvIGF0dHIuYmxrc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldGF0dHIobm9kZSwgYXR0cikge1xuICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLCBhdHRyLnNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9va3VwKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIHRocm93IEZTLmdlbmVyaWNFcnJvcnNbNDRdO1xuICAgICAgICB9LFxuICAgICAgICBta25vZChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSkge1xuICAgICAgICAgIGlmIChGUy5pc0RpcihvbGRfbm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICBpZiAobmV3X25vZGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lO1xuICAgICAgICAgIG5ld19kaXIuY29udGVudHNbbmV3X25hbWVdID0gb2xkX25vZGU7XG4gICAgICAgICAgbmV3X2Rpci50aW1lc3RhbXAgPSBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wO1xuICAgICAgICB9LFxuICAgICAgICB1bmxpbmsocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXIocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRkaXIobm9kZSkge1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gWycuJywgJy4uJ107XG4gICAgICAgICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG5vZGUuY29udGVudHMpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmV3bmFtZSwgNTExIHwgNDA5NjAsIDApO1xuICAgICAgICAgIG5vZGUubGluayA9IG9sZHBhdGg7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRsaW5rKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICByZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHN0cmVhbS5ub2RlLnVzZWRCeXRlcyAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgIGlmIChzaXplID4gOCAmJiBjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgYnVmZmVyLnNldChjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKSwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlciA9PT0gSEVBUDguYnVmZmVyKSB7XG4gICAgICAgICAgICBjYW5Pd24gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdHJlYW0ubm9kZTtcbiAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICBpZiAoYnVmZmVyLnN1YmFycmF5ICYmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSkge1xuICAgICAgICAgICAgaWYgKGNhbk93bikge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudXNlZEJ5dGVzID09PSAwICYmIHBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gKyBsZW5ndGggPD0gbm9kZS51c2VkQnl0ZXMpIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXG4gICAgICAgICAgICAgICAgYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgYnVmZmVyLnN1YmFycmF5KSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChcbiAgICAgICAgICAgICAgYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChub2RlLnVzZWRCeXRlcywgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBhbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgc3RyZWFtLm5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMsXG4gICAgICAgICAgICBvZmZzZXQgKyBsZW5ndGgsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHB0cjtcbiAgICAgICAgICB2YXIgYWxsb2NhdGVkO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cyAmJiBjb250ZW50cy5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgYWxsb2NhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBwdHIgPSBjb250ZW50cy5ieXRlT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCB8fCBwb3NpdGlvbiArIGxlbmd0aCA8IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICsgbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSEVBUDguc2V0KGNvbnRlbnRzLCBwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwdHIsIGFsbG9jYXRlZCB9O1xuICAgICAgICB9LFxuICAgICAgICBtc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykge1xuICAgICAgICAgIE1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIDAsIGxlbmd0aCwgb2Zmc2V0LCBmYWxzZSk7XG5cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBhc3luY0xvYWQgPSAodXJsLCBvbmxvYWQsIG9uZXJyb3IsIG5vUnVuRGVwKSA9PiB7XG4gICAgICB2YXIgZGVwID0gIW5vUnVuRGVwID8gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShgYWwgJHt1cmx9YCkgOiAnJztcbiAgICAgIHJlYWRBc3luYyh1cmwpLnRoZW4oXG4gICAgICAgIChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICAgIG9ubG9hZChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgIGlmIChkZXApIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGBMb2FkaW5nIGRhdGEgZmlsZSBcIiR7dXJsfVwiIGZhaWxlZC5gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBpZiAoZGVwKSBhZGRSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgfTtcblxuICAgIHZhciBGU19jcmVhdGVEYXRhRmlsZSA9IChcbiAgICAgIHBhcmVudCxcbiAgICAgIG5hbWUsXG4gICAgICBmaWxlRGF0YSxcbiAgICAgIGNhblJlYWQsXG4gICAgICBjYW5Xcml0ZSxcbiAgICAgIGNhbk93bixcbiAgICApID0+IHtcbiAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCwgbmFtZSwgZmlsZURhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgIH07XG5cbiAgICB2YXIgcHJlbG9hZFBsdWdpbnMgPSBNb2R1bGVbJ3ByZWxvYWRQbHVnaW5zJ10gfHwgW107XG4gICAgdmFyIEZTX2hhbmRsZWRCeVByZWxvYWRQbHVnaW4gPSAoYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCBvbmVycm9yKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIEJyb3dzZXIgIT0gJ3VuZGVmaW5lZCcpIEJyb3dzZXIuaW5pdCgpO1xuXG4gICAgICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgcHJlbG9hZFBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgIGlmIChoYW5kbGVkKSByZXR1cm47XG4gICAgICAgIGlmIChwbHVnaW5bJ2NhbkhhbmRsZSddKGZ1bGxuYW1lKSkge1xuICAgICAgICAgIHBsdWdpblsnaGFuZGxlJ10oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCBvbmVycm9yKTtcbiAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9O1xuICAgIHZhciBGU19jcmVhdGVQcmVsb2FkZWRGaWxlID0gKFxuICAgICAgcGFyZW50LFxuICAgICAgbmFtZSxcbiAgICAgIHVybCxcbiAgICAgIGNhblJlYWQsXG4gICAgICBjYW5Xcml0ZSxcbiAgICAgIG9ubG9hZCxcbiAgICAgIG9uZXJyb3IsXG4gICAgICBkb250Q3JlYXRlRmlsZSxcbiAgICAgIGNhbk93bixcbiAgICAgIHByZUZpbmlzaCxcbiAgICApID0+IHtcbiAgICAgIHZhciBmdWxsbmFtZSA9IG5hbWUgPyBQQVRIX0ZTLnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpKSA6IHBhcmVudDtcbiAgICAgIHZhciBkZXAgPSBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGBjcCAke2Z1bGxuYW1lfWApO1xuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaChieXRlQXJyYXkpIHtcbiAgICAgICAgICBwcmVGaW5pc2g/LigpO1xuICAgICAgICAgIGlmICghZG9udENyZWF0ZUZpbGUpIHtcbiAgICAgICAgICAgIEZTX2NyZWF0ZURhdGFGaWxlKFxuICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGJ5dGVBcnJheSxcbiAgICAgICAgICAgICAgY2FuUmVhZCxcbiAgICAgICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgICAgIGNhbk93bixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ubG9hZD8uKCk7XG4gICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgKCkgPT4ge1xuICAgICAgICAgICAgb25lcnJvcj8uKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXN5bmNMb2FkKHVybCwgcHJvY2Vzc0RhdGEsIG9uZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0RhdGEodXJsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEZTX21vZGVTdHJpbmdUb0ZsYWdzID0gKHN0cikgPT4ge1xuICAgICAgdmFyIGZsYWdNb2RlcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgJ3IrJzogMixcbiAgICAgICAgdzogNTEyIHwgNjQgfCAxLFxuICAgICAgICAndysnOiA1MTIgfCA2NCB8IDIsXG4gICAgICAgIGE6IDEwMjQgfCA2NCB8IDEsXG4gICAgICAgICdhKyc6IDEwMjQgfCA2NCB8IDIsXG4gICAgICB9O1xuICAgICAgdmFyIGZsYWdzID0gZmxhZ01vZGVzW3N0cl07XG4gICAgICBpZiAodHlwZW9mIGZsYWdzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJHtzdHJ9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfTtcblxuICAgIHZhciBGU19nZXRNb2RlID0gKGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICB2YXIgbW9kZSA9IDA7XG4gICAgICBpZiAoY2FuUmVhZCkgbW9kZSB8PSAyOTIgfCA3MztcbiAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9O1xuXG4gICAgdmFyIEZTID0ge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIG1vdW50czogW10sXG4gICAgICBkZXZpY2VzOiB7fSxcbiAgICAgIHN0cmVhbXM6IFtdLFxuICAgICAgbmV4dElub2RlOiAxLFxuICAgICAgbmFtZVRhYmxlOiBudWxsLFxuICAgICAgY3VycmVudFBhdGg6ICcvJyxcbiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGlnbm9yZVBlcm1pc3Npb25zOiB0cnVlLFxuICAgICAgRXJybm9FcnJvcjogY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3RvcihlcnJubykge1xuICAgICAgICAgIHRoaXMubmFtZSA9ICdFcnJub0Vycm9yJztcbiAgICAgICAgICB0aGlzLmVycm5vID0gZXJybm87XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmljRXJyb3JzOiB7fSxcbiAgICAgIGZpbGVzeXN0ZW1zOiBudWxsLFxuICAgICAgc3luY0ZTUmVxdWVzdHM6IDAsXG4gICAgICByZWFkRmlsZXM6IHt9LFxuICAgICAgRlNTdHJlYW06IGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5zaGFyZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgb2JqZWN0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IG9iamVjdCh2YWwpIHtcbiAgICAgICAgICB0aGlzLm5vZGUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzUmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNXcml0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNBcHBlbmQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxMDI0O1xuICAgICAgICB9XG4gICAgICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWQuZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGZsYWdzKHZhbCkge1xuICAgICAgICAgIHRoaXMuc2hhcmVkLmZsYWdzID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWQucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHBvc2l0aW9uKHZhbCkge1xuICAgICAgICAgIHRoaXMuc2hhcmVkLnBvc2l0aW9uID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgRlNOb2RlOiBjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikge1xuICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICAgICAgICAgIHRoaXMubW91bnRlZCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pZCA9IEZTLm5leHRJbm9kZSsrO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLm5vZGVfb3BzID0ge307XG4gICAgICAgICAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gICAgICAgICAgdGhpcy5yZGV2ID0gcmRldjtcbiAgICAgICAgICB0aGlzLnJlYWRNb2RlID0gMjkyIHwgNzM7XG4gICAgICAgICAgdGhpcy53cml0ZU1vZGUgPSAxNDY7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB0aGlzLnJlYWRNb2RlKSA9PT0gdGhpcy5yZWFkTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgcmVhZCh2YWwpIHtcbiAgICAgICAgICB2YWwgPyAodGhpcy5tb2RlIHw9IHRoaXMucmVhZE1vZGUpIDogKHRoaXMubW9kZSAmPSB+dGhpcy5yZWFkTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHdyaXRlKCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgdGhpcy53cml0ZU1vZGUpID09PSB0aGlzLndyaXRlTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgd3JpdGUodmFsKSB7XG4gICAgICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSB0aGlzLndyaXRlTW9kZSkgOiAodGhpcy5tb2RlICY9IH50aGlzLndyaXRlTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzRm9sZGVyKCkge1xuICAgICAgICAgIHJldHVybiBGUy5pc0Rpcih0aGlzLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc0RldmljZSgpIHtcbiAgICAgICAgICByZXR1cm4gRlMuaXNDaHJkZXYodGhpcy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxvb2t1cFBhdGgocGF0aCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHBhdGggPSBQQVRIX0ZTLnJlc29sdmUocGF0aCk7XG5cbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4geyBwYXRoOiAnJywgbm9kZTogbnVsbCB9O1xuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBmb2xsb3dfbW91bnQ6IHRydWUsXG4gICAgICAgICAgcmVjdXJzZV9jb3VudDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuXG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKTtcblxuICAgICAgICB2YXIgY3VycmVudCA9IEZTLnJvb3Q7XG4gICAgICAgIHZhciBjdXJyZW50X3BhdGggPSAnLyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpc2xhc3QgPSBpID09PSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpc2xhc3QgJiYgb3B0cy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnQgPSBGUy5sb29rdXBOb2RlKGN1cnJlbnQsIHBhcnRzW2ldKTtcbiAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILmpvaW4yKGN1cnJlbnRfcGF0aCwgcGFydHNbaV0pO1xuXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFpc2xhc3QgfHwgKGlzbGFzdCAmJiBvcHRzLmZvbGxvd19tb3VudCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubW91bnRlZC5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNsYXN0IHx8IG9wdHMuZm9sbG93KSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5rID0gRlMucmVhZGxpbmsoY3VycmVudF9wYXRoKTtcbiAgICAgICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSF9GUy5yZXNvbHZlKFBBVEguZGlybmFtZShjdXJyZW50X3BhdGgpLCBsaW5rKTtcblxuICAgICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChjdXJyZW50X3BhdGgsIHtcbiAgICAgICAgICAgICAgICByZWN1cnNlX2NvdW50OiBvcHRzLnJlY3Vyc2VfY291bnQgKyAxLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudCsrID4gNDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgICAgIH0sXG4gICAgICBnZXRQYXRoKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSkge1xuICAgICAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudC5tb3VudHBvaW50O1xuICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQ7XG4gICAgICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoIC0gMV0gIT09ICcvJ1xuICAgICAgICAgICAgICA/IGAke21vdW50fS8ke3BhdGh9YFxuICAgICAgICAgICAgICA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBgJHtub2RlLm5hbWV9LyR7cGF0aH1gIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc2hOYW1lKHBhcmVudGlkLCBuYW1lKSB7XG4gICAgICAgIHZhciBoYXNoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWUuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHBhcmVudGlkICsgaGFzaCkgPj4+IDApICUgRlMubmFtZVRhYmxlLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBoYXNoQWRkTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlO1xuICAgICAgfSxcbiAgICAgIGhhc2hSZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKEZTLm5hbWVUYWJsZVtoYXNoXSA9PT0gbm9kZSkge1xuICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5uYW1lX25leHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5uYW1lX25leHQgPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uYW1lX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9va3VwTm9kZShwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlMb29rdXAocGFyZW50KTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7XG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBGUy5uYW1lVGFibGVbaGFzaF07IG5vZGU7IG5vZGUgPSBub2RlLm5hbWVfbmV4dCkge1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuXG4gICAgICAgIEZTLmhhc2hBZGROb2RlKG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lOb2RlKG5vZGUpIHtcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7XG4gICAgICB9LFxuICAgICAgaXNSb290KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IG5vZGUucGFyZW50O1xuICAgICAgfSxcbiAgICAgIGlzTW91bnRwb2ludChub2RlKSB7XG4gICAgICAgIHJldHVybiAhIW5vZGUubW91bnRlZDtcbiAgICAgIH0sXG4gICAgICBpc0ZpbGUobW9kZSkge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDMyNzY4O1xuICAgICAgfSxcbiAgICAgIGlzRGlyKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAxNjM4NDtcbiAgICAgIH0sXG4gICAgICBpc0xpbmsobW9kZSkge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYwO1xuICAgICAgfSxcbiAgICAgIGlzQ2hyZGV2KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA4MTkyO1xuICAgICAgfSxcbiAgICAgIGlzQmxrZGV2KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAyNDU3NjtcbiAgICAgIH0sXG4gICAgICBpc0ZJRk8obW9kZSkge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTY7XG4gICAgICB9LFxuICAgICAgaXNTb2NrZXQobW9kZSkge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA0OTE1MikgPT09IDQ5MTUyO1xuICAgICAgfSxcbiAgICAgIGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWcpIHtcbiAgICAgICAgdmFyIHBlcm1zID0gWydyJywgJ3cnLCAncncnXVtmbGFnICYgM107XG4gICAgICAgIGlmIChmbGFnICYgNTEyKSB7XG4gICAgICAgICAgcGVybXMgKz0gJ3cnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZXJtcztcbiAgICAgIH0sXG4gICAgICBub2RlUGVybWlzc2lvbnMobm9kZSwgcGVybXMpIHtcbiAgICAgICAgaWYgKEZTLmlnbm9yZVBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVybXMuaW5jbHVkZXMoJ3InKSAmJiAhKG5vZGUubW9kZSAmIDI5MikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygndycpICYmICEobm9kZS5tb2RlICYgMTQ2KSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluY2x1ZGVzKCd4JykgJiYgIShub2RlLm1vZGUgJiA3MykpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBtYXlMb29rdXAoZGlyKSB7XG4gICAgICAgIGlmICghRlMuaXNEaXIoZGlyLm1vZGUpKSByZXR1cm4gNTQ7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBtYXlDcmVhdGUoZGlyLCBuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICB9LFxuICAgICAgbWF5RGVsZXRlKGRpciwgbmFtZSwgaXNkaXIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzZGlyKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkgfHwgRlMuZ2V0UGF0aChub2RlKSA9PT0gRlMuY3dkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgbWF5T3Blbihub2RlLCBmbGFncykge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSAncicgfHwgZmxhZ3MgJiA1MTIpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxcbiAgICAgIE1BWF9PUEVOX0ZEUzogNDA5NixcbiAgICAgIG5leHRmZCgpIHtcbiAgICAgICAgZm9yICh2YXIgZmQgPSAwOyBmZCA8PSBGUy5NQVhfT1BFTl9GRFM7IGZkKyspIHtcbiAgICAgICAgICBpZiAoIUZTLnN0cmVhbXNbZmRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMzKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdHJlYW1DaGVja2VkKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgZ2V0U3RyZWFtOiAoZmQpID0+IEZTLnN0cmVhbXNbZmRdLFxuICAgICAgY3JlYXRlU3RyZWFtKHN0cmVhbSwgZmQgPSAtMSkge1xuICAgICAgICBzdHJlYW0gPSBPYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSgpLCBzdHJlYW0pO1xuICAgICAgICBpZiAoZmQgPT0gLTEpIHtcbiAgICAgICAgICBmZCA9IEZTLm5leHRmZCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5mZCA9IGZkO1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBjbG9zZVN0cmVhbShmZCkge1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgZHVwU3RyZWFtKG9yaWdTdHJlYW0sIGZkID0gLTEpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbShvcmlnU3RyZWFtLCBmZCk7XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzPy5kdXA/LihzdHJlYW0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGNocmRldl9zdHJlYW1fb3BzOiB7XG4gICAgICAgIG9wZW4oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtcblxuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzID0gZGV2aWNlLnN0cmVhbV9vcHM7XG5cbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuPy4oc3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGxzZWVrKCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBtYWpvcjogKGRldikgPT4gZGV2ID4+IDgsXG4gICAgICBtaW5vcjogKGRldikgPT4gZGV2ICYgMHhmZixcbiAgICAgIG1ha2VkZXY6IChtYSwgbWkpID0+IChtYSA8PCA4KSB8IG1pLFxuICAgICAgcmVnaXN0ZXJEZXZpY2UoZGV2LCBvcHMpIHtcbiAgICAgICAgRlMuZGV2aWNlc1tkZXZdID0geyBzdHJlYW1fb3BzOiBvcHMgfTtcbiAgICAgIH0sXG4gICAgICBnZXREZXZpY2U6IChkZXYpID0+IEZTLmRldmljZXNbZGV2XSxcbiAgICAgIGdldE1vdW50cyhtb3VudCkge1xuICAgICAgICB2YXIgbW91bnRzID0gW107XG4gICAgICAgIHZhciBjaGVjayA9IFttb3VudF07XG5cbiAgICAgICAgd2hpbGUgKGNoZWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBtID0gY2hlY2sucG9wKCk7XG5cbiAgICAgICAgICBtb3VudHMucHVzaChtKTtcblxuICAgICAgICAgIGNoZWNrLnB1c2goLi4ubS5tb3VudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdW50cztcbiAgICAgIH0sXG4gICAgICBzeW5jZnMocG9wdWxhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wdWxhdGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrID0gcG9wdWxhdGU7XG4gICAgICAgICAgcG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzKys7XG5cbiAgICAgICAgaWYgKEZTLnN5bmNGU1JlcXVlc3RzID4gMSkge1xuICAgICAgICAgIGVycihcbiAgICAgICAgICAgIGB3YXJuaW5nOiAke0ZTLnN5bmNGU1JlcXVlc3RzfSBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyckNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvQ2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBtb3VudCh0eXBlLCBvcHRzLCBtb3VudHBvaW50KSB7XG4gICAgICAgIHZhciByb290ID0gbW91bnRwb2ludCA9PT0gJy8nO1xuICAgICAgICB2YXIgcHNldWRvID0gIW1vdW50cG9pbnQ7XG4gICAgICAgIHZhciBub2RlO1xuXG4gICAgICAgIGlmIChyb290ICYmIEZTLnJvb3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvb3QgJiYgIXBzZXVkbykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG1vdW50cG9pbnQsIHsgZm9sbG93X21vdW50OiBmYWxzZSB9KTtcblxuICAgICAgICAgIG1vdW50cG9pbnQgPSBsb29rdXAucGF0aDtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG5cbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdW50ID0ge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgb3B0cyxcbiAgICAgICAgICBtb3VudHBvaW50LFxuICAgICAgICAgIG1vdW50czogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdW50Um9vdCA9IHR5cGUubW91bnQobW91bnQpO1xuICAgICAgICBtb3VudFJvb3QubW91bnQgPSBtb3VudDtcbiAgICAgICAgbW91bnQucm9vdCA9IG1vdW50Um9vdDtcblxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIEZTLnJvb3QgPSBtb3VudFJvb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgICAgIG5vZGUubW91bnRlZCA9IG1vdW50O1xuXG4gICAgICAgICAgaWYgKG5vZGUubW91bnQpIHtcbiAgICAgICAgICAgIG5vZGUubW91bnQubW91bnRzLnB1c2gobW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3VudFJvb3Q7XG4gICAgICB9LFxuICAgICAgdW5tb3VudChtb3VudHBvaW50KSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG1vdW50cG9pbnQsIHsgZm9sbG93X21vdW50OiBmYWxzZSB9KTtcblxuICAgICAgICBpZiAoIUZTLmlzTW91bnRwb2ludChsb29rdXAubm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50ZWQ7XG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMobW91bnQpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaCgoaGFzaCkgPT4ge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uYW1lX25leHQ7XG5cbiAgICAgICAgICAgIGlmIChtb3VudHMuaW5jbHVkZXMoY3VycmVudC5tb3VudCkpIHtcbiAgICAgICAgICAgICAgRlMuZGVzdHJveU5vZGUoY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZS5tb3VudGVkID0gbnVsbDtcblxuICAgICAgICB2YXIgaWR4ID0gbm9kZS5tb3VudC5tb3VudHMuaW5kZXhPZihtb3VudCk7XG4gICAgICAgIG5vZGUubW91bnQubW91bnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfSxcbiAgICAgIGxvb2t1cChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBta25vZChwYXRoLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gJy4nIHx8IG5hbWUgPT09ICcuLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ta25vZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGUocGF0aCwgbW9kZSkge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDQzODtcbiAgICAgICAgbW9kZSAmPSA0MDk1O1xuICAgICAgICBtb2RlIHw9IDMyNzY4O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LFxuICAgICAgbWtkaXIocGF0aCwgbW9kZSkge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDUxMTtcbiAgICAgICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgICAgIG1vZGUgfD0gMTYzODQ7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sXG4gICAgICBta2RpclRyZWUocGF0aCwgbW9kZSkge1xuICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZTtcbiAgICAgICAgICBkICs9ICcvJyArIGRpcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmVycm5vICE9IDIwKSB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1rZGV2KHBhdGgsIG1vZGUsIGRldikge1xuICAgICAgICBpZiAodHlwZW9mIGRldiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRldiA9IG1vZGU7XG4gICAgICAgICAgbW9kZSA9IDQzODtcbiAgICAgICAgfVxuICAgICAgICBtb2RlIHw9IDgxOTI7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxcbiAgICAgIHN5bWxpbmsob2xkcGF0aCwgbmV3cGF0aCkge1xuICAgICAgICBpZiAoIVBBVEhfRlMucmVzb2x2ZShvbGRwYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bmFtZSA9IFBBVEguYmFzZW5hbWUobmV3cGF0aCk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmV3bmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKTtcbiAgICAgIH0sXG4gICAgICByZW5hbWUob2xkX3BhdGgsIG5ld19wYXRoKSB7XG4gICAgICAgIHZhciBvbGRfZGlybmFtZSA9IFBBVEguZGlybmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfZGlybmFtZSA9IFBBVEguZGlybmFtZShuZXdfcGF0aCk7XG4gICAgICAgIHZhciBvbGRfbmFtZSA9IFBBVEguYmFzZW5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld19wYXRoKTtcblxuICAgICAgICB2YXIgbG9va3VwLCBvbGRfZGlyLCBuZXdfZGlyO1xuXG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBvbGRfZGlyID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3X3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7XG5cbiAgICAgICAgaWYgKCFvbGRfZGlyIHx8ICFuZXdfZGlyKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG5cbiAgICAgICAgaWYgKG9sZF9kaXIubW91bnQgIT09IG5ld19kaXIubW91bnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3NSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkX25vZGUgPSBGUy5sb29rdXBOb2RlKG9sZF9kaXIsIG9sZF9uYW1lKTtcblxuICAgICAgICB2YXIgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG9sZF9wYXRoLCBuZXdfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShuZXdfcGF0aCwgb2xkX2Rpcm5hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICBpZiAob2xkX25vZGUgPT09IG5ld19ub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzZGlyID0gRlMuaXNEaXIob2xkX25vZGUubW9kZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKG9sZF9kaXIsIG9sZF9uYW1lLCBpc2Rpcik7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJDb2RlID0gbmV3X25vZGVcbiAgICAgICAgICA/IEZTLm1heURlbGV0ZShuZXdfZGlyLCBuZXdfbmFtZSwgaXNkaXIpXG4gICAgICAgICAgOiBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSkgfHxcbiAgICAgICAgICAobmV3X25vZGUgJiYgRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHtcbiAgICAgICAgICBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsICd3Jyk7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSk7XG5cbiAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQgPSBuZXdfZGlyO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBybWRpcihwYXRoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LFxuICAgICAgcmVhZGRpcihwYXRoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMucmVhZGRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5yZWFkZGlyKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHVubGluayhwYXRoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnVubGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5ub2RlX29wcy51bmxpbmsocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LFxuICAgICAgcmVhZGxpbmsocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKFxuICAgICAgICAgIEZTLmdldFBhdGgobGluay5wYXJlbnQpLFxuICAgICAgICAgIGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluayksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc3RhdChwYXRoLCBkb250Rm9sbG93KSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5nZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSk7XG4gICAgICB9LFxuICAgICAgbHN0YXQocGF0aCkge1xuICAgICAgICByZXR1cm4gRlMuc3RhdChwYXRoLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBjaG1vZChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2htb2QocGF0aCwgbW9kZSkge1xuICAgICAgICBGUy5jaG1vZChwYXRoLCBtb2RlLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBmY2htb2QoZmQsIG1vZGUpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7XG4gICAgICB9LFxuICAgICAgY2hvd24ocGF0aCwgdWlkLCBnaWQsIGRvbnRGb2xsb3cpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGxjaG93bihwYXRoLCB1aWQsIGdpZCkge1xuICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmNob3duKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XG4gICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7XG4gICAgICB9LFxuICAgICAgdHJ1bmNhdGUocGF0aCwgbGVuKSB7XG4gICAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCAndycpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgc2l6ZTogbGVuLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZnRydW5jYXRlKGZkLCBsZW4pIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLnRydW5jYXRlKHN0cmVhbS5ub2RlLCBsZW4pO1xuICAgICAgfSxcbiAgICAgIHV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgubWF4KGF0aW1lLCBtdGltZSksXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gdHlwZW9mIGZsYWdzID09ICdzdHJpbmcnID8gRlNfbW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpIDogZmxhZ3M7XG4gICAgICAgIGlmIChmbGFncyAmIDY0KSB7XG4gICAgICAgICAgbW9kZSA9IHR5cGVvZiBtb2RlID09ICd1bmRlZmluZWQnID8gNDM4IDogbW9kZTtcbiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHtcbiAgICAgICAgICAgICAgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZmxhZ3MgJiA2NCkge1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiAxMjgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgICAgICBjcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBmbGFncyAmPSB+NTEyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgNjU1MzYgJiYgIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiA1MTIgJiYgIWNyZWF0ZWQpIHtcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWdzICY9IH4oMTI4IHwgNTEyIHwgMTMxMDcyKTtcblxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBhdGg6IEZTLmdldFBhdGgobm9kZSksXG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgc2Vla2FibGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3RyZWFtX29wczogbm9kZS5zdHJlYW1fb3BzLFxuXG4gICAgICAgICAgdW5nb3R0ZW46IFtdLFxuICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pIHtcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1vZHVsZVsnbG9nUmVhZEZpbGVzJ10gJiYgIShmbGFncyAmIDEpKSB7XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKHN0cmVhbSkge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMpIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGlzQ2xvc2VkKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmZkID09PSBudWxsO1xuICAgICAgfSxcbiAgICAgIGxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICByZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IHN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XG4gICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICB9LFxuICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLnNlZWthYmxlICYmIHN0cmVhbS5mbGFncyAmIDEwMjQpIHtcbiAgICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCAwLCAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNXcml0dGVuID0gc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUoXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIGNhbk93bixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNXcml0dGVuO1xuICAgICAgICByZXR1cm4gYnl0ZXNXcml0dGVuO1xuICAgICAgfSxcbiAgICAgIGFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIG1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHByb3QgJiAyKSAhPT0gMCAmJlxuICAgICAgICAgIChmbGFncyAmIDIpID09PSAwICYmXG4gICAgICAgICAgKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpICE9PSAyXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLm1tYXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncyk7XG4gICAgICB9LFxuICAgICAgbXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tc3luYykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tc3luYyhcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgbW1hcEZsYWdzLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGlvY3RsKHN0cmVhbSwgY21kLCBhcmcpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLCBjbWQsIGFyZyk7XG4gICAgICB9LFxuICAgICAgcmVhZEZpbGUocGF0aCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDA7XG4gICAgICAgIG9wdHMuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nIHx8ICdiaW5hcnknO1xuICAgICAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gJ3V0ZjgnICYmIG9wdHMuZW5jb2RpbmcgIT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVuY29kaW5nIHR5cGUgXCIke29wdHMuZW5jb2Rpbmd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzKTtcbiAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTtcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgIHJldCA9IFVURjhBcnJheVRvU3RyaW5nKGJ1Zik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICByZXQgPSBidWY7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxcbiAgICAgIGN3ZDogKCkgPT4gRlMuY3VycmVudFBhdGgsXG4gICAgICBjaGRpcihwYXRoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICBpZiAobG9va3VwLm5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhsb29rdXAubm9kZSwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jdXJyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpIHtcbiAgICAgICAgRlMubWtkaXIoJy90bXAnKTtcbiAgICAgICAgRlMubWtkaXIoJy9ob21lJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZS93ZWJfdXNlcicpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZURlZmF1bHREZXZpY2VzKCkge1xuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKEZTLm1ha2VkZXYoMSwgMyksIHtcbiAgICAgICAgICByZWFkOiAoKSA9PiAwLFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IGxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L251bGwnLCBGUy5tYWtlZGV2KDEsIDMpKTtcblxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG5cbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEwMjQpLFxuICAgICAgICAgIHJhbmRvbUxlZnQgPSAwO1xuICAgICAgICB2YXIgcmFuZG9tQnl0ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAocmFuZG9tTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgcmFuZG9tTGVmdCA9IHJhbmRvbUZpbGwocmFuZG9tQnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmFuZG9tQnVmZmVyWy0tcmFuZG9tTGVmdF07XG4gICAgICAgIH07XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdyYW5kb20nLCByYW5kb21CeXRlKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3VyYW5kb20nLCByYW5kb21CeXRlKTtcblxuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0nKTtcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htL3RtcCcpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpIHtcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jJyk7XG4gICAgICAgIHZhciBwcm9jX3NlbGYgPSBGUy5ta2RpcignL3Byb2Mvc2VsZicpO1xuICAgICAgICBGUy5ta2RpcignL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgICBGUy5tb3VudChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb3VudCgpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHByb2Nfc2VsZiwgJ2ZkJywgMTYzODQgfCA1MTEsIDczKTtcbiAgICAgICAgICAgICAgbm9kZS5ub2RlX29wcyA9IHtcbiAgICAgICAgICAgICAgICBsb29rdXAocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmQgPSArbmFtZTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbW91bnQ6IHsgbW91bnRwb2ludDogJ2Zha2UnIH0sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVfb3BzOiB7IHJlYWRsaW5rOiAoKSA9PiBzdHJlYW0ucGF0aCB9LFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHt9LFxuICAgICAgICAgICcvcHJvYy9zZWxmL2ZkJyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTdGFuZGFyZFN0cmVhbXMoaW5wdXQsIG91dHB1dCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGluJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZG91dCcsIG51bGwsIG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRlMuc3ltbGluaygnL2Rldi90dHknLCAnL2Rldi9zdGRvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkZXJyJywgbnVsbCwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbignL2Rldi9zdGRpbicsIDApO1xuICAgICAgICB2YXIgc3Rkb3V0ID0gRlMub3BlbignL2Rldi9zdGRvdXQnLCAxKTtcbiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgMSk7XG4gICAgICB9LFxuICAgICAgc3RhdGljSW5pdCgpIHtcbiAgICAgICAgWzQ0XS5mb3JFYWNoKChjb2RlKSA9PiB7XG4gICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXSA9IG5ldyBGUy5FcnJub0Vycm9yKGNvZGUpO1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0uc3RhY2sgPSAnPGdlbmVyaWMgZXJyb3IsIG5vIHN0YWNrPic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEZTLm5hbWVUYWJsZSA9IG5ldyBBcnJheSg0MDk2KTtcblxuICAgICAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7XG5cbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzKCk7XG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7XG4gICAgICAgIEZTLmNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpO1xuXG4gICAgICAgIEZTLmZpbGVzeXN0ZW1zID0ge1xuICAgICAgICAgIE1FTUZTOiBNRU1GUyxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBpbml0KGlucHV0LCBvdXRwdXQsIGVycm9yKSB7XG4gICAgICAgIEZTLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICBpbnB1dCA/Pz0gTW9kdWxlWydzdGRpbiddO1xuICAgICAgICBvdXRwdXQgPz89IE1vZHVsZVsnc3Rkb3V0J107XG4gICAgICAgIGVycm9yID8/PSBNb2R1bGVbJ3N0ZGVyciddO1xuXG4gICAgICAgIEZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcyhpbnB1dCwgb3V0cHV0LCBlcnJvcik7XG4gICAgICB9LFxuICAgICAgcXVpdCgpIHtcbiAgICAgICAgRlMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEZTLnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuc3RyZWFtc1tpXTtcbiAgICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaW5kT2JqZWN0KHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspIHtcbiAgICAgICAgdmFyIHJldCA9IEZTLmFuYWx5emVQYXRoKHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspO1xuICAgICAgICBpZiAoIXJldC5leGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0Lm9iamVjdDtcbiAgICAgIH0sXG4gICAgICBhbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IDAsXG4gICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG51bGwsXG4gICAgICAgICAgcGFyZW50T2JqZWN0OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7XG4gICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUGF0aChwYXJlbnQsIHBhdGgsIGNhblJlYWQsIGNhbldyaXRlKSB7XG4gICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCk7XG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBQQVRILmpvaW4yKHBhcmVudCwgcGFydCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGN1cnJlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgcGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKFxuICAgICAgICAgIHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIG1vZGUgPSBGU19nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pIHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgICBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIocGFyZW50LCBuYW1lKSA6IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IEZTX2dldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVEZXZpY2UocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlNfZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZS5tYWpvciA/Pz0gNjQ7XG4gICAgICAgIHZhciBkZXYgPSBGUy5tYWtlZGV2KEZTLmNyZWF0ZURldmljZS5tYWpvcisrLCAwKTtcblxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIHtcbiAgICAgICAgICBvcGVuKHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZShzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQ/LmJ1ZmZlcj8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG91dHB1dCgxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dChidWZmZXJbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEZTLm1rZGV2KHBhdGgsIG1vZGUsIGRldik7XG4gICAgICB9LFxuICAgICAgZm9yY2VMb2FkRmlsZShvYmopIHtcbiAgICAgICAgaWYgKG9iai5pc0RldmljZSB8fCBvYmouaXNGb2xkZXIgfHwgb2JqLmxpbmsgfHwgb2JqLmNvbnRlbnRzKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0xhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gcmVhZEJpbmFyeShvYmoudXJsKTtcbiAgICAgICAgICAgIG9iai51c2VkQnl0ZXMgPSBvYmouY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVMYXp5RmlsZShwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUpIHtcbiAgICAgICAgY2xhc3MgTGF6eVVpbnQ4QXJyYXkge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGhLbm93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0KGlkeCkge1xuICAgICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoIC0gMSB8fCBpZHggPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBjaHVua051bSA9IChpZHggLyB0aGlzLmNodW5rU2l6ZSkgfCAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGVMZW5ndGgoKSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICEoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArICcuIFN0YXR1czogJyArIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgZGF0YWxlbmd0aCA9IE51bWJlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtbGVuZ3RoJykpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgIHZhciBoYXNCeXRlU2VydmluZyA9XG4gICAgICAgICAgICAgIChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0FjY2VwdC1SYW5nZXMnKSkgJiZcbiAgICAgICAgICAgICAgaGVhZGVyID09PSAnYnl0ZXMnO1xuICAgICAgICAgICAgdmFyIHVzZXNHemlwID1cbiAgICAgICAgICAgICAgKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1FbmNvZGluZycpKSAmJlxuICAgICAgICAgICAgICBoZWFkZXIgPT09ICdnemlwJztcblxuICAgICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0O1xuXG4gICAgICAgICAgICBpZiAoIWhhc0J5dGVTZXJ2aW5nKSBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgZG9YSFIgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGZyb20gPiB0bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCByYW5nZSAoJyArXG4gICAgICAgICAgICAgICAgICAgIGZyb20gK1xuICAgICAgICAgICAgICAgICAgICAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgdG8gK1xuICAgICAgICAgICAgICAgICAgICAnKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodG8gPiBkYXRhbGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnb25seSAnICsgZGF0YWxlbmd0aCArICcgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIScsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFsZW5ndGggIT09IGNodW5rU2l6ZSlcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGZyb20gKyAnLScgKyB0byk7XG5cbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArICcuIFN0YXR1czogJyArIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSB8fCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0IHx8ICcnLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpcztcbiAgICAgICAgICAgIGxhenlBcnJheS5zZXREYXRhR2V0dGVyKChjaHVua051bSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBjaHVua051bSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSArIDEpICogY2h1bmtTaXplIC0gMTtcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBkYXRhbGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9IGRvWEhSKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb1hIUiBmYWlsZWQhJyk7XG4gICAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodXNlc0d6aXAgfHwgIWRhdGFsZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgIGRhdGFsZW5ndGggPSB0aGlzLmdldHRlcigwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICAgIG91dChcbiAgICAgICAgICAgICAgICAnTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gZGF0YWxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCBjaHVua1NpemUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpXG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIGNvbnRlbnRzOiBsYXp5QXJyYXkgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCB1cmw6IHVybCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbnRlbnRzKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IHByb3BlcnRpZXMuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy51cmwpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICBub2RlLnVybCA9IHByb3BlcnRpZXMudXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwge1xuICAgICAgICAgIHVzZWRCeXRlczoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHN0cmVhbV9vcHMgPSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnN0cmVhbV9vcHMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIHZhciBmbiA9IG5vZGUuc3RyZWFtX29wc1trZXldO1xuICAgICAgICAgIHN0cmVhbV9vcHNba2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB3cml0ZUNodW5rcyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGNvbnRlbnRzLmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihjb250ZW50cy5sZW5ndGggLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBpZiAoY29udGVudHMuc2xpY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzLmdldChwb3NpdGlvbiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbV9vcHMucmVhZCA9IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZWFtX29wcy5tbWFwID0gKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHZhciBwdHIgPSBtbWFwQWxsb2MobGVuZ3RoKTtcbiAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3cml0ZUNodW5rcyhzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgIHJldHVybiB7IHB0ciwgYWxsb2NhdGVkOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IHN0cmVhbV9vcHM7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIFVURjhUb1N0cmluZyA9IChwdHIsIG1heEJ5dGVzVG9SZWFkKSA9PiB7XG4gICAgICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xuICAgIH07XG4gICAgdmFyIFNZU0NBTExTID0ge1xuICAgICAgREVGQVVMVF9QT0xMTUFTSzogNSxcbiAgICAgIGNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgIGlmIChQQVRILmlzQWJzKHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlyO1xuICAgICAgICBpZiAoZGlyZmQgPT09IC0xMDApIHtcbiAgICAgICAgICBkaXIgPSBGUy5jd2QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGlyc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGRpcmZkKTtcbiAgICAgICAgICBkaXIgPSBkaXJzdHJlYW0ucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIGlmICghYWxsb3dFbXB0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVRILmpvaW4yKGRpciwgcGF0aCk7XG4gICAgICB9LFxuICAgICAgZG9TdGF0KGZ1bmMsIHBhdGgsIGJ1Zikge1xuICAgICAgICB2YXIgc3RhdCA9IGZ1bmMocGF0aCk7XG4gICAgICAgIEhFQVAzMltidWYgPj4gMl0gPSBzdGF0LmRldjtcbiAgICAgICAgSEVBUDMyWyhidWYgKyA0KSA+PiAyXSA9IHN0YXQubW9kZTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgOCkgPj4gMl0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDEyKSA+PiAyXSA9IHN0YXQudWlkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDE2KSA+PiAyXSA9IHN0YXQuZ2lkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDIwKSA+PiAyXSA9IHN0YXQucmRldjtcbiAgICAgICAgSEVBUDY0WyhidWYgKyAyNCkgPj4gM10gPSBCaWdJbnQoc3RhdC5zaXplKTtcbiAgICAgICAgSEVBUDMyWyhidWYgKyAzMikgPj4gMl0gPSA0MDk2O1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDM2KSA+PiAyXSA9IHN0YXQuYmxvY2tzO1xuICAgICAgICB2YXIgYXRpbWUgPSBzdGF0LmF0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIG10aW1lID0gc3RhdC5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xuICAgICAgICBIRUFQNjRbKGJ1ZiArIDQwKSA+PiAzXSA9IEJpZ0ludChNYXRoLmZsb29yKGF0aW1lIC8gMTAwMCkpO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyA0OCkgPj4gMl0gPSAoYXRpbWUgJSAxMDAwKSAqIDEwMDAgKiAxMDAwO1xuICAgICAgICBIRUFQNjRbKGJ1ZiArIDU2KSA+PiAzXSA9IEJpZ0ludChNYXRoLmZsb29yKG10aW1lIC8gMTAwMCkpO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyA2NCkgPj4gMl0gPSAobXRpbWUgJSAxMDAwKSAqIDEwMDAgKiAxMDAwO1xuICAgICAgICBIRUFQNjRbKGJ1ZiArIDcyKSA+PiAzXSA9IEJpZ0ludChNYXRoLmZsb29yKGN0aW1lIC8gMTAwMCkpO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyA4MCkgPj4gMl0gPSAoY3RpbWUgJSAxMDAwKSAqIDEwMDAgKiAxMDAwO1xuICAgICAgICBIRUFQNjRbKGJ1ZiArIDg4KSA+PiAzXSA9IEJpZ0ludChzdGF0Lmlubyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIGRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBIRUFQVTguc2xpY2UoYWRkciwgYWRkciArIGxlbik7XG4gICAgICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICAgICAgfSxcbiAgICAgIGdldFN0cmVhbUZyb21GRChmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgdmFyYXJnczogdW5kZWZpbmVkLFxuICAgICAgZ2V0U3RyKHB0cikge1xuICAgICAgICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9jaG1vZChwYXRoLCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBGUy5jaG1vZChwYXRoLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCwgcGF0aCwgYW1vZGUsIGZsYWdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICBpZiAoYW1vZGUgJiB+Nykge1xuICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHJldHVybiAtNDQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBlcm1zID0gJyc7XG4gICAgICAgIGlmIChhbW9kZSAmIDQpIHBlcm1zICs9ICdyJztcbiAgICAgICAgaWYgKGFtb2RlICYgMikgcGVybXMgKz0gJ3cnO1xuICAgICAgICBpZiAoYW1vZGUgJiAxKSBwZXJtcyArPSAneCc7XG4gICAgICAgIGlmIChwZXJtcyAmJiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgcGVybXMpKSB7XG4gICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY2htb2QoZmQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIEZTLmZjaG1vZChmZCwgbW9kZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY2hvd24zMihmZCwgb3duZXIsIGdyb3VwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBGUy5mY2hvd24oZmQsIG93bmVyLCBncm91cCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3lzY2FsbEdldFZhcmFyZ0koKSB7XG4gICAgICB2YXIgcmV0ID0gSEVBUDMyWytTWVNDQUxMUy52YXJhcmdzID4+IDJdO1xuICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdmFyIHN5c2NhbGxHZXRWYXJhcmdQID0gc3lzY2FsbEdldFZhcmFyZ0k7XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBzeXNjYWxsR2V0VmFyYXJnSSgpO1xuICAgICAgICAgICAgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChGUy5zdHJlYW1zW2FyZ10pIHtcbiAgICAgICAgICAgICAgYXJnKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3U3RyZWFtO1xuICAgICAgICAgICAgbmV3U3RyZWFtID0gRlMuZHVwU3RyZWFtKHN0cmVhbSwgYXJnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdHJlYW0uZmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLmZsYWdzO1xuICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgdmFyIGFyZyA9IHN5c2NhbGxHZXRWYXJhcmdJKCk7XG4gICAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIEhFQVAxNlsoYXJnICsgb2Zmc2V0KSA+PiAxXSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnN0YXQ2NChmZCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBJTlQ1M19NQVggPSA5MDA3MTk5MjU0NzQwOTkyO1xuXG4gICAgdmFyIElOVDUzX01JTiA9IC05MDA3MTk5MjU0NzQwOTkyO1xuICAgIHZhciBiaWdpbnRUb0k1M0NoZWNrZWQgPSAobnVtKSA9PlxuICAgICAgbnVtIDwgSU5UNTNfTUlOIHx8IG51bSA+IElOVDUzX01BWCA/IE5hTiA6IE51bWJlcihudW0pO1xuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsIGxlbmd0aCkge1xuICAgICAgbGVuZ3RoID0gYmlnaW50VG9JNTNDaGVja2VkKGxlbmd0aCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpKSByZXR1cm4gNjE7XG4gICAgICAgIEZTLmZ0cnVuY2F0ZShmZCwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nVG9VVEY4ID0gKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpID0+IHtcbiAgICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRjd2QoYnVmLCBzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIC0yODtcbiAgICAgICAgdmFyIGN3ZCA9IEZTLmN3ZCgpO1xuICAgICAgICB2YXIgY3dkTGVuZ3RoSW5CeXRlcyA9IGxlbmd0aEJ5dGVzVVRGOChjd2QpICsgMTtcbiAgICAgICAgaWYgKHNpemUgPCBjd2RMZW5ndGhJbkJ5dGVzKSByZXR1cm4gLTY4O1xuICAgICAgICBzdHJpbmdUb1VURjgoY3dkLCBidWYsIHNpemUpO1xuICAgICAgICByZXR1cm4gY3dkTGVuZ3RoSW5CeXRlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgY2FzZSAyMTUwOToge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MDU6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0udHR5Lm9wcy5pb2N0bF90Y2dldHMpIHtcbiAgICAgICAgICAgICAgdmFyIHRlcm1pb3MgPSBzdHJlYW0udHR5Lm9wcy5pb2N0bF90Y2dldHMoc3RyZWFtKTtcbiAgICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xuICAgICAgICAgICAgICBIRUFQMzJbYXJncCA+PiAyXSA9IHRlcm1pb3MuY19pZmxhZyB8fCAwO1xuICAgICAgICAgICAgICBIRUFQMzJbKGFyZ3AgKyA0KSA+PiAyXSA9IHRlcm1pb3MuY19vZmxhZyB8fCAwO1xuICAgICAgICAgICAgICBIRUFQMzJbKGFyZ3AgKyA4KSA+PiAyXSA9IHRlcm1pb3MuY19jZmxhZyB8fCAwO1xuICAgICAgICAgICAgICBIRUFQMzJbKGFyZ3AgKyAxMikgPj4gMl0gPSB0ZXJtaW9zLmNfbGZsYWcgfHwgMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgSEVBUDhbYXJncCArIGkgKyAxN10gPSB0ZXJtaW9zLmNfY2NbaV0gfHwgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTEwOlxuICAgICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgICAgY2FzZSAyMTUxMjoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MDY6XG4gICAgICAgICAgY2FzZSAyMTUwNzpcbiAgICAgICAgICBjYXNlIDIxNTA4OiB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGNzZXRzKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdwID0gc3lzY2FsbEdldFZhcmFyZ1AoKTtcbiAgICAgICAgICAgICAgdmFyIGNfaWZsYWcgPSBIRUFQMzJbYXJncCA+PiAyXTtcbiAgICAgICAgICAgICAgdmFyIGNfb2ZsYWcgPSBIRUFQMzJbKGFyZ3AgKyA0KSA+PiAyXTtcbiAgICAgICAgICAgICAgdmFyIGNfY2ZsYWcgPSBIRUFQMzJbKGFyZ3AgKyA4KSA+PiAyXTtcbiAgICAgICAgICAgICAgdmFyIGNfbGZsYWcgPSBIRUFQMzJbKGFyZ3AgKyAxMikgPj4gMl07XG4gICAgICAgICAgICAgIHZhciBjX2NjID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNfY2MucHVzaChIRUFQOFthcmdwICsgaSArIDE3XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS50dHkub3BzLmlvY3RsX3Rjc2V0cyhzdHJlYW0udHR5LCBvcCwge1xuICAgICAgICAgICAgICAgIGNfaWZsYWcsXG4gICAgICAgICAgICAgICAgY19vZmxhZyxcbiAgICAgICAgICAgICAgICBjX2NmbGFnLFxuICAgICAgICAgICAgICAgIGNfbGZsYWcsXG4gICAgICAgICAgICAgICAgY19jYyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUxOToge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xuICAgICAgICAgICAgSEVBUDMyW2FyZ3AgPj4gMl0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MjA6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MzE6IHtcbiAgICAgICAgICAgIHZhciBhcmdwID0gc3lzY2FsbEdldFZhcmFyZ1AoKTtcbiAgICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUyMzoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgaWYgKHN0cmVhbS50dHkub3BzLmlvY3RsX3Rpb2Nnd2luc3opIHtcbiAgICAgICAgICAgICAgdmFyIHdpbnNpemUgPSBzdHJlYW0udHR5Lm9wcy5pb2N0bF90aW9jZ3dpbnN6KHN0cmVhbS50dHkpO1xuICAgICAgICAgICAgICB2YXIgYXJncCA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XG4gICAgICAgICAgICAgIEhFQVAxNlthcmdwID4+IDFdID0gd2luc2l6ZVswXTtcbiAgICAgICAgICAgICAgSEVBUDE2WyhhcmdwICsgMikgPj4gMV0gPSB3aW5zaXplWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MjQ6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTE1OiB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMubHN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX21rZGlyYXQoZGlyZmQsIHBhdGgsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG5cbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycpXG4gICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIEZTLm1rZGlyKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbmV3ZnN0YXRhdChkaXJmZCwgcGF0aCwgYnVmLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgdmFyIG5vZm9sbG93ID0gZmxhZ3MgJiAyNTY7XG4gICAgICAgIHZhciBhbGxvd0VtcHR5ID0gZmxhZ3MgJiA0MDk2O1xuICAgICAgICBmbGFncyA9IGZsYWdzICYgfjY0MDA7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSk7XG4gICAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQobm9mb2xsb3cgPyBGUy5sc3RhdCA6IEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgdmFyIG1vZGUgPSB2YXJhcmdzID8gc3lzY2FsbEdldFZhcmFyZ0koKSA6IDA7XG4gICAgICAgIHJldHVybiBGUy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlKS5mZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVhZGxpbmthdChkaXJmZCwgcGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICBpZiAoYnVmc2l6ZSA8PSAwKSByZXR1cm4gLTI4O1xuICAgICAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7XG5cbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTtcbiAgICAgICAgdmFyIGVuZENoYXIgPSBIRUFQOFtidWYgKyBsZW5dO1xuICAgICAgICBzdHJpbmdUb1VURjgocmV0LCBidWYsIGJ1ZnNpemUgKyAxKTtcblxuICAgICAgICBIRUFQOFtidWYgKyBsZW5dID0gZW5kQ2hhcjtcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzID09PSA1MTIpIHtcbiAgICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYm9ydCgnSW52YWxpZCBmbGFncyBwYXNzZWQgdG8gdW5saW5rYXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFkSTUzRnJvbUk2NCA9IChwdHIpID0+IHtcbiAgICAgIHJldHVybiBIRUFQVTMyW3B0ciA+PiAyXSArIEhFQVAzMlsocHRyICsgNCkgPj4gMl0gKiA0Mjk0OTY3Mjk2O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3V0aW1lbnNhdChkaXJmZCwgcGF0aCwgdGltZXMsIGZsYWdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIHRydWUpO1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICBhdGltZSxcbiAgICAgICAgICBtdGltZTtcbiAgICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICAgIGF0aW1lID0gbm93O1xuICAgICAgICAgIG10aW1lID0gbm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZWNvbmRzID0gcmVhZEk1M0Zyb21JNjQodGltZXMpO1xuICAgICAgICAgIHZhciBuYW5vc2Vjb25kcyA9IEhFQVAzMlsodGltZXMgKyA4KSA+PiAyXTtcbiAgICAgICAgICBpZiAobmFub3NlY29uZHMgPT0gMTA3Mzc0MTgyMykge1xuICAgICAgICAgICAgYXRpbWUgPSBub3c7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW5vc2Vjb25kcyA9PSAxMDczNzQxODIyKSB7XG4gICAgICAgICAgICBhdGltZSA9IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdGltZSA9IHNlY29uZHMgKiAxMDAwICsgbmFub3NlY29uZHMgLyAoMTAwMCAqIDEwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1lcyArPSAxNjtcbiAgICAgICAgICBzZWNvbmRzID0gcmVhZEk1M0Zyb21JNjQodGltZXMpO1xuICAgICAgICAgIG5hbm9zZWNvbmRzID0gSEVBUDMyWyh0aW1lcyArIDgpID4+IDJdO1xuICAgICAgICAgIGlmIChuYW5vc2Vjb25kcyA9PSAxMDczNzQxODIzKSB7XG4gICAgICAgICAgICBtdGltZSA9IG5vdztcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbm9zZWNvbmRzID09IDEwNzM3NDE4MjIpIHtcbiAgICAgICAgICAgIG10aW1lID0gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG10aW1lID0gc2Vjb25kcyAqIDEwMDAgKyBuYW5vc2Vjb25kcyAvICgxMDAwICogMTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG10aW1lICE9IC0xIHx8IGF0aW1lICE9IC0xKSB7XG4gICAgICAgICAgRlMudXRpbWUocGF0aCwgYXRpbWUsIG10aW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub3dJc01vbm90b25pYyA9IDE7XG4gICAgdmFyIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyA9ICgpID0+IG5vd0lzTW9ub3RvbmljO1xuXG4gICAgdmFyIGlzTGVhcFllYXIgPSAoeWVhcikgPT5cbiAgICAgIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xuXG4gICAgdmFyIE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFID0gW1xuICAgICAgMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUsXG4gICAgXTtcblxuICAgIHZhciBNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LFxuICAgIF07XG4gICAgdmFyIHlkYXlGcm9tRGF0ZSA9IChkYXRlKSA9PiB7XG4gICAgICB2YXIgbGVhcCA9IGlzTGVhcFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgIHZhciBtb250aERheXNDdW11bGF0aXZlID0gbGVhcFxuICAgICAgICA/IE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFXG4gICAgICAgIDogTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkU7XG4gICAgICB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcblxuICAgICAgcmV0dXJuIHlkYXk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB0aW1lID0gYmlnaW50VG9JNTNDaGVja2VkKHRpbWUpO1xuXG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgICAgIEhFQVAzMlt0bVB0ciA+PiAyXSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDQpID4+IDJdID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgOCkgPj4gMl0gPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMTIpID4+IDJdID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMTYpID4+IDJdID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDIwKSA+PiAyXSA9IGRhdGUuZ2V0RnVsbFllYXIoKSAtIDE5MDA7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMjQpID4+IDJdID0gZGF0ZS5nZXREYXkoKTtcblxuICAgICAgdmFyIHlkYXkgPSB5ZGF5RnJvbURhdGUoZGF0ZSkgfCAwO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDI4KSA+PiAyXSA9IHlkYXk7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMzYpID4+IDJdID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG5cbiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgZHN0ID1cbiAgICAgICAgKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiZcbiAgICAgICAgICBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT0gTWF0aC5taW4od2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpKSB8IDA7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMzIpID4+IDJdID0gZHN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fbW1hcF9qcyhsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2Zmc2V0LCBhbGxvY2F0ZWQsIGFkZHIpIHtcbiAgICAgIG9mZnNldCA9IGJpZ2ludFRvSTUzQ2hlY2tlZChvZmZzZXQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkgcmV0dXJuIDYxO1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgdmFyIHJlcyA9IEZTLm1tYXAoc3RyZWFtLCBsZW4sIG9mZnNldCwgcHJvdCwgZmxhZ3MpO1xuICAgICAgICB2YXIgcHRyID0gcmVzLnB0cjtcbiAgICAgICAgSEVBUDMyW2FsbG9jYXRlZCA+PiAyXSA9IHJlcy5hbGxvY2F0ZWQ7XG4gICAgICAgIEhFQVBVMzJbYWRkciA+PiAyXSA9IHB0cjtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX211bm1hcF9qcyhhZGRyLCBsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBiaWdpbnRUb0k1M0NoZWNrZWQob2Zmc2V0KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIGlmIChwcm90ICYgMikge1xuICAgICAgICAgIFNZU0NBTExTLmRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX190enNldF9qcyA9ICh0aW1lem9uZSwgZGF5bGlnaHQsIHN0ZF9uYW1lLCBkc3RfbmFtZSkgPT4ge1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgICAgdmFyIHdpbnRlciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgNiwgMSk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gd2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICAgIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcblxuICAgICAgSEVBUFUzMlt0aW1lem9uZSA+PiAyXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG5cbiAgICAgIEhFQVAzMltkYXlsaWdodCA+PiAyXSA9IE51bWJlcih3aW50ZXJPZmZzZXQgIT0gc3VtbWVyT2Zmc2V0KTtcblxuICAgICAgdmFyIGV4dHJhY3Rab25lID0gKHRpbWV6b25lT2Zmc2V0KSA9PiB7XG4gICAgICAgIHZhciBzaWduID0gdGltZXpvbmVPZmZzZXQgPj0gMCA/ICctJyA6ICcrJztcblxuICAgICAgICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnModGltZXpvbmVPZmZzZXQpO1xuICAgICAgICB2YXIgaG91cnMgPSBTdHJpbmcoTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIHZhciBtaW51dGVzID0gU3RyaW5nKGFic09mZnNldCAlIDYwKS5wYWRTdGFydCgyLCAnMCcpO1xuXG4gICAgICAgIHJldHVybiBgVVRDJHtzaWdufSR7aG91cnN9JHttaW51dGVzfWA7XG4gICAgICB9O1xuXG4gICAgICB2YXIgd2ludGVyTmFtZSA9IGV4dHJhY3Rab25lKHdpbnRlck9mZnNldCk7XG4gICAgICB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lck9mZnNldCk7XG4gICAgICBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gICAgICAgIHN0cmluZ1RvVVRGOCh3aW50ZXJOYW1lLCBzdGRfbmFtZSwgMTcpO1xuICAgICAgICBzdHJpbmdUb1VURjgoc3VtbWVyTmFtZSwgZHN0X25hbWUsIDE3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZ1RvVVRGOCh3aW50ZXJOYW1lLCBkc3RfbmFtZSwgMTcpO1xuICAgICAgICBzdHJpbmdUb1VURjgoc3VtbWVyTmFtZSwgc3RkX25hbWUsIDE3KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9lbXNjcmlwdGVuX2RhdGVfbm93ID0gKCkgPT4gRGF0ZS5ub3coKTtcblxuICAgIHZhciBfZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICB2YXIgZ2V0SGVhcE1heCA9ICgpID0+IDIxNDc0ODM2NDg7XG5cbiAgICB2YXIgZ3Jvd01lbW9yeSA9IChzaXplKSA9PiB7XG4gICAgICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuICAgICAgdmFyIHBhZ2VzID0gKChzaXplIC0gYi5ieXRlTGVuZ3RoICsgNjU1MzUpIC8gNjU1MzYpIHwgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdhc21NZW1vcnkuZ3JvdyhwYWdlcyk7XG4gICAgICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9O1xuICAgIHZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCA9IChyZXF1ZXN0ZWRTaXplKSA9PiB7XG4gICAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG5cbiAgICAgIHJlcXVlc3RlZFNpemUgPj4+PSAwO1xuXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gICAgICAgIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIDAuMiAvIGN1dERvd24pO1xuXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4oXG4gICAgICAgICAgb3Zlckdyb3duSGVhcFNpemUsXG4gICAgICAgICAgcmVxdWVzdGVkU2l6ZSArIDEwMDY2MzI5NixcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbmV3U2l6ZSA9IE1hdGgubWluKFxuICAgICAgICAgIG1heEhlYXBTaXplLFxuICAgICAgICAgIGFsaWduTWVtb3J5KE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpLFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IGdyb3dNZW1vcnkobmV3U2l6ZSk7XG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBFTlYgPSB7fTtcblxuICAgIHZhciBnZXRFeGVjdXRhYmxlTmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzUHJvZ3JhbSB8fCAnLi90aGlzLnByb2dyYW0nO1xuICAgIH07XG4gICAgdmFyIGdldEVudlN0cmluZ3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICB2YXIgbGFuZyA9XG4gICAgICAgICAgKFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJlxuICAgICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAgICAgJ0MnXG4gICAgICAgICAgKS5yZXBsYWNlKCctJywgJ18nKSArICcuVVRGLTgnO1xuICAgICAgICB2YXIgZW52ID0ge1xuICAgICAgICAgIFVTRVI6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgTE9HTkFNRTogJ3dlYl91c2VyJyxcbiAgICAgICAgICBQQVRIOiAnLycsXG4gICAgICAgICAgUFdEOiAnLycsXG4gICAgICAgICAgSE9NRTogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICBMQU5HOiBsYW5nLFxuICAgICAgICAgIF86IGdldEV4ZWN1dGFibGVOYW1lKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goYCR7eH09JHtlbnZbeF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfTtcblxuICAgIHZhciBzdHJpbmdUb0FzY2lpID0gKHN0ciwgYnVmZmVyKSA9PiB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBIRUFQOFtidWZmZXIrK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgSEVBUDhbYnVmZmVyXSA9IDA7XG4gICAgfTtcbiAgICB2YXIgX2Vudmlyb25fZ2V0ID0gKF9fZW52aXJvbiwgZW52aXJvbl9idWYpID0+IHtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIGdldEVudlN0cmluZ3MoKS5mb3JFYWNoKChzdHJpbmcsIGkpID0+IHtcbiAgICAgICAgdmFyIHB0ciA9IGVudmlyb25fYnVmICsgYnVmU2l6ZTtcbiAgICAgICAgSEVBUFUzMlsoX19lbnZpcm9uICsgaSAqIDQpID4+IDJdID0gcHRyO1xuICAgICAgICBzdHJpbmdUb0FzY2lpKHN0cmluZywgcHRyKTtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIHZhciBfZW52aXJvbl9zaXplc19nZXQgPSAocGVudmlyb25fY291bnQsIHBlbnZpcm9uX2J1Zl9zaXplKSA9PiB7XG4gICAgICB2YXIgc3RyaW5ncyA9IGdldEVudlN0cmluZ3MoKTtcbiAgICAgIEhFQVBVMzJbcGVudmlyb25fY291bnQgPj4gMl0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIHN0cmluZ3MuZm9yRWFjaCgoc3RyaW5nKSA9PiAoYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMSkpO1xuICAgICAgSEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZSA+PiAyXSA9IGJ1ZlNpemU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF9mZHN0YXRfZ2V0KGZkLCBwYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmlnaHRzQmFzZSA9IDA7XG4gICAgICAgIHZhciByaWdodHNJbmhlcml0aW5nID0gMDtcbiAgICAgICAgdmFyIGZsYWdzID0gMDtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSBzdHJlYW0udHR5XG4gICAgICAgICAgICA/IDJcbiAgICAgICAgICAgIDogRlMuaXNEaXIoc3RyZWFtLm1vZGUpXG4gICAgICAgICAgICAgID8gM1xuICAgICAgICAgICAgICA6IEZTLmlzTGluayhzdHJlYW0ubW9kZSlcbiAgICAgICAgICAgICAgICA/IDdcbiAgICAgICAgICAgICAgICA6IDQ7XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDhbcGJ1Zl0gPSB0eXBlO1xuICAgICAgICBIRUFQMTZbKHBidWYgKyAyKSA+PiAxXSA9IGZsYWdzO1xuICAgICAgICBIRUFQNjRbKHBidWYgKyA4KSA+PiAzXSA9IEJpZ0ludChyaWdodHNCYXNlKTtcbiAgICAgICAgSEVBUDY0WyhwYnVmICsgMTYpID4+IDNdID0gQmlnSW50KHJpZ2h0c0luaGVyaXRpbmcpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvUmVhZHYgPSAoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgaWYgKGN1cnIgPCBsZW4pIGJyZWFrO1xuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmRfcmVhZChmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICB2YXIgbnVtID0gZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgICAgSEVBUFUzMltwbnVtID4+IDJdID0gbnVtO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX3NlZWsoZmQsIG9mZnNldCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IGJpZ2ludFRvSTUzQ2hlY2tlZChvZmZzZXQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkgcmV0dXJuIDYxO1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBIRUFQNjRbbmV3T2Zmc2V0ID4+IDNdID0gQmlnSW50KHN0cmVhbS5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMClcbiAgICAgICAgICBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX3N5bmMoZmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHM/LmZzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmZzeW5jKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb1dyaXRldiA9IChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpID0+IHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4gMl07XG4gICAgICAgIHZhciBsZW4gPSBIRUFQVTMyWyhpb3YgKyA0KSA+PiAyXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMud3JpdGUoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgaWYgKGN1cnIgPCBsZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgdmFyIG51bSA9IGRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgICBIRUFQVTMyW3BudW0gPj4gMl0gPSBudW07XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBGUy5jcmVhdGVQcmVsb2FkZWRGaWxlID0gRlNfY3JlYXRlUHJlbG9hZGVkRmlsZTtcbiAgICBGUy5zdGF0aWNJbml0KCk7XG5cbiAgICB2YXIgd2FzbUltcG9ydHMgPSB7XG4gICAgICBfX3N5c2NhbGxfY2htb2Q6IF9fX3N5c2NhbGxfY2htb2QsXG5cbiAgICAgIF9fc3lzY2FsbF9mYWNjZXNzYXQ6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuXG4gICAgICBfX3N5c2NhbGxfZmNobW9kOiBfX19zeXNjYWxsX2ZjaG1vZCxcblxuICAgICAgX19zeXNjYWxsX2ZjaG93bjMyOiBfX19zeXNjYWxsX2ZjaG93bjMyLFxuXG4gICAgICBfX3N5c2NhbGxfZmNudGw2NDogX19fc3lzY2FsbF9mY250bDY0LFxuXG4gICAgICBfX3N5c2NhbGxfZnN0YXQ2NDogX19fc3lzY2FsbF9mc3RhdDY0LFxuXG4gICAgICBfX3N5c2NhbGxfZnRydW5jYXRlNjQ6IF9fX3N5c2NhbGxfZnRydW5jYXRlNjQsXG5cbiAgICAgIF9fc3lzY2FsbF9nZXRjd2Q6IF9fX3N5c2NhbGxfZ2V0Y3dkLFxuXG4gICAgICBfX3N5c2NhbGxfaW9jdGw6IF9fX3N5c2NhbGxfaW9jdGwsXG5cbiAgICAgIF9fc3lzY2FsbF9sc3RhdDY0OiBfX19zeXNjYWxsX2xzdGF0NjQsXG5cbiAgICAgIF9fc3lzY2FsbF9ta2RpcmF0OiBfX19zeXNjYWxsX21rZGlyYXQsXG5cbiAgICAgIF9fc3lzY2FsbF9uZXdmc3RhdGF0OiBfX19zeXNjYWxsX25ld2ZzdGF0YXQsXG5cbiAgICAgIF9fc3lzY2FsbF9vcGVuYXQ6IF9fX3N5c2NhbGxfb3BlbmF0LFxuXG4gICAgICBfX3N5c2NhbGxfcmVhZGxpbmthdDogX19fc3lzY2FsbF9yZWFkbGlua2F0LFxuXG4gICAgICBfX3N5c2NhbGxfcm1kaXI6IF9fX3N5c2NhbGxfcm1kaXIsXG5cbiAgICAgIF9fc3lzY2FsbF9zdGF0NjQ6IF9fX3N5c2NhbGxfc3RhdDY0LFxuXG4gICAgICBfX3N5c2NhbGxfdW5saW5rYXQ6IF9fX3N5c2NhbGxfdW5saW5rYXQsXG5cbiAgICAgIF9fc3lzY2FsbF91dGltZW5zYXQ6IF9fX3N5c2NhbGxfdXRpbWVuc2F0LFxuXG4gICAgICBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYzogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuXG4gICAgICBfbG9jYWx0aW1lX2pzOiBfX2xvY2FsdGltZV9qcyxcblxuICAgICAgX21tYXBfanM6IF9fbW1hcF9qcyxcblxuICAgICAgX211bm1hcF9qczogX19tdW5tYXBfanMsXG5cbiAgICAgIF90enNldF9qczogX190enNldF9qcyxcblxuICAgICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG5cbiAgICAgIGVtc2NyaXB0ZW5fZ2V0X25vdzogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcblxuICAgICAgZW1zY3JpcHRlbl9yZXNpemVfaGVhcDogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXG5cbiAgICAgIGVudmlyb25fZ2V0OiBfZW52aXJvbl9nZXQsXG5cbiAgICAgIGVudmlyb25fc2l6ZXNfZ2V0OiBfZW52aXJvbl9zaXplc19nZXQsXG5cbiAgICAgIGZkX2Nsb3NlOiBfZmRfY2xvc2UsXG5cbiAgICAgIGZkX2Zkc3RhdF9nZXQ6IF9mZF9mZHN0YXRfZ2V0LFxuXG4gICAgICBmZF9yZWFkOiBfZmRfcmVhZCxcblxuICAgICAgZmRfc2VlazogX2ZkX3NlZWssXG5cbiAgICAgIGZkX3N5bmM6IF9mZF9zeW5jLFxuXG4gICAgICBmZF93cml0ZTogX2ZkX3dyaXRlLFxuXG4gICAgICBtZW1vcnk6IHdhc21NZW1vcnksXG4gICAgfTtcbiAgICB2YXIgd2FzbUV4cG9ydHMgPSBjcmVhdGVXYXNtKCk7XG4gICAgdmFyIF9fX3dhc21fY2FsbF9jdG9ycyA9ICgpID0+XG4gICAgICAoX19fd2FzbV9jYWxsX2N0b3JzID0gd2FzbUV4cG9ydHNbJ19fd2FzbV9jYWxsX2N0b3JzJ10pKCk7XG4gICAgdmFyIF9zcWxpdGUzX3N0YXR1czY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzNjQnXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM19zdGF0dXM2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzNjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0YXR1czY0J10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX3N0YXR1cyddID0gKGEwLCBhMSwgYTIsIGEzKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0YXR1cyA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdGF0dXMnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfZGJfc3RhdHVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfc3RhdHVzJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19kYl9zdGF0dXMgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZGJfc3RhdHVzJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19tc2l6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX21zaXplJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfbXNpemUgPSBNb2R1bGVbJ19zcWxpdGUzX21zaXplJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19tc2l6ZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192ZnNfZmluZCA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc19maW5kJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmZzX2ZpbmQgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19maW5kJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192ZnNfZmluZCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19pbml0aWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfaW5pdGlhbGl6ZSddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19pbml0aWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19pbml0aWFsaXplJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19pbml0aWFsaXplJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19tYWxsb2MgPSAoTW9kdWxlWydfc3FsaXRlM19tYWxsb2MnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19tYWxsb2MgPSBNb2R1bGVbJ19zcWxpdGUzX21hbGxvYyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbWFsbG9jJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM19mcmVlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfZnJlZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZnJlZSddID0gd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZnJlZSddKShcbiAgICAgICAgYTAsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IE1vZHVsZVsnX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192ZnNfcmVnaXN0ZXInXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXInXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IE1vZHVsZVsnX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX21hbGxvYzY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jNjQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19tYWxsb2M2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jNjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX21hbGxvYzY0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2MgPSAoTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3JlYWxsb2MgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2MnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3JlYWxsb2MnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19yZWFsbG9jNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVhbGxvYzY0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdGV4dCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3RleHQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX3RleHQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmFuZG9tbmVzcyA9IChNb2R1bGVbJ19zcWxpdGUzX3JhbmRvbW5lc3MnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfcmFuZG9tbmVzcyA9IE1vZHVsZVsnX3NxbGl0ZTNfcmFuZG9tbmVzcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmFuZG9tbmVzcyddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RyaWNtcCA9IChNb2R1bGVbJ19zcWxpdGUzX3N0cmljbXAnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RyaWNtcCA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RyaWNtcCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RyaWNtcCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RybmljbXAgPSAoTW9kdWxlWydfc3FsaXRlM19zdHJuaWNtcCddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RybmljbXAgPSBNb2R1bGVbJ19zcWxpdGUzX3N0cm5pY21wJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdHJuaWNtcCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfcGFyYW1ldGVyJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9wYXJhbWV0ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VyaV9wYXJhbWV0ZXInXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3VyaV9ib29sZWFuID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2Jvb2xlYW4nXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3VyaV9ib29sZWFuID0gTW9kdWxlWydfc3FsaXRlM191cmlfYm9vbGVhbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdXJpX2Jvb2xlYW4nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19zZXJpYWxpemUgPSAoTW9kdWxlWydfc3FsaXRlM19zZXJpYWxpemUnXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM19zZXJpYWxpemUgPSBNb2R1bGVbJ19zcWxpdGUzX3NlcmlhbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc2VyaWFsaXplJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXBhcmVfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19wcmVwYXJlX3YyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19wcmVwYXJlX3YyID0gTW9kdWxlWydfc3FsaXRlM19wcmVwYXJlX3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcmVwYXJlX3YyJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19zdGVwID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RlcCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0ZXAgPSBNb2R1bGVbJ19zcWxpdGUzX3N0ZXAnXSA9IHdhc21FeHBvcnRzWydzcWxpdGUzX3N0ZXAnXSkoXG4gICAgICAgIGEwLFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19jb2x1bW5faW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX2ludDY0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19yZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc2V0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzZXQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc2V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXNldCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19leGVjID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXhlYyddID0gKGEwLCBhMSwgYTIsIGEzLCBhNCkgPT5cbiAgICAgIChfc3FsaXRlM19leGVjID0gTW9kdWxlWydfc3FsaXRlM19leGVjJ10gPSB3YXNtRXhwb3J0c1snc3FsaXRlM19leGVjJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2ludCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2ludCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX2ludCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfZmluYWxpemUgPSAoTW9kdWxlWydfc3FsaXRlM19maW5hbGl6ZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2ZpbmFsaXplID0gTW9kdWxlWydfc3FsaXRlM19maW5hbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZmluYWxpemUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gTW9kdWxlWydfc3FsaXRlM19maWxlX2NvbnRyb2wnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2ZpbGVfY29udHJvbCddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fbmFtZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9uYW1lJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fbmFtZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX25hbWUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3RleHQnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl90ZXh0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fdGV4dCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX3R5cGUgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdHlwZSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19jb2x1bW5fdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3R5cGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl90eXBlJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19lcnJtc2cgPSAoTW9kdWxlWydfc3FsaXRlM19lcnJtc2cnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19lcnJtc2cgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm1zZyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXJybXNnJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGVzZXJpYWxpemUnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgICBhNSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfZGVzZXJpYWxpemUgPSBNb2R1bGVbJ19zcWxpdGUzX2Rlc2VyaWFsaXplJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kZXNlcmlhbGl6ZSddKShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSk7XG4gICAgdmFyIF9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19jbGVhcl9iaW5kaW5ncyA9IE1vZHVsZVsnX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NsZWFyX2JpbmRpbmdzJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ibG9iJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfYmxvYiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfYmxvYiddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9ieXRlcyA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2J5dGVzJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2J5dGVzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9ieXRlcyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9kb3VibGUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9kb3VibGUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2RvdWJsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2ludCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfaW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9pbnQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfaW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9pbnQ2NCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9pbnQ2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfaW50NjQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfc3VidHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3N1YnR5cGUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9zdWJ0eXBlID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX3BvaW50ZXIgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9wb2ludGVyJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX3BvaW50ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3BvaW50ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX3BvaW50ZXInXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX3R5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV90eXBlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdHlwZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfdHlwZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX25vY2hhbmdlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX25vY2hhbmdlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9mcm9tYmluZCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9mcm9tYmluZCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9kdXAgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9kdXAnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9kdXAgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2R1cCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfZHVwJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcmVlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfZnJlZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZnJlZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfZnJlZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfYmxvYiA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9ibG9iJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9ibG9iJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfYmxvYiddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyddID1cbiAgICAgIChhMCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZG91YmxlJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9kb3VibGUgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9kb3VibGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9kb3VibGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvciA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfZXJyb3IgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X2ludCA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2ludCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2ludCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2ludDY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2ludDY0J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2ludDY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfaW50NjQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9udWxsID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X251bGwnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfbnVsbCA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X251bGwnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9udWxsJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfcG9pbnRlciA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9wb2ludGVyJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfc3VidHlwZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3RleHQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfdGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3RleHQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF90ZXh0J10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdXNlcl9kYXRhID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXNlcl9kYXRhJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdXNlcl9kYXRhID0gTW9kdWxlWydfc3FsaXRlM191c2VyX2RhdGEnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VzZXJfZGF0YSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192dGFiX25vY2hhbmdlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9pbl9maXJzdCA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fZmlyc3QnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfdnRhYl9pbl9maXJzdCA9IE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9pbl9maXJzdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdnRhYl9pbl9maXJzdCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9pbl9uZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9pbl9uZXh0J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfaW5fbmV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9pbl9uZXh0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX2luX25leHQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gTW9kdWxlWydfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXhkYXRhID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1eGRhdGEnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfZ2V0X2F1eGRhdGEgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXhkYXRhJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19nZXRfYXV4ZGF0YSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc2V0X2F1eGRhdGEgPSAoTW9kdWxlWydfc3FsaXRlM19zZXRfYXV4ZGF0YSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3NldF9hdXhkYXRhID0gTW9kdWxlWydfc3FsaXRlM19zZXRfYXV4ZGF0YSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2NvdW50J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fY291bnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9jb3VudCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19kYXRhX2NvdW50ID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGF0YV9jb3VudCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2RhdGFfY291bnQgPSBNb2R1bGVbJ19zcWxpdGUzX2RhdGFfY291bnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2RhdGFfY291bnQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYmxvYiddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19jb2x1bW5fYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2Jsb2InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9ibG9iJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fYnl0ZXMgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9ieXRlcyddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9kb3VibGUnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX2RvdWJsZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX3ZhbHVlID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3ZhbHVlJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3ZhbHVlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fdmFsdWUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9kZWNsdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9kZWNsdHlwZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2RlY2x0eXBlID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fZGVjbHR5cGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9kZWNsdHlwZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9ibG9iJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfYmxvYiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9ibG9iJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19iaW5kX2RvdWJsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfZG91YmxlJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9kb3VibGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfZG91YmxlJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludCddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfaW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX2ludCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfaW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludDY0J10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludDY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX2ludDY0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9udWxsID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9udWxsJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2JpbmRfbnVsbCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9udWxsJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX251bGwnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfcG9pbnRlciA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfcG9pbnRlciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfcG9pbnRlciddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF90ZXh0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfdGV4dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF90ZXh0J10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQnXG4gICAgXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9uYW1lJ10gPVxuICAgICAgKGEwLCBhMSkgPT5cbiAgICAgICAgKF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUnXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfbmFtZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXggPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4J1xuICAgIF0gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RiX2hhbmRsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX2hhbmRsZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2RiX2hhbmRsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZGJfaGFuZGxlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kYl9oYW5kbGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RtdF9yZWFkb25seSA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfcmVhZG9ubHknXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19zdG10X3JlYWRvbmx5ID0gTW9kdWxlWydfc3FsaXRlM19zdG10X3JlYWRvbmx5J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdG10X3JlYWRvbmx5J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfaXNleHBsYWluID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW4nXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfZXhwbGFpbiA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfZXhwbGFpbiddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19zdG10X2V4cGxhaW4gPSBNb2R1bGVbJ19zcWxpdGUzX3N0bXRfZXhwbGFpbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RtdF9leHBsYWluJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19zdG10X2J1c3kgPSAoTW9kdWxlWydfc3FsaXRlM19zdG10X2J1c3knXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19zdG10X2J1c3kgPSBNb2R1bGVbJ19zcWxpdGUzX3N0bXRfYnVzeSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RtdF9idXN5J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9zdGF0dXMnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gTW9kdWxlWydfc3FsaXRlM19zdG10X3N0YXR1cyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RtdF9zdGF0dXMnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19zcWwgPSAoTW9kdWxlWydfc3FsaXRlM19zcWwnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19zcWwgPSBNb2R1bGVbJ19zcWxpdGUzX3NxbCddID0gd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3FsJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2V4cGFuZGVkX3NxbCA9IChNb2R1bGVbJ19zcWxpdGUzX2V4cGFuZGVkX3NxbCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2V4cGFuZGVkX3NxbCA9IE1vZHVsZVsnX3NxbGl0ZTNfZXhwYW5kZWRfc3FsJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19leHBhbmRlZF9zcWwnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX29sZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcmV1cGRhdGVfY291bnQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfZGVwdGgnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSddID1cbiAgICAgIChhMCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfbmV3ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX25ldyddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19wcmV1cGRhdGVfbmV3ID0gTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfbmV3J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcmV1cGRhdGVfbmV3J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IChNb2R1bGVbJ19zcWxpdGUzX3NldF9hdXRob3JpemVyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3NldF9hdXRob3JpemVyID0gTW9kdWxlWydfc3FsaXRlM19zZXRfYXV0aG9yaXplciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19zdHJnbG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RyZ2xvYiddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19zdHJnbG9iID0gTW9kdWxlWydfc3FsaXRlM19zdHJnbG9iJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdHJnbG9iJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19zdHJsaWtlID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RybGlrZSddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RybGlrZSA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RybGlrZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RybGlrZSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfYXV0b19leHRlbnNpb24nXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVsnX3NxbGl0ZTNfYXV0b19leHRlbnNpb24nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uJ1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24nXG4gICAgXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJlcGFyZV92MyA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjMnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgICBhNSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJlcGFyZV92MyA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJlcGFyZV92MyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJlcGFyZV92MyddKShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSk7XG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGUgPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfbW9kdWxlJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX21vZHVsZSddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfZHJvcF9tb2R1bGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kcm9wX21vZHVsZXMnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RlY2xhcmVfdnRhYiA9IChNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSBNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZGVjbGFyZV92dGFiJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2NvbGxhdGlvbiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfY29sbGF0aW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX2NvbGxhdGlvbiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9pbiA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW4nXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfaW4gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfaW4nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM192dGFiX3Joc192YWx1ZSA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlID0gTW9kdWxlWydfc3FsaXRlM192dGFiX3Joc192YWx1ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM192dGFiX2Rpc3RpbmN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfZGlzdGluY3QnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfZGlzdGluY3QnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfa2V5d29yZF9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9uYW1lJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2tleXdvcmRfbmFtZSA9IE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9uYW1lJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19rZXl3b3JkX25hbWUnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19rZXl3b3JkX2NvdW50ID0gKE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jb3VudCddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19rZXl3b3JkX2NvdW50ID0gTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX2NvdW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19rZXl3b3JkX2NvdW50J10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19rZXl3b3JkX2NoZWNrID0gKE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jaGVjayddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19rZXl3b3JkX2NoZWNrID0gTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jb21wbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBsZXRlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY29tcGxldGUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbXBsZXRlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb21wbGV0ZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19saWJ2ZXJzaW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGlidmVyc2lvbiddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19saWJ2ZXJzaW9uID0gTW9kdWxlWydfc3FsaXRlM19saWJ2ZXJzaW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19saWJ2ZXJzaW9uJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciA9IChNb2R1bGVbJ19zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJ10gPVxuICAgICAgKCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyID0gTW9kdWxlWydfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc2h1dGRvd24gPSAoTW9kdWxlWydfc3FsaXRlM19zaHV0ZG93biddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19zaHV0ZG93biA9IE1vZHVsZVsnX3NxbGl0ZTNfc2h1dGRvd24nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NodXRkb3duJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCA9IChNb2R1bGVbJ19zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbJ19zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCdcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jaGFuZ2VzNjQgPSAoTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19jaGFuZ2VzNjQgPSBNb2R1bGVbJ19zcWxpdGUzX2NoYW5nZXM2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY2hhbmdlczY0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NoYW5nZXMgPSAoTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY2hhbmdlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfY2hhbmdlcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY2hhbmdlcyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQgPSAoTW9kdWxlWydfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3RvdGFsX2NoYW5nZXMgPSAoTW9kdWxlWydfc3FsaXRlM190b3RhbF9jaGFuZ2VzJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM190eG5fc3RhdGUgPSAoTW9kdWxlWydfc3FsaXRlM190eG5fc3RhdGUnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfdHhuX3N0YXRlID0gTW9kdWxlWydfc3FsaXRlM190eG5fc3RhdGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3R4bl9zdGF0ZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY2xvc2VfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19jbG9zZV92MiddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2Nsb3NlX3YyID0gTW9kdWxlWydfc3FsaXRlM19jbG9zZV92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY2xvc2VfdjInXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV9oYW5kbGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19idXN5X2hhbmRsZXInXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV90aW1lb3V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19idXN5X3RpbWVvdXQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2ludGVycnVwdCA9IChNb2R1bGVbJ19zcWxpdGUzX2ludGVycnVwdCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2ludGVycnVwdCA9IE1vZHVsZVsnX3NxbGl0ZTNfaW50ZXJydXB0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19pbnRlcnJ1cHQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfaXNfaW50ZXJydXB0ZWQgPSAoTW9kdWxlWydfc3FsaXRlM19pc19pbnRlcnJ1cHRlZCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2lzX2ludGVycnVwdGVkID0gTW9kdWxlWydfc3FsaXRlM19pc19pbnRlcnJ1cHRlZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfaXNfaW50ZXJydXB0ZWQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgICBhNixcbiAgICAgIGE3LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICAgIGE1LFxuICAgICAgICBhNixcbiAgICAgICAgYTcsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgICBhNixcbiAgICAgIGE3LFxuICAgICAgYTgsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInXSkoXG4gICAgICAgIGEwLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGEzLFxuICAgICAgICBhNCxcbiAgICAgICAgYTUsXG4gICAgICAgIGE2LFxuICAgICAgICBhNyxcbiAgICAgICAgYTgsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSA9PlxuICAgICAgKF9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24nXSkoXG4gICAgICAgIGEwLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGEzLFxuICAgICAgICBhNCxcbiAgICAgICAgYTUsXG4gICAgICAgIGE2LFxuICAgICAgICBhNyxcbiAgICAgICAgYTgsXG4gICAgICAgIGE5LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb24nXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb24gPSBNb2R1bGVbJ19zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3RyYWNlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdHJhY2VfdjInXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM190cmFjZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfdHJhY2VfdjInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3RyYWNlX3YyJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbW1pdF9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29tbWl0X2hvb2snXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbW1pdF9ob29rID0gTW9kdWxlWydfc3FsaXRlM19jb21taXRfaG9vayddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29tbWl0X2hvb2snXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM191cGRhdGVfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX3VwZGF0ZV9ob29rJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM191cGRhdGVfaG9vayA9IE1vZHVsZVsnX3NxbGl0ZTNfdXBkYXRlX2hvb2snXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VwZGF0ZV9ob29rJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX3JvbGxiYWNrX2hvb2snXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IE1vZHVsZVsnX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vayddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ob29rJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcmV1cGRhdGVfaG9vayddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IChNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IE1vZHVsZVsnX3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19lcnJvcl9vZmZzZXQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfZXJyY29kZSA9IChNb2R1bGVbJ19zcWxpdGUzX2VycmNvZGUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19lcnJjb2RlID0gTW9kdWxlWydfc3FsaXRlM19lcnJjb2RlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19lcnJjb2RlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUgPSAoTW9kdWxlWydfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19lcnJzdHIgPSAoTW9kdWxlWydfc3FsaXRlM19lcnJzdHInXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19lcnJzdHIgPSBNb2R1bGVbJ19zcWxpdGUzX2VycnN0ciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXJyc3RyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2xpbWl0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGltaXQnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX2xpbWl0ID0gTW9kdWxlWydfc3FsaXRlM19saW1pdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbGltaXQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19vcGVuID0gKE1vZHVsZVsnX3NxbGl0ZTNfb3BlbiddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19vcGVuID0gTW9kdWxlWydfc3FsaXRlM19vcGVuJ10gPSB3YXNtRXhwb3J0c1snc3FsaXRlM19vcGVuJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNfb3Blbl92MiA9IChNb2R1bGVbJ19zcWxpdGUzX29wZW5fdjInXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM19vcGVuX3YyID0gTW9kdWxlWydfc3FsaXRlM19vcGVuX3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19vcGVuX3YyJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiddID1cbiAgICAgIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSA9PlxuICAgICAgICAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXRvY29tbWl0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19nZXRfYXV0b2NvbW1pdCA9IE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2dldF9hdXRvY29tbWl0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhJ1xuICAgIF0gPSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgPT5cbiAgICAgIChfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICAgIGE1LFxuICAgICAgICBhNixcbiAgICAgICAgYTcsXG4gICAgICAgIGE4LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzJ1xuICAgIF0gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcydcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3VyaV9rZXkgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfa2V5J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3VyaV9rZXkgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9rZXknXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VyaV9rZXknXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3VyaV9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3VyaV9pbnQ2NCddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfdXJpX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM191cmlfaW50NjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VyaV9pbnQ2NCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RiX25hbWUgPSAoTW9kdWxlWydfc3FsaXRlM19kYl9uYW1lJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2RiX25hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX25hbWUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2RiX25hbWUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfZmlsZW5hbWUnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfZGJfZmlsZW5hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX2ZpbGVuYW1lJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kYl9maWxlbmFtZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfZGJfcmVhZG9ubHkgPSAoTW9kdWxlWydfc3FsaXRlM19kYl9yZWFkb25seSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19kYl9yZWFkb25seSA9IE1vZHVsZVsnX3NxbGl0ZTNfZGJfcmVhZG9ubHknXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2RiX3JlYWRvbmx5J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSAoTW9kdWxlWydfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9kaWZmID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2RpZmYnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2RpZmYnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9kaWZmJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9hdHRhY2gnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9hdHRhY2gnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jcmVhdGUgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY3JlYXRlJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9jcmVhdGUgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jcmVhdGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9jcmVhdGUnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZGVsZXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInXSA9XG4gICAgICAoYTAsIGExLCBhMikgPT5cbiAgICAgICAgKF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0gPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9lbmFibGUnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHkgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25faXNlbXB0eSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZydcbiAgICBdID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSddID1cbiAgICAgIChhMCwgYTEsIGEyKSA9PlxuICAgICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0nXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X25leHQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXh0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9uZXh0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X29wID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X29wID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9vcCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSkoYTAsIGExLCBhMiwgYTMsIGE0KSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfcGsnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9wayddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfcGsnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9vbGQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9vbGQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9vbGQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X29sZCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X25ldyA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X25ldyddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X25ldyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHMnXG4gICAgXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZSddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2ludmVydCddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nXG4gICAgXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgICBhNSxcbiAgICAgIGE2LFxuICAgICAgYTcsXG4gICAgICBhOCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjIgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgYTMsXG4gICAgICAgIGE0LFxuICAgICAgICBhNSxcbiAgICAgICAgYTYsXG4gICAgICAgIGE3LFxuICAgICAgICBhOCxcbiAgICAgICkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknXSkoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtJ1xuICAgIF0gPSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICAgIGE1LFxuICAgICAgICBhNixcbiAgICAgICAgYTcsXG4gICAgICAgIGE4LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0gPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJ10gPVxuICAgICAgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpID0+XG4gICAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0nXSkoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX25ldyA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZWdyb3VwX25ldyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSddID1cbiAgICAgIChhMCwgYTEsIGEyKSA9PlxuICAgICAgICAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICAgIGE1LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0J10pKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJ1xuICAgIF0gPSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jb25maWcnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc291cmNlaWQgPSAoTW9kdWxlWydfc3FsaXRlM19zb3VyY2VpZCddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19zb3VyY2VpZCA9IE1vZHVsZVsnX3NxbGl0ZTNfc291cmNlaWQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NvdXJjZWlkJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3B0ciddID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUnXG4gICAgXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZSA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3BzdGFja19yZXN0b3JlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3BzdGFja19hbGxvYyA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3BzdGFja19hbGxvYyddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3BzdGFja19hbGxvYyA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX2FsbG9jJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3JlbWFpbmluZyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3JlbWFpbmluZydcbiAgICBdID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3JlbWFpbmluZydcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVtYWluaW5nJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9wc3RhY2tfcXVvdGEgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9wc3RhY2tfcXVvdGEnXSA9XG4gICAgICAoKSA9PlxuICAgICAgICAoX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9wc3RhY2tfcXVvdGEnXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl9lcnJvciA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX2Vycm9yJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2RiX2Vycm9yID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9lcnJvciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfZXJyb3InXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdCA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3Rfc3RydWN0J10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJ1Y3QgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3Rfc3RydWN0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9lbnVtX2pzb24gPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9lbnVtX2pzb24nXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZW51bV9qc29uID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9lbnVtX2pzb24nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2VudW1fanNvbiddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdmZzX3VubGluayA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Zmc191bmxpbmsnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Zmc191bmxpbmsgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Zmc191bmxpbmsnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Zmc191bmxpbmsnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2RiX3ZmcyA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3ZmcyddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9kYl92ZnMgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3ZmcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfdmZzJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl9yZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3Jlc2V0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfcmVzZXQgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3Jlc2V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9kYl9yZXNldCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl9leHBvcnRfY2h1bmtlZCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQnXG4gICAgXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV9kYl9leHBvcnRfY2h1bmtlZCdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9kYl9leHBvcnRfY2h1bmtlZCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9kYl9zZXJpYWxpemUgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3NlcmlhbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3Zmc19jcmVhdGVfZmlsZSdcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Zmc19jcmVhdGVfZmlsZSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3Zmc19jcmVhdGVfZmlsZSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJ1xuICAgIF0gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2sgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrJ1xuICAgIF0gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2snXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2snXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9rdnZmc19tZXRob2RzJ10gPVxuICAgICAgKCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMnXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fa3Z2ZnNfbWV0aG9kcyddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdnRhYl9jb25maWcgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZyddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZyA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdnRhYl9jb25maWcnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Z0YWJfY29uZmlnJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfaXAnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcCddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcGlpID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaSddID1cbiAgICAgIChhMCwgYTEsIGEyLCBhMywgYTQpID0+XG4gICAgICAgIChfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcGlpID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcGlpJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19waWknXSkoYTAsIGExLCBhMiwgYTMsIGE0KSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3MnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3MgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcyddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2NvbmZpZ19pID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fY29uZmlnX2knXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2NvbmZpZ19pID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9jb25maWdfaSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fY29uZmlnX2knXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2NvbmZpZ19paSA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2NvbmZpZ19paSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9jb25maWdfaWkgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2NvbmZpZ19paSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fY29uZmlnX2lpJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fY29uZmlnX2ogPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9jb25maWdfaiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fY29uZmlnX2ogPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2NvbmZpZ19qJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9jb25maWdfaiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcWZtdF90b2tlbiA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3FmbXRfdG9rZW4nXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3FmbXRfdG9rZW4gPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3FmbXRfdG9rZW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3FmbXRfdG9rZW4nXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2luaXRfd2FzbWZzID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcyA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2luaXRfd2FzbWZzJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnRwdHInXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludHB0ciA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnRwdHInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0ciddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0ciA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF92b2lkcHRyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X3ZvaWRwdHInXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9tYXggPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4J1xuICAgIF0gPSAoKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4ID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21heCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9tYXgnXSkoKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWluID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbidcbiAgICBdID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbiA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWluJ10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF90aW1lczInXG4gICAgXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfdGltZXMyJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfdGltZXMyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWlubWF4ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWlubWF4J1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWlubWF4J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0cHRyID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NHB0ciddID1cbiAgICAgIChhMCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRwdHIgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRwdHInXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NHB0ciddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93J1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X3N0cl9oZWxsbyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJfaGVsbG8nXG4gICAgXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X3N0cl9oZWxsbyA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJfaGVsbG8nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3Rfc3RyX2hlbGxvJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYidcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfbWFsbG9jID0gKE1vZHVsZVsnX21hbGxvYyddID0gKGEwKSA9PlxuICAgICAgKF9tYWxsb2MgPSBNb2R1bGVbJ19tYWxsb2MnXSA9IHdhc21FeHBvcnRzWydtYWxsb2MnXSkoYTApKTtcbiAgICB2YXIgX2ZyZWUgPSAoTW9kdWxlWydfZnJlZSddID0gKGEwKSA9PlxuICAgICAgKF9mcmVlID0gTW9kdWxlWydfZnJlZSddID0gd2FzbUV4cG9ydHNbJ2ZyZWUnXSkoYTApKTtcbiAgICB2YXIgX3JlYWxsb2MgPSAoTW9kdWxlWydfcmVhbGxvYyddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfcmVhbGxvYyA9IE1vZHVsZVsnX3JlYWxsb2MnXSA9IHdhc21FeHBvcnRzWydyZWFsbG9jJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gKGEwLCBhMSkgPT5cbiAgICAgIChfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiddKShhMCwgYTEpO1xuICAgIHZhciBfX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSA9IChhMCkgPT5cbiAgICAgIChfX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSA9IHdhc21FeHBvcnRzWydfZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlJ10pKFxuICAgICAgICBhMCxcbiAgICAgICk7XG4gICAgdmFyIF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyA9IChhMCkgPT5cbiAgICAgIChfX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MgPSB3YXNtRXhwb3J0c1snX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MnXSkoYTApO1xuICAgIHZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9ICgpID0+XG4gICAgICAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPVxuICAgICAgICB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCddKSgpO1xuXG4gICAgTW9kdWxlWyd3YXNtTWVtb3J5J10gPSB3YXNtTWVtb3J5O1xuXG4gICAgdmFyIGNhbGxlZFJ1bjtcbiAgICB2YXIgY2FsbGVkUHJlcnVuO1xuXG4gICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbGxlZFByZXJ1bikge1xuICAgICAgICBjYWxsZWRQcmVydW4gPSAxO1xuICAgICAgICBwcmVSdW4oKTtcblxuICAgICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb1J1bigpIHtcbiAgICAgICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgICAgICBjYWxsZWRSdW4gPSAxO1xuICAgICAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gMTtcblxuICAgICAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgICAgICBpbml0UnVudGltZSgpO1xuXG4gICAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgICAgICAgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddPy4oKTtcblxuICAgICAgICBwb3N0UnVuKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJ1J1bm5pbmcuLi4nKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKSwgMSk7XG4gICAgICAgICAgZG9SdW4oKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1J1bigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ3ByZUluaXQnXSkge1xuICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gICAgICB3aGlsZSAoTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkge1xuICAgICAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJ1bigpO1xuXG4gICAgTW9kdWxlLnJ1blNRTGl0ZTNQb3N0TG9hZEluaXQgPSBmdW5jdGlvbiAoRW1zY3JpcHRlbk1vZHVsZSkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAgPSBmdW5jdGlvbiBzcWxpdGUzQXBpQm9vdHN0cmFwKFxuICAgICAgICBhcGlDb25maWcgPSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgfHxcbiAgICAgICAgICBzcWxpdGUzQXBpQm9vdHN0cmFwLmRlZmF1bHRDb25maWcsXG4gICAgICApIHtcbiAgICAgICAgaWYgKHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMykge1xuICAgICAgICAgIChzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTMuY29uZmlnIHx8IGNvbnNvbGUpLndhcm4oXG4gICAgICAgICAgICAnc3FsaXRlM0FwaUJvb3RzdHJhcCgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy4nLFxuICAgICAgICAgICAgJ0NvbmZpZyBhbmQgZXh0ZXJuYWwgaW5pdGlhbGl6ZXJzIGFyZSBpZ25vcmVkIG9uIGNhbGxzIGFmdGVyIHRoZSBmaXJzdC4nLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhwb3J0czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWVtb3J5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiaWdJbnRFbmFibGVkOiAoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISFNb2R1bGUuSEVBUFU2NCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5CaWdJbnQ2NEFycmF5O1xuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXJuOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICAgICAgICAgIGVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBsb2c6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXNtZnNPcGZzRGlyOiAnL29wZnMnLFxuXG4gICAgICAgICAgICB1c2VTdGRBbGxvYzogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcGlDb25maWcgfHwge30sXG4gICAgICAgICk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAnbWFsbG9jJyA6ICdzcWxpdGUzX21hbGxvYycsXG4gICAgICAgICAgICBkZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ2ZyZWUnIDogJ3NxbGl0ZTNfZnJlZScsXG4gICAgICAgICAgICByZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jXG4gICAgICAgICAgICAgID8gJ3JlYWxsb2MnXG4gICAgICAgICAgICAgIDogJ3NxbGl0ZTNfcmVhbGxvYycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICk7XG5cbiAgICAgICAgWydleHBvcnRzJywgJ21lbW9yeScsICd3YXNtZnNPcGZzRGlyJ10uZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgY29uZmlnW2tdKSB7XG4gICAgICAgICAgICBjb25maWdba10gPSBjb25maWdba10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmRlZmF1bHRDb25maWc7XG5cbiAgICAgICAgY29uc3QgY2FwaSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3Qgd2FzbSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgX19yY1N0ciA9IChyYykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY2FwaS5zcWxpdGUzX2pzX3JjX3N0ciAmJiBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSkgfHxcbiAgICAgICAgICAgICdVbmtub3duIHJlc3VsdCBjb2RlICMnICsgcmNcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9faXNJbnQgPSAobikgPT4gJ251bWJlcicgPT09IHR5cGVvZiBuICYmIG4gPT09IChuIHwgMCk7XG5cbiAgICAgICAgY2xhc3MgU1FMaXRlM0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoX19pc0ludChhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJjID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKF9fcmNTdHIoYXJnc1swXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByY1N0ciA9IF9fcmNTdHIocmMpO1xuICAgICAgICAgICAgICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgYXJnc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihyY1N0ciwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gcmNTdHIgKyAnOic7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKDIgPT09IGFyZ3MubGVuZ3RoICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1sxXSkge1xuICAgICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0Q29kZSA9IHJjIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NRTGl0ZTNFcnJvcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBTUUxpdGUzRXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvc3MzID0gU1FMaXRlM0Vycm9yLnRvc3M7XG5cbiAgICAgICAgaWYgKGNvbmZpZy53YXNtZnNPcGZzRGlyICYmICEvXlxcL1teL10rJC8udGVzdChjb25maWcud2FzbWZzT3Bmc0RpcikpIHtcbiAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgIFwiY29uZmlnLndhc21mc09wZnNEaXIgbXVzdCBiZSBmYWxzeSBvciBpbiB0aGUgZm9ybSAnL2Rpci1uYW1lJy5cIixcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNJbnQzMiA9IChuKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdiaWdpbnQnICE9PSB0eXBlb2YgbiAmJlxuICAgICAgICAgICAgISEobiA9PT0gKG4gfCAwKSAmJiBuIDw9IDIxNDc0ODM2NDcgJiYgbiA+PSAtMjE0NzQ4MzY0OClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludEZpdHM2NCA9IGZ1bmN0aW9uIGYoYikge1xuICAgICAgICAgIGlmICghZi5fbWF4KSB7XG4gICAgICAgICAgICBmLl9tYXggPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpO1xuICAgICAgICAgICAgZi5fbWluID0gfmYuX21heDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludEZpdHMzMiA9IChiKSA9PiBiID49IC0weDdmZmZmZmZmbiAtIDFuICYmIGIgPD0gMHg3ZmZmZmZmZm47XG5cbiAgICAgICAgY29uc3QgYmlnSW50Rml0c0RvdWJsZSA9IGZ1bmN0aW9uIGYoYikge1xuICAgICAgICAgIGlmICghZi5fbWluKSB7XG4gICAgICAgICAgICBmLl9taW4gPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGYuX21heCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYiA+PSBmLl9taW4gJiYgYiA8PSBmLl9tYXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXNUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gdiAmJiB2LmNvbnN0cnVjdG9yICYmIGlzSW50MzIodi5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVClcbiAgICAgICAgICAgID8gdlxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX1NBQiA9XG4gICAgICAgICAgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgOiBTaGFyZWRBcnJheUJ1ZmZlcjtcblxuICAgICAgICBjb25zdCBpc1NoYXJlZFR5cGVkQXJyYXkgPSAoYVR5cGVkQXJyYXkpID0+XG4gICAgICAgICAgYVR5cGVkQXJyYXkuYnVmZmVyIGluc3RhbmNlb2YgX19TQUI7XG5cbiAgICAgICAgY29uc3QgdHlwZWRBcnJheVBhcnQgPSAoYVR5cGVkQXJyYXksIGJlZ2luLCBlbmQpID0+IHtcbiAgICAgICAgICByZXR1cm4gaXNTaGFyZWRUeXBlZEFycmF5KGFUeXBlZEFycmF5KVxuICAgICAgICAgICAgPyBhVHlwZWRBcnJheS5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICAgICAgOiBhVHlwZWRBcnJheS5zdWJhcnJheShiZWdpbiwgZW5kKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc0JpbmRhYmxlVHlwZWRBcnJheSA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHYgJiZcbiAgICAgICAgICAgICh2IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzU1FMYWJsZVR5cGVkQXJyYXkgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB2ICYmXG4gICAgICAgICAgICAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc0JpbmRhYmxlVHlwZWRBcnJheSh2KSB8fFxuICAgICAgICAgICAgdG9zczMoJ1ZhbHVlIGlzIG5vdCBvZiBhIHN1cHBvcnRlZCBUeXBlZEFycmF5IHR5cGUuJylcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXG4gICAgICAgIGNvbnN0IHR5cGVkQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uICh0eXBlZEFycmF5LCBiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZSh0eXBlZEFycmF5UGFydCh0eXBlZEFycmF5LCBiZWdpbiwgZW5kKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZmxleGlibGVTdHJpbmcgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmIChpc1NRTGFibGVUeXBlZEFycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheSh2KSA6IHYsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIHYuam9pbignJyk7XG4gICAgICAgICAgZWxzZSBpZiAod2FzbS5pc1B0cih2KSkgdiA9IHdhc20uY3N0clRvSnModik7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xhc3MgV2FzbUFsbG9jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKDIgPT09IGFyZ3MubGVuZ3RoICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1sxXSkge1xuICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3VwZXIoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VwZXIoJ0FsbG9jYXRpb24gZmFpbGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHRDb2RlID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnV2FzbUFsbG9jRXJyb3InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBXYXNtQWxsb2NFcnJvciguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNhcGksIHtcbiAgICAgICAgICBzcWxpdGUzX2JpbmRfYmxvYjogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgc3FsaXRlM19iaW5kX3RleHQ6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIHNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyOiAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uOiAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb246IChcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgICAgeEludmVyc2UsXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19wcmVwYXJlX3YzOiAoXG4gICAgICAgICAgICBkYlB0cixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbEJ5dGVMZW4sXG4gICAgICAgICAgICBwcmVwRmxhZ3MsXG4gICAgICAgICAgICBzdG10UHRyUHRyLFxuICAgICAgICAgICAgc3RyUHRyUHRyLFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX3ByZXBhcmVfdjI6IChcbiAgICAgICAgICAgIGRiUHRyLFxuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgc3FsQnl0ZUxlbixcbiAgICAgICAgICAgIHN0bXRQdHJQdHIsXG4gICAgICAgICAgICBzdHJQdHJQdHIsXG4gICAgICAgICAgKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfZXhlYzogKHBEYiwgc3FsLCBjYWxsYmFjaywgcFZvaWQsIHBFcnJNc2cpID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19yYW5kb21uZXNzOiAobiwgb3V0UHRyKSA9PiB7fSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXRpbCA9IHtcbiAgICAgICAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXksXG4gICAgICAgICAgZmxleGlibGVTdHJpbmcsXG4gICAgICAgICAgYmlnSW50Rml0czMyLFxuICAgICAgICAgIGJpZ0ludEZpdHM2NCxcbiAgICAgICAgICBiaWdJbnRGaXRzRG91YmxlLFxuICAgICAgICAgIGlzQmluZGFibGVUeXBlZEFycmF5LFxuICAgICAgICAgIGlzSW50MzIsXG4gICAgICAgICAgaXNTUUxhYmxlVHlwZWRBcnJheSxcbiAgICAgICAgICBpc1R5cGVkQXJyYXksXG4gICAgICAgICAgdHlwZWRBcnJheVRvU3RyaW5nLFxuICAgICAgICAgIGlzVUlUaHJlYWQ6ICgpID0+XG4gICAgICAgICAgICBnbG9iYWxUaGlzLndpbmRvdyA9PT0gZ2xvYmFsVGhpcyAmJiAhIWdsb2JhbFRoaXMuZG9jdW1lbnQsXG5cbiAgICAgICAgICBpc1NoYXJlZFR5cGVkQXJyYXksXG4gICAgICAgICAgdG9zczogZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b3NzMyxcbiAgICAgICAgICB0eXBlZEFycmF5UGFydCxcblxuICAgICAgICAgIGFmZmlybURiSGVhZGVyOiBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9ICdTUUxpdGUgZm9ybWF0IDMnO1xuICAgICAgICAgICAgaWYgKGhlYWRlci5sZW5ndGggPiBieXRlcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnB1dCBkb2VzIG5vdCBjb250YWluIGFuIFNRTGl0ZTMgZGF0YWJhc2UgaGVhZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGhlYWRlci5jaGFyQ29kZUF0KGkpICE9PSBieXRlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKCdJbnB1dCBkb2VzIG5vdCBjb250YWluIGFuIFNRTGl0ZTMgZGF0YWJhc2UgaGVhZGVyLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmZmlybUlzRGI6IGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDUxMiB8fCBuICUgNTEyICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdCeXRlIGFycmF5IHNpemUnLCBuLCAnaXMgaW52YWxpZCBmb3IgYW4gU1FMaXRlMyBkYi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoYnl0ZXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih3YXNtLCB7XG4gICAgICAgICAgcHRyU2l6ZW9mOiBjb25maWcud2FzbVB0clNpemVvZiB8fCA0LFxuXG4gICAgICAgICAgcHRySVI6IGNvbmZpZy53YXNtUHRySVIgfHwgJ2kzMicsXG5cbiAgICAgICAgICBiaWdJbnRFbmFibGVkOiAhIWNvbmZpZy5iaWdJbnRFbmFibGVkLFxuXG4gICAgICAgICAgZXhwb3J0czpcbiAgICAgICAgICAgIGNvbmZpZy5leHBvcnRzIHx8XG4gICAgICAgICAgICB0b3NzMygnTWlzc2luZyBBUEkgY29uZmlnLmV4cG9ydHMgKFdBU00gbW9kdWxlIGV4cG9ydHMpLicpLFxuXG4gICAgICAgICAgbWVtb3J5OlxuICAgICAgICAgICAgY29uZmlnLm1lbW9yeSB8fFxuICAgICAgICAgICAgY29uZmlnLmV4cG9ydHNbJ21lbW9yeSddIHx8XG4gICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgJ0FQSSBjb25maWcgb2JqZWN0IHJlcXVpcmVzIGEgV2ViQXNzZW1ibHkuTWVtb3J5IG9iamVjdCcsXG4gICAgICAgICAgICAgICdpbiBlaXRoZXIgY29uZmlnLmV4cG9ydHMubWVtb3J5IChleHBvcnRlZCknLFxuICAgICAgICAgICAgICAnb3IgY29uZmlnLm1lbW9yeSAoaW1wb3J0ZWQpLicsXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgYWxsb2M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIHJlYWxsb2M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIGRlYWxsb2M6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5ID0gZnVuY3Rpb24gKHNyY1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICBpZiAoc3JjVHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBzcmNUeXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFmZmlybUJpbmRhYmxlVHlwZWRBcnJheShzcmNUeXBlZEFycmF5KTtcbiAgICAgICAgICBjb25zdCBwUmV0ID0gd2FzbS5hbGxvYyhzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggfHwgMSk7XG4gICAgICAgICAgd2FzbVxuICAgICAgICAgICAgLmhlYXBGb3JTaXplKHNyY1R5cGVkQXJyYXkuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuc2V0KHNyY1R5cGVkQXJyYXkuYnl0ZUxlbmd0aCA/IHNyY1R5cGVkQXJyYXkgOiBbMF0sIHBSZXQpO1xuICAgICAgICAgIHJldHVybiBwUmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBrZXlBbGxvYyA9IGNvbmZpZy5hbGxvY0V4cG9ydE5hbWUsXG4gICAgICAgICAgICBrZXlEZWFsbG9jID0gY29uZmlnLmRlYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgICAga2V5UmVhbGxvYyA9IGNvbmZpZy5yZWFsbG9jRXhwb3J0TmFtZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBba2V5QWxsb2MsIGtleURlYWxsb2MsIGtleVJlYWxsb2NdKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gd2FzbS5leHBvcnRzW2tleV07XG4gICAgICAgICAgICBpZiAoIShmIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyByZXF1aXJlZCBleHBvcnRzWycsIGtleSwgJ10gZnVuY3Rpb24uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2FzbS5hbGxvYyA9IGZ1bmN0aW9uIGYobikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZi5pbXBsKG4pIHx8XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoJ0ZhaWxlZCB0byBhbGxvY2F0ZScsIG4sICcgYnl0ZXMuJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YXNtLmFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5QWxsb2NdO1xuICAgICAgICAgIHdhc20ucmVhbGxvYyA9IGZ1bmN0aW9uIGYobSwgbikge1xuICAgICAgICAgICAgY29uc3QgbTIgPSBmLmltcGwobSwgbik7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICA/IG0yIHx8IFdhc21BbGxvY0Vycm9yLnRvc3MoJ0ZhaWxlZCB0byByZWFsbG9jYXRlJywgbiwgJyBieXRlcy4nKVxuICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YXNtLnJlYWxsb2MuaW1wbCA9IHdhc20uZXhwb3J0c1trZXlSZWFsbG9jXTtcbiAgICAgICAgICB3YXNtLmRlYWxsb2MgPSB3YXNtLmV4cG9ydHNba2V5RGVhbGxvY107XG4gICAgICAgIH1cblxuICAgICAgICB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkID0gZnVuY3Rpb24gZihvcHROYW1lKSB7XG4gICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZi5fcmVzdWx0KSByZXR1cm4gZi5fcmVzdWx0O1xuICAgICAgICAgICAgZWxzZSBpZiAoIWYuX29wdCkge1xuICAgICAgICAgICAgICBmLl9yeCA9IC9eKFtePV0rKT0oLispLztcbiAgICAgICAgICAgICAgZi5fcnhJbnQgPSAvXi0/XFxkKyQvO1xuICAgICAgICAgICAgICBmLl9vcHQgPSBmdW5jdGlvbiAob3B0LCBydikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmLl9yeC5leGVjKG9wdCk7XG4gICAgICAgICAgICAgICAgcnZbMF0gPSBtID8gbVsxXSA6IG9wdDtcbiAgICAgICAgICAgICAgICBydlsxXSA9IG0gPyAoZi5fcnhJbnQudGVzdChtWzJdKSA/ICttWzJdIDogbVsyXSkgOiB0cnVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmMgPSB7fSxcbiAgICAgICAgICAgICAgb3YgPSBbMCwgMF07XG4gICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgIGs7XG4gICAgICAgICAgICB3aGlsZSAoKGsgPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQoaSsrKSkpIHtcbiAgICAgICAgICAgICAgZi5fb3B0KGssIG92KTtcbiAgICAgICAgICAgICAgcmNbb3ZbMF1dID0gb3ZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGYuX3Jlc3VsdCA9IHJjKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJjID0ge307XG4gICAgICAgICAgICBvcHROYW1lLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgICAgcmNbdl0gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG9wdE5hbWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdE5hbWUpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgb3B0TmFtZVtrXSA9IGNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQoayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcHROYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ3N0cmluZycgPT09IHR5cGVvZiBvcHROYW1lXG4gICAgICAgICAgICA/ICEhY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZChvcHROYW1lKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB3YXNtLnBzdGFjayA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgIHJlc3RvcmU6IHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX3BzdGFja19yZXN0b3JlLFxuXG4gICAgICAgICAgYWxsb2M6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuICYmICEobiA9IHdhc20uc2l6ZW9mSVIobikpKSB7XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUgZm9yIHBzdGFjay5hbGxvYygnLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MobikgfHxcbiAgICAgICAgICAgICAgV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAnQ291bGQgbm90IGFsbG9jYXRlJyxcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICdieXRlcyBmcm9tIHRoZSBwc3RhY2suJyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYWxsb2NDaHVua3M6IGZ1bmN0aW9uIChuLCBzeikge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygc3ogJiYgIShzeiA9IHdhc20uc2l6ZW9mSVIoc3opKSkge1xuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIHNpemUgdmFsdWUgZm9yIGFsbG9jQ2h1bmtzKCcsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lbSA9IHdhc20ucHN0YWNrLmFsbG9jKG4gKiBzeik7XG4gICAgICAgICAgICBjb25zdCByYyA9IFtdO1xuICAgICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBuOyArK2ksIG9mZnNldCArPSBzeikgcmMucHVzaChtZW0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhbGxvY1B0cjogKG4gPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAxID09PSBuXG4gICAgICAgICAgICAgID8gd2FzbS5wc3RhY2suYWxsb2Moc2FmZVB0clNpemUgPyA4IDogd2FzbS5wdHJTaXplb2YpXG4gICAgICAgICAgICAgIDogd2FzbS5wc3RhY2suYWxsb2NDaHVua3Mobiwgc2FmZVB0clNpemUgPyA4IDogd2FzbS5wdHJTaXplb2YpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tQb3MgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYoc3FsaXRlMyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2FzbS5wc3RhY2ssIHtcbiAgICAgICAgICBwb2ludGVyOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgaXRlcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBxdW90YToge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGl0ZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZW1haW5pbmc6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3JhbmRvbW5lc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDEgPT09IGFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICB1dGlsLmlzVHlwZWRBcnJheShhcmdzWzBdKSAmJlxuICAgICAgICAgICAgMSA9PT0gYXJnc1swXS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgdGEgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKDAgPT09IHRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcygwLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IG4gPSB0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzO1xuICAgICAgICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgICAgICAgY29uc3QgbkFsbG9jID0gbiA8IDUxMiA/IG4gOiA1MTI7XG4gICAgICAgICAgICAgIGNvbnN0IHB0ciA9IHdhc20ucHN0YWNrLmFsbG9jKG5BbGxvYyk7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqID0gbiA+IG5BbGxvYyA/IG5BbGxvYyA6IG47XG4gICAgICAgICAgICAgICAgcihqLCBwdHIpO1xuICAgICAgICAgICAgICAgIHRhLnNldCh0eXBlZEFycmF5UGFydChoZWFwLCBwdHIsIHB0ciArIGopLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG4gLT0gajtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gajtcbiAgICAgICAgICAgICAgfSB3aGlsZSAobiA+IDApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdIaWdobHkgdW5leHBlY3RlZCAoYW5kIGlnbm9yZWQhKSAnICtcbiAgICAgICAgICAgICAgICAgICdleGNlcHRpb24gaW4gc3FsaXRlM19yYW5kb21uZXNzKCk6JyxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3MoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IF9fd2FzbWZzT3Bmc0RpciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IF9fd2FzbWZzT3Bmc0RpcikgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpcjtcblxuICAgICAgICAgIGNvbnN0IHBkaXIgPSBjb25maWcud2FzbWZzT3Bmc0RpcjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhcGRpciB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwZGlyICYmXG4gICAgICAgICAgICAgIDAgPT09XG4gICAgICAgICAgICAgICAgd2FzbS54Q2FsbFdyYXBwZWQoXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcycsXG4gICAgICAgICAgICAgICAgICAnaTMyJyxcbiAgICAgICAgICAgICAgICAgIFsnc3RyaW5nJ10sXG4gICAgICAgICAgICAgICAgICBwZGlyLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gKF9fd2FzbWZzT3Bmc0RpciA9IHBkaXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM193YXNtZnNfZmlsZW5hbWVfaXNfcGVyc2lzdGVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgY29uc3QgcCA9IGNhcGkuc3FsaXRlM193YXNtZnNfb3Bmc19kaXIoKTtcbiAgICAgICAgICByZXR1cm4gcCAmJiBuYW1lID8gbmFtZS5zdGFydHNXaXRoKHAgKyAnLycpIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2RiX3VzZXNfdmZzID0gZnVuY3Rpb24gKHBEYiwgdmZzTmFtZSwgZGJOYW1lID0gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwSyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCh2ZnNOYW1lKTtcbiAgICAgICAgICAgIGlmICghcEspIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwRGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBLID09PSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCkgPyBwSyA6IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBLID09PSBjYXBpLnNxbGl0ZTNfanNfZGJfdmZzKHBEYiwgZGJOYW1lKSA/IHBLIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfdmZzX2xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgcmMgPSBbXTtcbiAgICAgICAgICBsZXQgcFZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCgwKTtcbiAgICAgICAgICB3aGlsZSAocFZmcykge1xuICAgICAgICAgICAgY29uc3Qgb1ZmcyA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICAgICAgcmMucHVzaCh3YXNtLmNzdHJUb0pzKG9WZnMuJHpOYW1lKSk7XG4gICAgICAgICAgICBwVmZzID0gb1Zmcy4kcE5leHQ7XG4gICAgICAgICAgICBvVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQgPSBmdW5jdGlvbiAocERiLCBzY2hlbWEgPSAwKSB7XG4gICAgICAgICAgcERiID0gd2FzbS54V3JhcC50ZXN0Q29udmVydEFyZygnc3FsaXRlMyonLCBwRGIpO1xuICAgICAgICAgIGlmICghcERiKSB0b3NzMygnSW52YWxpZCBzcWxpdGUzKiBhcmd1bWVudC4nKTtcbiAgICAgICAgICBpZiAoIXdhc20uYmlnSW50RW5hYmxlZCkgdG9zczMoJ0JpZ0ludDY0IHN1cHBvcnQgaXMgbm90IGVuYWJsZWQuJyk7XG4gICAgICAgICAgY29uc3Qgc2NvcGUgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgICAgIGxldCBwT3V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwU2l6ZSA9IHdhc20uc2NvcGVkQWxsb2MoOCArIHdhc20ucHRyU2l6ZW9mKTtcbiAgICAgICAgICAgIGNvbnN0IHBwT3V0ID0gcFNpemUgKyA4O1xuXG4gICAgICAgICAgICBjb25zdCB6U2NoZW1hID0gc2NoZW1hXG4gICAgICAgICAgICAgID8gd2FzbS5pc1B0cihzY2hlbWEpXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFcbiAgICAgICAgICAgICAgICA6IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKCcnICsgc2NoZW1hKVxuICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBsZXQgcmMgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9kYl9zZXJpYWxpemUoXG4gICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgelNjaGVtYSxcbiAgICAgICAgICAgICAgcHBPdXQsXG4gICAgICAgICAgICAgIHBTaXplLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYykge1xuICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAnRGF0YWJhc2Ugc2VyaWFsaXphdGlvbiBmYWlsZWQgd2l0aCBjb2RlJyxcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcE91dCA9IHdhc20ucGVla1B0cihwcE91dCk7XG4gICAgICAgICAgICBjb25zdCBuT3V0ID0gd2FzbS5wZWVrKHBTaXplLCAnaTY0Jyk7XG4gICAgICAgICAgICByYyA9IG5PdXRcbiAgICAgICAgICAgICAgPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBPdXQsIHBPdXQgKyBOdW1iZXIobk91dCkpXG4gICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHBPdXQpIHdhc20uZXhwb3J0cy5zcWxpdGUzX2ZyZWUocE91dCk7XG4gICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyA9IChkYlBvaW50ZXIsIGRiTmFtZSA9IDApID0+XG4gICAgICAgICAgdXRpbC5zcWxpdGUzX193YXNtX2RiX3ZmcyhkYlBvaW50ZXIsIGRiTmFtZSk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gKHBDdHgsIG4pID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0KHBDdHgsIG4pIHx8XG4gICAgICAgICAgICAoblxuICAgICAgICAgICAgICA/IFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgICAnQ2Fubm90IGFsbG9jYXRlJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnYnl0ZXMgZm9yIHNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQoKScsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IDApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGRhdGEsIGRhdGFMZW4pIHtcbiAgICAgICAgICBsZXQgcERhdGE7XG4gICAgICAgICAgaWYgKGRhdGEgJiYgd2FzbS5pc1B0cihkYXRhKSkge1xuICAgICAgICAgICAgcERhdGEgPSBkYXRhO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICAgICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyB8fCAhdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW4gPCAwKSB7XG4gICAgICAgICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAnSW52YWxpZCAybmQgYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW4gPCAwKSB7XG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYyA9IHV0aWwuc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZShcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHBEYXRhLFxuICAgICAgICAgICAgICBkYXRhTGVuLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgdmZzLFxuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGF0YUxlbixcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uZmlnLndhcm4oXG4gICAgICAgICAgICAnc3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUoKSBpcyBkZXByZWNhdGVkIGFuZCcsXG4gICAgICAgICAgICAnc2hvdWxkIGJlIGF2b2lkZWQgYmVjYXVzZSBpdCBjYW4gbGVhZCB0byBDLWxldmVsIGNyYXNoZXMuJyxcbiAgICAgICAgICAgICdTZWUgaXRzIGRvY3VtZW50YXRpb24gZm9yIGFsdGVybmF0aXZlIG9wdGlvbnMuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBwRGF0YTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKHdhc20uaXNQdHIoZGF0YSkpIHtcbiAgICAgICAgICAgICAgcERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHBEYXRhID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDQgfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8XG4gICAgICAgICAgICAgICAgZGF0YUxlbiA8IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGF0YUxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcERhdGEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuIDwgMCkge1xuICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHBEYXRhKTtcbiAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAnSW52YWxpZCA0dGggYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHV0aWwuc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIHZmcyxcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHBEYXRhLFxuICAgICAgICAgICAgICBkYXRhTGVuLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19zcWxfdG9fc3RyaW5nID0gKHNxbCkgPT4ge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNxbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNxbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeCA9IGZsZXhpYmxlU3RyaW5nKHYpO1xuICAgICAgICAgIHJldHVybiB4ID09PSB2ID8gdW5kZWZpbmVkIDogeDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICBjb25zdCBfX2t2dmZzSW5mbyA9IGZ1bmN0aW9uICh3aGljaCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmMucHJlZml4ID0gJ2t2dmZzLScgKyB3aGljaDtcbiAgICAgICAgICAgIHJjLnN0b3JlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCdzZXNzaW9uJyA9PT0gd2hpY2ggfHwgJycgPT09IHdoaWNoKVxuICAgICAgICAgICAgICByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLnNlc3Npb25TdG9yYWdlKTtcbiAgICAgICAgICAgIGlmICgnbG9jYWwnID09PSB3aGljaCB8fCAnJyA9PT0gd2hpY2gpXG4gICAgICAgICAgICAgIHJjLnN0b3Jlcy5wdXNoKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyID0gZnVuY3Rpb24gKHdoaWNoID0gJycpIHtcbiAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICBjb25zdCBrdmluZm8gPSBfX2t2dmZzSW5mbyh3aGljaCk7XG4gICAgICAgICAgICBrdmluZm8uc3RvcmVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9SbSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSkgdG9SbS5wdXNoKGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvUm0uZm9yRWFjaCgoa2spID0+IHMucmVtb3ZlSXRlbShraykpO1xuICAgICAgICAgICAgICByYyArPSB0b1JtLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZSA9IGZ1bmN0aW9uICh3aGljaCA9ICcnKSB7XG4gICAgICAgICAgICBsZXQgc3ogPSAwO1xuICAgICAgICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAgICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBzLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAoay5zdGFydHNXaXRoKGt2aW5mby5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICBzeiArPSBrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHN6ICs9IHMuZ2V0SXRlbShrKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzeiAqIDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcGkuc3FsaXRlM19kYl9jb25maWcgPSBmdW5jdGlvbiAocERiLCBvcCwgLi4uYXJncykge1xuICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZLRVk6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfRlRTM19UT0tFTklaRVI6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9MT0FEX0VYVEVOU0lPTjpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTk9fQ0tQVF9PTl9DTE9TRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0c6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSSUdHRVJfRVFQOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfREVGRU5TSVZFOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9BTFRFUl9UQUJMRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RNTDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RETDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVc6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUzpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVI6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9BVFRBQ0hfQ1JFQVRFOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfQVRUQUNIX1dSSVRFOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfQ09NTUVOVFM6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5pcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXAgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcCcsICdpbnQnLCBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pcChwRGIsIG9wLCBhcmdzWzBdLCBhcmdzWzFdIHx8IDApO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MT09LQVNJREU6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5waWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpaSA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaScsICdpbnQnLCBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBpaShwRGIsIG9wLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTUFJTkRCTkFNRTpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zKHBEYiwgb3AsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgcFZhbCxcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBhcmc7XG4gICAgICAgICAgY29uc3QgdmFsVHlwZSA9IGNhcGkuc3FsaXRlM192YWx1ZV90eXBlKHBWYWwpO1xuICAgICAgICAgIHN3aXRjaCAodmFsVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOlxuICAgICAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2ludDY0KHBWYWwpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUoYXJnKSkgYXJnID0gTnVtYmVyKGFyZyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9kb3VibGUocFZhbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdGV4dChwVmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IGNhcGkuc3FsaXRlM192YWx1ZV9ieXRlcyhwVmFsKTtcbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYmxvYihwVmFsKTtcbiAgICAgICAgICAgICAgaWYgKG4gJiYgIXBCbG9iKVxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWxsb2NhdGUgbWVtb3J5IGZvciBibG9iIGFyZ3VtZW50IG9mJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnYnl0ZShzKScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXJnID0gbiA/IHdhc20uaGVhcDh1KCkuc2xpY2UocEJsb2IsIHBCbG9iICsgTnVtYmVyKG4pKSA6IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9OVUxMOlxuICAgICAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0aHJvd0lmQ2Fubm90Q29udmVydCkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgICAgICAgICAnVW5oYW5kbGVkIHNxbGl0ZTNfdmFsdWVfdHlwZSgpOicsXG4gICAgICAgICAgICAgICAgICB2YWxUeXBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgYXJnYyxcbiAgICAgICAgICBwQXJndixcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGNvbnN0IHRndCA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgICAgIHRndC5wdXNoKFxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMoXG4gICAgICAgICAgICAgICAgd2FzbS5wZWVrUHRyKHBBcmd2ICsgd2FzbS5wdHJTaXplb2YgKiBpKSxcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0Z3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyA9IGZ1bmN0aW9uIChwQ3R4LCBlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbShwQ3R4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcihwQ3R4LCAnJyArIGUsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyA9IGZ1bmN0aW9uIChwQ3R4LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuYmlnSW50Rml0czMyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50KHBDdHgsIE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuYmlnSW50Rml0c0RvdWJsZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZShwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKVxuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDY0KHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgICAgICdCaWdJbnQgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICdpcyB0b28gQmlnSW50IGZvciBpbnQ2NC4nLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b3NzMygnQmlnSW50IHZhbHVlJywgdmFsLnRvU3RyaW5nKCksICdpcyB0b28gQmlnSW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIGxldCBmO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIodmFsKSkge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICB3YXNtLmJpZ0ludEVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgdXRpbC5iaWdJbnRGaXRzNjQoQmlnSW50KHZhbCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfZG91YmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmKHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF90ZXh0KHBDdHgsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X251bGwocEN0eCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfYmxvYihcbiAgICAgICAgICAgICAgICAgICAgcEN0eCxcbiAgICAgICAgICAgICAgICAgICAgcEJsb2IsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBcIkRvbid0IG5vdCBob3cgdG8gaGFuZGxlIHRoaXMgVURGIHJlc3VsdCB2YWx1ZTpcIixcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwsXG4gICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfY29sdW1uX2pzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHBTdG10LFxuICAgICAgICAgIGlDb2wsXG4gICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB2ID0gY2FwaS5zcWxpdGUzX2NvbHVtbl92YWx1ZShwU3RtdCwgaUNvbCk7XG4gICAgICAgICAgcmV0dXJuIDAgPT09IHZcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyh2LCB0aHJvd0lmQ2Fubm90Q29udmVydCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19uZXdPbGRWYWx1ZSA9IGZ1bmN0aW9uIChwT2JqLCBpQ29sLCBpbXBsKSB7XG4gICAgICAgICAgaW1wbCA9IGNhcGlbaW1wbF07XG4gICAgICAgICAgaWYgKCF0aGlzLnB0cikgdGhpcy5wdHIgPSB3YXNtLmFsbG9jUHRyKCk7XG4gICAgICAgICAgZWxzZSB3YXNtLnBva2VQdHIodGhpcy5wdHIsIDApO1xuICAgICAgICAgIGNvbnN0IHJjID0gaW1wbChwT2JqLCBpQ29sLCB0aGlzLnB0cik7XG4gICAgICAgICAgaWYgKHJjKVxuICAgICAgICAgICAgcmV0dXJuIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzJdICsgJygpIGZhaWxlZCB3aXRoIGNvZGUgJyArIHJjLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBwdiA9IHdhc20ucGVla1B0cih0aGlzLnB0cik7XG4gICAgICAgICAgcmV0dXJuIHB2ID8gY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKHB2LCB0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfbmV3X2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX25ldycpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfb2xkX2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCcpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9uZXdfanMgPSAocENoYW5nZXNldEl0ZXIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCwgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3Jyk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzY2hhbmdlc2V0X29sZF9qcyA9IChwQ2hhbmdlc2V0SXRlciwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBDaGFuZ2VzZXRJdGVyLCBpQ29sLCAnc3FsaXRlM2NoYW5nZXNldF9vbGQnKTtcblxuICAgICAgICBjb25zdCBzcWxpdGUzID0ge1xuICAgICAgICAgIFdhc21BbGxvY0Vycm9yOiBXYXNtQWxsb2NFcnJvcixcbiAgICAgICAgICBTUUxpdGUzRXJyb3I6IFNRTGl0ZTNFcnJvcixcbiAgICAgICAgICBjYXBpLFxuICAgICAgICAgIHV0aWwsXG4gICAgICAgICAgd2FzbSxcbiAgICAgICAgICBjb25maWcsXG5cbiAgICAgICAgICB2ZXJzaW9uOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgICAgY2xpZW50OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBhc3luY1Bvc3RJbml0OiBhc3luYyBmdW5jdGlvbiBmZigpIHtcbiAgICAgICAgICAgIGlmIChmZi5pc1JlYWR5IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIGZmLmlzUmVhZHk7XG4gICAgICAgICAgICBsZXQgbGlhID0gc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3FsaXRlMy5fX2lzVW5kZXJUZXN0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNxbGl0ZTMudXRpbDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLlN0cnVjdEJpbmRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3FsaXRlMztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYXRjaGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uZmlnLmVycm9yKCdhbiBhc3luYyBzcWxpdGUzIGluaXRpYWxpemVyIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWxpYSB8fCAhbGlhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwb3N0SW5pdCgpLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpYSA9IGxpYS5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFzeW5jICh4KSA9PiBmKHNxbGl0ZTMpIDogZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlhLnB1c2gocG9zdEluaXQpO1xuICAgICAgICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICAgICAgICB3aGlsZSAobGlhLmxlbmd0aCkgcCA9IHAudGhlbihsaWEuc2hpZnQoKSk7XG4gICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2NyaXB0SW5mbzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgICAgIGYoc3FsaXRlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzIGJvb3RzdHJhcCBpbml0aWFsaXplciB0aHJldzonLCBlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycztcbiAgICAgICAgc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gc3FsaXRlMztcbiAgICAgICAgcmV0dXJuIHNxbGl0ZTM7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzID0gW107XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYyA9IFtdO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gdW5kZWZpbmVkO1xuXG4gICAgICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB0YXJnZXQuYmlnSW50RW5hYmxlZCA9ICEhZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRhcmdldC5leHBvcnRzKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ2V4cG9ydHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB0YXJnZXQuaW5zdGFuY2UgJiYgdGFyZ2V0Lmluc3RhbmNlLmV4cG9ydHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdHJJUiA9IHRhcmdldC5wb2ludGVySVIgfHwgJ2kzMic7XG4gICAgICAgIGNvbnN0IHB0clNpemVvZiA9ICh0YXJnZXQucHRyU2l6ZW9mID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVJcbiAgICAgICAgICAgID8gNFxuICAgICAgICAgICAgOiAnaTY0JyA9PT0gcHRySVJcbiAgICAgICAgICAgICAgPyA4XG4gICAgICAgICAgICAgIDogdG9zcygnVW5oYW5kbGVkIHB0clNpemVvZjonLCBwdHJJUikpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS5oZWFwU2l6ZSA9IDA7XG5cbiAgICAgICAgY2FjaGUubWVtb3J5ID0gbnVsbDtcblxuICAgICAgICBjYWNoZS5mcmVlRnVuY0luZGV4ZXMgPSBbXTtcblxuICAgICAgICBjYWNoZS5zY29wZWRBbGxvYyA9IFtdO1xuXG4gICAgICAgIGNhY2hlLnV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGNhY2hlLnV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG4gICAgICAgIHRhcmdldC5zaXplb2ZJUiA9IChuKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgIHJldHVybiBwdHJTaXplb2Y7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gKCcnICsgbikuZW5kc1dpdGgoJyonKSA/IHB0clNpemVvZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGVhcFdyYXBwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghY2FjaGUubWVtb3J5KSB7XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgPVxuICAgICAgICAgICAgICB0YXJnZXQubWVtb3J5IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5XG4gICAgICAgICAgICAgICAgPyB0YXJnZXQubWVtb3J5XG4gICAgICAgICAgICAgICAgOiB0YXJnZXQuZXhwb3J0cy5tZW1vcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYiA9IGNhY2hlLm1lbW9yeS5idWZmZXI7XG4gICAgICAgICAgY2FjaGUuSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVA4VSA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNlUgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyVSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNhY2hlLkhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpO1xuICAgICAgICAgICAgY2FjaGUuSEVBUDY0VSA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGUuSEVBUDMyRiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDY0RiA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuaGVhcFNpemUgPSBiLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOCA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVA4O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOHUgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAxNiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNjtcblxuICAgICAgICB0YXJnZXQuaGVhcDE2dSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAzMiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMjtcblxuICAgICAgICB0YXJnZXQuaGVhcDMydSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXBGb3JTaXplID0gZnVuY3Rpb24gKG4sIHVuc2lnbmVkID0gdHJ1ZSkge1xuICAgICAgICAgIGxldCBjdG9yO1xuICAgICAgICAgIGNvbnN0IGMgPVxuICAgICAgICAgICAgY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgPyBjYWNoZVxuICAgICAgICAgICAgICA6IGhlYXBXcmFwcGVycygpO1xuICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVA4O1xuICAgICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQOFU7XG4gICAgICAgICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNjtcbiAgICAgICAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNlU7XG4gICAgICAgICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMjtcbiAgICAgICAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMlU7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDhVIDogYy5IRUFQODtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDE2VSA6IGMuSEVBUDE2O1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQMzJVIDogYy5IRUFQMzI7XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDY0VSA6IGMuSEVBUDY0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQuYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBnbG9iYWxUaGlzWydCaWdVaW50NjRBcnJheSddKSByZXR1cm4gYy5IRUFQNjRVO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gPT09IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBoZWFwRm9yU2l6ZSgpIHNpemU6IGV4cGVjdGluZyA4LCAxNiwgMzIsJyxcbiAgICAgICAgICAgICdvciAoaWYgQmlnSW50IGlzIGVuYWJsZWQpIDY0LicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmV4cG9ydHMuX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25FbnRyeSA9IGZ1bmN0aW9uIChmcHRyKSB7XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIHJldHVybiBmcHRyIDwgZnQubGVuZ3RoID8gZnQuZ2V0KGZwdHIpIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc0Z1bmNUb1dhc20gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZykge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7XG4gICAgICAgICAgICAgIHNpZ1R5cGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBpOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBwOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBQOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBzOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBqOiAnaTY0JyxcbiAgICAgICAgICAgICAgICBmOiAnZjMyJyxcbiAgICAgICAgICAgICAgICBkOiAnZjY0JyxcbiAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgdHlwZUNvZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBmNjQ6IDB4N2MsXG4gICAgICAgICAgICAgICAgZjMyOiAweDdkLFxuICAgICAgICAgICAgICAgIGk2NDogMHg3ZSxcbiAgICAgICAgICAgICAgICBpMzI6IDB4N2YsXG4gICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgIHVsZWIxMjhFbmNvZGU6IGZ1bmN0aW9uICh0Z3QsIG1ldGhvZCwgbikge1xuICAgICAgICAgICAgICAgIGlmIChuIDwgMTI4KSB0Z3RbbWV0aG9kXShuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRndFttZXRob2RdKG4gJSAxMjggfCAxMjgsIG4gPj4gNyk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgcnhKU2lnOiAvXihcXHcpXFwoKFxcdyopXFwpJC8sXG5cbiAgICAgICAgICAgICAgc2lnUGFyYW1zOiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGYuXy5yeEpTaWcuZXhlYyhzaWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtID8gbVsyXSA6IHNpZy5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgbGV0dGVyVHlwZTogKHgpID0+XG4gICAgICAgICAgICAgICAgZi5fLnNpZ1R5cGVzW3hdIHx8IHRvc3MoJ0ludmFsaWQgc2lnbmF0dXJlIGxldHRlcjonLCB4KSxcblxuICAgICAgICAgICAgICBwdXNoU2lnVHlwZTogKGRlc3QsIGxldHRlcikgPT5cbiAgICAgICAgICAgICAgICBkZXN0LnB1c2goZi5fLnR5cGVDb2Rlc1tmLl8ubGV0dGVyVHlwZShsZXR0ZXIpXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgICAgICAgc2lnID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWdQYXJhbXMgPSBmLl8uc2lnUGFyYW1zKHNpZyk7XG4gICAgICAgICAgY29uc3Qgd2FzbUNvZGUgPSBbMHgwMSwgMHg2MF07XG4gICAgICAgICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICdwdXNoJywgc2lnUGFyYW1zLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCB4IG9mIHNpZ1BhcmFtcykgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCB4KTtcbiAgICAgICAgICBpZiAoJ3YnID09PSBzaWdbMF0pIHdhc21Db2RlLnB1c2goMCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXNtQ29kZS5wdXNoKDEpO1xuICAgICAgICAgICAgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCBzaWdbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmLl8udWxlYjEyOEVuY29kZSh3YXNtQ29kZSwgJ3Vuc2hpZnQnLCB3YXNtQ29kZS5sZW5ndGgpO1xuICAgICAgICAgIHdhc21Db2RlLnVuc2hpZnQoXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHg2MSxcbiAgICAgICAgICAgIDB4NzMsXG4gICAgICAgICAgICAweDZkLFxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3YXNtQ29kZS5wdXNoKFxuICAgICAgICAgICAgMHgwMixcbiAgICAgICAgICAgIDB4MDcsXG5cbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHg2NSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDA3LFxuICAgICAgICAgICAgMHgwNSxcblxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgICAgICAgbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheSh3YXNtQ29kZSkpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlOiB7IGY6IGZ1bmMgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKS5leHBvcnRzWydmJ107XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZywgc2NvcGVkKSB7XG4gICAgICAgICAgaWYgKHNjb3BlZCAmJiAhY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBzaWc7XG4gICAgICAgICAgICBzaWcgPSBmdW5jO1xuICAgICAgICAgICAgZnVuYyA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNpZyB8fCAhKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50czogZXhwZWN0aW5nIChmdW5jdGlvbixzaWduYXR1cmUpICcgK1xuICAgICAgICAgICAgICAgICdvciAoc2lnbmF0dXJlLGZ1bmN0aW9uKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIGNvbnN0IG9sZExlbiA9IGZ0Lmxlbmd0aDtcbiAgICAgICAgICBsZXQgcHRyO1xuICAgICAgICAgIHdoaWxlIChjYWNoZS5mcmVlRnVuY0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwdHIgPSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoZnQuZ2V0KHB0cikpIHtcbiAgICAgICAgICAgICAgcHRyID0gbnVsbDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHB0ciA9IG9sZExlbjtcbiAgICAgICAgICAgIGZ0Lmdyb3coMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmdW5jKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgICAgICAgICBpZiAocHRyID09PSBvbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZwdHIgPSB0YXJnZXQuanNGdW5jVG9XYXNtKGZ1bmMsIHNpZyk7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmcHRyKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChwdHIgPT09IG9sZExlbikgY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnB1c2gob2xkTGVuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0Lmluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCBmYWxzZSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCB0cnVlKTtcblxuICAgICAgICB0YXJnZXQudW5pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgICAgaWYgKCFwdHIgJiYgMCAhPT0gcHRyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGZpID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzO1xuICAgICAgICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICAgICAgICBmaS5wdXNoKHB0cik7XG4gICAgICAgICAgY29uc3QgcmMgPSBmdC5nZXQocHRyKTtcbiAgICAgICAgICBmdC5zZXQocHRyLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWsgPSBmdW5jdGlvbiBmKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkocHRyKSA/IFtdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCByYztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobGlzdCkgcHRyID0gYXJndW1lbnRzWzBdLnNoaWZ0KCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgcmMgPSBjLkhFQVA4W3B0ciA+PiAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDE2W3B0ciA+PiAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDMyW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIHJjID0gYy5IRUFQMzJGW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgICAgICByYyA9IE51bWJlcihjLkhFQVA2NEZbcHRyID4+IDNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gQmlnSW50KGMuSEVBUDY0W3B0ciA+PiAzXSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHR5cGUgZm9yIHBlZWsoKTonLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0KSBsaXN0LnB1c2gocmMpO1xuICAgICAgICAgIH0gd2hpbGUgKGxpc3QgJiYgYXJndW1lbnRzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGxpc3QgfHwgcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBva2UgPSBmdW5jdGlvbiAocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwIG9mIEFycmF5LmlzQXJyYXkocHRyKSA/IHB0ciA6IFtwdHJdKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQOFtwID4+IDBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgICAgICAgYy5IRUFQMTZbcCA+PiAxXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyW3AgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyRltwID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Y2NCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQNjRGW3AgPj4gM10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHtcbiAgICAgICAgICAgICAgICAgIGMuSEVBUDY0W3AgPj4gM10gPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwb2tlKCk6ICcgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWtQdHIgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsIHB0cklSKTtcblxuICAgICAgICB0YXJnZXQucG9rZVB0ciA9IChwdHIsIHZhbHVlID0gMCkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgcHRySVIpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrOCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k4Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U4ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpOCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMTYgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucG9rZTE2ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucGVlazMyID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMiA9IChwdHIsIHZhbHVlKSA9PiB0YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBlZWs2NCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlNjQgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMzJmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMmYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2YzMicpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrNjRmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjY0Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U2NGYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2Y2NCcpO1xuXG4gICAgICAgIHRhcmdldC5nZXRNZW1WYWx1ZSA9IHRhcmdldC5wZWVrO1xuXG4gICAgICAgIHRhcmdldC5nZXRQdHJWYWx1ZSA9IHRhcmdldC5wZWVrUHRyO1xuXG4gICAgICAgIHRhcmdldC5zZXRNZW1WYWx1ZSA9IHRhcmdldC5wb2tlO1xuXG4gICAgICAgIHRhcmdldC5zZXRQdHJWYWx1ZSA9IHRhcmdldC5wb2tlUHRyO1xuXG4gICAgICAgIHRhcmdldC5pc1B0cjMyID0gKHB0cikgPT5cbiAgICAgICAgICAnbnVtYmVyJyA9PT0gdHlwZW9mIHB0ciAmJiBwdHIgPT09IChwdHIgfCAwKSAmJiBwdHIgPj0gMDtcblxuICAgICAgICB0YXJnZXQuaXNQdHIgPSB0YXJnZXQuaXNQdHIzMjtcblxuICAgICAgICB0YXJnZXQuY3N0cmxlbiA9IGZ1bmN0aW9uIChwdHIpIHtcbiAgICAgICAgICBpZiAoIXB0ciB8fCAhdGFyZ2V0LmlzUHRyKHB0cikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IGggPSBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG4gICAgICAgICAgbGV0IHBvcyA9IHB0cjtcbiAgICAgICAgICBmb3IgKDsgaFtwb3NdICE9PSAwOyArK3Bvcykge31cbiAgICAgICAgICByZXR1cm4gcG9zIC0gcHRyO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fU0FCID1cbiAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUudXRmOERlY29kZXIuZGVjb2RlKFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIuYnVmZmVyIGluc3RhbmNlb2YgX19TQUJcbiAgICAgICAgICAgICAgPyBhcnJheUJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICAgICAgICA6IGFycmF5QnVmZmVyLnN1YmFycmF5KGJlZ2luLCBlbmQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJUb0pzID0gZnVuY3Rpb24gKHB0cikge1xuICAgICAgICAgIGNvbnN0IG4gPSB0YXJnZXQuY3N0cmxlbihwdHIpO1xuICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICA/IF9fdXRmOERlY29kZShoZWFwV3JhcHBlcnMoKS5IRUFQOFUsIHB0ciwgcHRyICsgbilcbiAgICAgICAgICAgIDogbnVsbCA9PT0gblxuICAgICAgICAgICAgICA/IG5cbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuanN0cmxlbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHIpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IG4gPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKHUgPj0gMHhkODAwICYmIHUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIHUgPVxuICAgICAgICAgICAgICAgICgweDEwMDAwICsgKCh1ICYgMHgzZmYpIDw8IDEwKSkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1IDw9IDB4N2YpICsrbGVuO1xuICAgICAgICAgICAgZWxzZSBpZiAodSA8PSAweDdmZikgbGVuICs9IDI7XG4gICAgICAgICAgICBlbHNlIGlmICh1IDw9IDB4ZmZmZikgbGVuICs9IDM7XG4gICAgICAgICAgICBlbHNlIGxlbiArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc3RyY3B5ID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGpzdHIsXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgbWF4Qnl0ZXMgPSAtMSxcbiAgICAgICAgICBhZGROdWwgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGd0IHx8XG4gICAgICAgICAgICAoISh0Z3QgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpICYmICEodGd0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b3NzKCdqc3RyY3B5KCkgdGFyZ2V0IG11c3QgYmUgYW4gSW50OEFycmF5IG9yIFVpbnQ4QXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhCeXRlcyA8IDApIG1heEJ5dGVzID0gdGd0Lmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICBpZiAoIShtYXhCeXRlcyA+IDApIHx8ICEob2Zmc2V0ID49IDApKSByZXR1cm4gMDtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBtYXggPSBqc3RyLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBiZWdpbiA9IG9mZnNldCxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIG1heEJ5dGVzIC0gKGFkZE51bCA/IDEgOiAwKTtcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heCAmJiBvZmZzZXQgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHUgPSBqc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAodSA+PSAweGQ4MDAgJiYgdSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgdSA9XG4gICAgICAgICAgICAgICAgKDB4MTAwMDAgKyAoKHUgJiAweDNmZikgPDwgMTApKSB8XG4gICAgICAgICAgICAgICAgKGpzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUgPD0gMHg3Zikge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSB1O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N2ZmKSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAxID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGMwIHwgKHUgPj4gNik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodSA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDIgPj0gZW5kKSBicmVhaztcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAzID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRkTnVsKSB0Z3Rbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gYmVnaW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJuY3B5ID0gZnVuY3Rpb24gKHRndFB0ciwgc3JjUHRyLCBuKSB7XG4gICAgICAgICAgaWYgKCF0Z3RQdHIgfHwgIXNyY1B0cilcbiAgICAgICAgICAgIHRvc3MoJ2NzdHJuY3B5KCkgZG9lcyBub3QgYWNjZXB0IE5VTEwgc3RyaW5ncy4nKTtcbiAgICAgICAgICBpZiAobiA8IDApIG4gPSB0YXJnZXQuY3N0cmxlbihzdHJQdHIpICsgMTtcbiAgICAgICAgICBlbHNlIGlmICghKG4gPiAwKSkgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgaGVhcCA9IHRhcmdldC5oZWFwOHUoKTtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBjaDtcbiAgICAgICAgICBmb3IgKDsgaSA8IG4gJiYgKGNoID0gaGVhcFtzcmNQdHIgKyBpXSk7ICsraSkge1xuICAgICAgICAgICAgaGVhcFt0Z3RQdHIgKyBpXSA9IGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA8IG4pIGhlYXBbdGd0UHRyICsgaSsrXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmpzdHJUb1VpbnRBcnJheSA9IChzdHIsIGFkZE51bCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLnV0ZjhFbmNvZGVyLmVuY29kZShhZGROdWwgPyBzdHIgKyAnXFwwJyA6IHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hZmZpcm1BbGxvYyA9IChvYmosIGZ1bmNOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShvYmouYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgICEob2JqLmRlYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdPYmplY3QgaXMgbWlzc2luZyBhbGxvYygpIGFuZC9vciBkZWFsbG9jKCkgZnVuY3Rpb24ocyknLFxuICAgICAgICAgICAgICAncmVxdWlyZWQgYnknLFxuICAgICAgICAgICAgICBmdW5jTmFtZSArICcoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHIgPSBmdW5jdGlvbiAoXG4gICAgICAgICAganN0cixcbiAgICAgICAgICByZXR1cm5XaXRoTGVuZ3RoLFxuICAgICAgICAgIGFsbG9jYXRvcixcbiAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIGZ1bmNOYW1lKTtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBqc3RyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoMCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IHRhcmdldC5qc3RybGVuKGpzdHIpLFxuICAgICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IobiArIDEpO1xuICAgICAgICAgICAgdGFyZ2V0LmpzdHJjcHkoanN0ciwgdGFyZ2V0LmhlYXA4dSgpLCBwdHIsIG4gKyAxLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgbl0gOiBwdHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoanN0ciksXG4gICAgICAgICAgICAgIHB0ciA9IGFsbG9jYXRvcih1Lmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgICBoZWFwID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgICAgICAgICAgaGVhcC5zZXQodSwgcHRyKTtcbiAgICAgICAgICAgIGhlYXBbcHRyICsgdS5sZW5ndGhdID0gMDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgdS5sZW5ndGhdIDogcHRyO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuYWxsb2NDU3RyaW5nID0gKGpzdHIsIHJldHVybldpdGhMZW5ndGggPSBmYWxzZSkgPT5cbiAgICAgICAgICBfX2FsbG9jQ1N0cihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLCB0YXJnZXQuYWxsb2MsICdhbGxvY0NTdHJpbmcoKScpO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1B1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1B1c2gnKTtcbiAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2MucHVzaChhKTtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3AgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgJ3Njb3BlZEFsbG9jUG9wJyk7XG4gICAgICAgICAgY29uc3QgbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgID8gY2FjaGUuc2NvcGVkQWxsb2MuaW5kZXhPZihzdGF0ZSlcbiAgICAgICAgICAgIDogY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAobiA8IDApIHRvc3MoJ0ludmFsaWQgc3RhdGUgb2JqZWN0IGZvciBzY29wZWRBbGxvY1BvcCgpLicpO1xuICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSBzdGF0ZSA9IGNhY2hlLnNjb3BlZEFsbG9jW25dO1xuICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jLnNwbGljZShuLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBwOyAocCA9IHN0YXRlLnBvcCgpKTsgKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmZ1bmN0aW9uRW50cnkocCkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uKHApO1xuICAgICAgICAgICAgfSBlbHNlIHRhcmdldC5kZWFsbG9jKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGlmICghY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHAgPSB0YXJnZXQuYWxsb2Mobik7XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnNjb3BlZEFsbG9jLCAnbGV2ZWwnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IGNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJUaGUgJ2FjdGl2ZScgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jQ1N0cmluZyA9IChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoID0gZmFsc2UpID0+XG4gICAgICAgICAgX19hbGxvY0NTdHIoXG4gICAgICAgICAgICBqc3RyLFxuICAgICAgICAgICAgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvYyxcbiAgICAgICAgICAgICdzY29wZWRBbGxvY0NTdHJpbmcoKScsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jTWFpbkFyZ3YgPSBmdW5jdGlvbiAoaXNTY29wZWQsIGxpc3QpIHtcbiAgICAgICAgICBjb25zdCBwTGlzdCA9IHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvYycgOiAnYWxsb2MnXShcbiAgICAgICAgICAgIChsaXN0Lmxlbmd0aCArIDEpICogdGFyZ2V0LnB0clNpemVvZixcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICBsaXN0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5wb2tlUHRyKFxuICAgICAgICAgICAgICBwTGlzdCArIHRhcmdldC5wdHJTaXplb2YgKiBpKyssXG4gICAgICAgICAgICAgIHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvY0NTdHJpbmcnIDogJ2FsbG9jQ1N0cmluZyddKCcnICsgZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5wb2tlUHRyKHBMaXN0ICsgdGFyZ2V0LnB0clNpemVvZiAqIGksIDApO1xuICAgICAgICAgIHJldHVybiBwTGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NNYWluQXJndiA9IChsaXN0KSA9PiBfX2FsbG9jTWFpbkFyZ3YodHJ1ZSwgbGlzdCk7XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jTWFpbkFyZ3YgPSAobGlzdCkgPT4gX19hbGxvY01haW5Bcmd2KGZhbHNlLCBsaXN0KTtcblxuICAgICAgICB0YXJnZXQuY0FyZ3ZUb0pzID0gKGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0YXJnZXQucGVla1B0cihwQXJndiArIHRhcmdldC5wdHJTaXplb2YgKiBpKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChhcmcgPyB0YXJnZXQuY3N0clRvSnMoYXJnKSA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NDYWxsID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1BvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jUHRyID0gZnVuY3Rpb24gKGhvd01hbnksIHNhZmVQdHJTaXplLCBtZXRob2QpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgbWV0aG9kKTtcbiAgICAgICAgICBjb25zdCBwSXIgPSBzYWZlUHRyU2l6ZSA/ICdpNjQnIDogcHRySVI7XG4gICAgICAgICAgbGV0IG0gPSB0YXJnZXRbbWV0aG9kXShob3dNYW55ICogKHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZikpO1xuICAgICAgICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcik7XG4gICAgICAgICAgaWYgKDEgPT09IGhvd01hbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhID0gW21dO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaG93TWFueTsgKytpKSB7XG4gICAgICAgICAgICBtICs9IHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZjtcbiAgICAgICAgICAgIGFbaV0gPSBtO1xuICAgICAgICAgICAgdGFyZ2V0LnBva2UobSwgMCwgcElyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ2FsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ3Njb3BlZEFsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnhHZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0YXJnZXQuZXhwb3J0c1tuYW1lXSB8fCB0b3NzKCdDYW5ub3QgZmluZCBleHBvcnRlZCBzeW1ib2w6JywgbmFtZSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYXJnY01pc21hdGNoID0gKGYsIG4pID0+XG4gICAgICAgICAgdG9zcyhmICsgJygpIHJlcXVpcmVzJywgbiwgJ2FyZ3VtZW50KHMpLicpO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbCA9IGZ1bmN0aW9uIChmbmFtZSwgLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IGYgPSBmbmFtZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZm5hbWUgOiB0YXJnZXQueEdldChmbmFtZSk7XG4gICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgIHRvc3MoJ0V4cG9ydGVkIHN5bWJvbCcsIGZuYW1lLCAnaXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIF9fYXJnY01pc21hdGNoKGYgPT09IGZuYW1lID8gZi5uYW1lIDogZm5hbWUsIGYubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gMiA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSlcbiAgICAgICAgICAgID8gZi5hcHBseShudWxsLCBhcmd1bWVudHNbMV0pXG4gICAgICAgICAgICA6IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FjaGUueFdyYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZyA9IG5ldyBNYXAoKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgeEFyZyA9IGNhY2hlLnhXcmFwLmNvbnZlcnQuYXJnLFxuICAgICAgICAgIHhSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdDtcblxuICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB4QXJnLnNldCgnaTY0JywgKGkpID0+IEJpZ0ludChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX194QXJnUHRyID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVIgPyAoaSkgPT4gaSB8IDAgOiAoaSkgPT4gQmlnSW50KGkpIHwgQmlnSW50KDApO1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnaTMyJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ2kxNicsIChpKSA9PiAoaSB8IDApICYgMHhmZmZmKVxuICAgICAgICAgIC5zZXQoJ2k4JywgKGkpID0+IChpIHwgMCkgJiAweGZmKVxuICAgICAgICAgIC5zZXQoJ2YzMicsIChpKSA9PiBOdW1iZXIoaSkudmFsdWVPZigpKVxuICAgICAgICAgIC5zZXQoJ2Zsb2F0JywgeEFyZy5nZXQoJ2YzMicpKVxuICAgICAgICAgIC5zZXQoJ2Y2NCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAgICAgICAuc2V0KCdkb3VibGUnLCB4QXJnLmdldCgnZjY0JykpXG4gICAgICAgICAgLnNldCgnaW50JywgeEFyZy5nZXQoJ2kzMicpKVxuICAgICAgICAgIC5zZXQoJ251bGwnLCAoaSkgPT4gaSlcbiAgICAgICAgICAuc2V0KG51bGwsIHhBcmcuZ2V0KCdudWxsJykpXG4gICAgICAgICAgLnNldCgnKionLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnKicsIF9feEFyZ1B0cik7XG4gICAgICAgIHhSZXN1bHRcbiAgICAgICAgICAuc2V0KCcqJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnbnVtYmVyJywgKHYpID0+IE51bWJlcih2KSlcbiAgICAgICAgICAuc2V0KCd2b2lkJywgKHYpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAuc2V0KCdudWxsJywgKHYpID0+IHYpXG4gICAgICAgICAgLnNldChudWxsLCB4UmVzdWx0LmdldCgnbnVsbCcpKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29weVRvUmVzdWx0ID0gW1xuICAgICAgICAgICAgJ2k4JyxcbiAgICAgICAgICAgICdpMTYnLFxuICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdmMzInLFxuICAgICAgICAgICAgJ2Zsb2F0JyxcbiAgICAgICAgICAgICdmNjQnLFxuICAgICAgICAgICAgJ2RvdWJsZScsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIGNvcHlUb1Jlc3VsdC5wdXNoKCdpNjQnKTtcbiAgICAgICAgICBjb25zdCBhZGFwdFB0ciA9IHhBcmcuZ2V0KHB0cklSKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgY29weVRvUmVzdWx0KSB7XG4gICAgICAgICAgICB4QXJnLnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0LCB4QXJnLmdldCh0KSB8fCB0b3NzKCdNaXNzaW5nIGFyZyBjb252ZXJ0ZXI6JywgdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9feEFyZ1N0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdikgcmV0dXJuIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcodik7XG4gICAgICAgICAgcmV0dXJuIHYgPyBfX3hBcmdQdHIodikgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnc3RyaW5nJywgX194QXJnU3RyaW5nKVxuICAgICAgICAgIC5zZXQoJ3V0ZjgnLCBfX3hBcmdTdHJpbmcpXG4gICAgICAgICAgLnNldCgncG9pbnRlcicsIF9feEFyZ1N0cmluZyk7XG5cbiAgICAgICAgeFJlc3VsdFxuICAgICAgICAgIC5zZXQoJ3N0cmluZycsIChpKSA9PiB0YXJnZXQuY3N0clRvSnMoaSkpXG4gICAgICAgICAgLnNldCgndXRmOCcsIHhSZXN1bHQuZ2V0KCdzdHJpbmcnKSlcbiAgICAgICAgICAuc2V0KCdzdHJpbmc6ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IHRhcmdldC5jc3RyVG9KcyhpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZXQoJ3V0Zjg6ZGVhbGxvYycsIHhSZXN1bHQuZ2V0KCdzdHJpbmc6ZGVhbGxvYycpKVxuICAgICAgICAgIC5zZXQoJ2pzb24nLCAoaSkgPT4gSlNPTi5wYXJzZSh0YXJnZXQuY3N0clRvSnMoaSkpKVxuICAgICAgICAgIC5zZXQoJ2pzb246ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IEpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBBYnN0cmFjdEFyZ0FkYXB0ZXIgPSBjbGFzcyB7XG4gICAgICAgICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCBhZGFwdGVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb252ZXJ0QXJnKHYsIGFyZ3YsIGFyZ0luZGV4KSB7XG4gICAgICAgICAgICB0b3NzKCdBYnN0cmFjdEFyZ0FkYXB0ZXIgbXVzdCBiZSBzdWJjbGFzc2VkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyID0gY2xhc3MgRnVuY1B0ckFkYXB0ZXIgZXh0ZW5kcyBBYnN0cmFjdEFyZ0FkYXB0ZXIge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgICAgIGlmICh4QXJnLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3hBcmcuRnVuY1B0ckFkYXB0ZXIgaXMgYW4gaW50ZXJuYWwtb25seSBBUEknLFxuICAgICAgICAgICAgICAgICdhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGludm9rZWQgZnJvbScsXG4gICAgICAgICAgICAgICAgJ2NsaWVudC1sZXZlbCBjb2RlLiBJbnZva2VkIHdpdGg6JyxcbiAgICAgICAgICAgICAgICBvcHQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCc7XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG9wdC5zaWduYXR1cmU7XG4gICAgICAgICAgICBpZiAob3B0LmNvbnRleHRLZXkgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkgPSBvcHQuY29udGV4dEtleTtcbiAgICAgICAgICAgICAgaWYgKCFvcHQuYmluZFNjb3BlKSBvcHQuYmluZFNjb3BlID0gJ2NvbnRleHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kU2NvcGUgPVxuICAgICAgICAgICAgICBvcHQuYmluZFNjb3BlIHx8XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIG9wdGlvbnMgcmVxdWlyZXMgYSBiaW5kU2NvcGUgKGV4cGxpY2l0IG9yIGltcGxpZWQpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5pbmRleE9mKG9wdC5iaW5kU2NvcGUpIDwgMCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIG9wdGlvbnMuYmluZFNjb3BlICgnICtcbiAgICAgICAgICAgICAgICAgIG9wdC5iaW5kTW9kICtcbiAgICAgICAgICAgICAgICAgICcpIGZvciBGdW5jUHRyQWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0aW5nIG9uZSBvZjogKCcgK1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2llbnQgPSAndHJhbnNpZW50JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGV4dCA9ICdjb250ZXh0JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzUGVybWFuZW50ID0gJ3Blcm1hbmVudCcgPT09IHRoaXMuYmluZFNjb3BlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGV0b24gPSAnc2luZ2xldG9uJyA9PT0gdGhpcy5iaW5kU2NvcGUgPyBbXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5jYWxsUHJveHkgPVxuICAgICAgICAgICAgICBvcHQuY2FsbFByb3h5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHQuY2FsbFByb3h5IDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRNYXAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjbSA9IHRoaXMuX19jbWFwIHx8ICh0aGlzLl9fY21hcCA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBsZXQgcmMgPSBjbS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJjKSBjbS5zZXQoa2V5LCAocmMgPSBbXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnZlcnRBcmcodiwgYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gdGhpcy5zaW5nbGV0b247XG4gICAgICAgICAgICBpZiAoIXBhaXIgJiYgdGhpcy5pc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgcGFpciA9IHRoaXMuY29udGV4dE1hcCh0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWlyICYmIHBhaXJbMF0gPT09IHYpIHJldHVybiBwYWlyWzFdO1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsUHJveHkpIHYgPSB0aGlzLmNhbGxQcm94eSh2KTtcbiAgICAgICAgICAgICAgY29uc3QgZnAgPSBfX2luc3RhbGxGdW5jdGlvbih2LCB0aGlzLnNpZ25hdHVyZSwgdGhpcy5pc1RyYW5zaWVudCk7XG4gICAgICAgICAgICAgIGlmIChGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAnRnVuY1B0ckFkYXB0ZXIgaW5zdGFsbGVkJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgJ0AnICsgZnAsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFpclsxXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIHVuaW5zdGFsbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICdAJyArIHBhaXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgcGFpclsxXSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhaXJbMF0gPSB2O1xuICAgICAgICAgICAgICAgIHBhaXJbMV0gPSBmcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pc1B0cih2KSB8fCBudWxsID09PSB2IHx8IHVuZGVmaW5lZCA9PT0gdikge1xuICAgICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyWzFdICYmIHBhaXJbMV0gIT09IHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCkge1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICdGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAnQCcgKyBwYWlyWzFdLFxuICAgICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocGFpclsxXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICBwYWlyWzBdID0gcGFpclsxXSA9IHYgfCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB2IHx8IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIEZ1bmNQdHJBZGFwdGVyIGFyZ3VtZW50IHR5cGUuICcgK1xuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGluZyBhIGZ1bmN0aW9uIHBvaW50ZXIgb3IgYSAnICtcbiAgICAgICAgICAgICAgICAgICh0aGlzLm5hbWUgPyB0aGlzLm5hbWUgKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uIG1hdGNoaW5nIHNpZ25hdHVyZSAnICtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlICtcbiAgICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0ID0gY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xuXG4gICAgICAgIHhBcmcuRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3BlcyA9IFtcbiAgICAgICAgICAndHJhbnNpZW50JyxcbiAgICAgICAgICAnY29udGV4dCcsXG4gICAgICAgICAgJ3NpbmdsZXRvbicsXG4gICAgICAgICAgJ3Blcm1hbmVudCcsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgX194QXJnQWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeEFyZy5nZXQodCkgfHwgdG9zcygnQXJndW1lbnQgYWRhcHRlciBub3QgZm91bmQ6JywgdCk7XG5cbiAgICAgICAgY29uc3QgX194UmVzdWx0QWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeFJlc3VsdC5nZXQodCkgfHwgdG9zcygnUmVzdWx0IGFkYXB0ZXIgbm90IGZvdW5kOicsIHQpO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmcgPSAodCwgLi4uYXJncykgPT4gX194QXJnQWRhcHRlckNoZWNrKHQpKC4uLmFyZ3MpO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmdOb0NoZWNrID0gKHQsIC4uLmFyZ3MpID0+IHhBcmcuZ2V0KHQpKC4uLmFyZ3MpO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQgPSAodCwgdikgPT5cbiAgICAgICAgICBudWxsID09PSB0ID8gdiA6IHQgPyBfX3hSZXN1bHRBZGFwdGVyQ2hlY2sodCkodikgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY2FjaGUueFdyYXAuY29udmVydFJlc3VsdE5vQ2hlY2sgPSAodCwgdikgPT5cbiAgICAgICAgICBudWxsID09PSB0ID8gdiA6IHQgPyB4UmVzdWx0LmdldCh0KSh2KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICB0YXJnZXQueFdyYXAgPSBmdW5jdGlvbiAoZkFyZywgcmVzdWx0VHlwZSwgLi4uYXJnVHlwZXMpIHtcbiAgICAgICAgICBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICAgIGFyZ1R5cGVzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGFyZ2V0LmlzUHRyKGZBcmcpKSB7XG4gICAgICAgICAgICBmQXJnID1cbiAgICAgICAgICAgICAgdGFyZ2V0LmZ1bmN0aW9uRW50cnkoZkFyZykgfHxcbiAgICAgICAgICAgICAgdG9zcygnRnVuY3Rpb24gcG9pbnRlciBub3QgZm91bmQgaW4gV0FTTSBmdW5jdGlvbiB0YWJsZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZklzRnVuYyA9IGZBcmcgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICAgICAgICBjb25zdCB4ZiA9IGZJc0Z1bmMgPyBmQXJnIDogdGFyZ2V0LnhHZXQoZkFyZyk7XG4gICAgICAgICAgaWYgKGZJc0Z1bmMpIGZBcmcgPSB4Zi5uYW1lIHx8ICd1bm5hbWVkIGZ1bmN0aW9uJztcbiAgICAgICAgICBpZiAoYXJnVHlwZXMubGVuZ3RoICE9PSB4Zi5sZW5ndGgpIF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJlc3VsdFR5cGUgJiYgMCA9PT0geGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geGY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IHJlc3VsdFR5cGUgJiYgbnVsbCAhPT0gcmVzdWx0VHlwZSlcbiAgICAgICAgICAgIF9feFJlc3VsdEFkYXB0ZXJDaGVjayhyZXN1bHRUeXBlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgYXJnVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgQWJzdHJhY3RBcmdBZGFwdGVyKVxuICAgICAgICAgICAgICB4QXJnLnNldCh0LCAoLi4uYXJncykgPT4gdC5jb252ZXJ0QXJnKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIGVsc2UgX194QXJnQWRhcHRlckNoZWNrKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjeHcgPSBjYWNoZS54V3JhcDtcbiAgICAgICAgICBpZiAoMCA9PT0geGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+XG4gICAgICAgICAgICAgIGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBjeHcuY29udmVydFJlc3VsdChyZXN1bHRUeXBlLCB4Zi5jYWxsKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IHhmLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gdGFyZ2V0LnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGN4dy5jb252ZXJ0QXJnTm9DaGVjayhhcmdUeXBlc1tpXSwgYXJnc1tpXSwgYXJncywgaSk7XG4gICAgICAgICAgICAgIHJldHVybiBjeHcuY29udmVydFJlc3VsdE5vQ2hlY2socmVzdWx0VHlwZSwgeGYuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9feEFkYXB0ZXIgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICBhcmdjLFxuICAgICAgICAgIHR5cGVOYW1lLFxuICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgbW9kZU5hbWUsXG4gICAgICAgICAgeGN2UGFydCxcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdHlwZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICgxID09PSBhcmdjKSByZXR1cm4geGN2UGFydC5nZXQodHlwZU5hbWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoMiA9PT0gYXJnYykge1xuICAgICAgICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgICAgICAgICB4Y3ZQYXJ0LmRlbGV0ZSh0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhZGFwdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhtb2RlTmFtZSwgJ3JlcXVpcmVzIGEgZnVuY3Rpb24gYXJndW1lbnQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeGN2UGFydC5zZXQodHlwZU5hbWUsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnSW52YWxpZCBhcmd1bWVudHMgdG8nLCBtb2RlTmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwLnJlc3VsdEFkYXB0ZXIgPSBmdW5jdGlvbiBmKHR5cGVOYW1lLCBhZGFwdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9feEFkYXB0ZXIoXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGVOYW1lLFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgICdyZXN1bHRBZGFwdGVyKCknLFxuICAgICAgICAgICAgeFJlc3VsdCxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC54V3JhcC5hcmdBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcikge1xuICAgICAgICAgIHJldHVybiBfX3hBZGFwdGVyKFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICAnYXJnQWRhcHRlcigpJyxcbiAgICAgICAgICAgIHhBcmcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAuRnVuY1B0ckFkYXB0ZXIgPSB4QXJnLkZ1bmNQdHJBZGFwdGVyO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbFdyYXBwZWQgPSBmdW5jdGlvbiAoZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbM10pKSBhcmdzID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIC54V3JhcChmQXJnLCByZXN1bHRUeXBlLCBhcmdUeXBlcyB8fCBbXSlcbiAgICAgICAgICAgIC5hcHBseShudWxsLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0QXJnO1xuXG4gICAgICAgIHRhcmdldC54V3JhcC50ZXN0Q29udmVydFJlc3VsdCA9IGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlci55YXdsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25zdCB3ZmV0Y2ggPSAoKSA9PiBmZXRjaChjb25maWcudXJpLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICAgICAgICBjb25zdCB3dWkgPSB0aGlzO1xuICAgICAgICBjb25zdCBmaW5hbFRoZW4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53YXNtVXRpbFRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGd0ID0gY29uZmlnLndhc21VdGlsVGFyZ2V0O1xuICAgICAgICAgICAgdGd0Lm1vZHVsZSA9IGFyZy5tb2R1bGU7XG4gICAgICAgICAgICB0Z3QuaW5zdGFuY2UgPSBhcmcuaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGlmICghdGd0Lmluc3RhbmNlLmV4cG9ydHMubWVtb3J5KSB7XG4gICAgICAgICAgICAgIHRndC5tZW1vcnkgPVxuICAgICAgICAgICAgICAgIChjb25maWcuaW1wb3J0cyAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMuZW52ICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuaW1wb3J0cy5lbnYubWVtb3J5KSB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXCJNaXNzaW5nICdtZW1vcnknIG9iamVjdCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRndC5hbGxvYyAmJiBhcmcuaW5zdGFuY2UuZXhwb3J0cy5tYWxsb2MpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXhwb3J0cyA9IGFyZy5pbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICB0Z3QuYWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBleHBvcnRzLm1hbGxvYyhuKSB8fCB0b3NzKCdBbGxvY2F0aW9uIG9mJywgbiwgJ2J5dGVzIGZhaWxlZC4nKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRndC5kZWFsbG9jID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmZyZWUobSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3dWkodGd0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbmZpZy5vbmxvYWQpIGNvbmZpZy5vbmxvYWQoYXJnLCBjb25maWcpO1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWRXYXNtID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcbiAgICAgICAgICA/IGZ1bmN0aW9uIGxvYWRXYXNtU3RyZWFtaW5nKCkge1xuICAgICAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoXG4gICAgICAgICAgICAgICAgd2ZldGNoKCksXG4gICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMgfHwge30sXG4gICAgICAgICAgICAgICkudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gbG9hZFdhc21PbGRTY2hvb2woKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3ZmV0Y2goKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoYnl0ZXMpID0+XG4gICAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgY29uZmlnLmltcG9ydHMgfHwge30pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxvYWRXYXNtO1xuICAgICAgfS5iaW5kKGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcik7XG5cbiAgICAgICgndXNlIHN0cmljdCcpO1xuICAgICAgZ2xvYmFsVGhpcy5KYWNjd2FieXQgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXJGYWN0b3J5KGNvbmZpZykge1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KSAmJlxuICAgICAgICAgICEoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICdjb25maWcuaGVhcCBtdXN0IGJlIFdlYkFzc2VtYmx5Lk1lbW9yeSBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBbJ2FsbG9jJywgJ2RlYWxsb2MnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgY29uZmlnW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgIHRvc3MoXCJDb25maWcgb3B0aW9uICdcIiArIGsgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFNCRiA9IFN0cnVjdEJpbmRlckZhY3Rvcnk7XG4gICAgICAgIGNvbnN0IGhlYXAgPVxuICAgICAgICAgICAgY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICA/IGNvbmZpZy5oZWFwXG4gICAgICAgICAgICAgIDogKCkgPT4gbmV3IFVpbnQ4QXJyYXkoY29uZmlnLmhlYXAuYnVmZmVyKSxcbiAgICAgICAgICBhbGxvYyA9IGNvbmZpZy5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jID0gY29uZmlnLmRlYWxsb2MsXG4gICAgICAgICAgbG9nID0gY29uZmlnLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgIG1lbWJlclByZWZpeCA9IGNvbmZpZy5tZW1iZXJQcmVmaXggfHwgJycsXG4gICAgICAgICAgbWVtYmVyU3VmZml4ID0gY29uZmlnLm1lbWJlclN1ZmZpeCB8fCAnJyxcbiAgICAgICAgICBiaWdJbnRFbmFibGVkID1cbiAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gY29uZmlnLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgICAgICAgPyAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXVxuICAgICAgICAgICAgICA6ICEhY29uZmlnLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgQmlnSW50ID0gZ2xvYmFsVGhpc1snQmlnSW50J10sXG4gICAgICAgICAgQmlnSW50NjRBcnJheSA9IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSxcbiAgICAgICAgICBwdHJTaXplb2YgPSBjb25maWcucHRyU2l6ZW9mIHx8IDQsXG4gICAgICAgICAgcHRySVIgPSBjb25maWcucHRySVIgfHwgJ2kzMic7XG4gICAgICAgIGlmICghU0JGLmRlYnVnRmxhZ3MpIHtcbiAgICAgICAgICBTQkYuX19tYWtlRGVidWdGbGFncyA9IGZ1bmN0aW9uIChkZXJpdmVGcm9tID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRlcml2ZUZyb20gJiYgZGVyaXZlRnJvbS5fX2ZsYWdzKVxuICAgICAgICAgICAgICBkZXJpdmVGcm9tID0gZGVyaXZlRnJvbS5fX2ZsYWdzO1xuICAgICAgICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uIGYoZmxhZ3MpIHtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5fX2ZsYWdzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmdldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLnNldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmFsbG9jO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmLl9fZmxhZ3MuZGVhbGxvYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLl9fZmxhZ3MuZ2V0dGVyID0gMCAhPT0gKDB4MDEgJiBmbGFncyk7XG4gICAgICAgICAgICAgICAgZi5fX2ZsYWdzLnNldHRlciA9IDAgIT09ICgweDAyICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5hbGxvYyA9IDAgIT09ICgweDA0ICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5kZWFsbG9jID0gMCAhPT0gKDB4MDggJiBmbGFncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGYuX2ZsYWdzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAnX19mbGFncycsIHtcbiAgICAgICAgICAgICAgaXRlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKGRlcml2ZUZyb20pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRlcml2ZUZyb20pIGYoMCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFNCRi5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdID09PSAyNTY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgY29uc3QgaXNGdW5jU2lnID0gKHMpID0+ICcoJyA9PT0gc1sxXTtcblxuICAgICAgICBjb25zdCBpc1B0clNpZyA9IChzKSA9PiAncCcgPT09IHMgfHwgJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBpc0F1dG9QdHJTaWcgPSAocykgPT4gJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBzaWdMZXR0ZXIgPSAocykgPT4gKGlzRnVuY1NpZyhzKSA/ICdwJyA6IHNbMF0pO1xuXG4gICAgICAgIGNvbnN0IHNpZ0lSID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpOCc7XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICByZXR1cm4gcHRySVI7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpNjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIHNpZ25hdHVyZSBJUjonLCBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1CaWdJbnRBcnJheSA9IEJpZ0ludDY0QXJyYXlcbiAgICAgICAgICA/ICgpID0+IHRydWVcbiAgICAgICAgICA6ICgpID0+IHRvc3MoJ0JpZ0ludDY0QXJyYXkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblxuICAgICAgICBjb25zdCBzaWdEVkdldHRlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBjYXNlICdzJzoge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHB0clNpemVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdnZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQzMic7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dldFVpbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0RmxvYXQzMic7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRGbG9hdDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIERhdGFWaWV3IGdldHRlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNpZ0RWU2V0dGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ3NldEJpZ0ludDY0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDgnO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgIHJldHVybiAnc2V0VWludDgnO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRGbG9hdDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEZsb2F0NjQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKCdVbmhhbmRsZWQgRGF0YVZpZXcgc2V0dGVyIGZvciBzaWduYXR1cmU6Jywgcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2lnRFZTZXRXcmFwcGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ1VuaGFuZGxlZCBEYXRhVmlldyBzZXQgd3JhcHBlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNQcm9wTmFtZSA9IChzLCBrKSA9PiBzICsgJzo6JyArIGs7XG5cbiAgICAgICAgY29uc3QgX19wcm9wVGhyb3dPblNldCA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lLCBwcm9wTmFtZSkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB0b3NzKHNQcm9wTmFtZShzdHJ1Y3ROYW1lLCBwcm9wTmFtZSksICdpcyByZWFkLW9ubHkuJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YW5jZVBvaW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGNvbnN0IHhQdHJQcm9wTmFtZSA9ICcocG9pbnRlci1pcy1leHRlcm5hbCknO1xuXG4gICAgICAgIGNvbnN0IF9fZnJlZVN0cnVjdCA9IGZ1bmN0aW9uIChjdG9yLCBvYmosIG0pIHtcbiAgICAgICAgICBpZiAoIW0pIG0gPSBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQob2JqKTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgX19pbnN0YW5jZVBvaW50ZXJNYXAuZGVsZXRlKG9iaik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoub25kaXNwb3NlKSkge1xuICAgICAgICAgICAgICBsZXQgeDtcbiAgICAgICAgICAgICAgd2hpbGUgKCh4ID0gb2JqLm9uZGlzcG9zZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB4LmNhbGwob2JqKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSB4LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdudW1iZXInID09PSB0eXBlb2YgeCkgZGVhbGxvYyh4KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICAgJ3RocmV3LiBOT1QgcHJvcGFnYXRpbmcgaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5vbmRpc3Bvc2UgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5vbmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsXG4gICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvYmoub25kaXNwb3NlO1xuICAgICAgICAgICAgaWYgKGN0b3IuZGVidWdGbGFncy5fX2ZsYWdzLmRlYWxsb2MpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5kZWFsbG9jOicsXG4gICAgICAgICAgICAgICAgb2JqW3hQdHJQcm9wTmFtZV0gPyAnRVhURVJOQUwnIDogJycsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICdpbnN0YW5jZTonLFxuICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXG4gICAgICAgICAgICAgICAgJ2J5dGVzIEAnICsgbSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqW3hQdHJQcm9wTmFtZV0pIGRlYWxsb2MobSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJvcCA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWxsb2NTdHJ1Y3QgPSBmdW5jdGlvbiAoY3Rvciwgb2JqLCBtKSB7XG4gICAgICAgICAgbGV0IGZpbGwgPSAhbTtcbiAgICAgICAgICBpZiAobSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgeFB0clByb3BOYW1lLCByb3AobSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbSA9IGFsbG9jKGN0b3Iuc3RydWN0SW5mby5zaXplb2YpO1xuICAgICAgICAgICAgaWYgKCFtKSB0b3NzKCdBbGxvY2F0aW9uIG9mJywgY3Rvci5zdHJ1Y3ROYW1lLCAnc3RydWN0dXJlIGZhaWxlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5hbGxvYykge1xuICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgJ2RlYnVnLmFsbG9jOicsXG4gICAgICAgICAgICAgICAgZmlsbCA/ICcnIDogJ0VYVEVSTkFMJyxcbiAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgJ2luc3RhbmNlOicsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZixcbiAgICAgICAgICAgICAgICAnYnl0ZXMgQCcgKyBtLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGwpIGhlYXAoKS5maWxsKDAsIG0sIG0gKyBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgICAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLnNldChvYmosIG0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF9fZnJlZVN0cnVjdChjdG9yLCBvYmosIG0pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1vcnlEdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoaGVhcCgpLnNsaWNlKHAsIHAgKyB0aGlzLnN0cnVjdEluZm8uc2l6ZW9mKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlcktleSA9IChrKSA9PiBtZW1iZXJQcmVmaXggKyBrICsgbWVtYmVyU3VmZml4O1xuICAgICAgICBjb25zdCBfX21lbWJlcktleVByb3AgPSByb3AoX19tZW1iZXJLZXkpO1xuXG4gICAgICAgIGNvbnN0IF9fbG9va3VwTWVtYmVyID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHN0cnVjdEluZm8sXG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICB0b3NzSWZOb3RGb3VuZCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBtID0gc3RydWN0SW5mby5tZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgICAgIGlmICghbSAmJiAobWVtYmVyUHJlZml4IHx8IG1lbWJlclN1ZmZpeCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgICAgaWYgKHYua2V5ID09PSBtZW1iZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgbSA9IHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbSAmJiB0b3NzSWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIG1lbWJlck5hbWUpLFxuICAgICAgICAgICAgICAgICdpcyBub3QgYSBtYXBwZWQgc3RydWN0IG1lbWJlci4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlclNpZ25hdHVyZSA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgZW1zY3JpcHRlbkZvcm1hdCA9IGZhbHNlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoIWYuXylcbiAgICAgICAgICAgIGYuXyA9ICh4KSA9PlxuICAgICAgICAgICAgICB4LnJlcGxhY2UoL1tedmlwUHNqcmRjQ10vZywgJycpLnJlcGxhY2UoL1twUHNjQ10vZywgJ2knKTtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBlbXNjcmlwdGVuRm9ybWF0ID8gZi5fKG0uc2lnbmF0dXJlKSA6IG0uc2lnbmF0dXJlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fcHRyUHJvcERlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJDYW5ub3QgYXNzaWduIHRoZSAncG9pbnRlcicgcHJvcGVydHkgb2YgYSBzdHJ1Y3QuXCIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc3RydWN0TWVtYmVyS2V5cyA9IHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLm1lbWJlcktleShrKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICBjb25zdCBfX3V0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gICAgICAgIGNvbnN0IF9fdXRmOERlY29kZSA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiBfX3V0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgICAgICAgIGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCXG4gICAgICAgICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKSxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWVtYmVySXNTdHJpbmcgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgdG9zc0lmTm90Rm91bmQgPSBmYWxzZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgcmV0dXJuIG0gJiYgMSA9PT0gbS5zaWduYXR1cmUubGVuZ3RoICYmICdzJyA9PT0gbS5zaWduYXR1cmVbMF1cbiAgICAgICAgICAgID8gbVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUgPSBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgaWYgKCdzJyA9PT0gbWVtYmVyLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBtZW1iZXIgdHlwZSBzaWduYXR1cmUgZm9yIEMtc3RyaW5nIHZhbHVlOicsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZW1iZXIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1iZXJUb0pzU3RyaW5nID0gZnVuY3Rpb24gZihvYmosIG1lbWJlck5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcbiAgICAgICAgICBjb25zdCBhZGRyID0gb2JqW20ua2V5XTtcblxuICAgICAgICAgIGlmICghYWRkcikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbGV0IHBvcyA9IGFkZHI7XG4gICAgICAgICAgY29uc3QgbWVtID0gaGVhcCgpO1xuICAgICAgICAgIGZvciAoOyBtZW1bcG9zXSAhPT0gMDsgKytwb3MpIHt9XG5cbiAgICAgICAgICByZXR1cm4gYWRkciA9PT0gcG9zID8gJycgOiBfX3V0ZjhEZWNvZGUobWVtLCBhZGRyLCBwb3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWRkT25EaXNwb3NlID0gZnVuY3Rpb24gKG9iaiwgLi4udikge1xuICAgICAgICAgIGlmIChvYmoub25kaXNwb3NlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtvYmoub25kaXNwb3NlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoub25kaXNwb3NlLnB1c2goLi4udik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgY29uc3QgdSA9IF9fdXRmOEVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgICAgICAgY29uc3QgbWVtID0gYWxsb2ModS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBpZiAoIW1lbSkgdG9zcygnQWxsb2NhdGlvbiBlcnJvciB3aGlsZSBkdXBsaWNhdGluZyBzdHJpbmc6Jywgc3RyKTtcbiAgICAgICAgICBjb25zdCBoID0gaGVhcCgpO1xuXG4gICAgICAgICAgaC5zZXQodSwgbWVtKTtcbiAgICAgICAgICBoW21lbSArIHUubGVuZ3RoXSA9IDA7XG5cbiAgICAgICAgICByZXR1cm4gbWVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc2V0TWVtYmVyQ1N0cmluZyA9IGZ1bmN0aW9uIChvYmosIG1lbWJlck5hbWUsIHN0cikge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlKG0pO1xuXG4gICAgICAgICAgY29uc3QgbWVtID0gX19hbGxvY0NTdHJpbmcoc3RyKTtcbiAgICAgICAgICBvYmpbbS5rZXldID0gbWVtO1xuICAgICAgICAgIF9fYWRkT25EaXNwb3NlKG9iaiwgbWVtKTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdFR5cGUgPSBmdW5jdGlvbiBjdG9yKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8pIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzWzJdICE9PSByb3ApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RydWN0VHlwZSBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICdmcm9tIGNsaWVudC1sZXZlbCBjb2RlLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICBkaXNwb3NlOiByb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX19mcmVlU3RydWN0KHRoaXMuY29uc3RydWN0b3IsIHRoaXMpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGxvb2t1cE1lbWJlcjogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2xvb2t1cE1lbWJlcih0aGlzLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1iZXJUb0pzU3RyaW5nOiByb3AoZnVuY3Rpb24gKG1lbWJlck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclRvSnNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVySXNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19tZW1iZXJJc1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3AsXG4gICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgIG1lbWJlclNpZ25hdHVyZTogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclNpZ25hdHVyZSh0aGlzLCBtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1vcnlEdW1wOiByb3AoX19tZW1vcnlEdW1wKSxcbiAgICAgICAgICBwb2ludGVyOiBfX3B0clByb3BEZXNjcmlwdG9yLFxuICAgICAgICAgIHNldE1lbWJlckNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZXRNZW1iZXJDU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUsIHN0cik7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU3RydWN0VHlwZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICBhZGRPbkRpc3Bvc2U6IGZ1bmN0aW9uICguLi52KSB7XG4gICAgICAgICAgICBfX2FkZE9uRGlzcG9zZSh0aGlzLCAuLi52KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdFR5cGUsIHtcbiAgICAgICAgICBhbGxvY0NTdHJpbmc6IHJvcChfX2FsbG9jQ1N0cmluZyksXG4gICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSxcbiAgICAgICAgICBoYXNFeHRlcm5hbFBvaW50ZXI6IHJvcChcbiAgICAgICAgICAgICh2KSA9PiB2IGluc3RhbmNlb2YgU3RydWN0VHlwZSAmJiAhIXZbeFB0clByb3BOYW1lXSxcbiAgICAgICAgICApLFxuICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpc051bWVyaWNWYWx1ZSA9ICh2KSA9PlxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh2KSB8fCB2IGluc3RhbmNlb2YgKEJpZ0ludCB8fCBOdW1iZXIpO1xuXG4gICAgICAgIGNvbnN0IG1ha2VNZW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gZihjdG9yLCBuYW1lLCBkZXNjcikge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7IGdldHRlcnM6IHt9LCBzZXR0ZXJzOiB7fSwgc3c6IHt9IH07XG4gICAgICAgICAgICBjb25zdCBhID0gWydpJywgJ2MnLCAnQycsICdwJywgJ1AnLCAncycsICdmJywgJ2QnLCAndigpJ107XG4gICAgICAgICAgICBpZiAoYmlnSW50RW5hYmxlZCkgYS5wdXNoKCdqJyk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgZi5fLmdldHRlcnNbdl0gPSBzaWdEVkdldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnNldHRlcnNbdl0gPSBzaWdEVlNldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnN3W3ZdID0gc2lnRFZTZXRXcmFwcGVyKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByeFNpZzEgPSAvXltpcFBzamZkY0NdJC8sXG4gICAgICAgICAgICAgIHJ4U2lnMiA9IC9eW3ZpcFBzamZkY0NdXFwoW2lwUHNqZmRjQ10qXFwpJC87XG4gICAgICAgICAgICBmLnNpZ0NoZWNrID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwga2V5LCBzaWcpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzKG9iai5zdHJ1Y3ROYW1lLCAnYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBuYW1lZCcsIGtleSArICcuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnhTaWcxLnRlc3Qoc2lnKSB8fFxuICAgICAgICAgICAgICAgIHJ4U2lnMi50ZXN0KHNpZykgfHxcbiAgICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICAgJ01hbGZvcm1lZCBzaWduYXR1cmUgZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShvYmouc3RydWN0TmFtZSwgbmFtZSkgKyAnOicsXG4gICAgICAgICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleSA9IGN0b3IubWVtYmVyS2V5KG5hbWUpO1xuICAgICAgICAgIGYuc2lnQ2hlY2soY3Rvci5wcm90b3R5cGUsIG5hbWUsIGtleSwgZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBkZXNjci5rZXkgPSBrZXk7XG4gICAgICAgICAgZGVzY3IubmFtZSA9IG5hbWU7XG4gICAgICAgICAgY29uc3Qgc2lnR2x5cGggPSBzaWdMZXR0ZXIoZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBjb25zdCB4UHJvcE5hbWUgPSBzUHJvcE5hbWUoY3Rvci5wcm90b3R5cGUuc3RydWN0TmFtZSwga2V5KTtcbiAgICAgICAgICBjb25zdCBkYmcgPSBjdG9yLnByb3RvdHlwZS5kZWJ1Z0ZsYWdzLl9fZmxhZ3M7XG5cbiAgICAgICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBwcm9wLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRiZy5nZXR0ZXIpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5nZXR0ZXI6JyxcbiAgICAgICAgICAgICAgICBmLl8uZ2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgJ2ZvcicsXG4gICAgICAgICAgICAgICAgc2lnSVIoc2lnR2x5cGgpLFxuICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgJ3N6JyxcbiAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmMgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgIGhlYXAoKS5idWZmZXIsXG4gICAgICAgICAgICAgIHRoaXMucG9pbnRlciArIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgKVtmLl8uZ2V0dGVyc1tzaWdHbHlwaF1dKDAsIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIGlmIChkYmcuZ2V0dGVyKSBsb2coJ2RlYnVnLmdldHRlcjonLCB4UHJvcE5hbWUsICdyZXN1bHQgPScsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZXNjci5yZWFkT25seSkge1xuICAgICAgICAgICAgcHJvcC5zZXQgPSBfX3Byb3BUaHJvd09uU2V0KGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsIGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3Auc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKGRiZy5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAnZGVidWcuc2V0dGVyOicsXG4gICAgICAgICAgICAgICAgICBmLl8uc2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgICAnZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICdzeicsXG4gICAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdDYW5ub3Qgc2V0IHN0cnVjdCBwcm9wZXJ0eSBvbiBkaXNwb3NlZCBpbnN0YW5jZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdikgdiA9IDA7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVtZXJpY1ZhbHVlKHYpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0b1B0clNpZyhkZXNjci5zaWduYXR1cmUpICYmXG4gICAgICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYucG9pbnRlciB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGJnLnNldHRlcilcbiAgICAgICAgICAgICAgICAgICAgICBsb2coJ2RlYnVnLnNldHRlcjonLCB4UHJvcE5hbWUsICdyZXNvbHZlZCB0bycsIHYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdmFsdWUgZm9yIHBvaW50ZXItdHlwZScsIHhQcm9wTmFtZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgICAgaGVhcCgpLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgICApW2YuXy5zZXR0ZXJzW3NpZ0dseXBoXV0oMCwgZi5fLnN3W3NpZ0dseXBoXSh2KSwgaXNMaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHByb3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdEJpbmRlciA9IGZ1bmN0aW9uIFN0cnVjdEJpbmRlcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKSB7XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8gPSBzdHJ1Y3ROYW1lO1xuICAgICAgICAgICAgc3RydWN0TmFtZSA9IHN0cnVjdEluZm8ubmFtZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJ1Y3RJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8ubmFtZSA9IHN0cnVjdE5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0TmFtZSkgdG9zcygnU3RydWN0IG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgbGV0IGxhc3RNZW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzdHJ1Y3RJbmZvLm1lbWJlcnNba107XG4gICAgICAgICAgICBpZiAoIW0uc2l6ZW9mKSB0b3NzKHN0cnVjdE5hbWUsICdtZW1iZXInLCBrLCAnaXMgbWlzc2luZyBzaXplb2YuJyk7XG4gICAgICAgICAgICBlbHNlIGlmIChtLnNpemVvZiA9PT0gMSkge1xuICAgICAgICAgICAgICBtLnNpZ25hdHVyZSA9PT0gJ2MnIHx8XG4gICAgICAgICAgICAgICAgbS5zaWduYXR1cmUgPT09ICdDJyB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBzaXplb2Y9PTEgbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIGspLFxuICAgICAgICAgICAgICAgICAgJ3dpdGggc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gbS5zaXplb2YgJSA0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IG1lbWJlciBkZXNjcmlwdGlvbiA9JyxcbiAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAnZnJvbScsXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3RJbmZvLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIHN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAnbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgICAnc2l6ZW9mIGlzIG5vdCBhbGlnbmVkLiBzaXplb2Y9JyArIG0uc2l6ZW9mLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDAgIT09IG0ub2Zmc2V0ICUgNCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPScsXG4gICAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgICAgJ2Zyb20nLFxuICAgICAgICAgICAgICAgICAgc3RydWN0SW5mbyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ21lbWJlcicsXG4gICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgJ29mZnNldCBpcyBub3QgYWxpZ25lZC4gb2Zmc2V0PScgKyBtLm9mZnNldCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhc3RNZW1iZXIgfHwgbGFzdE1lbWJlci5vZmZzZXQgPCBtLm9mZnNldCkgbGFzdE1lbWJlciA9IG07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFsYXN0TWVtYmVyKSB0b3NzKCdObyBtZW1iZXIgcHJvcGVydHkgZGVzY3JpcHRpb25zIGZvdW5kLicpO1xuICAgICAgICAgIGVsc2UgaWYgKHN0cnVjdEluZm8uc2l6ZW9mIDwgbGFzdE1lbWJlci5vZmZzZXQgKyBsYXN0TWVtYmVyLnNpemVvZikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IGNvbmZpZzonLFxuICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAnbWF4IG1lbWJlciBvZmZzZXQgKCcgKyBsYXN0TWVtYmVyLm9mZnNldCArICcpICcsXG4gICAgICAgICAgICAgICdleHRlbmRzIHBhc3QgZW5kIG9mIHN0cnVjdCAoc2l6ZW9mPScgKyBzdHJ1Y3RJbmZvLnNpemVvZiArICcpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWJ1Z0ZsYWdzID0gcm9wKFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSk7XG5cbiAgICAgICAgICBjb25zdCBTdHJ1Y3RDdG9yID0gZnVuY3Rpb24gU3RydWN0Q3RvcihleHRlcm5hbE1lbW9yeSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cnVjdEN0b3IpKSB7XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ1RoZScsXG4gICAgICAgICAgICAgICAgc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yIG1heSBvbmx5IGJlIGNhbGxlZCB2aWEgJ25ldycuXCIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5ICE9PSAoZXh0ZXJuYWxNZW1vcnkgfCAwKSB8fFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5IDw9IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCBwb2ludGVyIHZhbHVlIGZvcicsIHN0cnVjdE5hbWUsICdjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMsIGV4dGVybmFsTWVtb3J5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9fYWxsb2NTdHJ1Y3QoU3RydWN0Q3RvciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgICAgbWV0aG9kSW5mb0ZvcktleTogcm9wKGZ1bmN0aW9uIChtS2V5KSB7fSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgU3RydWN0Q3Rvci5wcm90b3R5cGUgPSBuZXcgU3RydWN0VHlwZShzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvLCByb3ApO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdEN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgY29uc3RydWN0b3I6IHJvcChTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICBtYWtlTWVtYmVyV3JhcHBlcihTdHJ1Y3RDdG9yLCBuYW1lLCBzdHJ1Y3RJbmZvLm1lbWJlcnNbbmFtZV0pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFN0cnVjdEN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgICAgICAgU3RydWN0QmluZGVyLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgU3RydWN0QmluZGVyLmFsbG9jQ1N0cmluZyA9IF9fYWxsb2NDU3RyaW5nO1xuICAgICAgICBpZiAoIVN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSB7XG4gICAgICAgICAgU3RydWN0QmluZGVyLmRlYnVnRmxhZ3MgPSBTQkYuX19tYWtlRGVidWdGbGFncyhTQkYuZGVidWdGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cnVjdEJpbmRlcjtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvc3MzID0gc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcztcbiAgICAgICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaSxcbiAgICAgICAgICB3YXNtID0gc3FsaXRlMy53YXNtLFxuICAgICAgICAgIHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcih3YXNtKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcjtcblxuICAgICAgICBpZiAoMCkge1xuICAgICAgICAgIGNvbnN0IGRlYWxsb2MgPSB3YXNtLmV4cG9ydHNbc3FsaXRlMy5jb25maWcuZGVhbGxvY0V4cG9ydE5hbWVdO1xuICAgICAgICAgIGNvbnN0IG5GdW5jID0gd2FzbS5mdW5jdGlvblRhYmxlKCkubGVuZ3RoO1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuRnVuYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gd2FzbS5mdW5jdGlvbkVudHJ5KGkpO1xuICAgICAgICAgICAgaWYgKGRlYWxsb2MgPT09IGUpIHtcbiAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWFsbG9jICE9PSB3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSkge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludGVybmFsIGVycm9yOiBjYW5ub3QgZmluZCBmdW5jdGlvbiBwb2ludGVyIGZvciBTUUxJVEVfV0FTTV9ERUFMTE9DLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0JywgJ3ZvaWQqJywgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9kb3VibGUnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50JywgJ2Y2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX2ludCcsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfbnVsbCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9uYW1lJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2JpbmRfcG9pbnRlcicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaSknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfYnVzeV90aW1lb3V0JywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnXSxcblxuICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jbGVhcl9iaW5kaW5ncycsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJywgJ2ludCcsICdzcWxpdGUzKicsICcqJywgJyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX2Jsb2InLCAnKicsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9jb3VudCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fZGVjbHR5cGUnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9kb3VibGUnLCAnZjY0JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9pbnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9uYW1lJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fdGV4dCcsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX3R5cGUnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl92YWx1ZScsICdzcWxpdGUzX3ZhbHVlKicsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbW1pdF9ob29rJyxcbiAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0JywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkJywgJ2ludCcsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29tcGxldGUnLCAnaW50JywgJ3N0cmluZzpmbGV4aWJsZSddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZScsICdzcWxpdGUzKicsICdzcWxpdGUzX2NvbnRleHQqJ10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfZGF0YV9jb3VudCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9maWxlbmFtZScsICdzdHJpbmcnLCAnc3FsaXRlMyonLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2RiX2hhbmRsZScsICdzcWxpdGUzKicsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2RiX25hbWUnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9yZWFkb25seScsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2RiX3N0YXR1cycsICdpbnQnLCAnc3FsaXRlMyonLCAnaW50JywgJyonLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXJyY29kZScsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXJybXNnJywgJ3N0cmluZycsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJvcl9vZmZzZXQnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2VycnN0cicsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfZXhlYycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZzpmbGV4aWJsZScsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBpcHApJyxcbiAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgYU5hbWVzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChwVm9pZCwgbkNvbHMsIHBDb2xWYWxzLCBwQ29sTmFtZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhVmFscyA9IHdhc20uY0FyZ3ZUb0pzKG5Db2xzLCBwQ29sVmFscyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFhTmFtZXMpIGFOYW1lcyA9IHdhc20uY0FyZ3ZUb0pzKG5Db2xzLCBwQ29sTmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhVmFscywgYU5hbWVzKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2V4cGFuZGVkX3NxbCcsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMnLCAnaW50JywgJ3NxbGl0ZTMqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19maWxlX2NvbnRyb2wnLCAnaW50JywgJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19maW5hbGl6ZScsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19mcmVlJywgdW5kZWZpbmVkLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19nZXRfYXV0b2NvbW1pdCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZ2V0X2F1eGRhdGEnLCAnKicsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19pbml0aWFsaXplJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfaW50ZXJydXB0JywgdW5kZWZpbmVkLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfaXNfaW50ZXJydXB0ZWQnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfY291bnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfbmFtZScsICdpbnQnLCBbJ2ludCcsICcqKicsICcqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19rZXl3b3JkX2NoZWNrJywgJ2ludCcsIFsnc3RyaW5nJywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2xpbWl0JywgJ2ludCcsIFsnc3FsaXRlMyonLCAnaW50JywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbWFsbG9jJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW4nLCAnaW50JywgJ3N0cmluZycsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW5fdjInLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCcsICdzdHJpbmcnXSxcblxuICAgICAgICAgIFsnc3FsaXRlM19yZWFsbG9jJywgJyonLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzZXQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcblxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Jlc3VsdF9ibG9iJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9kb3VibGUnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2Y2NCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Jlc3VsdF9lcnJvcicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfaW50JywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X251bGwnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlJywgdW5kZWZpbmVkLCAnc3FsaXRlM192YWx1ZSonLCAnaW50J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X3RleHQnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfemVyb2Jsb2InLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3JvbGxiYWNrX2hvb2snLFxuICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3JvbGxiYWNrX2hvb2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICA/ICcqJ1xuICAgICAgICAgICAgICAgIDogbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneERlc3Ryb3lBdXhEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19zaHV0ZG93bicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgWydzcWxpdGUzX3NvdXJjZWlkJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zcWwnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzJywgJ2ludCcsICdpbnQnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdGVwJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfYnVzeScsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdG10X3JlYWRvbmx5JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfc3RhdHVzJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RyZ2xvYicsICdpbnQnLCAnc3RyaW5nJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdHJpY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cmxpa2UnLCAnaW50JywgJ3N0cmluZycsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cm5pY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YScsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190b3RhbF9jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RyYWNlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3RyYWNlX3YyOjpjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShpcHBwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190eG5fc3RhdGUnLCAnaW50JywgWydzcWxpdGUzKicsICdzdHJpbmcnXV0sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2Jvb2xlYW4nLCAnaW50JywgJ3NxbGl0ZTNfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfa2V5JywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfcGFyYW1ldGVyJywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM191c2VyX2RhdGEnLCAndm9pZConLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ibG9iJywgJyonLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2RvdWJsZScsICdmNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfZHVwJywgJ3NxbGl0ZTNfdmFsdWUqJywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2ZyZWUnLCB1bmRlZmluZWQsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9mcm9tYmluZCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfaW50JywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ub2NoYW5nZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9wb2ludGVyJywgJyonLCAnc3FsaXRlM192YWx1ZSonLCAnc3RyaW5nOnN0YXRpYyddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9zdWJ0eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90ZXh0JywgJ3N0cmluZycsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfZmluZCcsICcqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfcmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICghIXdhc20uZXhwb3J0cy5zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIpIHtcbiAgICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLnB1c2goW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hQcm9ncmVzc0hhbmRsZXInLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISF3YXNtLmV4cG9ydHMuc3FsaXRlM19zdG10X2V4cGxhaW4pIHtcbiAgICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLnB1c2goXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfc3RtdF9leHBsYWluJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghIXdhc20uZXhwb3J0cy5zcWxpdGUzX3NldF9hdXRob3JpemVyKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcbiAgICAgICAgICAgICdzcWxpdGUzX3NldF9hdXRob3JpemVyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXI6OnhBdXRoJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBpJyArICdzc3NzKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHBWLCBpQ29kZSwgczAsIHMxLCBzMiwgczMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMwICYmIHdhc20uY3N0clRvSnMoczApO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gczEgJiYgd2FzbS5jc3RyVG9KcyhzMSk7XG4gICAgICAgICAgICAgICAgICAgICAgczIgPSBzMiAmJiB3YXNtLmNzdHJUb0pzKHMyKTtcbiAgICAgICAgICAgICAgICAgICAgICBzMyA9IHMzICYmIHdhc20uY3N0clRvSnMoczMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhwViwgaUNvZGUsIHMwLCBzMSwgczIsIHMzKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWxzZSAmJiB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkKCdTUUxJVEVfRU5BQkxFX05PUk1BTElaRScpKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcbiAgICAgICAgICAgICdzcWxpdGUzX25vcm1hbGl6ZWRfc3FsJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NCA9IFtcbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9pbnQ2NCcsICdpbnQnLCBbJ3NxbGl0ZTNfc3RtdConLCAnaW50JywgJ2k2NCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlczY0JywgJ2k2NCcsIFsnc3FsaXRlMyonXV0sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9pbnQ2NCcsICdpNjQnLCBbJ3NxbGl0ZTNfc3RtdConLCAnaW50J11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2Rlc2VyaWFsaXplJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2k2NCcsXG4gICAgICAgICAgICAnaTY0JyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJywgJ2k2NCcsIFsnc3FsaXRlMyonXV0sXG4gICAgICAgICAgWydzcWxpdGUzX21hbGxvYzY0JywgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX21zaXplJywgJ2k2NCcsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVhbGxvYzY0JywgJyonLCAnKicsICdpNjQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2ludDY0JywgdW5kZWZpbmVkLCAnKicsICdpNjQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQnLCAnaW50JywgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3NlcmlhbGl6ZScsICcqJywgJ3NxbGl0ZTMqJywgJ3N0cmluZycsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnLCB1bmRlZmluZWQsIFsnc3FsaXRlMyonLCAnaTY0J11dLFxuICAgICAgICAgIFsnc3FsaXRlM19zdGF0dXM2NCcsICdpbnQnLCAnaW50JywgJyonLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0JywgJ2k2NCcsIFsnc3FsaXRlMyonXV0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfdXBkYXRlX2hvb2snLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfdXBkYXRlX2hvb2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YoaWlwcGopJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndikgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChwLCBvcCwgejAsIHoxLCByb3dpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoejApLFxuICAgICAgICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoejEpLFxuICAgICAgICAgICAgICAgICAgICAgIHJvd2lkLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfaW50NjQnLCAnaTY0JywgWydzcWxpdGUzX2ZpbGVuYW1lJywgJ3N0cmluZycsICdpNjQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2ludDY0JywgJ2k2NCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQgJiYgISF3YXNtLmV4cG9ydHMuc3FsaXRlM19kZWNsYXJlX3Z0YWIpIHtcbiAgICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0LnB1c2goXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV9tb2R1bGUnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdzdHJpbmcnLCAnc3FsaXRlM19tb2R1bGUqJywgJyonXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdzdHJpbmcnLCAnc3FsaXRlM19tb2R1bGUqJywgJyonLCAnKiddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19kZWNsYXJlX3Z0YWInLCAnaW50JywgWydzcWxpdGUzKicsICdzdHJpbmc6ZmxleGlibGUnXV0sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfZHJvcF9tb2R1bGVzJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnKionXV0sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nLCAnc3RyaW5nJywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAnaW50J10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9kaXN0aW5jdCcsICdpbnQnLCAnc3FsaXRlM19pbmRleF9pbmZvKiddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW4nLCAnaW50JywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAnaW50JywgJ2ludCddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fZmlyc3QnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJywgJyoqJ10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9pbl9uZXh0JywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKicsICcqKiddLFxuXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9ub2NoYW5nZScsICdpbnQnLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X2luZm8qJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkICYmICEhd2FzbS5leHBvcnRzLnNxbGl0ZTNfcHJldXBkYXRlX2hvb2spIHtcbiAgICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0LnB1c2goXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZScsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19wcmV1cGRhdGVfY291bnQnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19wcmV1cGRhdGVfaG9vaycsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snLFxuICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwcGlwcGpqKScsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndikgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocCwgZGIsIG9wLCB6RGIsIHpUYmwsIGlLZXkxLCBpS2V5MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpEYiksXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpUYmwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaUtleTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpS2V5MixcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9uZXcnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCcsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ2ludCcsICcqKiddXSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHdhc20uYmlnSW50RW5hYmxlZCAmJlxuICAgICAgICAgICEhd2FzbS5leHBvcnRzLnNxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgJiZcbiAgICAgICAgICAhIXdhc20uZXhwb3J0cy5zcWxpdGUzc2Vzc2lvbl9jcmVhdGUgJiZcbiAgICAgICAgICAhIXdhc20uZXhwb3J0cy5zcWxpdGUzX3ByZXVwZGF0ZV9ob29rXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IF9faXBzUHJveHkgPSB7XG4gICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBzKScsXG4gICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKHAsIHMpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHAsIHdhc20uY3N0clRvSnMocykpIHwgMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQucHVzaChcbiAgICAgICAgICAgIC4uLltcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludCcsICd2b2lkKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZWdyb3VwKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnLCAnaW50JywgWycqKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ2ludCcsICd2b2lkKicsICdpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dEEnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0QicsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZScsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2ludmVydCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnKionLCAnaW50KicsICdpbnQqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X3BrJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0JywgJ2ludCcsIFsnKionLCAnaW50JywgJyonXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInLCAnaW50JywgWycqKicsICdpbnQnLCAnKicsICdpbnQnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jb25maWcnLCAnaW50JywgWydpbnQnLCAndm9pZConXV0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY3JlYXRlJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJyoqJ11dLFxuXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGlmZicsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJywgJ3N0cmluZycsICdzdHJpbmcnLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9lbmFibGUnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50J11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHknLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50JywgJ3ZvaWQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKicsICcqJywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbUludGVybmFsID0gW1xuICAgICAgICAgIFsnc3FsaXRlM19fd2FzbV9kYl9yZXNldCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfX3dhc21fZGJfdmZzJywgJ3NxbGl0ZTNfdmZzKicsICdzcWxpdGUzKicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnc3FsaXRlM192ZnMqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rJywgJ2ludCcsICdzcWxpdGUzX3ZmcyonLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX193YXNtX3FmbXRfdG9rZW4nLCAnc3RyaW5nOmRlYWxsb2MnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICBdO1xuXG4gICAgICAgIHNxbGl0ZTMuU3RydWN0QmluZGVyID0gZ2xvYmFsVGhpcy5KYWNjd2FieXQoe1xuICAgICAgICAgIGhlYXA6IDAgPyB3YXNtLm1lbW9yeSA6IHdhc20uaGVhcDh1LFxuICAgICAgICAgIGFsbG9jOiB3YXNtLmFsbG9jLFxuICAgICAgICAgIGRlYWxsb2M6IHdhc20uZGVhbGxvYyxcbiAgICAgICAgICBiaWdJbnRFbmFibGVkOiB3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgbWVtYmVyUHJlZml4OiAnJCcsXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5KYWNjd2FieXQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9feFN0cmluZyA9IHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3RyaW5nJyk7XG4gICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzdHJpbmc6ZmxleGlibGUnLCAodikgPT5cbiAgICAgICAgICAgIF9feFN0cmluZyh1dGlsLmZsZXhpYmxlU3RyaW5nKHYpKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKFxuICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKHdhc20uaXNQdHIodikpIHJldHVybiB2O1xuICAgICAgICAgICAgICB2ID0gJycgKyB2O1xuICAgICAgICAgICAgICBsZXQgcmMgPSB0aGlzW3ZdO1xuICAgICAgICAgICAgICByZXR1cm4gcmMgfHwgKHRoaXNbdl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh2KSk7XG4gICAgICAgICAgICB9LmJpbmQoT2JqZWN0LmNyZWF0ZShudWxsKSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IF9feEFyZ1B0ciA9IHdhc20ueFdyYXAuYXJnQWRhcHRlcignKicpO1xuICAgICAgICAgIGNvbnN0IG5pbFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3NxbGl0ZTNfZmlsZW5hbWUnLCBfX3hBcmdQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgX194QXJnUHRyLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfdmFsdWUqJywgX194QXJnUHRyKSgndm9pZConLCBfX3hBcmdQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgICAgIF9feEFyZ1B0cixcbiAgICAgICAgICApKCdzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsIF9feEFyZ1B0cikoXG4gICAgICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgICAgICBfX3hBcmdQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19zdG10KicsICh2KSA9PlxuICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uU3RtdCB8fCBuaWxUeXBlKSA/IHYucG9pbnRlciA6IHYsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICkoJ3NxbGl0ZTMqJywgKHYpID0+XG4gICAgICAgICAgICBfX3hBcmdQdHIoXG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoc3FsaXRlMz8ub28xPy5EQiB8fCBuaWxUeXBlKSA/IHYucG9pbnRlciA6IHYsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfdmZzKicsICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc19maW5kKHYpIHx8XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX05PVEZPVU5ELFxuICAgICAgICAgICAgICAgICAgJ1Vua25vd24gc3FsaXRlM192ZnMgbmFtZTonLFxuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX194QXJnUHRyKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM192ZnMgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAod2FzbS5leHBvcnRzLnNxbGl0ZTNfZGVjbGFyZV92dGFiKSB7XG4gICAgICAgICAgICB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAodikgPT5cbiAgICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8gfHwgbmlsVHlwZSlcbiAgICAgICAgICAgICAgICAgID8gdi5wb2ludGVyXG4gICAgICAgICAgICAgICAgICA6IHYsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApKCdzcWxpdGUzX21vZHVsZSonLCAodikgPT5cbiAgICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX21vZHVsZSB8fCBuaWxUeXBlKSA/IHYucG9pbnRlciA6IHYsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IF9feFJjUHRyID0gd2FzbS54V3JhcC5yZXN1bHRBZGFwdGVyKCcqJyk7XG4gICAgICAgICAgd2FzbS54V3JhcC5yZXN1bHRBZGFwdGVyKCdzcWxpdGUzKicsIF9feFJjUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgIF9feFJjUHRyLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfc3RtdConLCBfX3hSY1B0cikoJ3NxbGl0ZTNfdmFsdWUqJywgX194UmNQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdmZzKicsXG4gICAgICAgICAgICBfX3hSY1B0cixcbiAgICAgICAgICApKCd2b2lkKicsIF9feFJjUHRyKTtcblxuICAgICAgICAgIGlmICgwID09PSB3YXNtLmV4cG9ydHMuc3FsaXRlM19zdGVwLmxlbmd0aCkge1xuICAgICAgICAgICAgd2FzbS54V3JhcC5kb0FyZ2NDaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybihcbiAgICAgICAgICAgICAgJ0Rpc2FibGluZyBzcWxpdGUzLndhc20ueFdyYXAuZG9BcmdjQ2hlY2sgZHVlIHRvIGVudmlyb25tZW50YWwgcXVpcmtzLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcykge1xuICAgICAgICAgICAgY2FwaVtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLndhc21JbnRlcm5hbCkge1xuICAgICAgICAgICAgdXRpbFtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZkk2NERpc2FibGVkID0gZnVuY3Rpb24gKGZuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT5cbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICBmbmFtZSArICcoKSBpcyB1bmF2YWlsYWJsZSBkdWUgdG8gbGFjaycsXG4gICAgICAgICAgICAgICAgJ29mIEJpZ0ludCBzdXBwb3J0IGluIHRoaXMgYnVpbGQuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0KSB7XG4gICAgICAgICAgICBjYXBpW2VbMF1dID0gd2FzbS5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgID8gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKVxuICAgICAgICAgICAgICA6IGZJNjREaXNhYmxlZChlWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcztcblxuICAgICAgICAgIGlmICh3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9kYl9lcnJvcikge1xuICAgICAgICAgICAgY29uc3QgX19kYl9lcnIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgICAnc3FsaXRlM19fd2FzbV9kYl9lcnJvcicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbiAocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdENvZGUgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnJyArIHJlc3VsdENvZGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29kZSA9IHJlc3VsdENvZGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcERiID8gX19kYl9lcnIocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSA6IHJlc3VsdENvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbiAocERiLCBlcnJDb2RlLCBtc2cpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdzcWxpdGUzX193YXNtX2RiX2Vycm9yKCkgaXMgbm90IGV4cG9ydGVkLicsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNKc29uID0gd2FzbS54Q2FsbCgnc3FsaXRlM19fd2FzbV9lbnVtX2pzb24nKTtcbiAgICAgICAgICBpZiAoIWNKc29uKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICBcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBpbmNyZWFzZSBzcWxpdGUzX193YXNtX2VudW1fanNvbigpJ3NcIixcbiAgICAgICAgICAgICAgJ3N0YXRpYyBidWZmZXIgc2l6ZSEnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3YXNtLmN0eXBlID0gSlNPTi5wYXJzZSh3YXNtLmNzdHJUb0pzKGNKc29uKSk7XG5cbiAgICAgICAgICBjb25zdCBkZWZpbmVHcm91cHMgPSBbXG4gICAgICAgICAgICAnYWNjZXNzJyxcbiAgICAgICAgICAgICdhdXRob3JpemVyJyxcbiAgICAgICAgICAgICdibG9iRmluYWxpemVycycsXG4gICAgICAgICAgICAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICdjb25maWcnLFxuICAgICAgICAgICAgJ2RhdGFUeXBlcycsXG4gICAgICAgICAgICAnZGJDb25maWcnLFxuICAgICAgICAgICAgJ2RiU3RhdHVzJyxcbiAgICAgICAgICAgICdlbmNvZGluZ3MnLFxuICAgICAgICAgICAgJ2ZjbnRsJyxcbiAgICAgICAgICAgICdmbG9jaycsXG4gICAgICAgICAgICAnaW9DYXAnLFxuICAgICAgICAgICAgJ2xpbWl0cycsXG4gICAgICAgICAgICAnb3BlbkZsYWdzJyxcbiAgICAgICAgICAgICdwcmVwYXJlRmxhZ3MnLFxuICAgICAgICAgICAgJ3Jlc3VsdENvZGVzJyxcbiAgICAgICAgICAgICdzcWxpdGUzU3RhdHVzJyxcbiAgICAgICAgICAgICdzdG10U3RhdHVzJyxcbiAgICAgICAgICAgICdzeW5jRmxhZ3MnLFxuICAgICAgICAgICAgJ3RyYWNlJyxcbiAgICAgICAgICAgICd0eG5TdGF0ZScsXG4gICAgICAgICAgICAndWRmRmxhZ3MnLFxuICAgICAgICAgICAgJ3ZlcnNpb24nLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgZGVmaW5lR3JvdXBzLnB1c2goJ3NlcmlhbGl6ZScsICdzZXNzaW9uJywgJ3Z0YWInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIGRlZmluZUdyb3Vwcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHdhc20uY3R5cGVbdF0pKSB7XG4gICAgICAgICAgICAgIGNhcGlbZVswXV0gPSBlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXdhc20uZnVuY3Rpb25FbnRyeShjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCByZXNvbHZlIGV4cG9ydGVkIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgJ2VudHJ5IFNRTElURV9XQVNNX0RFQUxMT0MgKD09JyArIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyArICcpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBfX3JjTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgWydyZXN1bHRDb2RlcyddKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMod2FzbS5jdHlwZVt0XSkpIHtcbiAgICAgICAgICAgICAgX19yY01hcFtlWzFdXSA9IGVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0ciA9IChyYykgPT4gX19yY01hcFtyY107XG5cbiAgICAgICAgICBjb25zdCBub3RUaGVzZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgV2FzbVRlc3RTdHJ1Y3Q6IHRydWUsXG5cbiAgICAgICAgICAgIHNxbGl0ZTNfa3Z2ZnNfbWV0aG9kczogIXV0aWwuaXNVSVRocmVhZCgpLFxuXG4gICAgICAgICAgICBzcWxpdGUzX2luZGV4X2luZm86ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgICBzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQ6ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgICBzcWxpdGUzX2luZGV4X29yZGVyYnk6ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgICBzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2U6ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChjb25zdCBzIG9mIHdhc20uY3R5cGUuc3RydWN0cykge1xuICAgICAgICAgICAgaWYgKCFub3RUaGVzZVtzLm5hbWVdKSB7XG4gICAgICAgICAgICAgIGNhcGlbcy5uYW1lXSA9IHNxbGl0ZTMuU3RydWN0QmluZGVyKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBbXG4gICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQnLFxuICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9vcmRlcmJ5JyxcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZScsXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19pbmRleF9pbmZvW2tdID0gY2FwaVtrXTtcbiAgICAgICAgICAgICAgZGVsZXRlIGNhcGlba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdnRhYl9jb25maWcgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgICAnc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ2ludCcsICdpbnQnXSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgX19kYkFyZ2NNaXNtYXRjaCA9IChwRGIsIGYsIG4pID0+IHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgZiArICcoKSByZXF1aXJlcyAnICsgbiArICcgYXJndW1lbnQnICsgKDEgPT09IG4gPyAnJyA6ICdzJykgKyAnLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2VyckVuY29kaW5nID0gKHBEYikgPT4ge1xuICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBjYXBpLlNRTElURV9GT1JNQVQsXG4gICAgICAgICAgICAnU1FMSVRFX1VURjggaXMgdGhlIG9ubHkgc3VwcG9ydGVkIGVuY29kaW5nLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FyZ1BEYiA9IChwRGIpID0+IHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3FsaXRlMyonKShwRGIpO1xuICAgICAgICBjb25zdCBfX2FyZ1N0ciA9IChzdHIpID0+ICh3YXNtLmlzUHRyKHN0cikgPyB3YXNtLmNzdHJUb0pzKHN0cikgOiBzdHIpO1xuICAgICAgICBjb25zdCBfX2RiQ2xlYW51cE1hcCA9IGZ1bmN0aW9uIChwRGIsIG1vZGUpIHtcbiAgICAgICAgICBwRGIgPSBfX2FyZ1BEYihwRGIpO1xuICAgICAgICAgIGxldCBtID0gdGhpcy5kYk1hcC5nZXQocERiKTtcbiAgICAgICAgICBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGJNYXAuZGVsZXRlKHBEYik7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFtICYmIG1vZGUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRiTWFwLnNldChwRGIsIChtID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfS5iaW5kKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgZGJNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24gPSBmdW5jdGlvbiAocERiLCBuYW1lKSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgICAgICAgaWYgKCFtLmNvbGxhdGlvbikgbS5jb2xsYXRpb24gPSBuZXcgU2V0KCk7XG4gICAgICAgICAgbS5jb2xsYXRpb24uYWRkKF9fYXJnU3RyKG5hbWUpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9fZGJDbGVhbnVwTWFwLl9hZGRVREYgPSBmdW5jdGlvbiAocERiLCBuYW1lLCBhcml0eSwgbWFwKSB7XG4gICAgICAgICAgbmFtZSA9IF9fYXJnU3RyKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbGV0IHUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgIGlmICghdSkgbWFwLnNldChuYW1lLCAodSA9IG5ldyBTZXQoKSkpO1xuICAgICAgICAgIHUuYWRkKGFyaXR5IDwgMCA/IC0xIDogYXJpdHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZEZ1bmN0aW9uID0gZnVuY3Rpb24gKHBEYiwgbmFtZSwgYXJpdHkpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICAgICAgICBpZiAoIW0udWRmKSBtLnVkZiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS51ZGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3YXNtLmV4cG9ydHMuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uKSB7XG4gICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICAgICAgICAgIGlmICghbS53dWRmKSBtLnd1ZGYgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS53dWRmKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuY2xlYW51cCA9IGZ1bmN0aW9uIChwRGIpIHtcbiAgICAgICAgICBwRGIgPSBfX2FyZ1BEYihwRGIpO1xuXG4gICAgICAgICAgY29uc3QgY2xvc2VBcmdzID0gW3BEYl07XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2J1c3lfaGFuZGxlcicsXG4gICAgICAgICAgICAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgICAgICAnc3FsaXRlM19wcmV1cGRhdGVfaG9vaycsXG4gICAgICAgICAgICAnc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3JvbGxiYWNrX2hvb2snLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdHJhY2VfdjInLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdXBkYXRlX2hvb2snLFxuICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB3YXNtLmV4cG9ydHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZUFyZ3MubGVuZ3RoID0geC5sZW5ndGg7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYXBpW25hbWVdKC4uLmNsb3NlQXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgJ2Nsb3NlLXRpbWUgY2FsbCBvZicsXG4gICAgICAgICAgICAgICAgbmFtZSArICcoJyxcbiAgICAgICAgICAgICAgICBjbG9zZUFyZ3MsXG4gICAgICAgICAgICAgICAgJykgdGhyZXc6JyxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAwKTtcbiAgICAgICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgICAgICBpZiAobS5jb2xsYXRpb24pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtLmNvbGxhdGlvbikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyKFxuICAgICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1VURjgsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBtLmNvbGxhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZm1hcCA9IGkgPyBtLnd1ZGYgOiBtLnVkZjtcbiAgICAgICAgICAgIGlmICghZm1hcCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gaVxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXG4gICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBmbWFwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlWzBdLFxuICAgICAgICAgICAgICAgIGFyaXRpZXMgPSBlWzFdO1xuICAgICAgICAgICAgICBjb25zdCBmYXJncyA9IFtwRGIsIG5hbWUsIDAsIGNhcGkuU1FMSVRFX1VURjgsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICBpZiAoaSkgZmFyZ3MucHVzaCgwKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBhcml0eSBvZiBhcml0aWVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZhcmdzWzJdID0gYXJpdHk7XG4gICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KG51bGwsIGZhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyaXRpZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZtYXAuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIG0udWRmO1xuICAgICAgICAgIGRlbGV0ZSBtLnd1ZGY7XG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9fc3FsaXRlM0Nsb3NlVjIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY2xvc2VfdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyID0gZnVuY3Rpb24gKHBEYikge1xuICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY2xvc2VfdjInLCAxKTtcbiAgICAgICAgICAgIGlmIChwRGIpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5jbGVhbnVwKHBEYik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcWxpdGUzQ2xvc2VWMihwRGIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FwaS5zcWxpdGUzc2Vzc2lvbl9jcmVhdGUpIHtcbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9kZWxldGUnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJ10sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IGZ1bmN0aW9uIChwU2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJywgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBTZXNzaW9uKSB7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyKHBTZXNzaW9uLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fc3FsaXRlM1Nlc3Npb25EZWxldGUocFNlc3Npb24pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29udGV4dEtleSA9IChhcmd2LCBhcmdJbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ2FyZ3ZbJyArXG4gICAgICAgICAgICAgIGFyZ0luZGV4ICtcbiAgICAgICAgICAgICAgJ106JyArXG4gICAgICAgICAgICAgIGFyZ3ZbMF0gK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKGFyZ3ZbMV0pLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMiA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4Q29tcGFyZScsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXBpcCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgek5hbWUsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcmcsXG4gICAgICAgICAgICB4Q29tcGFyZSxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDYgIT09IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsIDYpO1xuICAgICAgICAgICAgZWxzZSBpZiAoMCA9PT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZUNvbGxhdGlvblYyKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICB6TmFtZSxcbiAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgICAgIHhDb21wYXJlLFxuICAgICAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gcmMgJiYgeENvbXBhcmUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZENvbGxhdGlvbihwRGIsIHpOYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IocERiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICB6TmFtZSxcbiAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgIHhDb21wYXJlLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDUgPT09IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbicsIDUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29udGV4dEtleSA9IGZ1bmN0aW9uIChhcmd2LCBhcmdJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJndlswXSArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIChhcmd2WzJdIDwgMCA/IC0xIDogYXJndlsyXSkgK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoYXJndlsxXSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19jZlByb3h5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICB4SW52ZXJzZUFuZFN0ZXA6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwQ3R4LCAuLi5jYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzKGFyZ2MsIHBBcmd2KSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4RmluYWxBbmRWYWx1ZToge1xuICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanMocEN0eCwgY2FsbGJhY2socEN0eCkpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEZ1bmM6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKFxuICAgICAgICAgICAgICAgICAgICAgIHBDdHgsXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeERlc3Ryb3k6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG5cbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBWb2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwVm9pZCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VERiB4RGVzdHJveSBtZXRob2QgdGhyZXc6JywgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbiA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RnVuYycsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhGdW5jLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4U3RlcCcsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEZpbmFsJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueERlc3Ryb3ksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24gPSB3YXNtLmV4cG9ydHNcbiAgICAgICAgICAgIC5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cbiAgICAgICAgICAgID8gd2FzbS54V3JhcCgnc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAneFN0ZXAnLFxuICAgICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbmFsJyxcbiAgICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAneFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAneEludmVyc2UnLFxuICAgICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAneERlc3Ryb3knLFxuICAgICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhEZXN0cm95LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgIHhGdW5jLFxuICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChmLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZUZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMCA9PT0gcmMgJiZcbiAgICAgICAgICAgICAgICAoeEZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeFN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeEZpbmFsIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIHhEZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZEZ1bmN0aW9uKHBEYiwgZnVuY05hbWUsIG5BcmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoKSBzZXR1cCB0aHJldzonLCBlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAnQ3JlYXRpb24gb2YgVURGIHRocmV3OiAnICsgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGYubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgICAgICAgIHhGdW5jLFxuICAgICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uJywgZi5sZW5ndGgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgeEludmVyc2UsXG4gICAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChmLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKDAgPT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVXaW5kb3dGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgICAgICAgICAgeEludmVyc2UsXG4gICAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDAgPT09IHJjICYmXG4gICAgICAgICAgICAgICAgICAoeFN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICB4RmluYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICB4VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICB4SW52ZXJzZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIHhEZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRXaW5kb3dGdW5jKHBEYiwgZnVuY05hbWUsIG5BcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbigpIHNldHVwIHRocmV3OicsXG4gICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAnQ3JlYXRpb24gb2YgVURGIHRocmV3OiAnICsgZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZTZXRSZXN1bHQgPVxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbi51ZGZTZXRSZXN1bHQgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzO1xuICAgICAgICAgIGlmIChjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzO1xuICAgICAgICAgIGlmIChjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0RXJyb3IgPVxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbi51ZGZTZXRFcnJvciA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanM7XG4gICAgICAgICAgaWYgKGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbi51ZGZTZXRFcnJvciA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9fZmxleGlTdHJpbmcgPSAodiwgbikgPT4ge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICBuID0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheSh2KSkge1xuICAgICAgICAgICAgICBuID0gdi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB2ID0gdXRpbC50eXBlZEFycmF5VG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgIHYgPSB2LmpvaW4oJycpO1xuICAgICAgICAgICAgICBuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3YsIG5dO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBfX3ByZXBhcmUgPSB7XG4gICAgICAgICAgICBiYXNpYzogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICAgICBmdWxsOiB3YXNtLnhXcmFwKCdzcWxpdGUzX3ByZXBhcmVfdjMnLCAnaW50JywgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICBzcWxMZW4sXG4gICAgICAgICAgICBwcmVwRmxhZ3MsXG4gICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICBwelRhaWwsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19wcmVwYXJlX3YzJywgZi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3hTcWwsIHhTcWxMZW5dID0gX19mbGV4aVN0cmluZyhzcWwsIHNxbExlbik7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB4U3FsKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fcHJlcGFyZS5iYXNpYyhcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIHhTcWwsXG4gICAgICAgICAgICAgICAgICB4U3FsTGVuLFxuICAgICAgICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgICAgICAgcHBTdG10LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBfX3ByZXBhcmUuZnVsbChcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIHhTcWwsXG4gICAgICAgICAgICAgICAgICB4U3FsTGVuLFxuICAgICAgICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgICAgICAgcHBTdG10LFxuICAgICAgICAgICAgICAgICAgcHpUYWlsLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFNRTCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX3ByZXBhcmVfdjIvdjMoKS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbExlbixcbiAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzKHBEYiwgc3FsLCBzcWxMZW4sIDAsIHBwU3RtdCwgcHpUYWlsKVxuICAgICAgICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19wcmVwYXJlX3YyJywgZi5sZW5ndGgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgX19iaW5kVGV4dCA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfYmluZF90ZXh0JywgJ2ludCcsIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBjb25zdCBfX2JpbmRCbG9iID0gd2FzbS54V3JhcCgnc3FsaXRlM19iaW5kX2Jsb2InLCAnaW50JywgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19iaW5kX3RleHQgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcFN0bXQsXG4gICAgICAgICAgICBpQ29sLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG5UZXh0LFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF90ZXh0JyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cih0ZXh0KSB8fCBudWxsID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCB0ZXh0LCBuVGV4dCwgeERlc3Ryb3kpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IG5ldyBVaW50OEFycmF5KHRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBwTWVtLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHAsIG47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBuID0gdGV4dC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGV4dCkge1xuICAgICAgICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfdGV4dCgpLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX19iaW5kVGV4dChwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19iaW5kX2Jsb2IgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcFN0bXQsXG4gICAgICAgICAgICBpQ29sLFxuICAgICAgICAgICAgcE1lbSxcbiAgICAgICAgICAgIG5NZW0sXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChmLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19iaW5kX2Jsb2InLFxuICAgICAgICAgICAgICAgIGYubGVuZ3RoLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmlzUHRyKHBNZW0pIHx8IG51bGwgPT09IHBNZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fYmluZEJsb2IocFN0bXQsIGlDb2wsIHBNZW0sIG5NZW0sIHhEZXN0cm95KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocE1lbSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHBNZW0gPSBuZXcgVWludDhBcnJheShwTWVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwTWVtKSkge1xuICAgICAgICAgICAgICBwTWVtID0gcE1lbS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwLCBuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkocE1lbSkpIHtcbiAgICAgICAgICAgICAgICBwID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KHBNZW0pO1xuICAgICAgICAgICAgICAgIG4gPSBuTWVtID49IDAgPyBuTWVtIDogcE1lbS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcE1lbSkge1xuICAgICAgICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHBNZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfYmxvYigpLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX19iaW5kQmxvYihwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY29uZmlnID0gZnVuY3Rpb24gKG9wLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0NPVkVSSU5HX0lOREVYX1NDQU46XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01FTVNUQVRVUzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU01BTExfTUFMTE9DOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TT1JURVJSRUZfU0laRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU1RNVEpSTkxfU1BJTEw6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1VSSTpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fY29uZmlnX2kob3AsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19MT09LQVNJREU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX2NvbmZpZ19paShcbiAgICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgICAgYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fY29uZmlnX2oob3AsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRNQUxMT0M6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVE1VVEVYOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUyOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0hFQVA6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0xPRzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUFMTE9DOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NTUFQX1NJWkU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01VTFRJVEhSRUFEOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NVVRFWDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUEFHRUNBQ0hFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEUyOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRV9IRFJTWjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUE1BU1o6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NFUklBTElaRUQ6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NJTkdMRVRIUkVBRDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU1FMTE9HOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19XSU4zMl9IRUFQU0laRTpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX2F1dG9FeHRGcHRyID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGZQdHIpIHtcbiAgICAgICAgICAgIGlmIChmUHRyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgZlB0ciA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKCdpKHBwcCknLCBmUHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoMSAhPT0gYXJndW1lbnRzLmxlbmd0aCB8fCAhd2FzbS5pc1B0cihmUHRyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTUlTVVNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmMgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM19hdXRvX2V4dGVuc2lvbihmUHRyKTtcbiAgICAgICAgICAgIGlmIChmUHRyICE9PSBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHJjKSBfX2F1dG9FeHRGcHRyLmFkZChmUHRyKTtcbiAgICAgICAgICAgICAgZWxzZSB3YXNtLnVuaW5zdGFsbEZ1bmN0aW9uKGZQdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGZQdHIpIHtcbiAgICAgICAgICAgIGlmICghZlB0ciB8fCAxICE9PSBhcmd1bWVudHMubGVuZ3RoIHx8ICF3YXNtLmlzUHRyKGZQdHIpKSByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24oZlB0cik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZwIG9mIF9fYXV0b0V4dEZwdHIpIHdhc20udW5pbnN0YWxsRnVuY3Rpb24oZnApO1xuICAgICAgICAgICAgX19hdXRvRXh0RnB0ci5jbGVhcigpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwS3Z2ZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoJ2t2dmZzJyk7XG4gICAgICAgIGlmIChwS3Z2ZnMpIHtcbiAgICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGt2dmZzTWV0aG9kcyA9IG5ldyBjYXBpLnNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcyhcbiAgICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fa3Z2ZnNfbWV0aG9kcygpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjYXBpLnNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcztcblxuICAgICAgICAgICAgY29uc3Qga3Z2ZnNNYWtlS2V5ID1cbiAgICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayxcbiAgICAgICAgICAgICAgcHN0YWNrID0gd2FzbS5wc3RhY2s7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzU3RvcmFnZSA9ICh6Q2xhc3MpID0+XG4gICAgICAgICAgICAgIDExNSA9PT0gd2FzbS5wZWVrKHpDbGFzcykgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZTtcblxuICAgICAgICAgICAgY29uc3Qga3Z2ZnNJbXBscyA9IHtcbiAgICAgICAgICAgICAgeFJlYWQ6ICh6Q2xhc3MsIHpLZXksIHpCdWYsIG5CdWYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyLFxuICAgICAgICAgICAgICAgICAgYXN0YWNrID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLCB6S2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghelhLZXkpIHJldHVybiAtMztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGpLZXkgPSB3YXNtLmNzdHJUb0pzKHpYS2V5KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGpWID0ga3Z2ZnNTdG9yYWdlKHpDbGFzcykuZ2V0SXRlbShqS2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghalYpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5WID0galYubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaWYgKG5CdWYgPD0gMCkgcmV0dXJuIG5WO1xuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoMSA9PT0gbkJ1Zikge1xuICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2UoekJ1ZiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuVjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHpWID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoalYpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5CdWYgPiBuViArIDEpIG5CdWYgPSBuViArIDE7XG4gICAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLmNvcHlXaXRoaW4oekJ1ZiwgelYsIHpWICsgbkJ1ZiAtIDEpO1xuICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYgKyBuQnVmIC0gMSwgMCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbkJ1ZiAtIDE7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigna3ZzdG9yYWdlUmVhZCgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3AoYXN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhXcml0ZTogKHpDbGFzcywgektleSwgekRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsIHpLZXkpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5zZXRJdGVtKGpLZXksIHdhc20uY3N0clRvSnMoekRhdGEpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZVdyaXRlKCknLCBlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgcHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeERlbGV0ZTogKHpDbGFzcywgektleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gcHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcywgektleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXpYS2V5KSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgIGt2dmZzU3RvcmFnZSh6Q2xhc3MpLnJlbW92ZUl0ZW0od2FzbS5jc3RyVG9Kcyh6WEtleSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigna3ZzdG9yYWdlRGVsZXRlKCknLCBlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgcHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoa3Z2ZnNJbXBscykpIHtcbiAgICAgICAgICAgICAga3Z2ZnNNZXRob2RzW2t2dmZzTWV0aG9kcy5tZW1iZXJLZXkoayldID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAga3Z2ZnNNZXRob2RzLm1lbWJlclNpZ25hdHVyZShrKSxcbiAgICAgICAgICAgICAgICBrdnZmc0ltcGxzW2tdLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmZzX3VucmVnaXN0ZXIocEt2dmZzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgU3RydWN0QmluZGVyID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXI7XG4gICAgICAgIGNvbnN0IGluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGNhbGxlZS5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoISh0Z3QgaW5zdGFuY2VvZiBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSkpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycm9yOiB0YXJnZXQgb2JqZWN0IGlzLW5vdC1hIFN0cnVjdFR5cGUuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIXdhc20uaXNQdHIoZnVuYykpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycnJvcjogZXhwZWN0aW5nIGEgRnVuY3Rpb24gb3IgV0FTTSBwb2ludGVyIHRvIG9uZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAobiwgZikgPT4gY2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbGxlZS5hcmdjUHJveHkpIHtcbiAgICAgICAgICAgIGNhbGxlZS5hcmdjUHJveHkgPSBmdW5jdGlvbiAodGd0LCBmdW5jTmFtZSwgZnVuYywgc2lnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IG1pc21hdGNoIGZvcicsXG4gICAgICAgICAgICAgICAgICAgIHRndC5zdHJ1Y3RJbmZvLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICc6OicgK1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAnOiBOYXRpdmUgc2lnbmF0dXJlIGlzOicsXG4gICAgICAgICAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QuZm9yRWFjaCgodiwgbmR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS51bmluc3RhbGxGdW5jdGlvbih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lnTiA9IHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSk7XG4gICAgICAgICAgaWYgKHNpZ04ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01lbWJlcicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICdkb2VzIG5vdCBoYXZlIGEgZnVuY3Rpb24gcG9pbnRlciBzaWduYXR1cmU6JyxcbiAgICAgICAgICAgICAgc2lnTixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbUtleSA9IHRndC5tZW1iZXJLZXkobmFtZSk7XG4gICAgICAgICAgY29uc3QgZlByb3h5ID1cbiAgICAgICAgICAgIGFwcGx5QXJnY0NoZWNrICYmICF3YXNtLmlzUHRyKGZ1bmMpXG4gICAgICAgICAgICAgID8gY2FsbGVlLmFyZ2NQcm94eSh0Z3QsIG1lbUtleSwgZnVuYywgc2lnTilcbiAgICAgICAgICAgICAgOiBmdW5jO1xuICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGZQcm94eSkpIHtcbiAgICAgICAgICAgIGlmIChmUHJveHkgJiYgIXdhc20uZnVuY3Rpb25FbnRyeShmUHJveHkpKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BvaW50ZXInLCBmUHJveHksICdpcyBub3QgYSBXQVNNIGZ1bmN0aW9uIHRhYmxlIGVudHJ5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGd0W21lbUtleV0gPSBmUHJveHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBGdW5jID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICAgIGZQcm94eSxcbiAgICAgICAgICAgICAgdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lLCB0cnVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0Z3RbbWVtS2V5XSA9IHBGdW5jO1xuICAgICAgICAgICAgaWYgKCF0Z3Qub25kaXNwb3NlIHx8ICF0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QpIHtcbiAgICAgICAgICAgICAgdGd0LmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgICAnb25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgaGFuZGxlcicsXG4gICAgICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5wdXNoKG1lbUtleSwgcEZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKG4sIGYpID0+IGNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgc3RydWN0SW5zdGFuY2UsXG4gICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0aG9kcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgY29uc3QgcHJpb3IgPSBzZWVuLmdldChtKTtcbiAgICAgICAgICAgIGlmIChwcmlvcikge1xuICAgICAgICAgICAgICBjb25zdCBta2V5ID0gc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KGspO1xuICAgICAgICAgICAgICBzdHJ1Y3RJbnN0YW5jZVtta2V5XSA9XG4gICAgICAgICAgICAgICAgc3RydWN0SW5zdGFuY2Vbc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KHByaW9yKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kKHN0cnVjdEluc3RhbmNlLCBrLCBtLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICAgIHNlZW4uc2V0KG0sIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RydWN0SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgbmFtZSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5hbWVcbiAgICAgICAgICAgID8gaW5zdGFsbE1ldGhvZHModGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBpbnN0YWxsTWV0aG9kKHRoaXMsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2ssXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpbnN0YWxsTWV0aG9kcyh0aGlzLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIHNxbGl0ZTMudmVyc2lvbiA9IHtcbiAgICAgICAgICBsaWJWZXJzaW9uOiAnMy40OS4xJyxcbiAgICAgICAgICBsaWJWZXJzaW9uTnVtYmVyOiAzMDQ5MDAxLFxuICAgICAgICAgIHNvdXJjZUlkOlxuICAgICAgICAgICAgJzIwMjUtMDItMTggMTM6Mzg6NTggODczZDRlMjc0YjQ5ODhkMjYwYmE4MzU0YTk3MTgzMjRhMWMyNjE4N2E0YWI0YzFjYzAyMjdjMDNkMGYxMGU3MCcsXG4gICAgICAgICAgZG93bmxvYWRWZXJzaW9uOiAzNDkwMTAwLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGksXG4gICAgICAgICAgd2FzbSA9IHNxbGl0ZTMud2FzbSxcbiAgICAgICAgICB1dGlsID0gc3FsaXRlMy51dGlsO1xuXG4gICAgICAgIGNvbnN0IF9fcHRyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICBjb25zdCBfX3N0bXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGNvbnN0IGdldE93bk9wdGlvbiA9IChvcHRzLCBwLCBkZmx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3B0cywgcCk7XG4gICAgICAgICAgcmV0dXJuIGQgPyBkLnZhbHVlIDogZGZsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjaGVja1NxbGl0ZTNSYyA9IGZ1bmN0aW9uIChkYlB0ciwgc3FsaXRlUmVzdWx0Q29kZSkge1xuICAgICAgICAgIGlmIChzcWxpdGVSZXN1bHRDb2RlKSB7XG4gICAgICAgICAgICBpZiAoZGJQdHIgaW5zdGFuY2VvZiBEQikgZGJQdHIgPSBkYlB0ci5wb2ludGVyO1xuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgIHNxbGl0ZVJlc3VsdENvZGUsXG4gICAgICAgICAgICAgICdzcWxpdGUzIHJlc3VsdCBjb2RlJyxcbiAgICAgICAgICAgICAgc3FsaXRlUmVzdWx0Q29kZSArICc6JyxcbiAgICAgICAgICAgICAgZGJQdHJcbiAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19lcnJtc2coZGJQdHIpXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfZXJyc3RyKHNxbGl0ZVJlc3VsdENvZGUpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2RiVHJhY2VUb0NvbnNvbGUgPSB3YXNtLmluc3RhbGxGdW5jdGlvbihcbiAgICAgICAgICAnaShpcHBwKScsXG4gICAgICAgICAgZnVuY3Rpb24gKHQsIGMsIHAsIHgpIHtcbiAgICAgICAgICAgIGlmIChjYXBpLlNRTElURV9UUkFDRV9TVE1UID09PSB0KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdTUUwgVFJBQ0UgIycgKyArK3RoaXMuY291bnRlciArICcgdmlhIHNxbGl0ZTNAJyArIGMgKyAnOicsXG4gICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh4KSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQoeyBjb3VudGVyOiAwIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IF9fdmZzUG9zdE9wZW5DYWxsYmFjayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgZGJDdG9ySGVscGVyID0gZnVuY3Rpb24gY3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFjdG9yLl9uYW1lMnZmcykge1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXNXb3JrZXJUaHJlYWQgPVxuICAgICAgICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgaW1wb3J0U2NyaXB0c1xuICAgICAgICAgICAgICAgID8gKG4pID0+XG4gICAgICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgICAgICdUaGUgVkZTIGZvcicsXG4gICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAnaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIG1haW4gd2luZG93IHRocmVhZC4nLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIGN0b3IuX25hbWUydmZzWyc6bG9jYWxTdG9yYWdlOiddID0ge1xuICAgICAgICAgICAgICB2ZnM6ICdrdnZmcycsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCkgPT4gJ2xvY2FsJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpzZXNzaW9uU3RvcmFnZTonXSA9IHtcbiAgICAgICAgICAgICAgdmZzOiAna3Z2ZnMnLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogaXNXb3JrZXJUaHJlYWQgfHwgKCgpID0+ICdzZXNzaW9uJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvcHQgPSBjdG9yLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgbGV0IGZuID0gb3B0LmZpbGVuYW1lLFxuICAgICAgICAgICAgdmZzTmFtZSA9IG9wdC52ZnMsXG4gICAgICAgICAgICBmbGFnc1N0ciA9IG9wdC5mbGFncztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoJ3N0cmluZycgIT09IHR5cGVvZiBmbiAmJiAnbnVtYmVyJyAhPT0gdHlwZW9mIGZuKSB8fFxuICAgICAgICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBmbGFnc1N0ciB8fFxuICAgICAgICAgICAgKHZmc05hbWUgJiZcbiAgICAgICAgICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiB2ZnNOYW1lICYmXG4gICAgICAgICAgICAgICdudW1iZXInICE9PSB0eXBlb2YgdmZzTmFtZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yKCdJbnZhbGlkIERCIGN0b3IgYXJncycsIG9wdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgREIgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmbkpzID0gJ251bWJlcicgPT09IHR5cGVvZiBmbiA/IHdhc20uY3N0clRvSnMoZm4pIDogZm47XG4gICAgICAgICAgY29uc3QgdmZzQ2hlY2sgPSBjdG9yLl9uYW1lMnZmc1tmbkpzXTtcbiAgICAgICAgICBpZiAodmZzQ2hlY2spIHtcbiAgICAgICAgICAgIHZmc05hbWUgPSB2ZnNDaGVjay52ZnM7XG4gICAgICAgICAgICBmbiA9IGZuSnMgPSB2ZnNDaGVjay5maWxlbmFtZShmbkpzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBEYixcbiAgICAgICAgICAgIG9mbGFncyA9IDA7XG4gICAgICAgICAgaWYgKGZsYWdzU3RyLmluZGV4T2YoJ2MnKSA+PSAwKSB7XG4gICAgICAgICAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUgfCBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYWdzU3RyLmluZGV4T2YoJ3cnKSA+PSAwKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFEV1JJVEU7XG4gICAgICAgICAgaWYgKDAgPT09IG9mbGFncykgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFk7XG4gICAgICAgICAgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fRVhSRVNDT0RFO1xuICAgICAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFB0ciA9IHdhc20ucHN0YWNrLmFsbG9jUHRyKCk7XG4gICAgICAgICAgICBsZXQgcmMgPSBjYXBpLnNxbGl0ZTNfb3Blbl92MihmbiwgcFB0ciwgb2ZsYWdzLCB2ZnNOYW1lIHx8IDApO1xuICAgICAgICAgICAgcERiID0gd2FzbS5wZWVrUHRyKHBQdHIpO1xuICAgICAgICAgICAgY2hlY2tTcWxpdGUzUmMocERiLCByYyk7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzKHBEYiwgMSk7XG4gICAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZigndCcpID49IDApIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3RyYWNlX3YyKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9UUkFDRV9TVE1ULFxuICAgICAgICAgICAgICAgIF9fZGJUcmFjZVRvQ29uc29sZSxcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHBEYikgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyKHBEYik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZuSnM7XG4gICAgICAgICAgX19wdHJNYXAuc2V0KHRoaXMsIHBEYik7XG4gICAgICAgICAgX19zdG10TWFwLnNldCh0aGlzLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl92ZnMocERiKSB8fFxuICAgICAgICAgICAgICB0b3NzMygnSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBnZXQgVkZTIGZvciBuZXcgZGIgaGFuZGxlLicpO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXRTcWwgPSBfX3Zmc1Bvc3RPcGVuQ2FsbGJhY2tbcFZmc107XG4gICAgICAgICAgICBpZiAocG9zdEluaXRTcWwpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3RJbml0U3FsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwb3N0SW5pdFNxbCh0aGlzLCBzcWxpdGUzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyhcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19leGVjKHBEYiwgcG9zdEluaXRTcWwsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkYkN0b3JIZWxwZXIuc2V0VmZzUG9zdE9wZW5DYWxsYmFjayA9IGZ1bmN0aW9uIChwVmZzLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgJ2RiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlbkNhbGxiYWNrKCkgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ2Egbm9uLWZ1bmN0aW9uIGFyZ3VtZW50LicsXG4gICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9fdmZzUG9zdE9wZW5DYWxsYmFja1twVmZzXSA9IGNhbGxiYWNrO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbGVuYW1lID0gJzptZW1vcnk6JyxcbiAgICAgICAgICBmbGFncyA9ICdjJyxcbiAgICAgICAgICB2ZnMgPSBudWxsLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSB7fTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxID09PSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gJiZcbiAgICAgICAgICAgICdvYmplY3QnID09PSB0eXBlb2YgYXJndW1lbnRzWzBdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFyZywgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGFyZy5mbGFncykgYXJnLmZsYWdzID0gJ2MnO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnLnZmcykgYXJnLnZmcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcuZmlsZW5hbWUpIGFyZy5maWxlbmFtZSA9ICc6bWVtb3J5Oic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgYXJnLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBhcmcudmZzID0gdmZzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IERCID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBkYkN0b3JIZWxwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIERCLmRiQ3RvckhlbHBlciA9IGRiQ3RvckhlbHBlcjtcblxuICAgICAgICBjb25zdCBCaW5kVHlwZXMgPSB7XG4gICAgICAgICAgbnVsbDogMSxcbiAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgc3RyaW5nOiAzLFxuICAgICAgICAgIGJvb2xlYW46IDQsXG4gICAgICAgICAgYmxvYjogNSxcbiAgICAgICAgfTtcbiAgICAgICAgQmluZFR5cGVzWyd1bmRlZmluZWQnXSA9PSBCaW5kVHlwZXMubnVsbDtcbiAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgIEJpbmRUeXBlcy5iaWdpbnQgPSBCaW5kVHlwZXMubnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgU3RtdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoQmluZFR5cGVzICE9PSBhcmd1bWVudHNbMl0pIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RtdCBjb25zdHJ1Y3RvciBkaXJlY3RseS4gVXNlIERCLnByZXBhcmUoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlckNvdW50ID0gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgaWYgKCFkYi5wb2ludGVyKSB0b3NzMygnREIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Db2xJbmRleCA9IGZ1bmN0aW9uIChzdG10LCBuZHgpIHtcbiAgICAgICAgICBpZiAobmR4ICE9PSAobmR4IHwgMCkgfHwgbmR4IDwgMCB8fCBuZHggPj0gc3RtdC5jb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgdG9zczMoJ0NvbHVtbiBpbmRleCcsIG5keCwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcGFyc2VFeGVjQXJncyA9IGZ1bmN0aW9uIChkYiwgYXJncykge1xuICAgICAgICAgIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgb3V0Lm9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBhcmdzWzBdIHx8XG4gICAgICAgICAgICAgICAgdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZ3NbMF0pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzWzBdICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBvdXQub3B0LnNxbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGZvciBleGVjKCkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC5zcWwgPSB1dGlsLmZsZXhpYmxlU3RyaW5nKG91dC5zcWwpO1xuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG91dC5zcWwpIHtcbiAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIFNRTCBhcmd1bWVudCBvciB1bnN1cHBvcnRlZCBTUUwgdmFsdWUgdHlwZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3B0ID0gb3V0Lm9wdDtcbiAgICAgICAgICBzd2l0Y2ggKG9wdC5yZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVzdWx0Um93cyc6XG4gICAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBvcHQucmVzdWx0Um93cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlU3FsJzpcbiAgICAgICAgICAgICAgaWYgKCFvcHQuc2F2ZVNxbCkgb3B0LnNhdmVTcWwgPSBbXTtcbiAgICAgICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpID0+IG9wdC5zYXZlU3FsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAndGhpcyc6XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBkYjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByZXR1cm5WYWx1ZSB2YWx1ZTonLCBvcHQucmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdC5jYWxsYmFjayAmJiAhb3B0LnJldHVyblZhbHVlICYmIHVuZGVmaW5lZCAhPT0gb3B0LnJvd01vZGUpIHtcbiAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCkgPT4gb3B0LnJlc3VsdFJvd3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHQuY2FsbGJhY2sgfHwgb3B0LnJlc3VsdFJvd3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodW5kZWZpbmVkID09PSBvcHQucm93TW9kZSA/ICdhcnJheScgOiBvcHQucm93TW9kZSkge1xuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10LCBjYWNoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5jb2x1bW5OYW1lcylcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuY29sdW1uTmFtZXMgPSBzdG10LmdldENvbHVtbk5hbWVzKFtdKTtcblxuICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gc3RtdC5nZXQoW10pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGNhY2hlLmNvbHVtbk5hbWVzKVxuICAgICAgICAgICAgICAgICAgICBydltjYWNoZS5jb2x1bW5OYW1lc1tpXV0gPSByb3dbaV07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0bXQnOlxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSkge1xuICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICdleGVjKCk6IGludmFsaWQgcm93TW9kZSBmb3IgYSByZXN1bHRSb3dzIGFycmF5OiBtdXN0JyxcbiAgICAgICAgICAgICAgICAgICAgXCJiZSBvbmUgb2YgJ2FycmF5JywgJ29iamVjdCcsXCIsXG4gICAgICAgICAgICAgICAgICAgICdhIHJlc3VsdCBjb2x1bW4gbnVtYmVyLCBvciBjb2x1bW4gbmFtZSByZWZlcmVuY2UuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIob3B0LnJvd01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCkgPT4gc3RtdC5nZXQob3B0LnJvd01vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0LnJvd01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG9wdC5yb3dNb2RlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICckJyA9PT0gb3B0LnJvd01vZGVbMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0ICRjb2xOYW1lID0gb3B0LnJvd01vZGUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKVskY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgPT09IHJjXG4gICAgICAgICAgICAgICAgICAgICAgPyB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdleGVjKCk6IHVua25vd24gcmVzdWx0IGNvbHVtbjonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IHJjO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByb3dNb2RlOicsIG9wdC5yb3dNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEZpcnN0Um93ID0gKGRiLCBzcWwsIGJpbmQsIC4uLmdldEFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG10ID0gZGIucHJlcGFyZShzcWwpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHN0bXQuYmluZChiaW5kKS5zdGVwKClcbiAgICAgICAgICAgICAgPyBzdG10LmdldCguLi5nZXRBcmdzKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEFsbCA9IChkYiwgc3FsLCBiaW5kLCByb3dNb2RlKSA9PlxuICAgICAgICAgIGRiLmV4ZWMoe1xuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgYmluZCxcbiAgICAgICAgICAgIHJvd01vZGUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIERCLmNoZWNrUmMgPSAoZGIsIHJlc3VsdENvZGUpID0+IGNoZWNrU3FsaXRlM1JjKGRiLCByZXN1bHRDb2RlKTtcblxuICAgICAgICBEQi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgaXNPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmZmlybU9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UgJiYgdGhpcy5vbmNsb3NlLmJlZm9yZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZS5iZWZvcmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwRGIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmZvckVhY2goKGssIHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocyAmJiBzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBfX3N0bXRNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSAmJiB0aGlzLm9uY2xvc2UuYWZ0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UuYWZ0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hhbmdlczogZnVuY3Rpb24gKHRvdGFsID0gZmFsc2UsIHNpeHR5Rm91ciA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NChwKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXMocCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY2hhbmdlczY0KHApXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY2hhbmdlcyhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJGaWxlbmFtZTogZnVuY3Rpb24gKGRiTmFtZSA9ICdtYWluJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9maWxlbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJOYW1lOiBmdW5jdGlvbiAoZGJOdW1iZXIgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX25hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTnVtYmVyKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJWZnNOYW1lOiBmdW5jdGlvbiAoZGJOYW1lID0gMCkge1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMoXG4gICAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLFxuICAgICAgICAgICAgICBkYk5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHBWZnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJjID0gd2FzbS5jc3RyVG9Kcyh2LiR6TmFtZSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcHJlcGFyZTogZnVuY3Rpb24gKHNxbCkge1xuICAgICAgICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgbGV0IHBwU3RtdCwgcFN0bXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcFN0bXQgPSB3YXNtLnBzdGFjay5hbGxvYyg4KTtcbiAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyKHRoaXMucG9pbnRlciwgc3FsLCAtMSwgcHBTdG10LCBudWxsKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwU3RtdCkgdG9zczMoJ0Nhbm5vdCBwcmVwYXJlIGVtcHR5IFNRTC4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgIF9fc3RtdE1hcC5nZXQodGhpcylbcFN0bXRdID0gc3RtdDtcbiAgICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXJzZUV4ZWNBcmdzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWFyZy5zcWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvc3MzKCdleGVjKCkgcmVxdWlyZXMgYW4gU1FMIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGFyZy5vcHQ7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdC5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFJvd3MgPSBBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKVxuICAgICAgICAgICAgICA/IG9wdC5yZXN1bHRSb3dzXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN0bXQ7XG4gICAgICAgICAgICBsZXQgYmluZCA9IG9wdC5iaW5kO1xuICAgICAgICAgICAgbGV0IGV2YWxGaXJzdFJlc3VsdCA9ICEhKFxuICAgICAgICAgICAgICBhcmcuY2JBcmcgfHxcbiAgICAgICAgICAgICAgb3B0LmNvbHVtbk5hbWVzIHx8XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzYXZlU3FsID0gQXJyYXkuaXNBcnJheShvcHQuc2F2ZVNxbClcbiAgICAgICAgICAgICAgPyBvcHQuc2F2ZVNxbFxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzVEEgPSB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGxldCBzcWxCeXRlTGVuID0gaXNUQVxuICAgICAgICAgICAgICAgID8gYXJnLnNxbC5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgOiB3YXNtLmpzdHJsZW4oYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBwU3RtdCA9IHdhc20uc2NvcGVkQWxsb2MoXG4gICAgICAgICAgICAgICAgMiAqIHdhc20ucHRyU2l6ZW9mICsgKHNxbEJ5dGVMZW4gKyAxKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgcHpUYWlsID0gcHBTdG10ICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGxldCBwU3FsID0gcHpUYWlsICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGNvbnN0IHBTcWxFbmQgPSBwU3FsICsgc3FsQnl0ZUxlbjtcbiAgICAgICAgICAgICAgaWYgKGlzVEEpIHdhc20uaGVhcDgoKS5zZXQoYXJnLnNxbCwgcFNxbCk7XG4gICAgICAgICAgICAgIGVsc2Ugd2FzbS5qc3RyY3B5KGFyZy5zcWwsIHdhc20uaGVhcDgoKSwgcFNxbCwgc3FsQnl0ZUxlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UocFNxbCArIHNxbEJ5dGVMZW4sIDApO1xuICAgICAgICAgICAgICB3aGlsZSAocFNxbCAmJiB3YXNtLnBlZWsocFNxbCwgJ2k4JykpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIoW3BwU3RtdCwgcHpUYWlsXSwgMCk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBwU3FsLFxuICAgICAgICAgICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgICAgICAgICAgIHBTcWwgPSB3YXNtLnBlZWtQdHIocHpUYWlsKTtcbiAgICAgICAgICAgICAgICBzcWxCeXRlTGVuID0gcFNxbEVuZCAtIHBTcWw7XG4gICAgICAgICAgICAgICAgaWYgKCFwU3RtdCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVTcWwpIHNhdmVTcWwucHVzaChjYXBpLnNxbGl0ZTNfc3FsKHBTdG10KS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZCAmJiBzdG10LnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgICAgICBiaW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxGaXJzdFJlc3VsdCAmJiBzdG10LmNvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ290Q29sTmFtZXMgPSBBcnJheS5pc0FycmF5KG9wdC5jb2x1bW5OYW1lcykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgIGV2YWxGaXJzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jYkFyZyB8fCByZXN1bHRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiQXJnQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgc3RtdC5zdGVwKCk7IHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGdvdENvbE5hbWVzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjYkFyZ0NhY2hlLmNvbHVtbk5hbWVzID0gb3B0LmNvbHVtbk5hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gYXJnLmNiQXJnKHN0bXQsIGNiQXJnQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRSb3dzKSByZXN1bHRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgZmFsc2UgPT09IGNhbGxiYWNrLmNhbGwob3B0LCByb3csIHN0bXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZ290Q29sTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RtdC5nZXRDb2x1bW5OYW1lcyhvcHQuY29sdW1uTmFtZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdG10LnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RtdC5yZXNldCgpLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgc3RtdCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc3RhY2spO1xuICAgICAgICAgICAgICBpZiAoc3RtdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG10Ll9sb2NrZWRCeUV4ZWM7XG4gICAgICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnLnJldHVyblZhbCgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gZihuYW1lLCB4RnVuYywgb3B0KSB7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSAoZikgPT4gZiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvcHQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBvcHQubmFtZTtcbiAgICAgICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmMoeEZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgICBvcHQgPSB4RnVuYztcbiAgICAgICAgICAgICAgICAgIHhGdW5jID0gb3B0LnhGdW5jIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdCkgb3B0ID0ge307XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBuYW1lKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50czogbWlzc2luZyBmdW5jdGlvbiBuYW1lLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHhTdGVwID0gb3B0LnhTdGVwIHx8IDA7XG4gICAgICAgICAgICBsZXQgeEZpbmFsID0gb3B0LnhGaW5hbCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgeFZhbHVlID0gb3B0LnhWYWx1ZSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgeEludmVyc2UgPSBvcHQueEludmVyc2UgfHwgMDtcbiAgICAgICAgICAgIGxldCBpc1dpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMoeEZ1bmMpKSB7XG4gICAgICAgICAgICAgIGlzV2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmMoeFN0ZXApIHx8IGlzRnVuYyh4RmluYWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoJ0FtYmlndW91cyBhcmd1bWVudHM6IHNjYWxhciBvciBhZ2dyZWdhdGU/Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeFN0ZXAgPSB4RmluYWwgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeFN0ZXApKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGdW5jKHhGaW5hbCkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyB4RmluYWwoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeEZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeEZpbmFsKSkge1xuICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyB4U3RlcCgpIGNhbGxiYWNrIGZvciBhZ2dyZWdhdGUgb3Igd2luZG93IFVERi4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIGZ1bmN0aW9uLXR5cGUgcHJvcGVydGllcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRnVuYyh4VmFsdWUpIHx8IGlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICd4VmFsdWUgYW5kIHhJbnZlcnNlIGFyZSBub3QgcGVybWl0dGVkIGZvciBub24td2luZG93IFVERnMuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuYyh4VmFsdWUpKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGdW5jKHhJbnZlcnNlKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKCd4SW52ZXJzZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhWYWx1ZSBpcy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ3hWYWx1ZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhJbnZlcnNlIGlzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcEFwcCA9IG9wdC5wQXBwO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBBcHAgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcEFwcCAmJlxuICAgICAgICAgICAgICAoJ251bWJlcicgIT09IHR5cGVvZiBwQXBwIHx8ICF1dGlsLmlzSW50MzIocEFwcCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUgZm9yIHBBcHAgcHJvcGVydHkuIE11c3QgYmUgYSBsZWdhbCBXQVNNIHBvaW50ZXIgdmFsdWUuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHhEZXN0cm95ID0gb3B0LnhEZXN0cm95IHx8IDA7XG4gICAgICAgICAgICBpZiAoeERlc3Ryb3kgJiYgIWlzRnVuYyh4RGVzdHJveSkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ3hEZXN0cm95IHByb3BlcnR5IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmRmxhZ3MgPSAwO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdkZXRlcm1pbmlzdGljJykpXG4gICAgICAgICAgICAgIGZGbGFncyB8PSBjYXBpLlNRTElURV9ERVRFUk1JTklTVElDO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdkaXJlY3RPbmx5JykpXG4gICAgICAgICAgICAgIGZGbGFncyB8PSBjYXBpLlNRTElURV9ESVJFQ1RPTkxZO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdpbm5vY3VvdXMnKSkgZkZsYWdzIHw9IGNhcGkuU1FMSVRFX0lOTk9DVU9VUztcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCB4QXJpdHkgPSB4RnVuYyB8fCB4U3RlcDtcbiAgICAgICAgICAgIGNvbnN0IGFyaXR5ID0gZ2V0T3duT3B0aW9uKG9wdCwgJ2FyaXR5Jyk7XG4gICAgICAgICAgICBjb25zdCBhcml0eUFyZyA9XG4gICAgICAgICAgICAgICdudW1iZXInID09PSB0eXBlb2YgYXJpdHlcbiAgICAgICAgICAgICAgICA/IGFyaXR5XG4gICAgICAgICAgICAgICAgOiB4QXJpdHkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IHhBcml0eS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgICBpZiAoaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhcml0eUFyZyxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLFxuICAgICAgICAgICAgICAgIHBBcHAgfHwgMCxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKFxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGFyaXR5QXJnLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1VURjggfCBmRmxhZ3MsXG4gICAgICAgICAgICAgICAgcEFwcCB8fCAwLFxuICAgICAgICAgICAgICAgIHhGdW5jLFxuICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERCLmNoZWNrUmModGhpcywgcmMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdFZhbHVlOiBmdW5jdGlvbiAoc3FsLCBiaW5kLCBhc1R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NlbGVjdEZpcnN0Um93KHRoaXMsIHNxbCwgYmluZCwgMCwgYXNUeXBlKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0VmFsdWVzOiBmdW5jdGlvbiAoc3FsLCBiaW5kLCBhc1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSB0aGlzLnByZXBhcmUoc3FsKSxcbiAgICAgICAgICAgICAgcmMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0bXQuYmluZChiaW5kKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0bXQuc3RlcCgpKSByYy5wdXNoKHN0bXQuZ2V0KDAsIGFzVHlwZSkpO1xuICAgICAgICAgICAgICBzdG10LnJlc2V0KCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBzdG10LmZpbmFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdEFycmF5OiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIFtdKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0T2JqZWN0OiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIHt9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0QXJyYXlzOiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RBbGwodGhpcywgc3FsLCBiaW5kLCAnYXJyYXknKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0T2JqZWN0czogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ29iamVjdCcpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvcGVuU3RhdGVtZW50Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXIgPyBPYmplY3Qua2V5cyhfX3N0bXRNYXAuZ2V0KHRoaXMpKS5sZW5ndGggOiAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgb3BlbmVyID0gJ0JFR0lOJztcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBpZiAoL1teYS16QS1aXS8udGVzdChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBmb3IgQkVHSU4gcXVhbGlmaWVyLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVuZXIgKz0gJyAnICsgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKG9wZW5lcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ0NPTU1JVCcpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhlYygnUk9MTEJBQ0snKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2F2ZXBvaW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKCdTQVZFUE9JTlQgb28xJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ1JFTEVBU0Ugb28xJyk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdST0xMQkFDSyB0byBTQVZFUE9JTlQgb28xOyBSRUxFQVNFIFNBVkVQT0lOVCBvbzEnKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hlY2tSYzogZnVuY3Rpb24gKHJlc3VsdENvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NxbGl0ZTNSYyh0aGlzLCByZXN1bHRDb2RlKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybVN0bXRPcGVuID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgICBpZiAoIXN0bXQucG9pbnRlcikgdG9zczMoJ1N0bXQgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGxldCB0ID0gQmluZFR5cGVzW251bGwgPT09IHYgfHwgdW5kZWZpbmVkID09PSB2ID8gJ251bGwnIDogdHlwZW9mIHZdO1xuICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmlnaW50OlxuICAgICAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSByZXR1cm4gdDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgPyBCaW5kVHlwZXMuYmxvYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1N1cHBvcnRlZEJpbmRUeXBlKHYpIHx8XG4gICAgICAgICAgICB0b3NzMygnVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6JywgdHlwZW9mIHYpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1QYXJhbUluZGV4ID0gZnVuY3Rpb24gKHN0bXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IG4gPVxuICAgICAgICAgICAgJ251bWJlcicgPT09IHR5cGVvZiBrZXlcbiAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgoc3RtdC5wb2ludGVyLCBrZXkpO1xuICAgICAgICAgIGlmICgwID09PSBuIHx8ICF1dGlsLmlzSW50MzIobikpIHtcbiAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGJpbmQoKSBwYXJhbWV0ZXIgbmFtZTogJyArIGtleSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuIDwgMSB8fCBuID4gc3RtdC5wYXJhbWV0ZXJDb3VudClcbiAgICAgICAgICAgIHRvc3MzKCdCaW5kIGluZGV4Jywga2V5LCAnaXMgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybU5vdExvY2tlZEJ5RXhlYyA9IGZ1bmN0aW9uIChzdG10LCBjdXJyZW50T3BOYW1lKSB7XG4gICAgICAgICAgaWYgKHN0bXQuX2xvY2tlZEJ5RXhlYykge1xuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICdPcGVyYXRpb24gaXMgaWxsZWdhbCB3aGVuIHN0YXRlbWVudCBpcyBsb2NrZWQ6JyxcbiAgICAgICAgICAgICAgY3VycmVudE9wTmFtZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJpbmRPbmUgPSBmdW5jdGlvbiBmKHN0bXQsIG5keCwgYmluZFR5cGUsIHZhbCkge1xuICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyhhZmZpcm1TdG10T3BlbihzdG10KSwgJ2JpbmQoKScpO1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl90b29CaWdJbnQgPSAodikgPT5cbiAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgJ0JpZ0ludCB2YWx1ZSBpcyB0b28gYmlnIHRvIHN0b3JlIHdpdGhvdXQgcHJlY2lzaW9uIGxvc3M6JyxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZi5fID0ge1xuICAgICAgICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChzdG10LCBuZHgsIHZhbCwgYXNCbG9iKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BTdHIsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcodmFsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gYXNCbG9iXG4gICAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2JcbiAgICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2JpbmRfdGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihzdG10LnBvaW50ZXIsIG5keCwgcFN0ciwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHZhbCk7XG4gICAgICAgICAgbmR4ID0gYWZmaXJtUGFyYW1JbmRleChzdG10LCBuZHgpO1xuICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgIG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCA/IEJpbmRUeXBlcy5udWxsIDogYmluZFR5cGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfbnVsbChzdG10LnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6IHtcbiAgICAgICAgICAgICAgbGV0IG07XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIodmFsKSkgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoJ2JpZ2ludCcgPT09IHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuYmlnSW50Rml0czY0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGYuX3Rvb0JpZ0ludCh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfZG91YmxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmMgPSBtKHN0bXQucG9pbnRlciwgbmR4LCB2YWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50KHN0bXQucG9pbnRlciwgbmR4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmxvYjoge1xuICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAnQmluZGluZyBhIHZhbHVlIGFzIGEgYmxvYiByZXF1aXJlcycsXG4gICAgICAgICAgICAgICAgICAndGhhdCBpdCBiZSBhIHN0cmluZywgVWludDhBcnJheSwgSW50OEFycmF5LCBvciBBcnJheUJ1ZmZlci4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jKHZhbC5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgICAgICB3YXNtLmhlYXA4KCkuc2V0KHZhbC5ieXRlTGVuZ3RoID8gdmFsIDogWzBdLCBwQmxvYik7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfYmxvYihcbiAgICAgICAgICAgICAgICBzdG10LnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmR4LFxuICAgICAgICAgICAgICAgIHBCbG9iLFxuICAgICAgICAgICAgICAgIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKCdVbnN1cHBvcnRlZCBiaW5kKCkgYXJndW1lbnQgdHlwZTonLCB2YWwpO1xuICAgICAgICAgICAgICB0b3NzMygnVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJjKSBEQi5jaGVja1JjKHN0bXQuZGIucG9pbnRlciwgcmMpO1xuICAgICAgICAgIHN0bXQuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0bXQucHJvdG90eXBlID0ge1xuICAgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCAnZmluYWxpemUoKScpO1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19maW5hbGl6ZSh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgICAgICBkZWxldGUgX19zdG10TWFwLmdldCh0aGlzLmRiKVt0aGlzLnBvaW50ZXJdO1xuICAgICAgICAgICAgICBfX3B0ck1hcC5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXlHZXQ7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlckNvdW50O1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9ja2VkQnlFeGVjO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjbGVhckJpbmRpbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4odGhpcyksICdjbGVhckJpbmRpbmdzKCknKTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jbGVhcl9iaW5kaW5ncyh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIChhbHNvQ2xlYXJCaW5kcykge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsICdyZXNldCgpJyk7XG4gICAgICAgICAgICBpZiAoYWxzb0NsZWFyQmluZHMpIHRoaXMuY2xlYXJCaW5kaW5ncygpO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfcmVzZXQoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNoZWNrU3FsaXRlM1JjKHRoaXMuZGIsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgICAgICAgIGxldCBuZHgsIGFyZztcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbmR4ID0gMTtcbiAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBuZHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGJpbmQoKSBhcmd1bWVudHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdUaGlzIHN0YXRlbWVudCBoYXMgbm8gYmluZGFibGUgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGFyZykge1xuICAgICAgICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5udWxsLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICdXaGVuIGJpbmRpbmcgYW4gYXJyYXksIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZy5mb3JFYWNoKCh2LCBpKSA9PlxuICAgICAgICAgICAgICAgIGJpbmRPbmUodGhpcywgaSArIDEsIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHYpLCB2KSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIGFyZyA9IG5ldyBVaW50OEFycmF5KGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBhcmcgJiYgIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgJ1doZW4gYmluZGluZyBhbiBvYmplY3QsIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaCgoaykgPT5cbiAgICAgICAgICAgICAgICBiaW5kT25lKHRoaXMsIGssIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKGFyZ1trXSksIGFyZ1trXSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9zczMoJ1Nob3VsZCBub3QgcmVhY2ggdGhpcyBwb2ludC4nKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYmluZEFzQmxvYjogZnVuY3Rpb24gKG5keCwgYXJnKSB7XG4gICAgICAgICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFyZyA9IG5keDtcbiAgICAgICAgICAgICAgbmR4ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBCaW5kVHlwZXMuc3RyaW5nICE9PSB0ICYmXG4gICAgICAgICAgICAgIEJpbmRUeXBlcy5ibG9iICE9PSB0ICYmXG4gICAgICAgICAgICAgIEJpbmRUeXBlcy5udWxsICE9PSB0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdG9zczMoJ0ludmFsaWQgdmFsdWUgdHlwZSBmb3IgYmluZEFzQmxvYigpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5ibG9iLCBhcmcpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywgJ3N0ZXAoKScpO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfc3RlcChhZmZpcm1TdG10T3Blbih0aGlzKS5wb2ludGVyKTtcbiAgICAgICAgICAgIHN3aXRjaCAocmMpIHtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ET05FOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWF5R2V0ID0gZmFsc2UpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1JPVzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX21heUdldCA9IHRydWUpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19zdGVwKCkgcmM9JyxcbiAgICAgICAgICAgICAgICAgIHJjLFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICAgICAnU1FMID0nLFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3NxbCh0aGlzLnBvaW50ZXIpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyh0aGlzLmRiLnBvaW50ZXIsIHJjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3RlcFJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHN0ZXBGaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAobmR4LCBhc1R5cGUpIHtcbiAgICAgICAgICAgIGlmICghYWZmaXJtU3RtdE9wZW4odGhpcykuX21heUdldCkge1xuICAgICAgICAgICAgICB0b3NzMygnU3RtdC5zdGVwKCkgaGFzIG5vdCAocmVjZW50bHkpIHJldHVybmVkIHRydWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZHgpKSB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIG5keFtpXSA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5keDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmR4ICYmICdvYmplY3QnID09PSB0eXBlb2YgbmR4KSB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIG5keFtjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLCBpKV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZmZpcm1Db2xJbmRleCh0aGlzLCBuZHgpO1xuICAgICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgICAgdW5kZWZpbmVkID09PSBhc1R5cGVcbiAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jb2x1bW5fdHlwZSh0aGlzLnBvaW50ZXIsIG5keClcbiAgICAgICAgICAgICAgICA6IGFzVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfTlVMTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOiB7XG4gICAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2ludDY0KHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmMgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmMgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHJjKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICByYyA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4gICAgICAgICAgICAgICAgICAgIHJjIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAnSW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UgZm9yIEpTIGludGVnZXIgcmFuZ2U6ICcgKyByYyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNJbnQzMihyYykgPyByYyB8IDAgOiByYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9GTE9BVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1RFWFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fdGV4dCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQkxPQjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2J5dGVzKHRoaXMucG9pbnRlciwgbmR4KSxcbiAgICAgICAgICAgICAgICAgIHB0ciA9IGNhcGkuc3FsaXRlM19jb2x1bW5fYmxvYih0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICByYyA9IG5ldyBVaW50OEFycmF5KG4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4pIHJjLnNldCh3YXNtLmhlYXA4dSgpLnNsaWNlKHB0ciwgcHRyICsgbiksIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gJiYgdGhpcy5kYi5fYmxvYlhmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYi5fYmxvYlhmZXIucHVzaChyYy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgIFwiRG9uJ3Qga25vdyBob3cgdG8gdHJhbnNsYXRlXCIsXG4gICAgICAgICAgICAgICAgICAndHlwZSBvZiByZXN1bHQgY29sdW1uICMnICsgbmR4ICsgJy4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3NzMygnTm90IHJlYWNoZWQuJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEludDogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfSU5URUdFUik7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEZsb2F0OiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9GTE9BVCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldFN0cmluZzogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfVEVYVCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEJsb2I6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX0JMT0IpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRKU09OOiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9TVFJJTkcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IHMgPyBzIDogSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0Q29sdW1uTmFtZTogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fbmFtZShcbiAgICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksIG5keCkucG9pbnRlcixcbiAgICAgICAgICAgICAgbmR4LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0Q29sdW1uTmFtZXM6IGZ1bmN0aW9uICh0Z3QgPSBbXSkge1xuICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksIDApO1xuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICB0Z3QucHVzaChjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGd0O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRQYXJhbUluZGV4OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybVN0bXRPcGVuKHRoaXMpLnBhcmFtZXRlckNvdW50XG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHRoaXMucG9pbnRlciwgbmFtZSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldFBhcmFtTmFtZTogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybVN0bXRPcGVuKHRoaXMpLnBhcmFtZXRlckNvdW50XG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUodGhpcy5wb2ludGVyLCBuZHgpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpc0J1c3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAwICE9PSBjYXBpLnNxbGl0ZTNfc3RtdF9idXN5KGFmZmlybVN0bXRPcGVuKHRoaXMpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNSZWFkT25seTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDAgIT09IGNhcGkuc3FsaXRlM19zdG10X3JlYWRvbmx5KGFmZmlybVN0bXRPcGVuKHRoaXMpKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwcm9wID0ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19wdHJNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogKCkgPT4gdG9zczMoJ1RoZSBwb2ludGVyIHByb3BlcnR5IGlzIHJlYWQtb25seS4nKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG10LnByb3RvdHlwZSwgJ3BvaW50ZXInLCBwcm9wKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoREIucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAnY29sdW1uQ291bnQnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9jb3VudCh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAoKSA9PiB0b3NzMygnVGhlIGNvbHVtbkNvdW50IHByb3BlcnR5IGlzIHJlYWQtb25seS4nKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3FsaXRlMy5vbzEgPSB7XG4gICAgICAgICAgREIsXG4gICAgICAgICAgU3RtdCxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICBzcWxpdGUzLm9vMS5Kc1N0b3JhZ2VEYiA9IGZ1bmN0aW9uIChzdG9yYWdlTmFtZSA9ICdzZXNzaW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lID0gb3B0LmZpbGVuYW1lO1xuICAgICAgICAgICAgaWYgKCdzZXNzaW9uJyAhPT0gc3RvcmFnZU5hbWUgJiYgJ2xvY2FsJyAhPT0gc3RvcmFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgdG9zczMoXCJKc1N0b3JhZ2VEYiBkYiBuYW1lIG11c3QgYmUgb25lIG9mICdzZXNzaW9uJyBvciAnbG9jYWwnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdC52ZnMgPSAna3Z2ZnMnO1xuICAgICAgICAgICAgZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGpkYiA9IHNxbGl0ZTMub28xLkpzU3RvcmFnZURiO1xuICAgICAgICAgIGpkYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERCLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICBqZGIuY2xlYXJTdG9yYWdlID0gY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyO1xuXG4gICAgICAgICAgamRiLnByb3RvdHlwZS5jbGVhclN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gamRiLmNsZWFyU3RvcmFnZShhZmZpcm1EYk9wZW4odGhpcykuZmlsZW5hbWUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBqZGIuc3RvcmFnZVNpemUgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZTtcblxuICAgICAgICAgIGpkYi5wcm90b3R5cGUuc3RvcmFnZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gamRiLnN0b3JhZ2VTaXplKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICAgICAgICBzcWxpdGUzLmluaXRXb3JrZXIxQVBJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIShnbG9iYWxUaGlzLldvcmtlckdsb2JhbFNjb3BlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0b3NzKCdpbml0V29ya2VyMUFQSSgpIG11c3QgYmUgcnVuIGZyb20gYSBXb3JrZXIgdGhyZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzcWxpdGUzID0gdGhpcy5zcWxpdGUzIHx8IHRvc3MoJ01pc3NpbmcgdGhpcy5zcWxpdGUzIG9iamVjdC4nKTtcbiAgICAgICAgICBjb25zdCBEQiA9IHNxbGl0ZTMub28xLkRCO1xuXG4gICAgICAgICAgY29uc3QgZ2V0RGJJZCA9IGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgbGV0IGlkID0gd1N0YXRlLmlkTWFwLmdldChkYik7XG4gICAgICAgICAgICBpZiAoaWQpIHJldHVybiBpZDtcbiAgICAgICAgICAgIGlkID0gJ2RiIycgKyArK3dTdGF0ZS5pZFNlcSArICdAJyArIGRiLnBvaW50ZXI7XG5cbiAgICAgICAgICAgIHdTdGF0ZS5pZE1hcC5zZXQoZGIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgd1N0YXRlID0ge1xuICAgICAgICAgICAgZGJMaXN0OiBbXSxcblxuICAgICAgICAgICAgaWRTZXE6IDAsXG5cbiAgICAgICAgICAgIGlkTWFwOiBuZXcgV2Vha01hcCgpLFxuXG4gICAgICAgICAgICB4ZmVyOiBbXSxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBuZXcgREIob3B0KTtcbiAgICAgICAgICAgICAgdGhpcy5kYnNbZ2V0RGJJZChkYildID0gZGI7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmRiTGlzdC5pbmRleE9mKGRiKSA8IDApIHRoaXMuZGJMaXN0LnB1c2goZGIpO1xuICAgICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChkYiwgYWxzb1VubGluaykge1xuICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYnNbZ2V0RGJJZChkYildO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZGIuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcFZmcyA9IHV0aWwuc3FsaXRlM19fd2FzbV9kYl92ZnMoZGIucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZE5keCA9IHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpO1xuICAgICAgICAgICAgICAgIGlmIChkZE5keCA+PSAwKSB0aGlzLmRiTGlzdC5zcGxpY2UoZGROZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhbHNvVW5saW5rICYmIGZpbGVuYW1lICYmIHBWZnMpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwuc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rKHBWZnMsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIChtc2csIHhmZXJMaXN0KSB7XG4gICAgICAgICAgICAgIGlmICh4ZmVyTGlzdCAmJiB4ZmVyTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKG1zZywgQXJyYXkuZnJvbSh4ZmVyTGlzdCkpO1xuICAgICAgICAgICAgICAgIHhmZXJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkYnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgICAgICAgIGdldERiOiBmdW5jdGlvbiAoaWQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5kYnNbaWRdIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVpcmUgPyB0b3NzKCdVbmtub3duIChvciBjbG9zZWQpIERCIElEOicsIGlkKSA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGFmZmlybURiT3BlbiA9IGZ1bmN0aW9uIChkYiA9IHdTdGF0ZS5kYkxpc3RbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYiAmJiBkYi5wb2ludGVyID8gZGIgOiB0b3NzKCdEQiBpcyBub3Qgb3BlbmVkLicpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBnZXRNc2dEYiA9IGZ1bmN0aW9uIChtc2dEYXRhLCBhZmZpcm1FeGlzdHMgPSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5nZXREYihtc2dEYXRhLmRiSWQsIGZhbHNlKSB8fCB3U3RhdGUuZGJMaXN0WzBdO1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybUV4aXN0cyA/IGFmZmlybURiT3BlbihkYikgOiBkYjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ2V0RGVmYXVsdERiSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd1N0YXRlLmRiTGlzdFswXSAmJiBnZXREYklkKHdTdGF0ZS5kYkxpc3RbMF0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBpc1NwZWNpYWxEYkZpbGVuYW1lID0gKG4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAnJyA9PT0gbiB8fCAnOicgPT09IG5bMF07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IHdNc2dIYW5kbGVyID0ge1xuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9hcmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBhcmdzID0gZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoYXJncy5zaW11bGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnVGhyb3dpbmcgYmVjYXVzZSBvZiBzaW11bGF0ZUVycm9yIGZsYWcuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBvYXJncy52ZnMgPSBhcmdzLnZmcztcbiAgICAgICAgICAgICAgb2FyZ3MuZmlsZW5hbWUgPSBhcmdzLmZpbGVuYW1lIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5vcGVuKG9hcmdzKTtcbiAgICAgICAgICAgICAgcmMuZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgcmMucGVyc2lzdGVudCA9ICEhc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMoXG4gICAgICAgICAgICAgICAgZGIucG9pbnRlcixcbiAgICAgICAgICAgICAgICAnb3BmcycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJjLmRiSWQgPSBnZXREYklkKGRiKTtcbiAgICAgICAgICAgICAgcmMudmZzID0gZGIuZGJWZnNOYW1lKCk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldiwgZmFsc2UpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZGIgJiYgZGIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVW5saW5rID1cbiAgICAgICAgICAgICAgICAgIGV2LmFyZ3MgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICAgID8gISFldi5hcmdzLnVubGlua1xuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdTdGF0ZS5jbG9zZShkYiwgZG9VbmxpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCByYyA9XG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICA/IHsgc3FsOiBldi5hcmdzIH1cbiAgICAgICAgICAgICAgICAgIDogZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoJ3N0bXQnID09PSByYy5yb3dNb2RlKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCByb3dNb2RlIGZvciAnZXhlYyc6IHN0bXQgbW9kZVwiLFxuICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IHdvcmsgaW4gdGhlIFdvcmtlciBBUEkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYy5zcWwpIHtcbiAgICAgICAgICAgICAgICB0b3NzKFwiJ2V4ZWMnIHJlcXVpcmVzIGlucHV0IFNRTC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICAgICAgICAgIGlmIChyYy5jYWxsYmFjayB8fCBBcnJheS5pc0FycmF5KHJjLnJlc3VsdFJvd3MpKSB7XG4gICAgICAgICAgICAgICAgZGIuX2Jsb2JYZmVyID0gd1N0YXRlLnhmZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlQ2FsbGJhY2sgPSByYy5jYWxsYmFjaztcbiAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGhhZENvbE5hbWVzID0gISFyYy5jb2x1bW5OYW1lcztcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhZENvbE5hbWVzKSByYy5jb2x1bW5OYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSBmdW5jdGlvbiAocm93LCBzdG10KSB7XG4gICAgICAgICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6ICsrcm93TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3U3RhdGUueGZlcixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNvdW50ID0gISFyYy5jb3VudENoYW5nZXNcbiAgICAgICAgICAgICAgICAgID8gZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGIuZXhlYyhyYyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gY2hhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHJjLmNoYW5nZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKSAtIGNoYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYi5fYmxvYlhmZXI7XG4gICAgICAgICAgICAgICAgaWYgKHJjLmNhbGxiYWNrKSByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjb25maWctZ2V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgc3JjID0gc3FsaXRlMy5jb25maWc7XG4gICAgICAgICAgICAgIFsnYmlnSW50RW5hYmxlZCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGspKSByY1trXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJjLnZlcnNpb24gPSBzcWxpdGUzLnZlcnNpb247XG4gICAgICAgICAgICAgIHJjLnZmc0xpc3QgPSBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHBvcnQ6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5OiBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQoZGIucG9pbnRlciksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGRiLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWV0eXBlOiAnYXBwbGljYXRpb24veC1zcWxpdGUzJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIucHVzaChyZXNwb25zZS5ieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9zczogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1Rlc3Rpbmcgd29ya2VyIGV4Y2VwdGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGV2ID0gZXYuZGF0YTtcbiAgICAgICAgICAgIGxldCByZXN1bHQsXG4gICAgICAgICAgICAgIGRiSWQgPSBldi5kYklkLFxuICAgICAgICAgICAgICBldlR5cGUgPSBldi50eXBlO1xuICAgICAgICAgICAgY29uc3QgYXJyaXZhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3TXNnSGFuZGxlci5oYXNPd25Qcm9wZXJ0eShldlR5cGUpICYmXG4gICAgICAgICAgICAgICAgd01zZ0hhbmRsZXJbZXZUeXBlXSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHdNc2dIYW5kbGVyW2V2VHlwZV0oZXYpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvc3MoJ1Vua25vd24gZGIgd29ya2VyIG1lc3NhZ2UgdHlwZTonLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGV2VHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGV2LnR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3JDbGFzczogZXJyLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGV2LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YWNrID1cbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2YgZXJyLnN0YWNrXG4gICAgICAgICAgICAgICAgICAgID8gZXJyLnN0YWNrLnNwbGl0KC9cXG5cXHMqLylcbiAgICAgICAgICAgICAgICAgICAgOiBlcnIuc3RhY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDApXG4gICAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybihcbiAgICAgICAgICAgICAgICAgICdXb3JrZXIgaXMgcHJvcGFnYXRpbmcgYW4gZXhjZXB0aW9uIHRvIG1haW4gdGhyZWFkLicsXG4gICAgICAgICAgICAgICAgICAnUmVwb3J0aW5nIGl0IF9oZXJlXyBmb3IgdGhlIHN0YWNrIHRyYWNlOicsXG4gICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGJJZCkge1xuICAgICAgICAgICAgICBkYklkID0gcmVzdWx0LmRiSWQgfHwgZ2V0RGVmYXVsdERiSWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd1N0YXRlLnBvc3QoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldlR5cGUsXG4gICAgICAgICAgICAgICAgZGJJZDogZGJJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGV2Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICB3b3JrZXJSZWNlaXZlZFRpbWU6IGFycml2YWxUaW1lLFxuICAgICAgICAgICAgICAgIHdvcmtlclJlc3BvbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICBkZXBhcnR1cmVUaW1lOiBldi5kZXBhcnR1cmVUaW1lLFxuXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHdTdGF0ZS54ZmVyLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3NxbGl0ZTMtYXBpJyxcbiAgICAgICAgICAgIHJlc3VsdDogJ3dvcmtlcjEtcmVhZHknLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQoeyBzcWxpdGUzIH0pO1xuICAgICAgfSk7XG5cbiAgICAgICgndXNlIHN0cmljdCcpO1xuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc20sXG4gICAgICAgICAgY2FwaSA9IHNxbGl0ZTMuY2FwaSxcbiAgICAgICAgICB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3MzO1xuICAgICAgICBjb25zdCB2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBzcWxpdGUzLnZmcyA9IHZmcztcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmZzLnByb3RvdHlwZS5yZWdpc3RlclZmcyA9IGZ1bmN0aW9uIChhc0RlZmF1bHQgPSBmYWxzZSkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnMpKSB7XG4gICAgICAgICAgICB0b3NzKCdFeHBlY3RpbmcgYSBzcWxpdGUzX3Zmcy10eXBlIGFyZ3VtZW50LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM192ZnNfcmVnaXN0ZXIodGhpcywgYXNEZWZhdWx0ID8gMSA6IDApO1xuICAgICAgICAgIGlmIChyYykge1xuICAgICAgICAgICAgdG9zcygnc3FsaXRlM192ZnNfcmVnaXN0ZXIoJywgdGhpcywgJykgZmFpbGVkIHdpdGggcmMnLCByYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXIgIT09IGNhcGkuc3FsaXRlM192ZnNfZmluZCh0aGlzLiR6TmFtZSkpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdCVUc6IHNxbGl0ZTNfdmZzX2ZpbmQodmZzLiR6TmFtZSkgZmFpbGVkIGZvciBqdXN0LWluc3RhbGxlZCBWRlMnLFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmZzLmluc3RhbGxWZnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICBjb25zdCBwcm9wTGlzdCA9IFsnaW8nLCAndmZzJ107XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcHJvcExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBvcHRba2V5XTtcbiAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICAgIG8uc3RydWN0Lmluc3RhbGxNZXRob2RzKG8ubWV0aG9kcywgISFvLmFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgICAgICAgaWYgKCd2ZnMnID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW8uc3RydWN0LiR6TmFtZSAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIG8ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgby5zdHJ1Y3QuYWRkT25EaXNwb3NlKFxuICAgICAgICAgICAgICAgICAgICAoby5zdHJ1Y3QuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoby5uYW1lKSksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvLnN0cnVjdC5yZWdpc3RlclZmcyghIW8uYXNEZWZhdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvdW50KVxuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01pc3VzZTogaW5zdGFsbFZmcygpIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzIGF0IGxlYXN0JyxcbiAgICAgICAgICAgICAgJ29uZSBvZjonLFxuICAgICAgICAgICAgICBwcm9wTGlzdCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgaWYgKCFzcWxpdGUzLndhc20uZXhwb3J0cy5zcWxpdGUzX2RlY2xhcmVfdnRhYikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtLFxuICAgICAgICAgIGNhcGkgPSBzcWxpdGUzLmNhcGksXG4gICAgICAgICAgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzMztcbiAgICAgICAgY29uc3QgdnRhYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHNxbGl0ZTMudnRhYiA9IHZ0YWI7XG5cbiAgICAgICAgY29uc3Qgc2lpID0gY2FwaS5zcWxpdGUzX2luZGV4X2luZm87XG5cbiAgICAgICAgc2lpLnByb3RvdHlwZS5udGhDb25zdHJhaW50ID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhQ29uc3RyYWludCArXG4gICAgICAgICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50LnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludChwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludFVzYWdlID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhQ29uc3RyYWludFVzYWdlICtcbiAgICAgICAgICAgIHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2Uuc3RydWN0SW5mby5zaXplb2YgKiBuO1xuICAgICAgICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlKHB0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lpLnByb3RvdHlwZS5udGhPcmRlckJ5ID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuT3JkZXJCeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhT3JkZXJCeSArIHNpaS5zcWxpdGUzX2luZGV4X29yZGVyYnkuc3RydWN0SW5mby5zaXplb2YgKiBuO1xuICAgICAgICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5KHB0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX194V3JhcEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgU3RydWN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocHRyLCByZW1vdmVNYXBwaW5nID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSBwdHIgPSBuZXcgU3RydWN0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHB0ciBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQocHRyLnBvaW50ZXIsIHB0cik7XG4gICAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3YXNtLmlzUHRyKHB0cikpIHtcbiAgICAgICAgICAgICAgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCB0bycsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSArICcoKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmMgPSB0aGlzLmdldChwdHIpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZU1hcHBpbmcpIHRoaXMuZGVsZXRlKHB0cik7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfS5iaW5kKG5ldyBNYXAoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgU3RydWN0UHRyTWFwcGVyID0gZnVuY3Rpb24gKG5hbWUsIFN0cnVjdFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBfX3hXcmFwID0gX194V3JhcEZhY3RvcnkobmFtZSwgU3RydWN0VHlwZSk7XG5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBTdHJ1Y3RUeXBlLFxuXG4gICAgICAgICAgICBjcmVhdGU6IChwcE91dCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9feFdyYXAoKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlUHRyKHBwT3V0LCByYy5wb2ludGVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0OiAocENPYmopID0+IF9feFdyYXAocENPYmopLFxuXG4gICAgICAgICAgICB1bmdldDogKHBDT2JqKSA9PiBfX3hXcmFwKHBDT2JqLCB0cnVlKSxcblxuICAgICAgICAgICAgZGlzcG9zZTogKHBDT2JqKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSBfX3hXcmFwKHBDT2JqLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKG8pIG8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2dGFiLnhWdGFiID0gU3RydWN0UHRyTWFwcGVyKCd4VnRhYicsIGNhcGkuc3FsaXRlM192dGFiKTtcblxuICAgICAgICB2dGFiLnhDdXJzb3IgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hDdXJzb3InLCBjYXBpLnNxbGl0ZTNfdnRhYl9jdXJzb3IpO1xuXG4gICAgICAgIHZ0YWIueEluZGV4SW5mbyA9IChwSWR4SW5mbykgPT4gbmV3IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvKHBJZHhJbmZvKTtcblxuICAgICAgICB2dGFiLnhFcnJvciA9IGZ1bmN0aW9uIGYobWV0aG9kTmFtZSwgZXJyLCBkZWZhdWx0UmMpIHtcbiAgICAgICAgICBpZiAoZi5lcnJvclJlcG9ydGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGYuZXJyb3JSZXBvcnRlcihcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19tb2R1bGU6OicgKyBtZXRob2ROYW1lICsgJygpOiAnICsgZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpIHJjID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHJjID0gZGVmYXVsdFJjO1xuICAgICAgICAgIGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuU1FMaXRlM0Vycm9yKSByYyA9IGVyci5yZXN1bHRDb2RlO1xuICAgICAgICAgIHJldHVybiByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgfTtcbiAgICAgICAgdnRhYi54RXJyb3IuZXJyb3JSZXBvcnRlciA9IDEgPyBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSkgOiBmYWxzZTtcblxuICAgICAgICB2dGFiLnhSb3dpZCA9IChwcFJvd2lkNjQsIHZhbHVlKSA9PiB3YXNtLnBva2UocHBSb3dpZDY0LCB2YWx1ZSwgJ2k2NCcpO1xuXG4gICAgICAgIHZ0YWIuc2V0dXBNb2R1bGUgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgbGV0IGNyZWF0ZWRNb2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBtb2QgPVxuICAgICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGNhcGkuc3FsaXRlM19tb2R1bGVcbiAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgIDogb3B0LnN0cnVjdCB8fCAoY3JlYXRlZE1vZCA9IG5ldyBjYXBpLnNxbGl0ZTNfbW9kdWxlKCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzID0gb3B0Lm1ldGhvZHMgfHwgdG9zcyhcIk1pc3NpbmcgJ21ldGhvZHMnIG9iamVjdC5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgICB4Q29ubmVjdDogJ3hDcmVhdGUnLFxuICAgICAgICAgICAgICB4RGlzY29ubmVjdDogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSBlWzBdLFxuICAgICAgICAgICAgICAgIHYgPSBlWzFdO1xuICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gbWV0aG9kc1trXSkgbWV0aG9kc1trXSA9IG1ldGhvZHNbdl07XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRydWUgPT09IG1ldGhvZHNbdl0pIG1ldGhvZHNbdl0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jYXRjaEV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZndyYXAgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgZnVuYykge1xuICAgICAgICAgICAgICAgIGlmIChbJ3hDb25uZWN0JywgJ3hDcmVhdGUnXS5pbmRleE9mKG1ldGhvZE5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocERiLCBwQXV4LCBhcmdjLCBhcmd2LCBwcFZ0YWIsIHB6RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJndW1lbnRzKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLmRlYWxsb2Mod2FzbS5wZWVrUHRyKHB6RXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIocHpFcnIsIHdhc20uYWxsb2NDU3RyaW5nKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBtbmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3hDcmVhdGUnLFxuICAgICAgICAgICAgICAgICd4Q29ubmVjdCcsXG4gICAgICAgICAgICAgICAgJ3hCZXN0SW5kZXgnLFxuICAgICAgICAgICAgICAgICd4RGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAneE9wZW4nLFxuICAgICAgICAgICAgICAgICd4Q2xvc2UnLFxuICAgICAgICAgICAgICAgICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAneE5leHQnLFxuICAgICAgICAgICAgICAgICd4RW9mJyxcbiAgICAgICAgICAgICAgICAneENvbHVtbicsXG4gICAgICAgICAgICAgICAgJ3hSb3dpZCcsXG4gICAgICAgICAgICAgICAgJ3hVcGRhdGUnLFxuICAgICAgICAgICAgICAgICd4QmVnaW4nLFxuICAgICAgICAgICAgICAgICd4U3luYycsXG4gICAgICAgICAgICAgICAgJ3hDb21taXQnLFxuICAgICAgICAgICAgICAgICd4Um9sbGJhY2snLFxuICAgICAgICAgICAgICAgICd4RmluZEZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAneFJlbmFtZScsXG4gICAgICAgICAgICAgICAgJ3hTYXZlcG9pbnQnLFxuICAgICAgICAgICAgICAgICd4UmVsZWFzZScsXG4gICAgICAgICAgICAgICAgJ3hSb2xsYmFja1RvJyxcbiAgICAgICAgICAgICAgICAneFNoYWRvd05hbWUnLFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBjb25zdCByZW1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgbW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IG1ldGhvZHNba107XG4gICAgICAgICAgICAgICAgaWYgKCEobSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3hDb25uZWN0JyA9PT0gayAmJiBtZXRob2RzLnhDcmVhdGUgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENyZWF0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCd4Q3JlYXRlJyA9PT0gayAmJiBtZXRob2RzLnhDb25uZWN0ID09PSBtKSB7XG4gICAgICAgICAgICAgICAgICByZW1ldGhvZHNba10gPSBtZXRob2RzLnhDb25uZWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZW1ldGhvZHNba10gPSBmd3JhcChrLCBtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbW9kLmluc3RhbGxNZXRob2RzKHJlbWV0aG9kcywgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kLmluc3RhbGxNZXRob2RzKG1ldGhvZHMsICEhb3B0LmFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwID09PSBtb2QuJGlWZXJzaW9uKSB7XG4gICAgICAgICAgICAgIGxldCB2O1xuICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBvcHQuaVZlcnNpb24pIHYgPSBvcHQuaVZlcnNpb247XG4gICAgICAgICAgICAgIGVsc2UgaWYgKG1vZC4keFNoYWRvd05hbWUpIHYgPSAzO1xuICAgICAgICAgICAgICBlbHNlIGlmIChtb2QuJHhTYXZlUG9pbnQgfHwgbW9kLiR4UmVsZWFzZSB8fCBtb2QuJHhSb2xsYmFja1RvKVxuICAgICAgICAgICAgICAgIHYgPSAyO1xuICAgICAgICAgICAgICBlbHNlIHYgPSAxO1xuICAgICAgICAgICAgICBtb2QuJGlWZXJzaW9uID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZE1vZCkgY3JlYXRlZE1vZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19tb2R1bGUucHJvdG90eXBlLnNldHVwTW9kdWxlID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgIHJldHVybiB2dGFiLnNldHVwTW9kdWxlLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAoJ3VzZSBzdHJpY3QnKTtcbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCBpbnN0YWxsT3Bmc1ZmcyA9IGZ1bmN0aW9uIGNhbGxlZShvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFnbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyIHx8ICFnbG9iYWxUaGlzLkF0b21pY3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdDYW5ub3QgaW5zdGFsbCBPUEZTOiBNaXNzaW5nIFNoYXJlZEFycmF5QnVmZmVyIGFuZC9vciBBdG9taWNzLiAnICtcbiAgICAgICAgICAgICAgICAgICdUaGUgc2VydmVyIG11c3QgZW1pdCB0aGUgQ09PUC9DT0VQIHJlc3BvbnNlIGhlYWRlcnMgdG8gZW5hYmxlIHRob3NlLiAnICtcbiAgICAgICAgICAgICAgICAgICdTZWUgaHR0cHM6Ly9zcWxpdGUub3JnL3dhc20vZG9jL3RydW5rL3BlcnNpc3RlbmNlLm1kI2Nvb3AtY29lcCcsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1RoZSBPUEZTIHNxbGl0ZTNfdmZzIGNhbm5vdCBydW4gaW4gdGhlIG1haW4gdGhyZWFkICcgK1xuICAgICAgICAgICAgICAgICAgJ2JlY2F1c2UgaXQgcmVxdWlyZXMgQXRvbWljcy53YWl0KCkuJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSB8fFxuICAgICAgICAgICAgIW5hdmlnYXRvcj8uc3RvcmFnZT8uZ2V0RGlyZWN0b3J5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgIGlmICh1cmxQYXJhbXMuaGFzKCdvcGZzLWRpc2FibGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzcWxpdGUzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZlcmJvc2UgPSB1cmxQYXJhbXMuaGFzKCdvcGZzLXZlcmJvc2UnKVxuICAgICAgICAgICAgICA/ICt1cmxQYXJhbXMuZ2V0KCdvcGZzLXZlcmJvc2UnKSB8fCAyXG4gICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2FuaXR5Q2hlY2tzID0gdXJsUGFyYW1zLmhhcygnb3Bmcy1zYW5pdHktY2hlY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy5wcm94eVVyaSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcm94eVVyaSA9IGNhbGxlZS5kZWZhdWx0UHJveHlVcmk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLnByb3h5VXJpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnByb3h5VXJpID0gb3B0aW9ucy5wcm94eVVyaSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0aGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKFxuICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVfLFxuICAgICAgICAgICAgcHJvbWlzZVJlamVjdF8sXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXJzID0gW1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcubG9nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0ltcGwgPSAobGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyYm9zZSA+IGxldmVsKVxuICAgICAgICAgICAgICAgIGxvZ2dlcnNbbGV2ZWxdKCdPUEZTIHN5bmNlcjonLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2cgPSAoLi4uYXJncykgPT4gbG9nSW1wbCgyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4gbG9nSW1wbCgxLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMCwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3M7XG4gICAgICAgICAgICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpO1xuICAgICAgICAgICAgY29uc3QgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgICAgICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX3ZmcyA9IGNhcGkuc3FsaXRlM192ZnM7XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX2ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZTtcbiAgICAgICAgICAgIGNvbnN0IHNxbGl0ZTNfaW9fbWV0aG9kcyA9IGNhcGkuc3FsaXRlM19pb19tZXRob2RzO1xuXG4gICAgICAgICAgICBjb25zdCBvcGZzVXRpbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRoaXNUaHJlYWRIYXNPUEZTID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSAmJlxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSAmJlxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwubWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgZHVtcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxldCBrLFxuICAgICAgICAgICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgICAgICAgICB0ID0gMCxcbiAgICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayBpbiBzdGF0ZS5vcElkcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IG1ldHJpY3Nba107XG4gICAgICAgICAgICAgICAgICBuICs9IG0uY291bnQ7XG4gICAgICAgICAgICAgICAgICB0ICs9IG0udGltZTtcbiAgICAgICAgICAgICAgICAgIHcgKz0gbS53YWl0O1xuICAgICAgICAgICAgICAgICAgbS5hdmdUaW1lID0gbS5jb3VudCAmJiBtLnRpbWUgPyBtLnRpbWUgLyBtLmNvdW50IDogMDtcbiAgICAgICAgICAgICAgICAgIG0uYXZnV2FpdCA9IG0uY291bnQgJiYgbS53YWl0ID8gbS53YWl0IC8gbS5jb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyhcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgICdtZXRyaWNzIGZvcicsXG4gICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgICAnOicsXG4gICAgICAgICAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICAgICAgICAgICAgJ1xcblRvdGFsIG9mJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnb3AocykgZm9yJyxcbiAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAnbXMgKGluY2wuICcgKyB3ICsgJyBtcyBvZiB3YWl0aW5nIG9uIHRoZSBhc3luYyBzaWRlKScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coJ1NlcmlhbGl6YXRpb24gbWV0cmljczonLCBtZXRyaWNzLnMxMW4pO1xuICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1tZXRyaWNzJyB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaztcbiAgICAgICAgICAgICAgICBjb25zdCByID0gKG0pID0+IChtLmNvdW50ID0gbS50aW1lID0gbS53YWl0ID0gMCk7XG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHN0YXRlLm9wSWRzKSB7XG4gICAgICAgICAgICAgICAgICByKChtZXRyaWNzW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcyA9IChtZXRyaWNzLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBzID0gcy5zZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHMgPSBtZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wZnNJb01ldGhvZHMgPSBuZXcgc3FsaXRlM19pb19tZXRob2RzKCk7XG4gICAgICAgICAgICBjb25zdCBvcGZzVmZzID0gbmV3IHNxbGl0ZTNfdmZzKCkuYWRkT25EaXNwb3NlKCgpID0+XG4gICAgICAgICAgICAgIG9wZnNJb01ldGhvZHMuZGlzcG9zZSgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBwcm9taXNlV2FzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlUmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBvcGZzVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RfKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHByb21pc2VXYXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVfKHNxbGl0ZTMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBuZXcgV29ya2VyKFxuICAgICAgICAgICAgICBuZXcgVVJMKCdzcWxpdGUzLW9wZnMtYXN5bmMtcHJveHkuanMnLCBpbXBvcnQubWV0YS51cmwpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KFxuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnVGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBPUEZTIGFzeW5jIHByb3h5IHdvcmtlci4nLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA0MDAwKTtcbiAgICAgICAgICAgIFcuX29yaWdpbmFsT25FcnJvciA9IFcub25lcnJvcjtcbiAgICAgICAgICAgIFcub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBPUEZTIGFzeW5jZXI6JywgZXJyKTtcbiAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnTG9hZGluZyBPUEZTIGFzeW5jIFdvcmtlciBmYWlsZWQgZm9yIHVua25vd24gcmVhc29ucy4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkVmZzID0gcERWZnMgPyBuZXcgc3FsaXRlM192ZnMocERWZnMpIDogbnVsbDtcbiAgICAgICAgICAgIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgICAgICAgICAgIG9wZnNWZnMuJGlWZXJzaW9uID0gMjtcbiAgICAgICAgICAgIG9wZnNWZnMuJHN6T3NGaWxlID0gY2FwaS5zcWxpdGUzX2ZpbGUuc3RydWN0SW5mby5zaXplb2Y7XG4gICAgICAgICAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gMTAyNDtcbiAgICAgICAgICAgIG9wZnNWZnMuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoJ29wZnMnKTtcblxuICAgICAgICAgICAgb3Bmc1Zmcy4keERsT3BlbiA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbEVycm9yID1cbiAgICAgICAgICAgICAgb3Bmc1Zmcy4keERsU3ltID1cbiAgICAgICAgICAgICAgb3Bmc1Zmcy4keERsQ2xvc2UgPVxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBvcGZzVmZzLmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgJyR6TmFtZScsXG4gICAgICAgICAgICAgIG9wZnNWZnMuJHpOYW1lLFxuICAgICAgICAgICAgICAnY2xlYW51cCBkZWZhdWx0IFZGUyB3cmFwcGVyJyxcbiAgICAgICAgICAgICAgKCkgPT4gKGRWZnMgPyBkVmZzLmRpc3Bvc2UoKSA6IG51bGwpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgc3RhdGUudmVyYm9zZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgICAgICAgICAgIHN0YXRlLmxpdHRsZUVuZGlhbiA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKVswXSA9PT0gMjU2O1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUgPSAxNTA7XG5cbiAgICAgICAgICAgIHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnMgPSAxO1xuXG4gICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSA9IDEwMjQgKiA2NDtcbiAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQgPSBzdGF0ZS5maWxlQnVmZmVyU2l6ZTtcblxuICAgICAgICAgICAgc3RhdGUuc2FiUzExblNpemUgPSBvcGZzVmZzLiRteFBhdGhuYW1lICogMjtcblxuICAgICAgICAgICAgc3RhdGUuc2FiSU8gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoXG4gICAgICAgICAgICAgIHN0YXRlLmZpbGVCdWZmZXJTaXplICsgc3RhdGUuc2FiUzExblNpemUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3RhdGUub3BJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy53aGljaE9wID0gaSsrO1xuXG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnJjID0gaSsrO1xuXG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhBY2Nlc3MgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhDbG9zZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueERlbGV0ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueERlbGV0ZU5vV2FpdCA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueEZpbGVTaXplID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54TG9jayA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueE9wZW4gPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhSZWFkID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54U2xlZXAgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhTeW5jID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54VHJ1bmNhdGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhVbmxvY2sgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhXcml0ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMubWtkaXIgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLW1ldHJpY3MnXSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHNbJ29wZnMtYXN5bmMtc2h1dGRvd24nXSA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy5yZXRyeSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUuc2FiT1AgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoaSAqIDQpO1xuICAgICAgICAgICAgICBvcGZzVXRpbC5tZXRyaWNzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLnNxM0NvZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ1NRTElURV9BQ0NFU1NfRVhJU1RTJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9BQ0NFU1NfUkVBRFdSSVRFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9CVVNZJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9DQU5UT1BFTicsXG4gICAgICAgICAgICAgICdTUUxJVEVfRVJST1InLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9BQ0NFU1MnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0NMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9ERUxFVEUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0ZTWU5DJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9TSE9SVF9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9UUlVOQ0FURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfSU9FUlJfVU5MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9XUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19FWENMVVNJVkUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0xPQ0tfTk9ORScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19QRU5ESU5HJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1JFU0VSVkVEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1NIQVJFRCcsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS0VEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9NSVNVU0UnLFxuICAgICAgICAgICAgICAnU1FMSVRFX05PVEZPVU5EJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX0NSRUFURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX01BSU5fREInLFxuICAgICAgICAgICAgICAnU1FMSVRFX09QRU5fUkVBRE9OTFknLFxuICAgICAgICAgICAgXS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IChzdGF0ZS5zcTNDb2Rlc1trXSA9IGNhcGlba10pKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG5vdCBmb3VuZDonLCBrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5vcGZzRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgT1BGU19VTkxPQ0tfQVNBUDogMHgwMSxcblxuICAgICAgICAgICAgICBPUEZTX1VOTElOS19CRUZPUkVfT1BFTjogMHgwMixcblxuICAgICAgICAgICAgICBkZWZhdWx0VW5sb2NrQXNhcDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgb3BSdW4gPSAob3AsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3BOZHggPSBzdGF0ZS5vcElkc1tvcF0gfHwgdG9zcygnSW52YWxpZCBvcCBJRDonLCBvcCk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKTtcbiAgICAgICAgICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIG9wTmR4KTtcbiAgICAgICAgICAgICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKTtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgJ25vdC1lcXVhbCcgIT09XG4gICAgICAgICAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKVxuICAgICAgICAgICAgICApIHt9XG5cbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBBdG9taWNzLmxvYWQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYyk7XG4gICAgICAgICAgICAgIG1ldHJpY3Nbb3BdLndhaXQgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICBpZiAocmMgJiYgc3RhdGUuYXN5bmNTMTFuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvcihvcCArICcoKSBhc3luYyBlcnJvcjonLCAuLi5lcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmRlYnVnID0ge1xuICAgICAgICAgICAgICBhc3luY1NodXRkb3duOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICdTaHV0dGluZyBkb3duIE9QRlMgYXN5bmMgbGlzdGVuZXIuIFRoZSBPUEZTIFZGUyB3aWxsIG5vIGxvbmdlciB3b3JrLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvcFJ1bignb3Bmcy1hc3luYy1zaHV0ZG93bicpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhc3luY1Jlc3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ0F0dGVtcHRpbmcgdG8gcmVzdGFydCBPUEZTIFZGUyBhc3luYyBsaXN0ZW5lci4gTWlnaHQgd29yaywgbWlnaHQgbm90LicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBXLnBvc3RNZXNzYWdlKHsgdHlwZTogJ29wZnMtYXN5bmMtcmVzdGFydCcgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBpbml0UzExbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLnMxMW4pIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLFxuICAgICAgICAgICAgICAgIHZpZXdVOCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblNpemUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB2aWV3RFYgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdGF0ZS5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICBjb25zdCBUeXBlSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgVHlwZUlkcy5udW1iZXIgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRGbG9hdDY0JyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRGbG9hdDY0JyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHlwZUlkcy5iaWdpbnQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRCaWdJbnQ2NCcsXG4gICAgICAgICAgICAgICAgc2V0dGVyOiAnc2V0QmlnSW50NjQnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLmJvb2xlYW4gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDMsXG4gICAgICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRJbnQzMicsXG4gICAgICAgICAgICAgICAgc2V0dGVyOiAnc2V0SW50MzInLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLnN0cmluZyA9IHsgaWQ6IDQgfTtcblxuICAgICAgICAgICAgICBjb25zdCBnZXRUeXBlSWQgPSAodikgPT5cbiAgICAgICAgICAgICAgICBUeXBlSWRzW3R5cGVvZiB2XSB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IHRoaXMgdmFsdWUgdHlwZSBjYW5ub3QgYmUgc2VyaWFsaXplZC4nLFxuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBnZXRUeXBlSWRCeUlkID0gKHRpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGlkKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMubnVtYmVyLmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5udW1iZXI7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMuYmlnaW50LmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5iaWdpbnQ7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMuYm9vbGVhbi5pZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVJZHMuYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5zdHJpbmcuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLnN0cmluZztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBJRDonLCB0aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGNsZWFyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICArK21ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnYyA9IHZpZXdVOFswXTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IGFyZ2MgPyBbXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ2MpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAxLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICB2O1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSwgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZEJ5SWQodmlld1U4W29mZnNldF0pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVJZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIHYgPSB2aWV3RFZbdC5nZXR0ZXJdKG9mZnNldCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG4gPSB2aWV3RFYuZ2V0SW50MzIob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIHYgPSB0ZXh0RGVjb2Rlci5kZWNvZGUodmlld1U4LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikpO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJjLnB1c2godik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhcikgdmlld1U4WzBdID0gMDtcblxuICAgICAgICAgICAgICAgIG1ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICArK21ldHJpY3MuczExbi5zZXJpYWxpemUuY291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgICB2aWV3VThbMF0gPSBhcmdzLmxlbmd0aCAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyArK2ksICsrb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWQoYXJnc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3VThbb2Zmc2V0XSA9IHR5cGVJZHNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmlld0RWW3Quc2V0dGVyXShvZmZzZXQsIGFyZ3NbaV0sIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gdGV4dEVuY29kZXIuZW5jb2RlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHZpZXdEVi5zZXRJbnQzMihvZmZzZXQsIHMuYnl0ZUxlbmd0aCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3VTguc2V0KHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2aWV3VThbMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRyaWNzLnMxMW4uc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuczExbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUZpbGVuYW1lID0gZnVuY3Rpb24gZihsZW4gPSAxNikge1xuICAgICAgICAgICAgICBpZiAoIWYuX2NoYXJzKSB7XG4gICAgICAgICAgICAgICAgZi5fY2hhcnMgPVxuICAgICAgICAgICAgICAgICAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArXG4gICAgICAgICAgICAgICAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICtcbiAgICAgICAgICAgICAgICAgICcwMTIzNDY3ODknO1xuICAgICAgICAgICAgICAgIGYuX24gPSBmLl9jaGFycy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZHggPSAoTWF0aC5yYW5kb20oKSAqIChmLl9uICogNjQpKSAlIGYuX24gfCAwO1xuICAgICAgICAgICAgICAgIGFbaV0gPSBmLl9jaGFyc1tuZHhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oJycpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgX19vcGVuRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCBvcFRpbWVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIG9wVGltZXIub3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvcFRpbWVyLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgbVRpbWVTdGFydCA9IChvcCkgPT4ge1xuICAgICAgICAgICAgICBvcFRpbWVyLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIG9wVGltZXIub3AgPSBvcDtcbiAgICAgICAgICAgICAgKyttZXRyaWNzW29wXS5jb3VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtVGltZUVuZCA9ICgpID0+XG4gICAgICAgICAgICAgIChtZXRyaWNzW29wVGltZXIub3BdLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBvcFRpbWVyLnN0YXJ0KTtcblxuICAgICAgICAgICAgY29uc3QgaW9TeW5jV3JhcHBlcnMgPSB7XG4gICAgICAgICAgICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24gKHBGaWxlLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIDAsICdpMzInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4Q2xvc2UnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4Q2xvc2UnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZi5zcTNGaWxlKSBmLnNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbiAocEZpbGUsIG9wSWQsIHBBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24gKHBGaWxlLCBwU3o2NCkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hGaWxlU2l6ZScpO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IG9wUnVuKCd4RmlsZVNpemUnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gcmMpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN6ID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2UocFN6NjQsIHN6LCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHJlYWRpbmcgeEZpbGVTaXplKCkgcmVzdWx0OicsIGUpO1xuICAgICAgICAgICAgICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneExvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWYubG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gb3BSdW4oJ3hMb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4UmVhZCcsIHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYyB8fCBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEID09PSByYykge1xuICAgICAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnNldChmLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHBEZXN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcigneFJlYWQoJywgYXJndW1lbnRzLCAnKSBmYWlsZWQ6JywgZSwgZik7XG4gICAgICAgICAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1JFQUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICAgICAgICAgICAgKyttZXRyaWNzLnhTeW5jLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hTeW5jJywgcEZpbGUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFRydW5jYXRlOiBmdW5jdGlvbiAocEZpbGUsIHN6NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4VHJ1bmNhdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4VHJ1bmNhdGUnLCBwRmlsZSwgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNhcGkuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGUgJiYgZi5sb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgICAgcmMgPSBvcFJ1bigneFVubG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZi5zYWJWaWV3LnNldCh3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMgKyBuKSk7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4V3JpdGUnLCBwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ3hXcml0ZSgnLCBhcmd1bWVudHMsICcpIGZhaWxlZDonLCBlLCBmKTtcbiAgICAgICAgICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfV1JJVEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdmZzU3luY1dyYXBwZXJzID0ge1xuICAgICAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneEFjY2VzcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hBY2Nlc3MnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSk7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIHJjID8gMCA6IDEsICdpMzInKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uIChwVmZzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgICAgIDI0NDA1ODcuNSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gODY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2UoXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICAgMjQ0MDU4Ny41ICogODY0MDAwMDAgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICdpNjQnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneERlbGV0ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oXG4gICAgICAgICAgICAgICAgICAneERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpOYW1lKSxcbiAgICAgICAgICAgICAgICAgIGRvU3luY0RpcixcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FybignT1BGUyB4R2V0TGFzdEVycm9yKCkgaGFzIG5vdGhpbmcgc2Vuc2libGUgdG8gcmV0dXJuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hPcGVuJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZnNGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB6TmFtZSA9IHJhbmRvbUZpbGVuYW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmlzUHRyKHpOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhcGkuc3FsaXRlM191cmlfYm9vbGVhbih6TmFtZSwgJ29wZnMtdW5sb2NrLWFzYXAnLCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBvcGZzRmxhZ3MgfD0gc3RhdGUub3Bmc0ZsYWdzLk9QRlNfVU5MT0NLX0FTQVA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM191cmlfYm9vbGVhbih6TmFtZSwgJ2RlbGV0ZS1iZWZvcmUtb3BlbicsIDApXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgb3Bmc0ZsYWdzIHw9IHN0YXRlLm9wZnNGbGFncy5PUEZTX1VOTElOS19CRUZPUkVfT1BFTjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHpOYW1lID0gd2FzbS5jc3RyVG9Kcyh6TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmaC5maWQgPSBwRmlsZTtcbiAgICAgICAgICAgICAgICBmaC5maWxlbmFtZSA9IHpOYW1lO1xuICAgICAgICAgICAgICAgIGZoLnNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgZmguZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgICAgICBmaC5yZWFkT25seSA9XG4gICAgICAgICAgICAgICAgICAhKHNxbGl0ZTMuU1FMSVRFX09QRU5fQ1JFQVRFICYgZmxhZ3MpICYmXG4gICAgICAgICAgICAgICAgICAhIShmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hPcGVuJywgcEZpbGUsIHpOYW1lLCBmbGFncywgb3Bmc0ZsYWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJjKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmgucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXRGbGFncywgY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWSwgJ2kzMicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX19vcGVuRmlsZXNbcEZpbGVdID0gZmg7XG4gICAgICAgICAgICAgICAgICBmaC5zYWJWaWV3ID0gc3RhdGUuc2FiRmlsZUJ1ZlZpZXc7XG4gICAgICAgICAgICAgICAgICBmaC5zcTNGaWxlID0gbmV3IHNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBmaC5zcTNGaWxlLiRwTWV0aG9kcyA9IG9wZnNJb01ldGhvZHMucG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgIGZoLmxvY2tUeXBlID0gY2FwaS5TUUxJVEVfTE9DS19OT05FO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkVmZzKSB7XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhSYW5kb21uZXNzID0gZFZmcy4keFJhbmRvbW5lc3M7XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhTbGVlcCA9IGRWZnMuJHhTbGVlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3Bmc1Zmcy4keFJhbmRvbW5lc3MpIHtcbiAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhSYW5kb21uZXNzID0gZnVuY3Rpb24gKHBWZnMsIG5PdXQsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBuT3V0OyArK2kpXG4gICAgICAgICAgICAgICAgICBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpICogMjU1MDAwKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhTbGVlcCkge1xuICAgICAgICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueFNsZWVwID0gZnVuY3Rpb24gKHBWZnMsIG1zKSB7XG4gICAgICAgICAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMueFNsZWVwLCAwLCBtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgc3BsaXRJdCkge1xuICAgICAgICAgICAgICBjb25zdCBwID0gbmV3IFVSTChmaWxlbmFtZSwgJ2ZpbGU6Ly9pcnJlbGV2YW50JykucGF0aG5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBzcGxpdEl0ID8gcC5zcGxpdCgnLycpLmZpbHRlcigodikgPT4gISF2KSA6IHA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZSA9IGFzeW5jIGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICAgIGFic0ZpbGVuYW1lLFxuICAgICAgICAgICAgICBjcmVhdGVEaXJzID0gZmFsc2UsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aChhYnNGaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgbGV0IGRoID0gb3Bmc1V0aWwucm9vdERpcmVjdG9yeTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkaXJOYW1lIG9mIHBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgZGggPSBhd2FpdCBkaC5nZXREaXJlY3RvcnlIYW5kbGUoZGlyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGU6ICEhY3JlYXRlRGlycyxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gW2RoLCBmaWxlbmFtZV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5ta2RpciA9IGFzeW5jIGZ1bmN0aW9uIChhYnNEaXJOYW1lKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoXG4gICAgICAgICAgICAgICAgICBhYnNEaXJOYW1lICsgJy9maWxlcGFydCcsXG4gICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmVudHJ5RXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKGZzRW50cnlOYW1lKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2RoLCBmbl0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmc0VudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJhbmRvbUZpbGVuYW1lID0gcmFuZG9tRmlsZW5hbWU7XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnRyZWVMaXN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsIHRndCkge1xuICAgICAgICAgICAgICAgIHRndC5uYW1lID0gZGlySGFuZGxlLm5hbWU7XG4gICAgICAgICAgICAgICAgdGd0LmRpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0Z3QuZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgnZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViRGlyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmRpcnMucHVzaChzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsZWUoaGFuZGxlLCBzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmZpbGVzLnB1c2goaGFuZGxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGF3YWl0IGRvRGlyKG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIHJvb3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJtZnIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IG9wZnNVdGlsLnJvb3REaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgb3B0ID0geyByZWN1cnNlOiB0cnVlIH07XG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGRpci5yZW1vdmVFbnRyeShoYW5kbGUubmFtZSwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudW5saW5rID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICBmc0VudHJ5TmFtZSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2UsXG4gICAgICAgICAgICAgIHRocm93T25FcnJvciA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICAgIGZzRW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICd1bmxpbmsoJyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAnKSBmYWlsZWQ6ICcgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudHJhdmVyc2UgPSBhc3luYyBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHQgPSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogb3Bmc1V0aWwucm9vdERpcmVjdG9yeSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHQpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IGNhbGxiYWNrOiBvcHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHQsIG9wdCB8fCB7fSk7XG4gICAgICAgICAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gb3B0LmNhbGxiYWNrKGhhbmRsZSwgZGlySGFuZGxlLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdC5yZWN1cnNpdmUgJiYgJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gKGF3YWl0IGNhbGxlZShoYW5kbGUsIGRlcHRoICsgMSkpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRvRGlyKG9wdC5kaXJlY3RvcnksIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgaW1wb3J0RGJDaHVua2VkID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgIGxldCBuV3JvdGUgPSAwLFxuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0lucHV0IHNpemUnLFxuICAgICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBzYWggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5pbXBvcnREYiA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RGJDaHVua2VkKGZpbGVuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICB1dGlsLmFmZmlybUlzRGIoYnl0ZXMpO1xuICAgICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgc2FoLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBuV3JvdGUgPSAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIHRvIHdyaXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG4gK1xuICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMgYnV0IHdyb3RlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG5Xcm90ZSArXG4gICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FoKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHNhaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc3FsaXRlMy5vbzEpIHtcbiAgICAgICAgICAgICAgY29uc3QgT3Bmc0RiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBvcHQudmZzID0gb3Bmc1Zmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT3Bmc0RiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3FsaXRlMy5vbzEuREIucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuT3Bmc0RiID0gT3Bmc0RiO1xuICAgICAgICAgICAgICBPcGZzRGIuaW1wb3J0RGIgPSBvcGZzVXRpbC5pbXBvcnREYjtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgb3Bmc1Zmcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvbzFEYiwgc3FsaXRlMykge1xuICAgICAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfYnVzeV90aW1lb3V0KG9vMURiLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWQgPSBzcTNGaWxlLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlbkZsYWdzID1cbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQjtcbiAgICAgICAgICAgICAgICBjb25zdCBwT3V0ID0gd2FzbS5zY29wZWRBbGxvYyg4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYkZpbGUgPSAnL3Nhbml0eS9jaGVjay9maWxlJyArIHJhbmRvbUZpbGVuYW1lKDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpEYkZpbGUgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhkYkZpbGUpO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSgnVGhpcyBpcyDDpCBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmMgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgbG9nKCdkZXNlcmlhbGl6ZSgpIHNheXM6JywgcmMpO1xuICAgICAgICAgICAgICAgIGlmICgnVGhpcyBpcyDDpCBzdHJpbmcuJyAhPT0gcmNbMF0pIHRvc3MoJ1N0cmluZyBkMTNuIGVycm9yLicpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGxvZygneEFjY2VzcygnLCBkYkZpbGUsICcpIGV4aXN0cyA/PScsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IHZmc1N5bmNXcmFwcGVycy54T3BlbihcbiAgICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIHpEYkZpbGUsXG4gICAgICAgICAgICAgICAgICBmaWQsXG4gICAgICAgICAgICAgICAgICBvcGVuRmxhZ3MsXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgJ29wZW4gcmMgPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgICdzdGF0ZS5zYWJPUFZpZXdbeE9wZW5dID0nLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnhPcGVuXSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSByYykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ29wZW4gZmFpbGVkIHdpdGggY29kZScsIHJjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCAnaTMyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykgdG9zcygneEFjY2VzcygpIGZhaWxlZCB0byBkZXRlY3QgZmlsZS4nKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhTeW5jKHNxM0ZpbGUucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJjKSB0b3NzKCdzeW5jIGZhaWxlZCB3LyByYycsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhUcnVuY2F0ZShzcTNGaWxlLnBvaW50ZXIsIDEwMjQpO1xuICAgICAgICAgICAgICAgIGlmIChyYykgdG9zcygndHJ1bmNhdGUgZmFpbGVkIHcvIHJjJywgcmMpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAwLCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54RmlsZVNpemUoc3EzRmlsZS5wb2ludGVyLCBwT3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hGaWxlU2l6ZSBmYWlsZWQgdy8gcmMnLCByYyk7XG4gICAgICAgICAgICAgICAgbG9nKCd4RmlsZVNpemUgc2F5czonLCB3YXNtLnBlZWsocE91dCwgJ2k2NCcpKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhXcml0ZShzcTNGaWxlLnBvaW50ZXIsIHpEYkZpbGUsIDEwLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hXcml0ZSgpIGZhaWxlZCEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkQnVmID0gd2FzbS5zY29wZWRBbGxvYygxNik7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54UmVhZChzcTNGaWxlLnBvaW50ZXIsIHJlYWRCdWYsIDYsIDIpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShyZWFkQnVmICsgNiwgMCk7XG4gICAgICAgICAgICAgICAgbGV0IGpSZWFkID0gd2FzbS5jc3RyVG9KcyhyZWFkQnVmKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hSZWFkKCkgZ290OicsIGpSZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3Nhbml0eScgIT09IGpSZWFkKSB0b3NzKCdVbmV4cGVjdGVkIHhSZWFkKCkgdmFsdWUuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZmc1N5bmNXcmFwcGVycy54U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgIGxvZygneFNsZWVwKClpbmcgYmVmb3JlIGNsb3NlKClpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAob3Bmc1Zmcy5wb2ludGVyLCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgIGxvZygnd2FraW5nIHVwIGZyb20geFNsZWVwKCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54Q2xvc2UoZmlkKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hDbG9zZSByYyA9JywgcmMsICdzYWJPUFZpZXcgPScsIHN0YXRlLnNhYk9QVmlldyk7XG4gICAgICAgICAgICAgICAgbG9nKCdEZWxldGluZyBmaWxlOicsIGRiRmlsZSk7XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhEZWxldGUob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAweDEyMzQpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAgICdFeHBlY3RpbmcgMCBmcm9tIHhBY2Nlc3MoJyxcbiAgICAgICAgICAgICAgICAgICAgZGJGaWxlLFxuICAgICAgICAgICAgICAgICAgICAnKSBhZnRlciB4RGVsZXRlKCkuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgd2FybignRW5kIG9mIE9QRlMgc2FuaXR5IGNoZWNrcy4nKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgVy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoeyBkYXRhIH0pIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLXVuYXZhaWxhYmxlJzpcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGRhdGEucGF5bG9hZC5qb2luKCcgJykpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtbG9hZGVkJzpcbiAgICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1pbml0JywgYXJnczogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWluaXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0cnVlID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgICAgICAgICAgICBpbzogeyBzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdmZzOiB7IHN0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1J1bm5pbmcgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIG9mIG9wZnMtc2FuaXR5LWNoZWNrIFVSTCBhcmcuLi4nLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgc2FuaXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1RocmVhZEhhc09QRlMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFcub25lcnJvciA9IFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3FsaXRlMy5vcGZzID0gb3Bmc1V0aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wZnNVdGlsLnJvb3REaXJlY3RvcnkgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0VuZCBvZiBPUEZTIHNxbGl0ZTNfdmZzIHNldHVwLicsIG9wZnNWZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChwcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSB0aGUgT1BGUyBhc3luYyB3b3JrZXI6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID0gJ3NxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qcyc7XG4gICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYy5wdXNoKFxuICAgICAgICAgIGFzeW5jIChzcWxpdGUzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgcHJveHlKcyA9IGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaTtcbiAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyICsgcHJveHlKcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFsbE9wZnNWZnMoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnSWdub3JpbmcgaW5hYmlsaXR5IHRvIGluc3RhbGwgT1BGUyBzcWxpdGUzX3ZmczonLFxuICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcignaW5zdGFsbE9wZnNWZnMoKSBleGNlcHRpb246JywgZSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgICAgICAgY29uc3QgdG9zczMgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG5cbiAgICAgICAgY29uc3QgU0VDVE9SX1NJWkUgPSA0MDk2O1xuICAgICAgICBjb25zdCBIRUFERVJfTUFYX1BBVEhfU0laRSA9IDUxMjtcbiAgICAgICAgY29uc3QgSEVBREVSX0ZMQUdTX1NJWkUgPSA0O1xuICAgICAgICBjb25zdCBIRUFERVJfRElHRVNUX1NJWkUgPSA4O1xuICAgICAgICBjb25zdCBIRUFERVJfQ09SUFVTX1NJWkUgPSBIRUFERVJfTUFYX1BBVEhfU0laRSArIEhFQURFUl9GTEFHU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0ZMQUdTID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgIGNvbnN0IEhFQURFUl9PRkZTRVRfRElHRVNUID0gSEVBREVSX0NPUlBVU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0RBVEEgPSBTRUNUT1JfU0laRTtcblxuICAgICAgICBjb25zdCBQRVJTSVNURU5UX0ZJTEVfVFlQRVMgPVxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQiB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwgfFxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fU1VQRVJfSk9VUk5BTCB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9XQUw7XG5cbiAgICAgICAgY29uc3QgT1BBUVVFX0RJUl9OQU1FID0gJy5vcGFxdWUnO1xuXG4gICAgICAgIGNvbnN0IGdldFJhbmRvbU5hbWUgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgbmFtZTogJ29wZnMtc2FocG9vbCcsXG4gICAgICAgICAgZGlyZWN0b3J5OiB1bmRlZmluZWQsXG4gICAgICAgICAgaW5pdGlhbENhcGFjaXR5OiA2LFxuICAgICAgICAgIGNsZWFyT25Jbml0OiBmYWxzZSxcblxuICAgICAgICAgIHZlcmJvc2l0eTogMixcbiAgICAgICAgICBmb3JjZVJlaW5pdElmUHJldmlvdXNseUZhaWxlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxvZ2dlcnMgPSBbXG4gICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2csXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxvZyA9IHNxbGl0ZTMuY29uZmlnLmxvZztcbiAgICAgICAgY29uc3Qgd2FybiA9IHNxbGl0ZTMuY29uZmlnLndhcm47XG4gICAgICAgIGNvbnN0IGVycm9yID0gc3FsaXRlMy5jb25maWcuZXJyb3I7XG5cbiAgICAgICAgY29uc3QgX19tYXBWZnNUb1Bvb2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGdldFBvb2xGb3JWZnMgPSAocFZmcykgPT4gX19tYXBWZnNUb1Bvb2wuZ2V0KHBWZnMpO1xuICAgICAgICBjb25zdCBzZXRQb29sRm9yVmZzID0gKHBWZnMsIHBvb2wpID0+IHtcbiAgICAgICAgICBpZiAocG9vbCkgX19tYXBWZnNUb1Bvb2wuc2V0KHBWZnMsIHBvb2wpO1xuICAgICAgICAgIGVsc2UgX19tYXBWZnNUb1Bvb2wuZGVsZXRlKHBWZnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWFwU3FsaXRlM0ZpbGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGdldFBvb2xGb3JQRmlsZSA9IChwRmlsZSkgPT4gX19tYXBTcWxpdGUzRmlsZS5nZXQocEZpbGUpO1xuICAgICAgICBjb25zdCBzZXRQb29sRm9yUEZpbGUgPSAocEZpbGUsIHBvb2wpID0+IHtcbiAgICAgICAgICBpZiAocG9vbCkgX19tYXBTcWxpdGUzRmlsZS5zZXQocEZpbGUsIHBvb2wpO1xuICAgICAgICAgIGVsc2UgX19tYXBTcWxpdGUzRmlsZS5kZWxldGUocEZpbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlvTWV0aG9kcyA9IHtcbiAgICAgICAgICB4Q2hlY2tSZXNlcnZlZExvY2s6IGZ1bmN0aW9uIChwRmlsZSwgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZygneENoZWNrUmVzZXJ2ZWRMb2NrJyk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwb29sLmxvZyhgeENsb3NlICR7ZmlsZS5wYXRofWApO1xuICAgICAgICAgICAgICAgIHBvb2wubWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUuZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UpIHtcbiAgICAgICAgICAgICAgICAgIHBvb2wuZGVsZXRlUGF0aChmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU47XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RmlsZUNvbnRyb2w6IGZ1bmN0aW9uIChwRmlsZSwgb3BJZCwgcEFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeEZpbGVTaXplOiBmdW5jdGlvbiAocEZpbGUsIHBTejY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4RmlsZVNpemVgKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG5cbiAgICAgICAgICAgIHdhc20ucG9rZTY0KHBTejY0LCBCaWdJbnQoc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4TG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeExvY2sgJHtsb2NrVHlwZX1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFJlYWQ6IGZ1bmN0aW9uIChwRmlsZSwgcERlc3QsIG4sIG9mZnNldDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4UmVhZCAke2ZpbGUucGF0aH0gJHtufSBAICR7b2Zmc2V0NjR9YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBuUmVhZCA9IGZpbGUuc2FoLnJlYWQoXG4gICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwRGVzdCwgcERlc3QgKyBuKSxcbiAgICAgICAgICAgICAgICB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIob2Zmc2V0NjQpIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChuUmVhZCA8IG4pIHtcbiAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLmZpbGwoMCwgcERlc3QgKyBuUmVhZCwgcERlc3QgKyBuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfU0hPUlRfUkVBRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeFNlY3RvclNpemU6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFNFQ1RPUl9TSVpFO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFN5bmM6IGZ1bmN0aW9uIChwRmlsZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhTeW5jICR7ZmxhZ3N9YCk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4VHJ1bmNhdGU6IGZ1bmN0aW9uIChwRmlsZSwgc3o2NCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeFRydW5jYXRlICR7c3o2NH1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmlsZS5zYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhVbmxvY2s6IGZ1bmN0aW9uIChwRmlsZSwgbG9ja1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coJ3hVbmxvY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFdyaXRlOiBmdW5jdGlvbiAocEZpbGUsIHBTcmMsIG4sIG9mZnNldDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4V3JpdGUgJHtmaWxlLnBhdGh9ICR7bn0gJHtvZmZzZXQ2NH1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5CeXRlcyA9IGZpbGUuc2FoLndyaXRlKFxuICAgICAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuc3ViYXJyYXkocFNyYywgcFNyYyArIG4pLFxuICAgICAgICAgICAgICAgIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG4gPT09IG5CeXRlcyA/IDAgOiB0b3NzKCdVbmtub3duIHdyaXRlKCkgZmFpbHVyZS4nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3Bmc0lvTWV0aG9kcyA9IG5ldyBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICAgICAgICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gICAgICAgIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgICAgICAgIGlvOiB7IHN0cnVjdDogb3Bmc0lvTWV0aG9kcywgbWV0aG9kczogaW9NZXRob2RzIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZmc01ldGhvZHMgPSB7XG4gICAgICAgICAgeEFjY2VzczogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBmbGFncywgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcG9vbC5nZXRQYXRoKHpOYW1lKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgcG9vbC5oYXNGaWxlbmFtZShuYW1lKSA/IDEgOiAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhDdXJyZW50VGltZTogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgIHdhc20ucG9rZShcbiAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgMjQ0MDU4Ny41ICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgLyA4NjQwMDAwMCxcbiAgICAgICAgICAgICAgJ2RvdWJsZScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAyNDQwNTg3LjUgKiA4NjQwMDAwMCArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCAnaTY0Jyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4RGVsZXRlICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9YCk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwb29sLmRlbGV0ZVBhdGgocG9vbC5nZXRQYXRoKHpOYW1lKSk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfREVMRVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeEZ1bGxQYXRobmFtZTogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBpID0gd2FzbS5jc3RybmNweShwT3V0LCB6TmFtZSwgbk91dCk7XG4gICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4R2V0TGFzdEVycm9yOiBmdW5jdGlvbiAocFZmcywgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICAgICAgICBjb25zdCBlID0gcG9vbC5wb3BFcnIoKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4R2V0TGFzdEVycm9yICR7bk91dH0gZSA9YCwgZSk7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICBjb25zdCBzY29wZSA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NNc2csIG5dID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoZS5tZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB3YXNtLmNzdHJuY3B5KHBPdXQsIGNNc2csIG5PdXQpO1xuICAgICAgICAgICAgICAgIGlmIChuID4gbk91dCkgd2FzbS5wb2tlOChwT3V0ICsgbk91dCAtIDEsIDApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZSA/IGUuc3FsaXRlM1JjIHx8IGNhcGkuU1FMSVRFX0lPRVJSIDogMDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgeE9wZW46IGZ1bmN0aW9uIGYocFZmcywgek5hbWUsIHBGaWxlLCBmbGFncywgcE91dEZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBvb2wubG9nKGB4T3BlbiAke3dhc20uY3N0clRvSnMoek5hbWUpfSAke2ZsYWdzfWApO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHBhdGggPVxuICAgICAgICAgICAgICAgIHpOYW1lICYmIHdhc20ucGVlazgoek5hbWUpXG4gICAgICAgICAgICAgICAgICA/IHBvb2wuZ2V0UGF0aCh6TmFtZSlcbiAgICAgICAgICAgICAgICAgIDogZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgICAgICBsZXQgc2FoID0gcG9vbC5nZXRTQUhGb3JQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICBpZiAoIXNhaCAmJiBmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvb2wuZ2V0RmlsZUNvdW50KCkgPCBwb29sLmdldENhcGFjaXR5KCkpIHtcbiAgICAgICAgICAgICAgICAgIHNhaCA9IHBvb2wubmV4dEF2YWlsYWJsZVNBSCgpO1xuICAgICAgICAgICAgICAgICAgcG9vbC5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIHBhdGgsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9zcygnU0FIIHBvb2wgaXMgZnVsbC4gQ2Fubm90IGNyZWF0ZSBmaWxlJywgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2FoKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnZmlsZSBub3QgZm91bmQ6JywgcGF0aCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBmaWxlID0geyBwYXRoLCBmbGFncywgc2FoIH07XG4gICAgICAgICAgICAgIHBvb2wubWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmlsZSk7XG4gICAgICAgICAgICAgIGZpbGUubG9ja1R5cGUgPSBjYXBpLlNRTElURV9MT0NLX05PTkU7XG4gICAgICAgICAgICAgIGNvbnN0IHNxM0ZpbGUgPSBuZXcgY2FwaS5zcWxpdGUzX2ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgICBzcTNGaWxlLiRwTWV0aG9kcyA9IG9wZnNJb01ldGhvZHMucG9pbnRlcjtcbiAgICAgICAgICAgICAgc3EzRmlsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIHdhc20ucG9rZTMyKHBPdXRGbGFncywgZmxhZ3MpO1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcG9vbC5zdG9yZUVycihlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0NBTlRPUEVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY3JlYXRlT3Bmc1ZmcyA9IGZ1bmN0aW9uICh2ZnNOYW1lKSB7XG4gICAgICAgICAgaWYgKHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmc19maW5kKHZmc05hbWUpKSB7XG4gICAgICAgICAgICB0b3NzMygnVkZTIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkOicsIHZmc05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvcGZzVmZzID0gbmV3IGNhcGkuc3FsaXRlM192ZnMoKTtcblxuICAgICAgICAgIGNvbnN0IHBEVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKG51bGwpO1xuICAgICAgICAgIGNvbnN0IGRWZnMgPSBwRFZmcyA/IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBEVmZzKSA6IG51bGw7XG4gICAgICAgICAgb3Bmc1Zmcy4kaVZlcnNpb24gPSAyO1xuICAgICAgICAgIG9wZnNWZnMuJHN6T3NGaWxlID0gY2FwaS5zcWxpdGUzX2ZpbGUuc3RydWN0SW5mby5zaXplb2Y7XG4gICAgICAgICAgb3Bmc1Zmcy4kbXhQYXRobmFtZSA9IEhFQURFUl9NQVhfUEFUSF9TSVpFO1xuICAgICAgICAgIG9wZnNWZnMuYWRkT25EaXNwb3NlKFxuICAgICAgICAgICAgKG9wZnNWZnMuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcodmZzTmFtZSkpLFxuICAgICAgICAgICAgKCkgPT4gc2V0UG9vbEZvclZmcyhvcGZzVmZzLnBvaW50ZXIsIDApLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoZFZmcykge1xuICAgICAgICAgICAgb3Bmc1Zmcy4keFJhbmRvbW5lc3MgPSBkVmZzLiR4UmFuZG9tbmVzcztcbiAgICAgICAgICAgIG9wZnNWZnMuJHhTbGVlcCA9IGRWZnMuJHhTbGVlcDtcbiAgICAgICAgICAgIGRWZnMuZGlzcG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhSYW5kb21uZXNzICYmICF2ZnNNZXRob2RzLnhSYW5kb21uZXNzKSB7XG4gICAgICAgICAgICB2ZnNNZXRob2RzLnhSYW5kb21uZXNzID0gZnVuY3Rpb24gKHBWZnMsIG5PdXQsIHBPdXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBuT3V0OyArK2kpXG4gICAgICAgICAgICAgICAgaGVhcFtwT3V0ICsgaV0gPSAoTWF0aC5yYW5kb20oKSAqIDI1NTAwMCkgJiAweGZmO1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3Bmc1Zmcy4keFNsZWVwICYmICF2ZnNNZXRob2RzLnhTbGVlcCkge1xuICAgICAgICAgICAgdmZzTWV0aG9kcy54U2xlZXAgPSAocFZmcywgbXMpID0+IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgICAgICAgICAgdmZzOiB7IHN0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzTWV0aG9kcyB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBvcGZzVmZzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsYXNzIE9wZnNTQUhQb29sIHtcbiAgICAgICAgICB2ZnNEaXI7XG5cbiAgICAgICAgICAjZGhWZnNSb290O1xuXG4gICAgICAgICAgI2RoT3BhcXVlO1xuXG4gICAgICAgICAgI2RoVmZzUGFyZW50O1xuXG4gICAgICAgICAgI21hcFNBSFRvTmFtZSA9IG5ldyBNYXAoKTtcblxuICAgICAgICAgICNtYXBGaWxlbmFtZVRvU0FIID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgI2F2YWlsYWJsZVNBSCA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICNtYXBTM0ZpbGVUb09GaWxlXyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAgICNhcEJvZHkgPSBuZXcgVWludDhBcnJheShIRUFERVJfQ09SUFVTX1NJWkUpO1xuXG4gICAgICAgICAgI2R2Qm9keTtcblxuICAgICAgICAgICNjVmZzO1xuXG4gICAgICAgICAgI3ZlcmJvc2l0eTtcblxuICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLiN2ZXJib3NpdHkgPSBvcHRpb25zLnZlcmJvc2l0eSA/PyBvcHRpb25EZWZhdWx0cy52ZXJib3NpdHk7XG4gICAgICAgICAgICB0aGlzLnZmc05hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9uRGVmYXVsdHMubmFtZTtcbiAgICAgICAgICAgIHRoaXMuI2NWZnMgPSBjcmVhdGVPcGZzVmZzKHRoaXMudmZzTmFtZSk7XG4gICAgICAgICAgICBzZXRQb29sRm9yVmZzKHRoaXMuI2NWZnMucG9pbnRlciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZmc0RpciA9IG9wdGlvbnMuZGlyZWN0b3J5IHx8ICcuJyArIHRoaXMudmZzTmFtZTtcbiAgICAgICAgICAgIHRoaXMuI2R2Qm9keSA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICAgICAgdGhpcy4jYXBCb2R5LmJ1ZmZlcixcbiAgICAgICAgICAgICAgdGhpcy4jYXBCb2R5LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdGhpcy5yZXNldChcbiAgICAgICAgICAgICAgISEob3B0aW9ucy5jbGVhck9uSW5pdCA/PyBvcHRpb25EZWZhdWx0cy5jbGVhck9uSW5pdCksXG4gICAgICAgICAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy4kZXJyb3IpIHRocm93IHRoaXMuJGVycm9yO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXBhY2l0eSgpXG4gICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIDogdGhpcy5hZGRDYXBhY2l0eShcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbml0aWFsQ2FwYWNpdHkgfHwgb3B0aW9uRGVmYXVsdHMuaW5pdGlhbENhcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICNsb2dJbXBsKGxldmVsLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmVyYm9zaXR5ID4gbGV2ZWwpXG4gICAgICAgICAgICAgIGxvZ2dlcnNbbGV2ZWxdKHRoaXMudmZzTmFtZSArICc6JywgLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZyguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dJbXBsKDIsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ0ltcGwoMSwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ0ltcGwoMCwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0VmZzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NWZnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0Q2FwYWNpdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWFwU0FIVG9OYW1lLnNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0RmlsZUNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRGaWxlTmFtZXMoKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaXRlciA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUgua2V5cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIGl0ZXIpIHJjLnB1c2gobik7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgYWRkQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldFJhbmRvbU5hbWUoKTtcbiAgICAgICAgICAgICAgY29uc3QgaCA9IGF3YWl0IHRoaXMuI2RoT3BhcXVlLmdldEZpbGVIYW5kbGUobmFtZSwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGFoID0gYXdhaXQgaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5zZXQoYWgsIG5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKGFoLCAnJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXBhY2l0eSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlZHVjZUNhcGFjaXR5KG4pIHtcbiAgICAgICAgICAgIGxldCBuUm0gPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhaCBvZiBBcnJheS5mcm9tKHRoaXMuI2F2YWlsYWJsZVNBSCkpIHtcbiAgICAgICAgICAgICAgaWYgKG5SbSA9PT0gbiB8fCB0aGlzLmdldEZpbGVDb3VudCgpID09PSB0aGlzLmdldENhcGFjaXR5KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy4jbWFwU0FIVG9OYW1lLmdldChhaCk7XG5cbiAgICAgICAgICAgICAgYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGhPcGFxdWUucmVtb3ZlRW50cnkobmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5kZWxldGUoYWgpO1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguZGVsZXRlKGFoKTtcbiAgICAgICAgICAgICAgKytuUm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gblJtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbGVhc2VBY2Nlc3NIYW5kbGVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhaCBvZiB0aGlzLiNtYXBTQUhUb05hbWUua2V5cygpKSBhaC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguY2xlYXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyBhY3F1aXJlQWNjZXNzSGFuZGxlcyhjbGVhckZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgaF0gb2YgdGhpcy4jZGhPcGFxdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCdmaWxlJyA9PT0gaC5raW5kKSB7XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChbbmFtZSwgaF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIGZpbGVzLm1hcChhc3luYyAoW25hbWUsIGhdKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFoID0gYXdhaXQgaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuc2V0KGFoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjbGVhckZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldEFzc29jaWF0ZWRQYXRoKGFoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNldChwYXRoLCBhaCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmFkZChhaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlRXJyKGUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRBc3NvY2lhdGVkUGF0aChzYWgpIHtcbiAgICAgICAgICAgIHNhaC5yZWFkKHRoaXMuI2FwQm9keSwgeyBhdDogMCB9KTtcblxuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSB0aGlzLiNkdkJvZHkuZ2V0VWludDMyKEhFQURFUl9PRkZTRVRfRkxBR1MpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLiNhcEJvZHlbMF0gJiZcbiAgICAgICAgICAgICAgKGZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFIHx8XG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUEVSU0lTVEVOVF9GSUxFX1RZUEVTKSA9PT0gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIGBSZW1vdmluZyBmaWxlIHdpdGggdW5leHBlY3RlZCBmbGFncyAke2ZsYWdzLnRvU3RyaW5nKDE2KX1gLFxuICAgICAgICAgICAgICAgIHRoaXMuI2FwQm9keSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmaWxlRGlnZXN0ID0gbmV3IFVpbnQzMkFycmF5KEhFQURFUl9ESUdFU1RfU0laRSAvIDQpO1xuICAgICAgICAgICAgc2FoLnJlYWQoZmlsZURpZ2VzdCwgeyBhdDogSEVBREVSX09GRlNFVF9ESUdFU1QgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wRGlnZXN0ID0gdGhpcy5jb21wdXRlRGlnZXN0KHRoaXMuI2FwQm9keSk7XG4gICAgICAgICAgICBpZiAoZmlsZURpZ2VzdC5ldmVyeSgodiwgaSkgPT4gdiA9PT0gY29tcERpZ2VzdFtpXSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEJ5dGVzID0gdGhpcy4jYXBCb2R5LmZpbmRJbmRleCgodikgPT4gMCA9PT0gdik7XG4gICAgICAgICAgICAgIGlmICgwID09PSBwYXRoQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGF0aEJ5dGVzXG4gICAgICAgICAgICAgICAgPyB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy4jYXBCb2R5LnN1YmFycmF5KDAsIHBhdGhCeXRlcykpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0Rpc2Fzc29jaWF0aW5nIGZpbGUgd2l0aCBiYWQgZGlnZXN0LicpO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBwYXRoLCBmbGFncykge1xuICAgICAgICAgICAgY29uc3QgZW5jID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhwYXRoLCB0aGlzLiNhcEJvZHkpO1xuICAgICAgICAgICAgaWYgKEhFQURFUl9NQVhfUEFUSF9TSVpFIDw9IGVuYy53cml0dGVuICsgMSkge1xuICAgICAgICAgICAgICB0b3NzKCdQYXRoIHRvbyBsb25nOicsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jYXBCb2R5LmZpbGwoMCwgZW5jLndyaXR0ZW4sIEhFQURFUl9NQVhfUEFUSF9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuI2R2Qm9keS5zZXRVaW50MzIoSEVBREVSX09GRlNFVF9GTEFHUywgZmxhZ3MpO1xuXG4gICAgICAgICAgICBjb25zdCBkaWdlc3QgPSB0aGlzLmNvbXB1dGVEaWdlc3QodGhpcy4jYXBCb2R5KTtcbiAgICAgICAgICAgIHNhaC53cml0ZSh0aGlzLiNhcEJvZHksIHsgYXQ6IDAgfSk7XG4gICAgICAgICAgICBzYWgud3JpdGUoZGlnZXN0LCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RJR0VTVCB9KTtcbiAgICAgICAgICAgIHNhaC5mbHVzaCgpO1xuXG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNldChwYXRoLCBzYWgpO1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguZGVsZXRlKHNhaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmFkZChzYWgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbXB1dGVEaWdlc3QoYnl0ZUFycmF5KSB7XG4gICAgICAgICAgICBsZXQgaDEgPSAweGRlYWRiZWVmO1xuICAgICAgICAgICAgbGV0IGgyID0gMHg0MWM2Y2U1NztcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBieXRlQXJyYXkpIHtcbiAgICAgICAgICAgICAgaDEgPSAzMSAqIGgxICsgdiAqIDMwNztcbiAgICAgICAgICAgICAgaDIgPSAzMSAqIGgyICsgdiAqIDMwNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoW2gxID4+PiAwLCBoMiA+Pj4gMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlc2V0KGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXNSZWFkeTtcbiAgICAgICAgICAgIGxldCBoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgICAgICAgICBsZXQgcHJldiwgcHJldk5hbWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgdGhpcy52ZnNEaXIuc3BsaXQoJy8nKSkge1xuICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBoO1xuICAgICAgICAgICAgICAgIGggPSBhd2FpdCBoLmdldERpcmVjdG9yeUhhbmRsZShkLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZGhWZnNSb290ID0gaDtcbiAgICAgICAgICAgIHRoaXMuI2RoVmZzUGFyZW50ID0gcHJldjtcbiAgICAgICAgICAgIHRoaXMuI2RoT3BhcXVlID0gYXdhaXQgdGhpcy4jZGhWZnNSb290LmdldERpcmVjdG9yeUhhbmRsZShcbiAgICAgICAgICAgICAgT1BBUVVFX0RJUl9OQU1FLFxuICAgICAgICAgICAgICB7IGNyZWF0ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFBhdGgoYXJnKSB7XG4gICAgICAgICAgICBpZiAod2FzbS5pc1B0cihhcmcpKSBhcmcgPSB3YXNtLmNzdHJUb0pzKGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBhcmcgaW5zdGFuY2VvZiBVUkwgPyBhcmcgOiBuZXcgVVJMKGFyZywgJ2ZpbGU6Ly9sb2NhbGhvc3QvJylcbiAgICAgICAgICAgICkucGF0aG5hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlUGF0aChwYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICAgICAgICAgIGlmIChzYWgpIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISFzYWg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RvcmVFcnIoZSwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgZS5zcWxpdGUzUmMgPSBjb2RlIHx8IGNhcGkuU1FMSVRFX0lPRVJSO1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9wRXJyKCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSB0aGlzLiRlcnJvcjtcbiAgICAgICAgICAgIHRoaXMuJGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRBdmFpbGFibGVTQUgoKSB7XG4gICAgICAgICAgICBjb25zdCBbcmNdID0gdGhpcy4jYXZhaWxhYmxlU0FILmtleXMoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRPRmlsZUZvclMzRmlsZShwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmdldChwRmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmlsZSkge1xuICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uc2V0KHBGaWxlLCBmaWxlKTtcbiAgICAgICAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmRlbGV0ZShwRmlsZSk7XG4gICAgICAgICAgICAgIHNldFBvb2xGb3JQRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc0ZpbGVuYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmhhcyhuYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRTQUhGb3JQYXRoKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyByZW1vdmVWZnMoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2NWZnMucG9pbnRlciB8fCAhdGhpcy4jZGhPcGFxdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM192ZnNfdW5yZWdpc3Rlcih0aGlzLiNjVmZzLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy4jY1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkZWxldGUgaW5pdFByb21pc2VzW3RoaXMudmZzTmFtZV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2RoVmZzUm9vdC5yZW1vdmVFbnRyeShPUEFRVUVfRElSX05BTUUsIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLiNkaE9wYXF1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNQYXJlbnQucmVtb3ZlRW50cnkodGhpcy4jZGhWZnNSb290Lm5hbWUsIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLiNkaFZmc1Jvb3QgPSB0aGlzLiNkaFZmc1BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IodGhpcy52ZnNOYW1lLCAncmVtb3ZlVmZzKCkgZmFpbGVkOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0RmlsZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fCB0b3NzKCdGaWxlIG5vdCBmb3VuZDonLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzYWguZ2V0U2l6ZSgpIC0gSEVBREVSX09GRlNFVF9EQVRBO1xuICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KG4gPiAwID8gbiA6IDApO1xuICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5SZWFkID0gc2FoLnJlYWQoYiwgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBIH0pO1xuICAgICAgICAgICAgICBpZiAoblJlYWQgIT0gbikge1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgdG8gcmVhZCAnICsgbiArICcgYnl0ZXMgYnV0IHJlYWQgJyArIG5SZWFkICsgJy4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGltcG9ydERiQ2h1bmtlZChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3Qgc2FoID1cbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKCkgfHxcbiAgICAgICAgICAgICAgdG9zcygnTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLicpO1xuICAgICAgICAgICAgc2FoLnRydW5jYXRlKDApO1xuICAgICAgICAgICAgbGV0IG5Xcm90ZSA9IDAsXG4gICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICBjaGVja2VkSGVhZGVyID0gZmFsc2UsXG4gICAgICAgICAgICAgIGVyciA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG5Xcm90ZSAmJiBjaHVuay5ieXRlTGVuZ3RoID49IDE1KSB7XG4gICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICBuV3JvdGUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnSW5wdXQgc2l6ZScsXG4gICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAnaXMgbm90IGNvcnJlY3QgZm9yIGFuIFNRTGl0ZSBkYXRhYmFzZS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFjaGVja2VkSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHtcbiAgICAgICAgICAgICAgICBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgMTgsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIG5hbWUsIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQik7XG4gICAgICAgICAgICByZXR1cm4gbldyb3RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGltcG9ydERiKG5hbWUsIGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnREYkNodW5rZWQobmFtZSwgYnl0ZXMpO1xuICAgICAgICAgICAgY29uc3Qgc2FoID1cbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKCkgfHxcbiAgICAgICAgICAgICAgdG9zcygnTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLicpO1xuICAgICAgICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDUxMiB8fCBuICUgNTEyICE9IDApIHtcbiAgICAgICAgICAgICAgdG9zcygnQnl0ZSBhcnJheSBzaXplIGlzIGludmFsaWQgZm9yIGFuIFNRTGl0ZSBkYi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9ICdTUUxpdGUgZm9ybWF0IDMnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGhlYWRlci5jaGFyQ29kZUF0KGkpICE9PSBieXRlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRvc3MoJ0lucHV0IGRvZXMgbm90IGNvbnRhaW4gYW4gU1FMaXRlIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgfSk7XG4gICAgICAgICAgICBpZiAobldyb3RlICE9IG4pIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgdG8gd3JpdGUgJyArIG4gKyAnIGJ5dGVzIGJ1dCB3cm90ZSAnICsgbldyb3RlICsgJy4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHtcbiAgICAgICAgICAgICAgICBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgMTgsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3MgT3Bmc1NBSFBvb2xVdGlsIHtcbiAgICAgICAgICAjcDtcblxuICAgICAgICAgIGNvbnN0cnVjdG9yKHNhaFBvb2wpIHtcbiAgICAgICAgICAgIHRoaXMuI3AgPSBzYWhQb29sO1xuICAgICAgICAgICAgdGhpcy52ZnNOYW1lID0gc2FoUG9vbC52ZnNOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGFkZENhcGFjaXR5KG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmFkZENhcGFjaXR5KG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlZHVjZUNhcGFjaXR5KG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlZHVjZUNhcGFjaXR5KG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldENhcGFjaXR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0Q2FwYWNpdHkodGhpcy4jcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0RmlsZUNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZUNvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEZpbGVOYW1lcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmdldEZpbGVOYW1lcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlc2VydmVNaW5pbXVtQ2FwYWNpdHkobWluKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy4jcC5nZXRDYXBhY2l0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGMgPCBtaW4gPyB0aGlzLiNwLmFkZENhcGFjaXR5KG1pbiAtIGMpIDogYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRGaWxlKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmV4cG9ydEZpbGUobmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmltcG9ydERiKG5hbWUsIGJ5dGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyB3aXBlRmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5yZXNldCh0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1bmxpbmsoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmRlbGV0ZVBhdGgoZmlsZW5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlbW92ZVZmcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlbW92ZVZmcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb25DaGVjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkaCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgICAgICAgIGNvbnN0IGZuID0gJy5vcGZzLXNhaHBvb2wtc3luYy1jaGVjay0nICsgZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgIGNvbnN0IGZoID0gYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbiwgeyBjcmVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBmaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgY29uc3QgY2xvc2UgPSBhaC5jbG9zZSgpO1xuICAgICAgICAgIGF3YWl0IGNsb3NlO1xuICAgICAgICAgIGF3YWl0IGRoLnJlbW92ZUVudHJ5KGZuKTtcbiAgICAgICAgICBpZiAoY2xvc2U/LnRoZW4pIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdUaGUgbG9jYWwgT1BGUyBBUEkgaXMgdG9vIG9sZCBmb3Igb3Bmcy1zYWhwb29sOicsXG4gICAgICAgICAgICAgICdpdCBoYXMgYW4gYXN5bmMgRmlsZVN5c3RlbVN5bmNBY2Nlc3NIYW5kbGUuY2xvc2UoKSBtZXRob2QuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNxbGl0ZTMuaW5zdGFsbE9wZnNTQUhQb29sVmZzID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBvcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB2ZnNOYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICAgIGlmIChvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTEpIHtcbiAgICAgICAgICAgIHRocm93IG9wdGlvbnMuJHRlc3RUaHJvd1BoYXNlMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluaXRQcm9taXNlc1t2ZnNOYW1lXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IGF3YWl0IGluaXRQcm9taXNlc1t2ZnNOYW1lXTtcblxuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VSZWluaXRJZlByZXZpb3VzbHlGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5pdFByb21pc2VzW3Zmc05hbWVdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlIHx8XG4gICAgICAgICAgICAhbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuJyksXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKGluaXRQcm9taXNlc1t2ZnNOYW1lXSA9IGFwaVZlcnNpb25DaGVjaygpXG4gICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlUG9vbCA9IG5ldyBPcGZzU0FIUG9vbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZVBvb2wuaXNSZWFkeVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBvb2xVdGlsID0gbmV3IE9wZnNTQUhQb29sVXRpbCh0aGVQb29sKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzcWxpdGUzLm9vMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbzEgPSBzcWxpdGUzLm9vMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlVmZzID0gdGhlUG9vbC5nZXRWZnMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgT3Bmc1NBSFBvb2xEYiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gb28xLkRCLmRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIG9wdC52ZnMgPSB0aGVWZnMuJHpOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIG9vMS5EQi5kYkN0b3JIZWxwZXIuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBPcGZzU0FIUG9vbERiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUob28xLkRCLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvb2xVdGlsLk9wZnNTQUhQb29sRGIgPSBPcGZzU0FIUG9vbERiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhlUG9vbC5sb2coJ1ZGUyBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwb29sVXRpbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhlUG9vbC5yZW1vdmVWZnMoKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgU0FCQyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHBvcnRzOlxuICAgICAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdhc21FeHBvcnRzID8gTW9kdWxlWydhc20nXSA6IHdhc21FeHBvcnRzLFxuICAgICAgICAgICAgbWVtb3J5OiBNb2R1bGUud2FzbU1lbW9yeSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCB7fSxcbiAgICAgICAgKTtcblxuICAgICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgPSBTQUJDO1xuICAgICAgICBsZXQgc3FsaXRlMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzcWxpdGUzID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzQXBpQm9vdHN0cmFwKCkgZXJyb3I6JywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwO1xuICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBNb2R1bGUuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYW4gRW1zY3JpcHRlbiBtb2R1bGUgY29udGV4dCwgc28nLFxuICAgICAgICAgICdnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKSBpcyBfbm90XyBiZWluZyBjYWxsZWQgZHVlIHRvIGxhY2snLFxuICAgICAgICAgICdvZiBjb25maWcgaW5mbyBmb3IgdGhlIFdBU00gZW52aXJvbm1lbnQuJyxcbiAgICAgICAgICAnSXQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlUnRuID0gcmVhZHlQcm9taXNlO1xuXG4gICAgcmV0dXJuIG1vZHVsZVJ0bjtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IHRvRXhwb3J0Rm9yRVNNID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxJbml0ID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIGlmICghb3JpZ2luYWxJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0V4cGVjdGluZyBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIHRvIGJlIGRlZmluZWQgYnkgdGhlIEVtc2NyaXB0ZW4gYnVpbGQuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5pdE1vZHVsZVN0YXRlID0gKGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB7XG4gICAgICBtb2R1bGVTY3JpcHQ6IGdsb2JhbFRoaXM/LmRvY3VtZW50Py5jdXJyZW50U2NyaXB0LFxuICAgICAgaXNXb3JrZXI6ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUsXG4gICAgICBsb2NhdGlvbjogZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICAgIHVybFBhcmFtczogZ2xvYmFsVGhpcz8ubG9jYXRpb24/LmhyZWZcbiAgICAgICAgPyBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zXG4gICAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgIH0sXG4gICkpO1xuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUgPSBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcyhcbiAgICAnc3FsaXRlMy5kZWJ1Z01vZHVsZScsXG4gIClcbiAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oJ3NxbGl0ZTMuZGVidWdNb2R1bGU6JywgLi4uYXJncylcbiAgICA6ICgpID0+IHt9O1xuXG4gIGlmIChpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kaXInKSkge1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID1cbiAgICAgIGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuZ2V0KCdzcWxpdGUzLmRpcicpICsgJy8nO1xuICB9IGVsc2UgaWYgKGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpIHtcbiAgICBjb25zdCBsaSA9IGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgbGkucG9wKCk7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBsaS5qb2luKCcvJykgKyAnLyc7XG4gIH1cblxuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlID0gZnVuY3Rpb24gZmYoLi4uYXJncykge1xuICAgIHJldHVybiBvcmlnaW5hbEluaXQoLi4uYXJncylcbiAgICAgIC50aGVuKChFbXNjcmlwdGVuTW9kdWxlKSA9PiB7XG4gICAgICAgIEVtc2NyaXB0ZW5Nb2R1bGUucnVuU1FMaXRlM1Bvc3RMb2FkSW5pdChFbXNjcmlwdGVuTW9kdWxlKTtcbiAgICAgICAgY29uc3QgcyA9IEVtc2NyaXB0ZW5Nb2R1bGUuc3FsaXRlMztcbiAgICAgICAgcy5zY3JpcHRJbmZvID0gaW5pdE1vZHVsZVN0YXRlO1xuXG4gICAgICAgIGlmIChmZi5fX2lzVW5kZXJUZXN0KSBzLl9faXNVbmRlclRlc3QgPSB0cnVlO1xuICAgICAgICBjb25zdCBmID0gcy5hc3luY1Bvc3RJbml0O1xuICAgICAgICBkZWxldGUgcy5hc3luY1Bvc3RJbml0O1xuICAgICAgICBjb25zdCBydiA9IGYoKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gbG9hZGluZyBzcWxpdGUzIG1vZHVsZTonLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICB9O1xuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlLnJlYWR5ID0gb3JpZ2luYWxJbml0LnJlYWR5O1xuXG4gIGlmIChnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUubW9kdWxlU2NyaXB0KSB7XG4gICAgY29uc3Qgc2ltID0gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIGxldCBzcmMgPSBzaW0ubW9kdWxlU2NyaXB0LnNyYy5zcGxpdCgnLycpO1xuICAgIHNyYy5wb3AoKTtcbiAgICBzaW0uc2NyaXB0RGlyID0gc3JjLmpvaW4oJy8nKSArICcvJztcbiAgfVxuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoJ3NxbGl0ZTNJbml0TW9kdWxlU3RhdGUgPScsIGluaXRNb2R1bGVTdGF0ZSk7XG4gIGlmICgwKSB7XG4gICAgY29uc29sZS53YXJuKCdSZXBsYWNlZCBzcWxpdGUzSW5pdE1vZHVsZSgpJyk7XG4gICAgY29uc29sZS53YXJuKCdnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYgPScsIGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZik7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZG9jdW1lbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjID0nLFxuICAgICAgICBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGU7XG59KSgpO1xuc3FsaXRlM0luaXRNb2R1bGUgPSB0b0V4cG9ydEZvckVTTTtcbmV4cG9ydCBkZWZhdWx0IHNxbGl0ZTNJbml0TW9kdWxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs":
/*!********************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n  2022-08-24\n\n  The author disclaims copyright to this source code.  In place of a\n  legal notice, here is a blessing:\n\n  *   May you do good and not evil.\n  *   May you find forgiveness for yourself and forgive others.\n  *   May you share freely, never taking more than you give.\n\n  ***********************************************************************\n\n  This file implements a Promise-based proxy for the sqlite3 Worker\n  API #1. It is intended to be included either from the main thread or\n  a Worker, but only if (A) the environment supports nested Workers\n  and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS\n  module. This file's features will load that module and provide a\n  slightly simpler client-side interface than the slightly-lower-level\n  Worker API does.\n\n  This script necessarily exposes one global symbol, but clients may\n  freely `delete` that symbol after calling it.\n*/\n\n\nglobalThis.sqlite3Worker1Promiser = function callee(\n  config = callee.defaultConfig,\n) {\n  if (1 === arguments.length && 'function' === typeof arguments[0]) {\n    const f = config;\n    config = Object.assign(Object.create(null), callee.defaultConfig);\n    config.onready = f;\n  } else {\n    config = Object.assign(Object.create(null), callee.defaultConfig, config);\n  }\n  const handlerMap = Object.create(null);\n  const noop = function () {};\n  const err = config.onerror || noop;\n  const debug = config.debug || noop;\n  const idTypeMap = config.generateMessageId ? undefined : Object.create(null);\n  const genMsgId =\n    config.generateMessageId ||\n    function (msg) {\n      return (\n        msg.type + '#' + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1)\n      );\n    };\n  const toss = (...args) => {\n    throw new Error(args.join(' '));\n  };\n  if (!config.worker) config.worker = callee.defaultConfig.worker;\n  if ('function' === typeof config.worker) config.worker = config.worker();\n  let dbId;\n  let promiserFunc;\n  config.worker.onmessage = function (ev) {\n    ev = ev.data;\n    debug('worker1.onmessage', ev);\n    let msgHandler = handlerMap[ev.messageId];\n    if (!msgHandler) {\n      if (ev && 'sqlite3-api' === ev.type && 'worker1-ready' === ev.result) {\n        if (config.onready) config.onready(promiserFunc);\n        return;\n      }\n      msgHandler = handlerMap[ev.type];\n      if (msgHandler && msgHandler.onrow) {\n        msgHandler.onrow(ev);\n        return;\n      }\n      if (config.onunhandled) config.onunhandled(arguments[0]);\n      else err('sqlite3Worker1Promiser() unhandled worker message:', ev);\n      return;\n    }\n    delete handlerMap[ev.messageId];\n    switch (ev.type) {\n      case 'error':\n        msgHandler.reject(ev);\n        return;\n      case 'open':\n        if (!dbId) dbId = ev.dbId;\n        break;\n      case 'close':\n        if (ev.dbId === dbId) dbId = undefined;\n        break;\n      default:\n        break;\n    }\n    try {\n      msgHandler.resolve(ev);\n    } catch (e) {\n      msgHandler.reject(e);\n    }\n  };\n  return (promiserFunc = function () {\n    let msg;\n    if (1 === arguments.length) {\n      msg = arguments[0];\n    } else if (2 === arguments.length) {\n      msg = Object.create(null);\n      msg.type = arguments[0];\n      msg.args = arguments[1];\n      msg.dbId = msg.args.dbId;\n    } else {\n      toss('Invalid arguments for sqlite3Worker1Promiser()-created factory.');\n    }\n    if (!msg.dbId && msg.type !== 'open') msg.dbId = dbId;\n    msg.messageId = genMsgId(msg);\n    msg.departureTime = performance.now();\n    const proxy = Object.create(null);\n    proxy.message = msg;\n    let rowCallbackId;\n    if ('exec' === msg.type && msg.args) {\n      if ('function' === typeof msg.args.callback) {\n        rowCallbackId = msg.messageId + ':row';\n        proxy.onrow = msg.args.callback;\n        msg.args.callback = rowCallbackId;\n        handlerMap[rowCallbackId] = proxy;\n      } else if ('string' === typeof msg.args.callback) {\n        toss(\n          'exec callback may not be a string when using the Promise interface.',\n        );\n      }\n    }\n\n    let p = new Promise(function (resolve, reject) {\n      proxy.resolve = resolve;\n      proxy.reject = reject;\n      handlerMap[msg.messageId] = proxy;\n      debug(\n        'Posting',\n        msg.type,\n        'message to Worker dbId=' + (dbId || 'default') + ':',\n        msg,\n      );\n      config.worker.postMessage(msg);\n    });\n    if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);\n    return p;\n  });\n};\n\nglobalThis.sqlite3Worker1Promiser.defaultConfig = {\n  worker: function () {\n    return new Worker(\n      __webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"_app-pages-browser_node_modules_pnpm_sqlite_org_sqlite-wasm_3_49_1-build2_node_modules_sqlite-d02caa\"), __webpack_require__.b)),\n      {\n        type: undefined,\n      },\n    );\n  },\n  onerror: (...args) => console.error('worker1 promiser error', ...args),\n};\n\nsqlite3Worker1Promiser.v2 = function (config) {\n  let oldFunc;\n  if ('function' == typeof config) {\n    oldFunc = config;\n    config = {};\n  } else if ('function' === typeof config?.onready) {\n    oldFunc = config.onready;\n    delete config.onready;\n  }\n  const promiseProxy = Object.create(null);\n  config = Object.assign(config || Object.create(null), {\n    onready: async function (func) {\n      try {\n        if (oldFunc) await oldFunc(func);\n        promiseProxy.resolve(func);\n      } catch (e) {\n        promiseProxy.reject(e);\n      }\n    },\n  });\n  const p = new Promise(function (resolve, reject) {\n    promiseProxy.resolve = resolve;\n    promiseProxy.reject = reject;\n  });\n  try {\n    this.original(config);\n  } catch (e) {\n    promiseProxy.reject(e);\n  }\n  return p;\n}.bind({\n  original: sqlite3Worker1Promiser,\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3Worker1Promiser.v2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNxbGl0ZS5vcmcrc3FsaXRlLXdhc21AMy40OS4xLWJ1aWxkMi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtd29ya2VyMS1wcm9taXNlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUFRLGdNQUF1RCxDQUFDO0FBQ3RFO0FBQ0EsY0FBYyxTQUFRO0FBQ3RCLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQsaUVBQWUseUJBQXlCLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL0BzcWxpdGUub3JnK3NxbGl0ZS13YXNtQDMuNDkuMS1idWlsZDIvbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLXdvcmtlcjEtcHJvbWlzZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIDIwMjItMDgtMjRcblxuICBUaGUgYXV0aG9yIGRpc2NsYWltcyBjb3B5cmlnaHQgdG8gdGhpcyBzb3VyY2UgY29kZS4gIEluIHBsYWNlIG9mIGFcbiAgbGVnYWwgbm90aWNlLCBoZXJlIGlzIGEgYmxlc3Npbmc6XG5cbiAgKiAgIE1heSB5b3UgZG8gZ29vZCBhbmQgbm90IGV2aWwuXG4gICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbiAgKiAgIE1heSB5b3Ugc2hhcmUgZnJlZWx5LCBuZXZlciB0YWtpbmcgbW9yZSB0aGFuIHlvdSBnaXZlLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgVGhpcyBmaWxlIGltcGxlbWVudHMgYSBQcm9taXNlLWJhc2VkIHByb3h5IGZvciB0aGUgc3FsaXRlMyBXb3JrZXJcbiAgQVBJICMxLiBJdCBpcyBpbnRlbmRlZCB0byBiZSBpbmNsdWRlZCBlaXRoZXIgZnJvbSB0aGUgbWFpbiB0aHJlYWQgb3JcbiAgYSBXb3JrZXIsIGJ1dCBvbmx5IGlmIChBKSB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgbmVzdGVkIFdvcmtlcnNcbiAgYW5kIChCKSBpdCdzIF9ub3RfIGEgV29ya2VyIHdoaWNoIGxvYWRzIHRoZSBzcWxpdGUzIFdBU00vSlNcbiAgbW9kdWxlLiBUaGlzIGZpbGUncyBmZWF0dXJlcyB3aWxsIGxvYWQgdGhhdCBtb2R1bGUgYW5kIHByb3ZpZGUgYVxuICBzbGlnaHRseSBzaW1wbGVyIGNsaWVudC1zaWRlIGludGVyZmFjZSB0aGFuIHRoZSBzbGlnaHRseS1sb3dlci1sZXZlbFxuICBXb3JrZXIgQVBJIGRvZXMuXG5cbiAgVGhpcyBzY3JpcHQgbmVjZXNzYXJpbHkgZXhwb3NlcyBvbmUgZ2xvYmFsIHN5bWJvbCwgYnV0IGNsaWVudHMgbWF5XG4gIGZyZWVseSBgZGVsZXRlYCB0aGF0IHN5bWJvbCBhZnRlciBjYWxsaW5nIGl0LlxuKi9cbid1c2Ugc3RyaWN0JztcblxuZ2xvYmFsVGhpcy5zcWxpdGUzV29ya2VyMVByb21pc2VyID0gZnVuY3Rpb24gY2FsbGVlKFxuICBjb25maWcgPSBjYWxsZWUuZGVmYXVsdENvbmZpZyxcbikge1xuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgY29uc3QgZiA9IGNvbmZpZztcbiAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGNhbGxlZS5kZWZhdWx0Q29uZmlnKTtcbiAgICBjb25maWcub25yZWFkeSA9IGY7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBjYWxsZWUuZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICBjb25zdCBlcnIgPSBjb25maWcub25lcnJvciB8fCBub29wO1xuICBjb25zdCBkZWJ1ZyA9IGNvbmZpZy5kZWJ1ZyB8fCBub29wO1xuICBjb25zdCBpZFR5cGVNYXAgPSBjb25maWcuZ2VuZXJhdGVNZXNzYWdlSWQgPyB1bmRlZmluZWQgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBnZW5Nc2dJZCA9XG4gICAgY29uZmlnLmdlbmVyYXRlTWVzc2FnZUlkIHx8XG4gICAgZnVuY3Rpb24gKG1zZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbXNnLnR5cGUgKyAnIycgKyAoaWRUeXBlTWFwW21zZy50eXBlXSA9IChpZFR5cGVNYXBbbXNnLnR5cGVdIHx8IDApICsgMSlcbiAgICAgICk7XG4gICAgfTtcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgfTtcbiAgaWYgKCFjb25maWcud29ya2VyKSBjb25maWcud29ya2VyID0gY2FsbGVlLmRlZmF1bHRDb25maWcud29ya2VyO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbmZpZy53b3JrZXIpIGNvbmZpZy53b3JrZXIgPSBjb25maWcud29ya2VyKCk7XG4gIGxldCBkYklkO1xuICBsZXQgcHJvbWlzZXJGdW5jO1xuICBjb25maWcud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIGV2ID0gZXYuZGF0YTtcbiAgICBkZWJ1Zygnd29ya2VyMS5vbm1lc3NhZ2UnLCBldik7XG4gICAgbGV0IG1zZ0hhbmRsZXIgPSBoYW5kbGVyTWFwW2V2Lm1lc3NhZ2VJZF07XG4gICAgaWYgKCFtc2dIYW5kbGVyKSB7XG4gICAgICBpZiAoZXYgJiYgJ3NxbGl0ZTMtYXBpJyA9PT0gZXYudHlwZSAmJiAnd29ya2VyMS1yZWFkeScgPT09IGV2LnJlc3VsdCkge1xuICAgICAgICBpZiAoY29uZmlnLm9ucmVhZHkpIGNvbmZpZy5vbnJlYWR5KHByb21pc2VyRnVuYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1zZ0hhbmRsZXIgPSBoYW5kbGVyTWFwW2V2LnR5cGVdO1xuICAgICAgaWYgKG1zZ0hhbmRsZXIgJiYgbXNnSGFuZGxlci5vbnJvdykge1xuICAgICAgICBtc2dIYW5kbGVyLm9ucm93KGV2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5vbnVuaGFuZGxlZCkgY29uZmlnLm9udW5oYW5kbGVkKGFyZ3VtZW50c1swXSk7XG4gICAgICBlbHNlIGVycignc3FsaXRlM1dvcmtlcjFQcm9taXNlcigpIHVuaGFuZGxlZCB3b3JrZXIgbWVzc2FnZTonLCBldik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBoYW5kbGVyTWFwW2V2Lm1lc3NhZ2VJZF07XG4gICAgc3dpdGNoIChldi50eXBlKSB7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIG1zZ0hhbmRsZXIucmVqZWN0KGV2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIGlmICghZGJJZCkgZGJJZCA9IGV2LmRiSWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICBpZiAoZXYuZGJJZCA9PT0gZGJJZCkgZGJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG1zZ0hhbmRsZXIucmVzb2x2ZShldik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXNnSGFuZGxlci5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKHByb21pc2VyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbXNnO1xuICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBtc2cgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBtc2cgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbXNnLnR5cGUgPSBhcmd1bWVudHNbMF07XG4gICAgICBtc2cuYXJncyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIG1zZy5kYklkID0gbXNnLmFyZ3MuZGJJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9zcygnSW52YWxpZCBhcmd1bWVudHMgZm9yIHNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIoKS1jcmVhdGVkIGZhY3RvcnkuJyk7XG4gICAgfVxuICAgIGlmICghbXNnLmRiSWQgJiYgbXNnLnR5cGUgIT09ICdvcGVuJykgbXNnLmRiSWQgPSBkYklkO1xuICAgIG1zZy5tZXNzYWdlSWQgPSBnZW5Nc2dJZChtc2cpO1xuICAgIG1zZy5kZXBhcnR1cmVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgcHJveHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHByb3h5Lm1lc3NhZ2UgPSBtc2c7XG4gICAgbGV0IHJvd0NhbGxiYWNrSWQ7XG4gICAgaWYgKCdleGVjJyA9PT0gbXNnLnR5cGUgJiYgbXNnLmFyZ3MpIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbXNnLmFyZ3MuY2FsbGJhY2spIHtcbiAgICAgICAgcm93Q2FsbGJhY2tJZCA9IG1zZy5tZXNzYWdlSWQgKyAnOnJvdyc7XG4gICAgICAgIHByb3h5Lm9ucm93ID0gbXNnLmFyZ3MuY2FsbGJhY2s7XG4gICAgICAgIG1zZy5hcmdzLmNhbGxiYWNrID0gcm93Q2FsbGJhY2tJZDtcbiAgICAgICAgaGFuZGxlck1hcFtyb3dDYWxsYmFja0lkXSA9IHByb3h5O1xuICAgICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG1zZy5hcmdzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRvc3MoXG4gICAgICAgICAgJ2V4ZWMgY2FsbGJhY2sgbWF5IG5vdCBiZSBhIHN0cmluZyB3aGVuIHVzaW5nIHRoZSBQcm9taXNlIGludGVyZmFjZS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJveHkucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm94eS5yZWplY3QgPSByZWplY3Q7XG4gICAgICBoYW5kbGVyTWFwW21zZy5tZXNzYWdlSWRdID0gcHJveHk7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgJ1Bvc3RpbmcnLFxuICAgICAgICBtc2cudHlwZSxcbiAgICAgICAgJ21lc3NhZ2UgdG8gV29ya2VyIGRiSWQ9JyArIChkYklkIHx8ICdkZWZhdWx0JykgKyAnOicsXG4gICAgICAgIG1zZyxcbiAgICAgICk7XG4gICAgICBjb25maWcud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSk7XG4gICAgaWYgKHJvd0NhbGxiYWNrSWQpIHAgPSBwLmZpbmFsbHkoKCkgPT4gZGVsZXRlIGhhbmRsZXJNYXBbcm93Q2FsbGJhY2tJZF0pO1xuICAgIHJldHVybiBwO1xuICB9KTtcbn07XG5cbmdsb2JhbFRoaXMuc3FsaXRlM1dvcmtlcjFQcm9taXNlci5kZWZhdWx0Q29uZmlnID0ge1xuICB3b3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihcbiAgICAgIG5ldyBVUkwoJ3NxbGl0ZTMtd29ya2VyMS1idW5kbGVyLWZyaWVuZGx5Lm1qcycsIGltcG9ydC5tZXRhLnVybCksXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdtb2R1bGUnLFxuICAgICAgfSxcbiAgICApO1xuICB9LFxuICBvbmVycm9yOiAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcignd29ya2VyMSBwcm9taXNlciBlcnJvcicsIC4uLmFyZ3MpLFxufTtcblxuc3FsaXRlM1dvcmtlcjFQcm9taXNlci52MiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgbGV0IG9sZEZ1bmM7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBjb25maWcpIHtcbiAgICBvbGRGdW5jID0gY29uZmlnO1xuICAgIGNvbmZpZyA9IHt9O1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjb25maWc/Lm9ucmVhZHkpIHtcbiAgICBvbGRGdW5jID0gY29uZmlnLm9ucmVhZHk7XG4gICAgZGVsZXRlIGNvbmZpZy5vbnJlYWR5O1xuICB9XG4gIGNvbnN0IHByb21pc2VQcm94eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oY29uZmlnIHx8IE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICBvbnJlYWR5OiBhc3luYyBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9sZEZ1bmMpIGF3YWl0IG9sZEZ1bmMoZnVuYyk7XG4gICAgICAgIHByb21pc2VQcm94eS5yZXNvbHZlKGZ1bmMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcm9taXNlUHJveHkucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICBjb25zdCBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHByb21pc2VQcm94eS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBwcm9taXNlUHJveHkucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLm9yaWdpbmFsKGNvbmZpZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9taXNlUHJveHkucmVqZWN0KGUpO1xuICB9XG4gIHJldHVybiBwO1xufS5iaW5kKHtcbiAgb3JpZ2luYWw6IHNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3FsaXRlM1dvcmtlcjFQcm9taXNlci52MjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm":
/*!****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.49.1-build2/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm ***!
  \****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/sqlite3.9fe1c4d8.wasm";

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js":
/*!***************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === 'object' ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4zLjBfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0xBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4zLjBfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gJ29iamVjdCcgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzJyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/process/browser.js":
/*!****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/process/browser.js ***!
  \****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4zLjBfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTUuMy4wX3JlYWN0LWRvbUAxOS4xLjBfcmVhY3RAMTkuMS4wX19yZWFjdEAxOS4xLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/.pnpm/next@15.3.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/chunks/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("static/webpack/" + __webpack_require__.h() + ".47d18365426a5fb8.hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("bcb6e6710cc2cdd3")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/relative url */
/******/ 	(() => {
/******/ 		__webpack_require__.U = function RelativeURL(url) {
/******/ 			var realUrl = new URL(url, "x:/");
/******/ 			var values = {};
/******/ 			for (var key in realUrl) values[key] = realUrl[key];
/******/ 			values.href = url;
/******/ 			values.pathname = url.replace(/[?#].*/, "");
/******/ 			values.origin = values.protocol = "";
/******/ 			values.toString = values.toJSON = () => (url);
/******/ 			for (var key in values) Object.defineProperty(this, key, { enumerable: true, configurable: true, value: values[key] });
/******/ 		};
/******/ 		__webpack_require__.U.prototype = URL.prototype;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script),
/******/ 					createScriptURL: (url) => (url)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	(() => {
/******/ 		__webpack_require__.tu = (url) => (__webpack_require__.tt().createScriptURL(url));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			(function(linkTag) {
/******/ 			                if (typeof _N_E_STYLE_LOAD === 'function') {
/******/ 			                    const { href, onload, onerror } = linkTag;
/******/ 			                    _N_E_STYLE_LOAD(href.indexOf(window.location.origin) === 0 ? new URL(href).pathname : href).then(()=>onload == null ? void 0 : onload.call(linkTag, {
/******/ 			                            type: 'load'
/******/ 			                        }), ()=>onerror == null ? void 0 : onerror.call(linkTag, {}));
/******/ 			                } else {
/******/ 			                    document.head.appendChild(linkTag);
/******/ 			                }
/******/ 			            })(linkTag)
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"_app-pages-browser_medfetch_dist_sqlite-wasm_worker1_mjs": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = (_, moreModules, runtime) => {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(app-pages-browser)/../medfetch/dist/sqlite-wasm/worker1.mjs");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;