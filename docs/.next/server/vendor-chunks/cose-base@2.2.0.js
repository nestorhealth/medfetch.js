/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cose-base@2.2.0";
exports.ids = ["vendor-chunks/cose-base@2.2.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! layout-base */ \"(ssr)/../node_modules/.pnpm/layout-base@2.0.1/node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_630__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_630__(551);\ncoseBase.CoSEConstants = __nested_webpack_require_630__(806);\ncoseBase.CoSEEdge = __nested_webpack_require_630__(767);\ncoseBase.CoSEGraph = __nested_webpack_require_630__(880);\ncoseBase.CoSEGraphManager = __nested_webpack_require_630__(578);\ncoseBase.CoSELayout = __nested_webpack_require_630__(765);\ncoseBase.CoSENode = __nested_webpack_require_630__(991);\ncoseBase.ConstraintHandler = __nested_webpack_require_630__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1167__) => {\n\n\n\nvar FDLayoutConstants = __nested_webpack_require_1167__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2468__) => {\n\n\n\nvar FDLayoutEdge = __nested_webpack_require_2468__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2879__) => {\n\n\n\nvar LGraph = __nested_webpack_require_2879__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3264__) => {\n\n\n\nvar LGraphManager = __nested_webpack_require_3264__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3683__) => {\n\n\n\nvar FDLayout = __nested_webpack_require_3683__(551).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_3683__(578);\nvar CoSEGraph = __nested_webpack_require_3683__(880);\nvar CoSENode = __nested_webpack_require_3683__(991);\nvar CoSEEdge = __nested_webpack_require_3683__(767);\nvar CoSEConstants = __nested_webpack_require_3683__(806);\nvar ConstraintHandler = __nested_webpack_require_3683__(902);\nvar FDLayoutConstants = __nested_webpack_require_3683__(551).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_3683__(551).LayoutConstants;\nvar Point = __nested_webpack_require_3683__(551).Point;\nvar PointD = __nested_webpack_require_3683__(551).PointD;\nvar DimensionD = __nested_webpack_require_3683__(551).DimensionD;\nvar Layout = __nested_webpack_require_3683__(551).Layout;\nvar Integer = __nested_webpack_require_3683__(551).Integer;\nvar IGeometry = __nested_webpack_require_3683__(551).IGeometry;\nvar LGraph = __nested_webpack_require_3683__(551).LGraph;\nvar Transform = __nested_webpack_require_3683__(551).Transform;\nvar LinkedList = __nested_webpack_require_3683__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_74190__) => {\n\n\n\nvar FDLayoutNode = __nested_webpack_require_74190__(551).FDLayoutNode;\nvar IMath = __nested_webpack_require_74190__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_77514__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __nested_webpack_require_77514__(806);\nvar LinkedList = __nested_webpack_require_77514__(551).LinkedList;\nvar Matrix = __nested_webpack_require_77514__(551).Matrix;\nvar SVD = __nested_webpack_require_77514__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_117795__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_117795__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_117795__(45);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc2UtYmFzZUAyLjIuMC9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsMEdBQWE7QUFDaEQsTUFBTSxFQUsyQztBQUNqRCxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsOEJBQW1COzs7O0FBSTdEOztBQUVBLHNCQUFzQiw4QkFBbUI7QUFDekMseUJBQXlCLDhCQUFtQjtBQUM1QyxvQkFBb0IsOEJBQW1CO0FBQ3ZDLHFCQUFxQiw4QkFBbUI7QUFDeEMsNEJBQTRCLDhCQUFtQjtBQUMvQyxzQkFBc0IsOEJBQW1CO0FBQ3pDLG9CQUFvQiw4QkFBbUI7QUFDdkMsNkJBQTZCLDhCQUFtQjs7QUFFaEQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0Qsd0JBQXdCLCtCQUFtQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELG1CQUFtQiwrQkFBbUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7OztBQUk3RCxhQUFhLCtCQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELG9CQUFvQiwrQkFBbUI7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFF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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFD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ZHVsZXMvLnBucG0vY29zZS1iYXNlQDIuMi4wL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxheW91dC1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxheW91dC1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyb290W1wibGF5b3V0QmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgY29zZUJhc2UgPSB7fTtcblxuY29zZUJhc2UubGF5b3V0QmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG5jb3NlQmFzZS5Db1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3KTtcbmNvc2VCYXNlLkNvU0VHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oODgwKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG5jb3NlQmFzZS5Db1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjUpO1xuY29zZUJhc2UuQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG5jb3NlQmFzZS5Db25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3NlQmFzZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcblxuZnVuY3Rpb24gQ29TRUNvbnN0YW50cygpIHt9XG5cbi8vQ29TRUNvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gRkRMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXRDb25zdGFudHMpIHtcbiAgQ29TRUNvbnN0YW50c1twcm9wXSA9IEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX01VTFRJX0xFVkVMX1NDQUxJTkcgPSBmYWxzZTtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04gPSA2MDtcbkNvU0VDb25zdGFudHMuVElMRSA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gMTA7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7IC8vIHRoaXMgc2hvdWxkIGJlIHNldCB0byBmYWxzZSBpZiB0aGVyZSB3aWxsIGJlIGEgY29uc3RyYWludFxuLy8gVGhpcyBjb25zdGFudCBpcyBmb3IgZGlmZmVyZW50aWF0aW5nIHdoZXRoZXIgYWN0dWFsIGxheW91dCBhbGdvcml0aG0gdGhhdCB1c2VzIGNvc2UtYmFzZSB3YW50cyB0byBhcHBseSBvbmx5IGluY3JlbWVudGFsIGxheW91dCBvciBcbi8vIGFuIGluY3JlbWVudGFsIGxheW91dCBvbiB0b3Agb2YgYSByYW5kb21pemVkIGxheW91dC4gSWYgaXQgaXMgb25seSBpbmNyZW1lbnRhbCBsYXlvdXQsIHRoZW4gdGhpcyBjb25zdGFudCBzaG91bGQgYmUgdHJ1ZS5cbkNvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFQ29uc3RhbnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dEVkZ2U7XG5cbmZ1bmN0aW9uIENvU0VFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBGRExheW91dEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xufVxuXG5Db1NFRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0RWRnZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dEVkZ2UpIHtcbiAgQ29TRUVkZ2VbcHJvcF0gPSBGRExheW91dEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUVkZ2U7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Nzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGhNYW5hZ2VyO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGhNYW5hZ2VyLmNhbGwodGhpcywgbGF5b3V0KTtcbn1cblxuQ29TRUdyYXBoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE1hbmFnZXIucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoTWFuYWdlcikge1xuICBDb1NFR3JhcGhNYW5hZ2VyW3Byb3BdID0gTEdyYXBoTWFuYWdlcltwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0O1xudmFyIENvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG52YXIgQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTEpO1xudmFyIENvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgQ29uc3RyYWludEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxheW91dENvbnN0YW50cztcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRGltZW5zaW9uRDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0O1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSW50ZWdlcjtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGg7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlRyYW5zZm9ybTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxpbmtlZExpc3Q7XG5cbmZ1bmN0aW9uIENvU0VMYXlvdXQoKSB7XG4gIEZETGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy50b0JlVGlsZWQgPSB7fTsgLy8gTWVtb3JpemUgaWYgYSBub2RlIGlzIHRvIGJlIHRpbGVkIG9yIGlzIHRpbGVkXG4gIHRoaXMuY29uc3RyYWludHMgPSB7fTsgLy8ga2VlcCBsYXlvdXQgY29uc3RyYWludHNcbn1cblxuQ29TRUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXQpIHtcbiAgQ29TRUxheW91dFtwcm9wXSA9IEZETGF5b3V0W3Byb3BdO1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBDb1NFR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBDb1NFR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBDb1NFRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA8IDEwKSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICAgIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciB0cmVlIHJlZHVjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IFtdO1xuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IENvU0UgcmVsYXRlZCBwYXJhbWV0ZXJzIHVzZWQgYnkgc3ByaW5nIGVtYmVkZGVyLlxuQ29TRUxheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gIHRoaXMuY29vbGluZ0N5Y2xlID0gMDtcbiAgdGhpcy5tYXhDb29saW5nQ3ljbGUgPSB0aGlzLm1heEl0ZXJhdGlvbnMgLyBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0Q7XG4gIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IDAuMDQ7XG4gIHRoaXMuY29vbGluZ0FkanVzdGVyID0gMTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29uc3RyYWludHMpLmxlbmd0aCA+IDApIHtcbiAgICBDb25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyh0aGlzKTtcbiAgICB0aGlzLmluaXRDb25zdHJhaW50VmFyaWFibGVzKCk7XG4gIH1cblxuICB0aGlzLmluaXRTcHJpbmdFbWJlZGRlcigpO1xuICBpZiAoQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQpIHtcbiAgICB0aGlzLnJ1blNwcmluZ0VtYmVkZGVyKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudG90YWxJdGVyYXRpb25zKys7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID09PSB0aGlzLm1heEl0ZXJhdGlvbnMgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID09IDAgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb29saW5nQ3ljbGUrKztcblxuICAgIGlmICh0aGlzLmxheW91dFF1YWxpdHkgPT0gMCkge1xuICAgICAgLy8gcXVhbGl0eSAtIFwiZHJhZnRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAxKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkZWZhdWx0XCJcbiAgICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gdGhpcy5jb29saW5nQ3ljbGUgLyAzO1xuICAgIH1cblxuICAgIC8vIGNvb2xpbmcgc2NoZWR1bGUgaXMgYmFzZWQgb24gaHR0cDovL3d3dy5idGx1a2UuY29tL3NpbWFuZjEuaHRtbCAtPiBjb29saW5nIHNjaGVkdWxlIDNcbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gTWF0aC5wb3codGhpcy5jb29saW5nQ3ljbGUsIE1hdGgubG9nKDEwMCAqICh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gdGhpcy5maW5hbFRlbXBlcmF0dXJlKSkgLyBNYXRoLmxvZyh0aGlzLm1heENvb2xpbmdDeWNsZSkpIC8gMTAwICogdGhpcy5jb29saW5nQWRqdXN0ZXIsIHRoaXMuZmluYWxUZW1wZXJhdHVyZSk7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBNYXRoLmNlaWwodGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kICogTWF0aC5zcXJ0KHRoaXMuY29vbGluZ0ZhY3RvcikpO1xuICB9XG4gIC8vIE9wZXJhdGlvbnMgd2hpbGUgdHJlZSBpcyBncm93aW5nIGFnYWluIFxuICBpZiAodGhpcy5pc1RyZWVHcm93aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMuZ3Jvd1RyZWUodGhpcy5wcnVuZWROb2Rlc0FsbCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAvIDI7ZWxzZSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMiAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgKiAoKDEwMCAtIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKSAvIDEwMCk7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9ICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZDtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc1RyZWVHcm93aW5nIHx8IHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDA7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB0aGlzLmNhbGNTcHJpbmdGb3JjZXMoKTtcbiAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2VzKGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcygpO1xuICB0aGlzLm1vdmVOb2RlcygpO1xuICB0aGlzLmFuaW1hdGUoKTtcblxuICByZXR1cm4gZmFsc2U7IC8vIExheW91dCBpcyBub3QgZW5kZWQgeWV0IHJldHVybiBmYWxzZVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHBEYXRhID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVjdCA9IGFsbE5vZGVzW2ldLnJlY3Q7XG4gICAgdmFyIGlkID0gYWxsTm9kZXNbaV0uaWQ7XG4gICAgcERhdGFbaWRdID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDogcmVjdC5nZXRDZW50ZXJYKCksXG4gICAgICB5OiByZWN0LmdldENlbnRlclkoKSxcbiAgICAgIHc6IHJlY3Qud2lkdGgsXG4gICAgICBoOiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcERhdGE7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW5TcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kID0gMjU7XG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kO1xuICB2YXIgbGF5b3V0RW5kZWQgPSBmYWxzZTtcblxuICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyBzaWduYWwgdGhhdCBsYXlvdXQgaXMgc3VwcG9zZWQgdG8gc3RhcnQgaXRlcmF0aW5nXG4gIGlmIChGRExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RhcnRlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHRpY2soKSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBpbmRleC5qc1xuICAgIHdoaWxlICghbGF5b3V0RW5kZWQpIHtcbiAgICAgIGxheW91dEVuZGVkID0gdGhpcy50aWNrKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIH1cbn07XG5cbi8vIG92ZXJyaWRlcyBtb3ZlTm9kZXMgbWV0aG9kIGluIEZETGF5b3V0XG5Db1NFTGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIC8vIGNhbGN1bGF0ZSBkaXNwbGFjZW1lbnQgZm9yIGVhY2ggbm9kZSBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50KCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMudXBkYXRlRGlzcGxhY2VtZW50cygpO1xuICB9XG5cbiAgLy8gbW92ZSBlYWNoIG5vZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUubW92ZSgpO1xuICB9XG59O1xuXG4vLyBjb25zdHJhaW50IHJlbGF0ZWQgbWV0aG9kczogaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMgYW5kIHVwZGF0ZURpc3BsYWNlbWVudHNcblxuLy8gaW5pdGlhbGl6ZSBjb25zdHJhaW50IHJlbGF0ZWQgdmFyaWFibGVzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0Q29uc3RyYWludFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmlkVG9Ob2RlTWFwID0gbmV3IE1hcCgpO1xuICB0aGlzLmZpeGVkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIGZpbGwgaWRUb05vZGVNYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgdGhpcy5pZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgZml4ZWQgbm9kZSB3ZWlnaHQgZm9yIGdpdmVuIGNvbXBvdW5kIG5vZGVcbiAgdmFyIGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQoY29tcG91bmROb2RlKSB7XG4gICAgdmFyIG5vZGVzID0gY29tcG91bmROb2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGYuZml4ZWROb2RlU2V0Lmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkTm9kZVdlaWdodDtcbiAgfTtcblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgLy8gZmlsbCBmaXhlZE5vZGVTZXRcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHNlbGYuZml4ZWROb2RlU2V0LmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gYXNzaWduIGZpeGVkIG5vZGUgd2VpZ2h0cyB0byBjb21wb3VuZHMgaWYgdGhleSBjb250YWluIGZpeGVkIG5vZGVzXG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQobm9kZSk7XG4gICAgICAgIGlmIChmaXhlZE5vZGVXZWlnaHQgPiAwKSB7XG4gICAgICAgICAgbm9kZS5maXhlZE5vZGVXZWlnaHQgPSBmaXhlZE5vZGVXZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPbkhvcml6b250YWwgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5maXhlZE5vZGVzT25WZXJ0aWNhbCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0c1xuICAgIHRoaXMuZml4ZWROb2RlU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChub2RlSWQpO1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2FsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbaV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUykge1xuXG4gICAgICB0aGlzLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGosIHgsIGk7XG4gICAgICAgIGZvciAoaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMiAqIGFycmF5Lmxlbmd0aCAvIDM7IGktLSkge1xuICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICB4ID0gYXJyYXlbaV07XG4gICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgICBhcnJheVtqXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsID0gW107XG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsID0gW107XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgLy8gZmlsbCBhcnJheXMgYW5kIG1hcHNcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBub2RlSWRMZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIG5vZGVJZFJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRMZWZ0KSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLnB1c2gobm9kZUlkTGVmdCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZExlZnQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRMZWZ0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkTGVmdCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuaW5jbHVkZXMobm9kZUlkUmlnaHQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRSaWdodCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRSaWdodCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRSaWdodClbMF0pLmdldENlbnRlclgoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRSaWdodCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZExlZnQpLnB1c2goeyByaWdodDogbm9kZUlkUmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBIb3Jpem9udGFsLmdldChub2RlSWRSaWdodCkucHVzaCh7IGxlZnQ6IG5vZGVJZExlZnQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGVJZFRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgbm9kZUlkQm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuXG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLmluY2x1ZGVzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwucHVzaChub2RlSWRUb3ApO1xuICAgICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkVG9wKVswXSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZFRvcCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkVG9wKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZEJvdHRvbSk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRCb3R0b20pWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkQm90dG9tLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRCb3R0b20pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZFRvcCkucHVzaCh7IGJvdHRvbTogbm9kZUlkQm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZEJvdHRvbSkucHVzaCh7IHRvcDogbm9kZUlkVG9wLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG5cbiAgICAgIC8vIGNvbnN0cnVjdCBzdWJncmFwaHMgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQubGVmdCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmxlZnQpIDogY29uc3RyYWludC5sZWZ0O1xuICAgICAgICAgIHZhciByaWdodCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQucmlnaHQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5yaWdodCkgOiBjb25zdHJhaW50LnJpZ2h0O1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobGVmdCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChsZWZ0KS5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGxlZnQsIFtyaWdodF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKHJpZ2h0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KHJpZ2h0KS5wdXNoKGxlZnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQocmlnaHQsIFtsZWZ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0b3AgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQudG9wKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC50b3ApIDogY29uc3RyYWludC50b3A7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5ib3R0b20pID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmJvdHRvbSkgOiBjb25zdHJhaW50LmJvdHRvbTtcbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyh0b3ApKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KHRvcCkucHVzaChib3R0b20pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KHRvcCwgW2JvdHRvbV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhib3R0b20pKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KGJvdHRvbSkucHVzaCh0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGJvdHRvbSwgW3RvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBjb21wb25lbnRzIGZyb20gYSBnaXZlbiBncmFwaCBcbiAgICAgIC8vIGFsc28gcmV0dXJucyBhbiBhcnJheSB0aGF0IGtlZXBzIHdoZXRoZXIgZWFjaCBjb21wb25lbnQgY29udGFpbnMgZml4ZWQgbm9kZVxuICAgICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudHMgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnRzKGdyYXBoLCBmaXhlZE5vZGVzKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBpc0ZpeGVkID0gW107XG4gICAgICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdID0gW107XG4gICAgICAgICAgICBpc0ZpeGVkW2NvdW50XSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICAgICAgcXVldWUucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0ucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBjb21wb25lbnRzOiBjb21wb25lbnRzLCBpc0ZpeGVkOiBpc0ZpeGVkIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzdWx0T25Ib3Jpem9udGFsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uSG9yaXpvbnRhbCwgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsKTtcbiAgICAgIHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPbkhvcml6b250YWwgPSByZXN1bHRPbkhvcml6b250YWwuaXNGaXhlZDtcbiAgICAgIHZhciByZXN1bHRPblZlcnRpY2FsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uVmVydGljYWwsIHNlbGYuZml4ZWROb2Rlc09uVmVydGljYWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuY29tcG9uZW50cztcbiAgICAgIHRoaXMuZml4ZWRDb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuaXNGaXhlZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgbm9kZSBkaXNwbGFjZW1lbnRzIGJhc2VkIG9uIGNvbnN0cmFpbnRzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS51cGRhdGVEaXNwbGFjZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHZhciBmaXhlZE5vZGUgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlRGF0YS5ub2RlSWQpO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgIHZhciBhbGxWZXJ0aWNhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFZlcnRpY2FsQWxpZ25tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudFggPSB0b3RhbERpc3BsYWNlbWVudFggLyBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgdmFyIGFsbEhvcml6b250YWxBbGlnbm1lbnRzID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZml4ZWROb2RlU2V0LmhhcyhhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WSA9IHRvdGFsRGlzcGxhY2VtZW50WSAvIGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG4gICAgICAvLyBzaHVmZmxlIGFycmF5IHRvIHJhbmRvbWl6ZSBub2RlIHByb2Nlc3Npbmcgb3JkZXJcbiAgICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbCk7XG4gICAgICAgIHRoaXMuc2h1ZmZsZSh0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICBpZiAoIXNlbGYuZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSAwO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpIC0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICBpZiAoZGlmZiA8IGNvbnN0cmFpbnQuZ2FwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50IC09IGNvbnN0cmFpbnQuZ2FwIC0gZGlmZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQubGVmdCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSArIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmJvdHRvbSkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChjb25zdHJhaW50LnRvcCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkLCBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbFtpXSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdHVhbE5vZGVzID0gdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsW2ldO1xuICAgICAgICBpZiAodGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKTtcbiAgICAgICAgICAgICAgc3VtICs9IGFjdHVhbE5vZGVzLmxlbmd0aCAqIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFjdHVhbE5vZGVzWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCArPSBhY3R1YWxOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudCA9IHN1bSAvIGNvdW50O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVMaXN0ID0gW107XG4gIHZhciBncmFwaDtcblxuICB2YXIgZ3JhcGhzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0R3JhcGhzKCk7XG4gIHZhciBzaXplID0gZ3JhcGhzLmxlbmd0aDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBncmFwaCA9IGdyYXBoc1tpXTtcblxuICAgIGdyYXBoLnVwZGF0ZUNvbm5lY3RlZCgpO1xuXG4gICAgaWYgKCFncmFwaC5pc0Nvbm5lY3RlZCkge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVMaXN0O1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2UpKSB7XG4gICAgICB2YXIgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHZhciB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBpZiAoc291cmNlID09IHRhcmdldCkge1xuICAgICAgICBlZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyhlZGdlKTtcbiAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcblxuICAgICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChzb3VyY2UuZ2V0RWRnZUxpc3RUb05vZGUodGFyZ2V0KSk7XG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRhcmdldC5nZXRFZGdlTGlzdFRvTm9kZShzb3VyY2UpKTtcblxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2VMaXN0WzBdKSkge1xuICAgICAgICAgIGlmIChlZGdlTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlZGdlTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICB2YXIgbXVsdGlFZGdlID0gZWRnZUxpc3Rba107XG4gICAgICAgICAgICAgIG11bHRpRWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKG11bHRpRWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGVkZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuc2l6ZSA9PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhZGlhbGx5ID0gZnVuY3Rpb24gKGZvcmVzdCkge1xuICAvLyBXZSB0aWxlIHRoZSB0cmVlcyB0byBhIGdyaWQgcm93IGJ5IHJvdzsgZmlyc3QgdHJlZSBzdGFydHMgYXQgKDAsMClcbiAgdmFyIGN1cnJlbnRTdGFydGluZ1BvaW50ID0gbmV3IFBvaW50KDAsIDApO1xuICB2YXIgbnVtYmVyT2ZDb2x1bW5zID0gTWF0aC5jZWlsKE1hdGguc3FydChmb3Jlc3QubGVuZ3RoKSk7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgY3VycmVudFkgPSAwO1xuICB2YXIgY3VycmVudFggPSAwO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnREKDAsIDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBudW1iZXJPZkNvbHVtbnMgPT0gMCkge1xuICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgcm93LCBtYWtlIHRoZSB4IGNvb3JkaW5hdGUgMCwgaW5jcmVtZW50IHRoZVxuICAgICAgLy8geSBjb29yZGluYXRlIHdpdGggdGhlIG1heCBoZWlnaHQgb2YgdGhlIHByZXZpb3VzIHJvd1xuICAgICAgY3VycmVudFggPSAwO1xuICAgICAgY3VycmVudFkgPSBoZWlnaHQ7XG5cbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgY3VycmVudFkgKz0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OO1xuICAgICAgfVxuXG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHZhciB0cmVlID0gZm9yZXN0W2ldO1xuXG4gICAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSB0cmVlXG4gICAgdmFyIGNlbnRlck5vZGUgPSBMYXlvdXQuZmluZENlbnRlck9mVHJlZSh0cmVlKTtcblxuICAgIC8vIFNldCB0aGUgc3RhcmluZyBwb2ludCBvZiB0aGUgbmV4dCB0cmVlXG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueCA9IGN1cnJlbnRYO1xuICAgIGN1cnJlbnRTdGFydGluZ1BvaW50LnkgPSBjdXJyZW50WTtcblxuICAgIC8vIERvIGEgcmFkaWFsIGxheW91dCBzdGFydGluZyB3aXRoIHRoZSBjZW50ZXJcbiAgICBwb2ludCA9IENvU0VMYXlvdXQucmFkaWFsTGF5b3V0KHRyZWUsIGNlbnRlck5vZGUsIGN1cnJlbnRTdGFydGluZ1BvaW50KTtcblxuICAgIGlmIChwb2ludC55ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKHBvaW50LnkpO1xuICAgIH1cblxuICAgIGN1cnJlbnRYID0gTWF0aC5mbG9vcihwb2ludC54ICsgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YIC0gcG9pbnQueCAvIDIsIExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSAtIHBvaW50LnkgLyAyKSk7XG59O1xuXG5Db1NFTGF5b3V0LnJhZGlhbExheW91dCA9IGZ1bmN0aW9uICh0cmVlLCBjZW50ZXJOb2RlLCBzdGFydGluZ1BvaW50KSB7XG4gIHZhciByYWRpYWxTZXAgPSBNYXRoLm1heCh0aGlzLm1heERpYWdvbmFsSW5UcmVlKHRyZWUpLCBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04pO1xuICBDb1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dChjZW50ZXJOb2RlLCBudWxsLCAwLCAzNTksIDAsIHJhZGlhbFNlcCk7XG4gIHZhciBib3VuZHMgPSBMR3JhcGguY2FsY3VsYXRlQm91bmRzKHRyZWUpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdYKGJvdW5kcy5nZXRNaW5YKCkpO1xuICB0cmFuc2Zvcm0uc2V0RGV2aWNlT3JnWShib3VuZHMuZ2V0TWluWSgpKTtcbiAgdHJhbnNmb3JtLnNldFdvcmxkT3JnWChzdGFydGluZ1BvaW50LngpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdZKHN0YXJ0aW5nUG9pbnQueSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICB2YXIgYm90dG9tUmlnaHQgPSBuZXcgUG9pbnREKGJvdW5kcy5nZXRNYXhYKCksIGJvdW5kcy5nZXRNYXhZKCkpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0uaW52ZXJzZVRyYW5zZm9ybVBvaW50KGJvdHRvbVJpZ2h0KTtcbn07XG5cbkNvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudE9mTm9kZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpc3RhbmNlLCByYWRpYWxTZXBhcmF0aW9uKSB7XG4gIC8vIEZpcnN0LCBwb3NpdGlvbiB0aGlzIG5vZGUgYnkgZmluZGluZyBpdHMgYW5nbGUuXG4gIHZhciBoYWxmSW50ZXJ2YWwgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlICsgMSkgLyAyO1xuXG4gIGlmIChoYWxmSW50ZXJ2YWwgPCAwKSB7XG4gICAgaGFsZkludGVydmFsICs9IDE4MDtcbiAgfVxuXG4gIHZhciBub2RlQW5nbGUgPSAoaGFsZkludGVydmFsICsgc3RhcnRBbmdsZSkgJSAzNjA7XG4gIHZhciB0ZXRhID0gbm9kZUFuZ2xlICogSUdlb21ldHJ5LlRXT19QSSAvIDM2MDtcblxuICAvLyBNYWtlIHBvbGFyIHRvIGphdmEgY29yZGluYXRlIGNvbnZlcnNpb24uXG4gIHZhciBjb3NfdGV0YSA9IE1hdGguY29zKHRldGEpO1xuICB2YXIgeF8gPSBkaXN0YW5jZSAqIE1hdGguY29zKHRldGEpO1xuICB2YXIgeV8gPSBkaXN0YW5jZSAqIE1hdGguc2luKHRldGEpO1xuXG4gIG5vZGUuc2V0Q2VudGVyKHhfLCB5Xyk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpc1xuICAvLyBmdW5jdGlvbi5cbiAgdmFyIG5laWdoYm9yRWRnZXMgPSBbXTtcbiAgbmVpZ2hib3JFZGdlcyA9IG5laWdoYm9yRWRnZXMuY29uY2F0KG5vZGUuZ2V0RWRnZXMoKSk7XG4gIHZhciBjaGlsZENvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgdmFyIGJyYW5jaENvdW50ID0gMDtcblxuICB2YXIgaW5jRWRnZXNDb3VudCA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICB2YXIgc3RhcnRJbmRleDtcblxuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzQmV0d2VlbihwYXJlbnRPZk5vZGUpO1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBlZGdlcywgcHJ1bmUgdGhlbSB1bnRpbCB0aGVyZSByZW1haW5zIG9ubHkgb25lXG4gIC8vIGVkZ2UuXG4gIHdoaWxlIChlZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgLy9uZWlnaGJvckVkZ2VzLnJlbW92ZShlZGdlcy5yZW1vdmUoMCkpO1xuICAgIHZhciB0ZW1wID0gZWRnZXNbMF07XG4gICAgZWRnZXMuc3BsaWNlKDAsIDEpO1xuICAgIHZhciBpbmRleCA9IG5laWdoYm9yRWRnZXMuaW5kZXhPZih0ZW1wKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgbmVpZ2hib3JFZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmNFZGdlc0NvdW50LS07XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgLy9hc3NlcnQgZWRnZXMubGVuZ3RoID09IDE7XG4gICAgc3RhcnRJbmRleCA9IChuZWlnaGJvckVkZ2VzLmluZGV4T2YoZWRnZXNbMF0pICsgMSkgJSBpbmNFZGdlc0NvdW50O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIHN0ZXBBbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyBjaGlsZENvdW50O1xuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBicmFuY2hDb3VudCAhPSBjaGlsZENvdW50OyBpID0gKytpICUgaW5jRWRnZXNDb3VudCkge1xuICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKG5vZGUpO1xuXG4gICAgLy8gRG9uJ3QgYmFjayB0cmF2ZXJzZSB0byByb290IG5vZGUgaW4gY3VycmVudCB0cmVlLlxuICAgIGlmIChjdXJyZW50TmVpZ2hib3IgPT0gcGFyZW50T2ZOb2RlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTdGFydEFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBicmFuY2hDb3VudCAqIHN0ZXBBbmdsZSkgJSAzNjA7XG4gICAgdmFyIGNoaWxkRW5kQW5nbGUgPSAoY2hpbGRTdGFydEFuZ2xlICsgc3RlcEFuZ2xlKSAlIDM2MDtcblxuICAgIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGN1cnJlbnROZWlnaGJvciwgbm9kZSwgY2hpbGRTdGFydEFuZ2xlLCBjaGlsZEVuZEFuZ2xlLCBkaXN0YW5jZSArIHJhZGlhbFNlcGFyYXRpb24sIHJhZGlhbFNlcGFyYXRpb24pO1xuXG4gICAgYnJhbmNoQ291bnQrKztcbiAgfVxufTtcblxuQ29TRUxheW91dC5tYXhEaWFnb25hbEluVHJlZSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gIHZhciBtYXhEaWFnb25hbCA9IEludGVnZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICB2YXIgZGlhZ29uYWwgPSBub2RlLmdldERpYWdvbmFsKCk7XG5cbiAgICBpZiAoZGlhZ29uYWwgPiBtYXhEaWFnb25hbCkge1xuICAgICAgbWF4RGlhZ29uYWwgPSBkaWFnb25hbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4RGlhZ29uYWw7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZvcm11bGEgaXMgMiB4IChsZXZlbCArIDEpIHggaWRlYWxFZGdlTGVuZ3RoXG4gIHJldHVybiAyICogKHRoaXMubGV2ZWwgKyAxKSAqIHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xufTtcblxuLy8gVGlsaW5nIG1ldGhvZHNcblxuLy8gR3JvdXAgemVybyBkZWdyZWUgbWVtYmVycyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWQsIGNyZWF0ZSBkdW1teSBwYXJlbnRzIHdoZXJlIG5lZWRlZCBhbmQgZmlsbCBtZW1iZXJHcm91cHMgYnkgdGhlaXIgZHVtbXAgcGFyZW50IGlkJ3NcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gYXJyYXkgb2YgW3BhcmVudF9pZCB4IG9uZURlZ3JlZU5vZGVfaWRdXG4gIHZhciB0ZW1wTWVtYmVyR3JvdXBzID0ge307IC8vIEEgdGVtcG9yYXJ5IG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgdGhpcy5tZW1iZXJHcm91cHMgPSB7fTsgLy8gQSBtYXAgb2YgZHVtbXkgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB0aGlzLmlkVG9EdW1teU5vZGUgPSB7fTsgLy8gQSBtYXAgb2YgaWQgdG8gZHVtbXkgbm9kZSBcblxuICB2YXIgemVyb0RlZ3JlZSA9IFtdOyAvLyBMaXN0IG9mIHplcm8gZGVncmVlIG5vZGVzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIEZpbGwgemVybyBkZWdyZWUgbGlzdFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAvLyBJZiBhIG5vZGUgaGFzIHplcm8gZGVncmVlIGFuZCBpdHMgcGFyZW50IGlzIG5vdCB0byBiZSB0aWxlZCBpZiBleGlzdHMgYWRkIHRoYXQgbm9kZSB0byB6ZXJvRGVncmVzIGxpc3RcbiAgICBpZiAodGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKG5vZGUpID09PSAwICYmIChwYXJlbnQuaWQgPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmdldFRvQmVUaWxlZChwYXJlbnQpKSkge1xuICAgICAgemVyb0RlZ3JlZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB6ZXJvRGVncmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB6ZXJvRGVncmVlW2ldOyAvLyBaZXJvIGRlZ3JlZSBub2RlIGl0c2VsZlxuICAgIHZhciBwX2lkID0gbm9kZS5nZXRQYXJlbnQoKS5pZDsgLy8gUGFyZW50IGlkXG5cbiAgICBpZiAodHlwZW9mIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPT09IFwidW5kZWZpbmVkXCIpIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSBbXTtcblxuICAgIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmNvbmNhdChub2RlKTsgLy8gUHVzaCBub2RlIHRvIHRoZSBsaXN0IGJlbG9uZ3MgdG8gaXRzIHBhcmVudCBpbiB0ZW1wTWVtYmVyR3JvdXBzXG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIG5vZGVzIGF0IGEgbGV2ZWwsIGNyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIGZvciB0aGVtXG4gIE9iamVjdC5rZXlzKHRlbXBNZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKHBfaWQpIHtcbiAgICBpZiAodGVtcE1lbWJlckdyb3Vwc1twX2lkXS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZHVtbXlDb21wb3VuZElkID0gXCJEdW1teUNvbXBvdW5kX1wiICsgcF9pZDsgLy8gVGhlIGlkIG9mIGR1bW15IGNvbXBvdW5kIHdoaWNoIHdpbGwgYmUgY3JlYXRlZCBzb29uXG4gICAgICBzZWxmLm1lbWJlckdyb3Vwc1tkdW1teUNvbXBvdW5kSWRdID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXTsgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIG1lbWJlckdyb3Vwc1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVswXS5nZXRQYXJlbnQoKTsgLy8gVGhlIHBhcmVudCBvZiB6ZXJvIGRlZ3JlZSBub2RlcyB3aWxsIGJlIHRoZSBwYXJlbnQgb2YgbmV3IGR1bW15IGNvbXBvdW5kXG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIHdpdGggY2FsY3VsYXRlZCBpZFxuICAgICAgdmFyIGR1bW15Q29tcG91bmQgPSBuZXcgQ29TRU5vZGUoc2VsZi5ncmFwaE1hbmFnZXIpO1xuICAgICAgZHVtbXlDb21wb3VuZC5pZCA9IGR1bW15Q29tcG91bmRJZDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ0xlZnQgPSBwYXJlbnQucGFkZGluZ0xlZnQgfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1JpZ2h0ID0gcGFyZW50LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nQm90dG9tID0gcGFyZW50LnBhZGRpbmdCb3R0b20gfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1RvcCA9IHBhcmVudC5wYWRkaW5nVG9wIHx8IDA7XG5cbiAgICAgIHNlbGYuaWRUb0R1bW15Tm9kZVtkdW1teUNvbXBvdW5kSWRdID0gZHVtbXlDb21wb3VuZDtcblxuICAgICAgdmFyIGR1bW15UGFyZW50R3JhcGggPSBzZWxmLmdldEdyYXBoTWFuYWdlcigpLmFkZChzZWxmLm5ld0dyYXBoKCksIGR1bW15Q29tcG91bmQpO1xuICAgICAgdmFyIHBhcmVudEdyYXBoID0gcGFyZW50LmdldENoaWxkKCk7XG5cbiAgICAgIC8vIEFkZCBkdW1teSBjb21wb3VuZCB0byBwYXJlbnQgdGhlIGdyYXBoXG4gICAgICBwYXJlbnRHcmFwaC5hZGQoZHVtbXlDb21wb3VuZCk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHplcm8gZGVncmVlIG5vZGUgaW4gdGhpcyBsZXZlbCByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IGdyYXBoIGFuZCBhZGQgaXQgdG8gdGhlIGdyYXBoIG9mIGR1bW15IHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVtpXTtcblxuICAgICAgICBwYXJlbnRHcmFwaC5yZW1vdmUobm9kZSk7XG4gICAgICAgIGR1bW15UGFyZW50R3JhcGguYWRkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhckNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkR3JhcGhNYXAgPSB7fTtcbiAgdmFyIGlkVG9Ob2RlID0ge307XG5cbiAgLy8gR2V0IGNvbXBvdW5kIG9yZGVyaW5nIGJ5IGZpbmRpbmcgdGhlIGlubmVyIG9uZSBmaXJzdFxuICB0aGlzLnBlcmZvcm1ERlNPbkNvbXBvdW5kcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb3VuZE9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZFRvTm9kZVt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIGNoaWxkR3JhcGhNYXBbdGhpcy5jb21wb3VuZE9yZGVyW2ldLmlkXSA9IFtdLmNvbmNhdCh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcblxuICAgIC8vIFJlbW92ZSBjaGlsZHJlbiBvZiBjb21wb3VuZHNcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUodGhpcy5jb21wb3VuZE9yZGVyW2ldLmdldENoaWxkKCkpO1xuICAgIHRoaXMuY29tcG91bmRPcmRlcltpXS5jaGlsZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG5cbiAgLy8gVGlsZSB0aGUgcmVtb3ZlZCBjaGlsZHJlblxuICB0aGlzLnRpbGVDb21wb3VuZE1lbWJlcnMoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xlYXJaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRaZXJvRGVncmVlUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKHRoaXMubWVtYmVyR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb21wb3VuZE5vZGUgPSBzZWxmLmlkVG9EdW1teU5vZGVbaWRdOyAvLyBHZXQgdGhlIGR1bW15IGNvbXBvdW5kXG5cbiAgICB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKHNlbGYubWVtYmVyR3JvdXBzW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICAvLyBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGR1bW15IGNvbXBvdW5kIGFzIGNhbGN1bGF0ZWRcbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclgsIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0O1xuICAgIHZhciBsYWJlbE1hcmdpblRvcCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgd3J0IGl0cyBjb21wb3VuZFxuICAgIHNlbGYuYWRqdXN0TG9jYXRpb25zKHRpbGVkUGFja1tpZF0sIGNvbXBvdW5kTm9kZS5yZWN0LngsIGNvbXBvdW5kTm9kZS5yZWN0LnksIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luLCBsYWJlbE1hcmdpbkxlZnQsIGxhYmVsTWFyZ2luVG9wKTtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb0JlVGlsZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICAvL2ZpcnN0bHkgY2hlY2sgdGhlIHByZXZpb3VzIHJlc3VsdHNcbiAgaWYgKHRoaXMudG9CZVRpbGVkW2lkXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CZVRpbGVkW2lkXTtcbiAgfVxuXG4gIC8vb25seSBjb21wb3VuZCBub2RlcyBhcmUgdG8gYmUgdGlsZWRcbiAgdmFyIGNoaWxkR3JhcGggPSBub2RlLmdldENoaWxkKCk7XG4gIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBjaGlsZEdyYXBoLmdldE5vZGVzKCk7IC8vIEdldCB0aGUgY2hpbGRyZW4gbm9kZXNcblxuICAvL2EgY29tcG91bmQgbm9kZSBpcyBub3QgdG8gYmUgdGlsZWQgaWYgYWxsIG9mIGl0cyBjb21wb3VuZCBjaGlsZHJlbiBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWUodGhlQ2hpbGQpID4gMCkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9wYXNzIHRoZSBjaGlsZHJlbiBub3QgaGF2aW5nIHRoZSBjb21wb3VuZCBzdHJ1Y3R1cmVcbiAgICBpZiAodGhlQ2hpbGQuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFt0aGVDaGlsZC5pZF0gPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRUb0JlVGlsZWQodGhlQ2hpbGQpKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b0JlVGlsZWRbaWRdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSBkZXBlbmRpbmcgb2YgaXRzIGVkZ2VzIGFuZCBpbmRlcGVuZGVudCBvZiBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzKCk7XG4gIHZhciBkZWdyZWUgPSAwO1xuXG4gIC8vIEZvciB0aGUgZWRnZXMgY29ubmVjdGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIGlmIChlZGdlLmdldFNvdXJjZSgpLmlkICE9PSBlZGdlLmdldFRhcmdldCgpLmlkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuLy8gR2V0IGRlZ3JlZSBvZiBhIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZGVncmVlID0gdGhpcy5nZXROb2RlRGVncmVlKG5vZGUpO1xuICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgZGVncmVlICs9IHRoaXMuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbihjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGRlZ3JlZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnBlcmZvcm1ERlNPbkNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb21wb3VuZE9yZGVyID0gW107XG4gIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlModGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZmlsbENvbXBleE9yZGVyQnlERlMgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlMoY2hpbGQuZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0VG9CZVRpbGVkKGNoaWxkKSkge1xuICAgICAgdGhpcy5jb21wb3VuZE9yZGVyLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIHBsYWNlcyBlYWNoIHplcm8gZGVncmVlIG1lbWJlciB3cnQgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZXMgKHRvcCBsZWZ0KS5cbiovXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5hZGp1c3RMb2NhdGlvbnMgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCB4LCB5LCBjb21wb3VuZEhvcml6b250YWxNYXJnaW4sIGNvbXBvdW5kVmVydGljYWxNYXJnaW4sIGNvbXBvdW5kTGFiZWxNYXJnaW5MZWZ0LCBjb21wb3VuZExhYmVsTWFyZ2luVG9wKSB7XG4gIHggKz0gY29tcG91bmRIb3Jpem9udGFsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQ7XG4gIHkgKz0gY29tcG91bmRWZXJ0aWNhbE1hcmdpbiArIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3A7XG5cbiAgdmFyIGxlZnQgPSB4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbaV07XG4gICAgeCA9IGxlZnQ7XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxub2RlID0gcm93W2pdO1xuXG4gICAgICBsbm9kZS5yZWN0LnggPSB4OyAvLyArIGxub2RlLnJlY3Qud2lkdGggLyAyO1xuICAgICAgbG5vZGUucmVjdC55ID0geTsgLy8gKyBsbm9kZS5yZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIHggKz0gbG5vZGUucmVjdC53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgaWYgKGxub2RlLnJlY3QuaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSBsbm9kZS5yZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB5ICs9IG1heEhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVDb21wb3VuZE1lbWJlcnMgPSBmdW5jdGlvbiAoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpbGVkTWVtYmVyUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGNoaWxkR3JhcGhNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHRoZSBjb21wb3VuZCBub2RlXG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IGlkVG9Ob2RlW2lkXTtcblxuICAgIHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKGNoaWxkR3JhcGhNYXBbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5oZWlnaHQ7XG4gICAgY29tcG91bmROb2RlLnNldENlbnRlcihzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWCwgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIGhvcml6b250YWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCB0cnVlKTtcbiAgdmFyIHZlcnRpY2FsT3JnID0gdGhpcy50aWxlTm9kZXNCeUZhdm9yaW5nRGltKG5vZGVzLCBtaW5XaWR0aCwgZmFsc2UpO1xuXG4gIHZhciBob3Jpem9udGFsUmF0aW8gPSB0aGlzLmdldE9yZ1JhdGlvKGhvcml6b250YWxPcmcpO1xuICB2YXIgdmVydGljYWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8odmVydGljYWxPcmcpO1xuICB2YXIgYmVzdE9yZztcblxuICAvLyB0aGUgYmVzdCByYXRpbyBpcyB0aGUgb25lIHRoYXQgaXMgY2xvc2VyIHRvIDEgc2luY2UgdGhlIHJhdGlvcyBhcmUgYWxyZWFkeSBub3JtYWxpemVkXG4gIC8vIGFuZCB0aGUgYmVzdCBvcmdhbml6YXRpb24gaXMgdGhlIG9uZSB0aGF0IGhhcyB0aGUgYmVzdCByYXRpb1xuICBpZiAodmVydGljYWxSYXRpbyA8IGhvcml6b250YWxSYXRpbykge1xuICAgIGJlc3RPcmcgPSB2ZXJ0aWNhbE9yZztcbiAgfSBlbHNlIHtcbiAgICBiZXN0T3JnID0gaG9yaXpvbnRhbE9yZztcbiAgfVxuXG4gIHJldHVybiBiZXN0T3JnO1xufTtcblxuLy8gZ2V0IHRoZSB3aWR0aC9oZWlnaHQgcmF0aW8gb2YgdGhlIG9yZ2FuaXphdGlvbiB0aGF0IGlzIG5vcm1hbGl6ZWQgc28gdGhhdCBpdCB3aWxsIG5vdCBiZSBsZXNzIHRoYW4gMVxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0T3JnUmF0aW8gPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIC8vIGdldCBkaW1lbnNpb25zIGFuZCBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmF0aW9cbiAgdmFyIHdpZHRoID0gb3JnYW5pemF0aW9uLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3JnYW5pemF0aW9uLmhlaWdodDtcbiAgdmFyIHJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgLy8gaWYgdGhlIGluaXRpYWwgcmF0aW8gaXMgbGVzcyB0aGVuIDEgdGhlbiBpbnZlcnNlIGl0XG4gIGlmIChyYXRpbyA8IDEpIHtcbiAgICByYXRpbyA9IDEgLyByYXRpbztcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgbm9ybWFsaXplZCByYXRpb1xuICByZXR1cm4gcmF0aW87XG59O1xuXG4vKlxuICogQ2FsY3VsYXRlcyB0aGUgaWRlYWwgd2lkdGggZm9yIHRoZSByb3dzLiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXRcbiAqIGVhY2ggbm9kZSBoYXMgdGhlIHNhbWUgc2l6ZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGlkZWFsIHJvdyB3aWR0aCB0aGF0XG4gKiBhcHByb3hpbWF0ZXMgYSBzcXVhcmUgc2hhcGVkIGNvbXBsZXggYWNjb3JkaW5nbHkuIEhvd2V2ZXIsIHNpbmNlIG5vZGVzIHdvdWxkXG4gKiBoYXZlIGRpZmZlcmVudCBzaXplcyBzb21lIHJvd3Mgd291bGQgaGF2ZSBkaWZmZXJlbnQgc2l6ZXMgYW5kIHRoZSByZXN1bHRpbmdcbiAqIHNoYXBlIHdvdWxkIG5vdCBiZSBhbiBleGFjdCBzcXVhcmUuXG4gKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbFJvd1dpZHRoID0gZnVuY3Rpb24gKG1lbWJlcnMsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAvLyBUbyBhcHByb3hpbWF0ZSBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCB3ZSBuZWVkIHRvIG1ha2UgY29tcGxleCB3aWR0aCBlcXVhbCB0byBjb21wbGV4IGhlaWdodC5cbiAgLy8gVG8gYWNoaWV2ZSB0aGlzIHdlIG5lZWQgdG8gc29sdmUgdGhlIGZvbGxvd2luZyBlcXVhdGlvbiBzeXN0ZW0gZm9yIGhjOlxuICAvLyAoeCArIGJ4KSAqIGhjIC0gYnggPSAoeSArIGJ5KSAqIHZjIC0gYnksIGhjICogdmMgPSBuXG4gIC8vIHdoZXJlIHggaXMgdGhlIGF2YXJhZ2Ugd2lkdGggb2YgdGhlIG5vZGVzLCB5IGlzIHRoZSBhdmFyYWdlIGhlaWdodCBvZiBub2Rlc1xuICAvLyBieCBhbmQgYnkgYXJlIHRoZSBidWZmZXIgc2l6ZXMgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9ucyBhY2NvcmRpbmdseSxcbiAgLy8gaGMgYW5kIHZjIGFyZSB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9uc1xuICAvLyBuIGlzIG51bWJlciBvZiBtZW1iZXJzLlxuXG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG5cbiAgLy8gbnVtYmVyIG9mIG1lbWJlcnNcbiAgdmFyIG1lbWJlcnNTaXplID0gbWVtYmVycy5sZW5ndGg7XG5cbiAgLy8gc3VtIG9mIHRoZSB3aWR0aCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxXaWR0aCA9IDA7XG5cbiAgLy8gc3VtIG9mIHRoZSBoZWlnaHQgb2YgYWxsIG1lbWJlcnNcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuICB2YXIgbWF4V2lkdGggPSAwO1xuXG4gIC8vIHRyYXZlcnNlIGFsbCBtZW1iZXJzIHRvIGNhbGN1bGF0ZSB0b3RhbCB3aWR0aCBhbmQgdG90YWwgaGVpZ2h0IGFuZCBnZXQgdGhlIG1heGltdW0gbWVtYmVycyB3aWR0aFxuICBtZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0b3RhbFdpZHRoICs9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB0b3RhbEhlaWdodCArPSBub2RlLmdldEhlaWdodCgpO1xuXG4gICAgaWYgKG5vZGUuZ2V0V2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICBtYXhXaWR0aCA9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF2ZXJhZ2Ugd2lkdGggb2YgdGhlIG1lbWJlcnNcbiAgdmFyIGF2ZXJhZ2VXaWR0aCA9IHRvdGFsV2lkdGggLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBhdmVyYWdlIGhlaWdodCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC8gbWVtYmVyc1NpemU7XG5cbiAgLy8gc29sdmluZyB0aGUgaW5pdGlhbCBlcXVhdGlvbiBzeXN0ZW0gZm9yIHRoZSBoYyB5aWVsZHMgdGhlIGZvbGxvd2luZyBzZWNvbmQgZGVncmVlIGVxdWF0aW9uOlxuICAvLyBoY14yICogKHgrYngpICsgaGMgKiAoYnkgLSBieCkgLSBuICogKHkgKyBieSkgPSAwXG5cbiAgLy8gdGhlIGRlbHRhIHZhbHVlIHRvIHNvbHZlIHRoZSBlcXVhdGlvbiBhYm92ZSBmb3IgaGNcbiAgdmFyIGRlbHRhID0gTWF0aC5wb3codmVydGljYWxQYWRkaW5nIC0gaG9yaXpvbnRhbFBhZGRpbmcsIDIpICsgNCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgKiAoYXZlcmFnZUhlaWdodCArIHZlcnRpY2FsUGFkZGluZykgKiBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2ZSB0aGUgZXF1YXRpb24gdXNpbmcgZGVsdGEgdmFsdWUgdG8gY2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGNvdW50XG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIGFuIGlkZWFsIHJvd1xuICB2YXIgaG9yaXpvbnRhbENvdW50RG91YmxlID0gKGhvcml6b250YWxQYWRkaW5nIC0gdmVydGljYWxQYWRkaW5nICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykpO1xuICAvLyByb3VuZCB0aGUgY2FsY3VsYXRlZCBob3Jpem9udGFsIGNvdW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIHRoZSBmYXZvcmVkIGRpbWVuc2lvblxuICB2YXIgaG9yaXpvbnRhbENvdW50O1xuXG4gIGlmIChmYXZvckhvcml6b250YWxEaW0pIHtcbiAgICBob3Jpem9udGFsQ291bnQgPSBNYXRoLmNlaWwoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgICAvLyBpZiBob3Jpem9udGFsQ291bnQgY291bnQgaXMgbm90IGEgZmxvYXQgdmFsdWUgdGhlbiBib3RoIG9mIHJvdW5kaW5nIHRvIGZsb29yIGFuZCBjZWlsXG4gICAgLy8gd2lsbCB5aWVsZCB0aGUgc2FtZSB2YWx1ZXMuIEluc3RlYWQgb2YgcmVwZWF0aW5nIHRoZSBzYW1lIGNhbGN1bGF0aW9uIHRyeSBnb2luZyB1cFxuICAgIC8vIHdoaWxlIGZhdm9yaW5nIGhvcml6b250YWwgZGltZW5zaW9uIGluIHN1Y2ggY2FzZXNcbiAgICBpZiAoaG9yaXpvbnRhbENvdW50ID09IGhvcml6b250YWxDb3VudERvdWJsZSkge1xuICAgICAgaG9yaXpvbnRhbENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgfVxuXG4gIC8vIGlkZWFsIHdpZHRoIHRvIGJlIGNhbGN1bGF0ZWRcbiAgdmFyIGlkZWFsV2lkdGggPSBob3Jpem9udGFsQ291bnQgKiAoYXZlcmFnZVdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcpIC0gaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gaWYgbWF4IHdpZHRoIGlzIGJpZ2dlciB0aGFuIGNhbGN1bGF0ZWQgaWRlYWwgd2lkdGggcmVzZXQgaWRlYWwgd2lkdGggdG8gaXRcbiAgaWYgKG1heFdpZHRoID4gaWRlYWxXaWR0aCkge1xuICAgIGlkZWFsV2lkdGggPSBtYXhXaWR0aDtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbGVmdC1yaWdodCBtYXJnaW5zIHRvIHRoZSBpZGVhbCByb3cgd2lkdGhcbiAgaWRlYWxXaWR0aCArPSBob3Jpem9udGFsUGFkZGluZyAqIDI7XG5cbiAgLy8gcmV0dXJuIHRoZSBpZGVhbCByb3cgd2lkdGgxXG4gIHJldHVybiBpZGVhbFdpZHRoO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzQnlGYXZvcmluZ0RpbSA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICB2YXIgdmVydGljYWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTDtcbiAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMO1xuICB2YXIgdGlsaW5nQ29tcGFyZUJ5ID0gQ29TRUNvbnN0YW50cy5USUxJTkdfQ09NUEFSRV9CWTtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZyxcbiAgICBjZW50ZXJYOiAwLFxuICAgIGNlbnRlclk6IDBcbiAgfTtcblxuICBpZiAodGlsaW5nQ29tcGFyZUJ5KSB7XG4gICAgb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGggPSB0aGlzLmNhbGNJZGVhbFJvd1dpZHRoKG5vZGVzLCBmYXZvckhvcml6b250YWxEaW0pO1xuICB9XG5cbiAgdmFyIGdldE5vZGVBcmVhID0gZnVuY3Rpb24gZ2V0Tm9kZUFyZWEobikge1xuICAgIHJldHVybiBuLnJlY3Qud2lkdGggKiBuLnJlY3QuaGVpZ2h0O1xuICB9O1xuXG4gIHZhciBhcmVhQ29tcGFyZUZjbiA9IGZ1bmN0aW9uIGFyZWFDb21wYXJlRmNuKG4xLCBuMikge1xuICAgIHJldHVybiBnZXROb2RlQXJlYShuMikgLSBnZXROb2RlQXJlYShuMSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgbm9kZXMgaW4gZGVzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICB2YXIgY21wQnkgPSBhcmVhQ29tcGFyZUZjbjtcbiAgICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgIGNtcEJ5ID0gdGlsaW5nQ29tcGFyZUJ5O1xuICAgICAgcmV0dXJuIGNtcEJ5KG4xLmlkLCBuMi5pZCk7XG4gICAgfVxuICAgIHJldHVybiBjbXBCeShuMSwgbjIpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG9yZ2FuaXphdGlvbiAtPiBjYWxjdWxhdGUgY29tcG91bmQgY2VudGVyXG4gIHZhciBzdW1DZW50ZXJYID0gMDtcbiAgdmFyIHN1bUNlbnRlclkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBzdW1DZW50ZXJYICs9IGxOb2RlLmdldENlbnRlclgoKTtcbiAgICBzdW1DZW50ZXJZICs9IGxOb2RlLmdldENlbnRlclkoKTtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5jZW50ZXJYID0gc3VtQ2VudGVyWCAvIG5vZGVzLmxlbmd0aDtcbiAgb3JnYW5pemF0aW9uLmNlbnRlclkgPSBzdW1DZW50ZXJZIC8gbm9kZXMubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdmFyIHJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgICAgcm93SW5kZXggPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCwgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBvcmdhbml6YXRpb247XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbnNlcnROb2RlVG9Sb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBub2RlLCByb3dJbmRleCwgbWluV2lkdGgpIHtcbiAgdmFyIG1pbkNvbXBvdW5kU2l6ZSA9IG1pbldpZHRoO1xuXG4gIC8vIEFkZCBuZXcgcm93IGlmIG5lZWRlZFxuICBpZiAocm93SW5kZXggPT0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoKSB7XG4gICAgdmFyIHNlY29uZERpbWVuc2lvbiA9IFtdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd3MucHVzaChzZWNvbmREaW1lbnNpb24pO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5wdXNoKG1pbkNvbXBvdW5kU2l6ZSk7XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodC5wdXNoKDApO1xuICB9XG5cbiAgLy8gVXBkYXRlIHJvdyB3aWR0aFxuICB2YXIgdyA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gKyBub2RlLnJlY3Qud2lkdGg7XG5cbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dzW3Jvd0luZGV4XS5sZW5ndGggPiAwKSB7XG4gICAgdyArPSBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG4gIH1cblxuICBvcmdhbml6YXRpb24ucm93V2lkdGhbcm93SW5kZXhdID0gdztcbiAgLy8gVXBkYXRlIGNvbXBvdW5kIHdpZHRoXG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCB3KSB7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gdztcbiAgfVxuXG4gIC8vIFVwZGF0ZSBoZWlnaHRcbiAgdmFyIGggPSBub2RlLnJlY3QuaGVpZ2h0O1xuICBpZiAocm93SW5kZXggPiAwKSBoICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgdmFyIGV4dHJhSGVpZ2h0ID0gMDtcbiAgaWYgKGggPiBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSkge1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF07XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gPSBoO1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gLSBleHRyYUhlaWdodDtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZXh0cmFIZWlnaHQ7XG5cbiAgLy8gSW5zZXJ0IG5vZGVcbiAgb3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLnB1c2gobm9kZSk7XG59O1xuXG4vL1NjYW5zIHRoZSByb3dzIG9mIGFuIG9yZ2FuaXphdGlvbiBhbmQgcmV0dXJucyB0aGUgb25lIHdpdGggdGhlIG1pbiB3aWR0aFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0U2hvcnRlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPCBtaW4pIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWF4IHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRMb25nZXN0Um93SW5kZXggPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciByID0gLTE7XG4gIHZhciBtYXggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPiBtYXgpIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWF4ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGFkZGluZyBleHRyYSB3aWR0aCB0byB0aGUgb3JnYW5pemF0aW9uIHZpb2xhdGVzXG4qIHRoZSBhc3BlY3QgcmF0aW8oMSkgb3Igbm90LlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbkFkZEhvcml6b250YWwgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBleHRyYVdpZHRoLCBleHRyYUhlaWdodCkge1xuXG4gIC8vIGlmIHRoZXJlIGlzIGFuIGlkZWFsIHJvdyB3aWR0aCBzcGVjaWZpZWQgdXNlIGl0IGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIGFzcGVjdCByYXRpb1xuICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICB2YXIgbGFzdFJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICB2YXIgbGFzdFJvd1dpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RSb3dJbmRleF07XG5cbiAgICAvLyBjaGVjayBhbmQgcmV0dXJuIGlmIGlkZWFsIHJvdyB3aWR0aCB3aWxsIGJlIGV4Y2VlZCBpZiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcm93XG4gICAgcmV0dXJuIGxhc3RSb3dXaWR0aCArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgPD0gb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGg7XG4gIH1cblxuICB2YXIgc3JpID0gdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG5cbiAgaWYgKHNyaSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbc3JpXTtcblxuICBpZiAobWluICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nICsgZXh0cmFXaWR0aCA8PSBvcmdhbml6YXRpb24ud2lkdGgpIHJldHVybiB0cnVlO1xuXG4gIHZhciBoRGlmZiA9IDA7XG5cbiAgLy8gQWRkaW5nIHRvIGFuIGV4aXN0aW5nIHJvd1xuICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldIDwgZXh0cmFIZWlnaHQpIHtcbiAgICBpZiAoc3JpID4gMCkgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcgLSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV07XG4gIH1cblxuICB2YXIgYWRkX3RvX3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG1pbiA+PSBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gKG1pbiArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpO1xuICB9IGVsc2Uge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIC8vIEFkZGluZyBhIG5ldyByb3cgZm9yIHRoaXMgbm9kZVxuICBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgdmFyIGFkZF9uZXdfcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIDwgZXh0cmFXaWR0aCkge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBleHRyYVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICBpZiAoYWRkX25ld19yb3dfcmF0aW8gPCAxKSBhZGRfbmV3X3Jvd19yYXRpbyA9IDEgLyBhZGRfbmV3X3Jvd19yYXRpbztcblxuICBpZiAoYWRkX3RvX3Jvd19yYXRpbyA8IDEpIGFkZF90b19yb3dfcmF0aW8gPSAxIC8gYWRkX3RvX3Jvd19yYXRpbztcblxuICByZXR1cm4gYWRkX3RvX3Jvd19yYXRpbyA8IGFkZF9uZXdfcm93X3JhdGlvO1xufTtcblxuLy9JZiBtb3ZpbmcgdGhlIGxhc3Qgbm9kZSBmcm9tIHRoZSBsb25nZXN0IHJvdyBhbmQgYWRkaW5nIGl0IHRvIHRoZSBsYXN0XG4vL3JvdyBtYWtlcyB0aGUgYm91bmRpbmcgYm94IHNtYWxsZXIsIGRvIGl0LlxuQ29TRUxheW91dC5wcm90b3R5cGUuc2hpZnRUb0xhc3RSb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciBsb25nZXN0ID0gdGhpcy5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgdmFyIGxhc3QgPSBvcmdhbml6YXRpb24ucm93V2lkdGgubGVuZ3RoIC0gMTtcbiAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2xvbmdlc3RdO1xuICB2YXIgbm9kZSA9IHJvd1tyb3cubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGRpZmYgPSBub2RlLndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBvbiB0aGUgbGFzdCByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA+IGRpZmYgJiYgbG9uZ2VzdCAhPSBsYXN0KSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvbmdlc3Qgcm93XG4gICAgcm93LnNwbGljZSgtMSwgMSk7XG5cbiAgICAvLyBQdXNoIGl0IHRvIHRoZSBsYXN0IHJvd1xuICAgIG9yZ2FuaXphdGlvbi5yb3dzW2xhc3RdLnB1c2gobm9kZSk7XG5cbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gLSBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSArIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2luc3RhbmNlLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pXTtcblxuICAgIC8vIFVwZGF0ZSBoZWlnaHRzIG9mIHRoZSBvcmdhbml6YXRpb25cbiAgICB2YXIgbWF4SGVpZ2h0ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJvd1tpXS5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IHJvd1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChsb25nZXN0ID4gMCkgbWF4SGVpZ2h0ICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgcHJldlRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG5cbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdID0gbWF4SGVpZ2h0O1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdIDwgbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nKSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdID0gbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIGZpbmFsVG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcbiAgICBvcmdhbml6YXRpb24uaGVpZ2h0ICs9IGZpbmFsVG90YWwgLSBwcmV2VG90YWw7XG5cbiAgICB0aGlzLnNoaWZ0VG9MYXN0Um93KG9yZ2FuaXphdGlvbik7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1ByZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIC8vIEZpbmQgemVybyBkZWdyZWUgbm9kZXMgYW5kIGNyZWF0ZSBhIGNvbXBvdW5kIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5ncm91cFplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgLy8gVGlsZSBhbmQgY2xlYXIgY2hpbGRyZW4gb2YgZWFjaCBjb21wb3VuZFxuICAgIHRoaXMuY2xlYXJDb21wb3VuZHMoKTtcbiAgICAvLyBTZXBhcmF0ZWx5IHRpbGUgYW5kIGNsZWFyIHplcm8gZGVncmVlIG5vZGVzIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5jbGVhclplcm9EZWdyZWVNZW1iZXJzKCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICB0aGlzLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIHRoaXMucmVwb3B1bGF0ZUNvbXBvdW5kcygpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogVHJlZSBSZWR1Y3Rpb24gbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlZHVjZSB0cmVlcyBcbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlZHVjZVRyZWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgdmFyIGNvbnRhaW5zTGVhZiA9IHRydWU7XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChjb250YWluc0xlYWYpIHtcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcFRlbXAgPSBbXTtcbiAgICBjb250YWluc0xlYWYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldEVkZ2VzKCkubGVuZ3RoID09IDEgJiYgIW5vZGUuZ2V0RWRnZXMoKVswXS5pc0ludGVyR3JhcGggJiYgbm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgICAgICAgIHZhciBvdGhlckVuZCA9IG5vZGUuZ2V0RWRnZXMoKVswXS5nZXRPdGhlckVuZChub2RlKTtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IG5ldyBEaW1lbnNpb25EKG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWCgpLCBub2RlLmdldENlbnRlclkoKSAtIG90aGVyRW5kLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpLCByZWxhdGl2ZVBvc2l0aW9uXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zTGVhZiA9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwLnB1c2gocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0T3duZXIoKS5yZW1vdmUocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJ1bmVkTm9kZXNBbGwucHVzaChwcnVuZWROb2Rlc0luU3RlcCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBwcnVuZWROb2Rlc0FsbDtcbn07XG5cbi8vIEdyb3cgdHJlZSBvbmUgc3RlcCBcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3dUcmVlID0gZnVuY3Rpb24gKHBydW5lZE5vZGVzQWxsKSB7XG4gIHZhciBsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwID0gcHJ1bmVkTm9kZXNBbGwubGVuZ3RoO1xuICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbFtsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwIC0gMV07XG5cbiAgdmFyIG5vZGVEYXRhO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBydW5lZE5vZGVzSW5TdGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZURhdGEgPSBwcnVuZWROb2Rlc0luU3RlcFtpXTtcblxuICAgIHRoaXMuZmluZFBsYWNlZm9yUHJ1bmVkTm9kZShub2RlRGF0YSk7XG5cbiAgICBub2RlRGF0YVsyXS5hZGQobm9kZURhdGFbMF0pO1xuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVsxXSwgbm9kZURhdGFbMV0uc291cmNlLCBub2RlRGF0YVsxXS50YXJnZXQpO1xuICB9XG5cbiAgcHJ1bmVkTm9kZXNBbGwuc3BsaWNlKHBydW5lZE5vZGVzQWxsLmxlbmd0aCAtIDEsIDEpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbn07XG5cbi8vIEZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb24gdG8gcmVwbGFjZSBwcnVuZWQgbm9kZSwgdGhpcyBtZXRob2QgY2FuIGJlIGltcHJvdmVkXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maW5kUGxhY2Vmb3JQcnVuZWROb2RlID0gZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG5cbiAgdmFyIGdyaWRGb3JQcnVuZWROb2RlO1xuICB2YXIgbm9kZVRvQ29ubmVjdDtcbiAgdmFyIHBydW5lZE5vZGUgPSBub2RlRGF0YVswXTtcbiAgaWYgKHBydW5lZE5vZGUgPT0gbm9kZURhdGFbMV0uc291cmNlKSB7XG4gICAgbm9kZVRvQ29ubmVjdCA9IG5vZGVEYXRhWzFdLnRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0uc291cmNlO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZURhdGFbM10uZ2V0V2lkdGgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlRGF0YVszXS5nZXRIZWlnaHQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgICB2YXIgZmluaXNoR3JpZFggPSBub2RlVG9Db25uZWN0LmZpbmlzaFg7XG4gICAgdmFyIHN0YXJ0R3JpZFkgPSBub2RlVG9Db25uZWN0LnN0YXJ0WTtcbiAgICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgICB2YXIgdXBOb2RlQ291bnQgPSAwO1xuICAgIHZhciBkb3duTm9kZUNvdW50ID0gMDtcbiAgICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICAgIHZhciBsZWZ0Tm9kZUNvdW50ID0gMDtcbiAgICB2YXIgY29udHJvbFJlZ2lvbnMgPSBbdXBOb2RlQ291bnQsIHJpZ2h0Tm9kZUNvdW50LCBkb3duTm9kZUNvdW50LCBsZWZ0Tm9kZUNvdW50XTtcblxuICAgIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFg7IGkgPD0gZmluaXNoR3JpZFg7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1swXSArPSB0aGlzLmdyaWRbaV1bc3RhcnRHcmlkWSAtIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmluaXNoR3JpZFggPCB0aGlzLmdyaWQubGVuZ3RoIC0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1sxXSArPSB0aGlzLmdyaWRbZmluaXNoR3JpZFggKyAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbZmluaXNoR3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWSA8IHRoaXMuZ3JpZFswXS5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzNdICs9IHRoaXMuZ3JpZFtzdGFydEdyaWRYIC0gMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW3N0YXJ0R3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluQ291bnQ7XG4gICAgdmFyIG1pbkluZGV4O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29udHJvbFJlZ2lvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgICBtaW4gPSBjb250cm9sUmVnaW9uc1tqXTtcbiAgICAgICAgbWluQ291bnQgPSAxO1xuICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zW2pdID09IG1pbikge1xuICAgICAgICBtaW5Db3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW5Db3VudCA9PSAzICYmIG1pbiA9PSAwKSB7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpO1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCkge1xuICAgICAgICA7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1pbkNvdW50ID09IDQgJiYgbWluID09IDApIHtcbiAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KTtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IG1pbkluZGV4O1xuICAgIH1cblxuICAgIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAwKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgLSBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSArIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH0gZWxzZSBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMikge1xuICAgICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgLSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC0gcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dE5vZGU7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG4gIC8vIHRoaXMgY2hlY2sgaXMgZm9yIGNvbXBvdW5kIG5vZGVzIHRoYXQgY29udGFpbiBmaXhlZCBub2Rlc1xuICBpZiAodGhpcy5nZXRDaGlsZCgpICE9IG51bGwgJiYgdGhpcy5maXhlZE5vZGVXZWlnaHQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVggKyB0aGlzLnJlcHVsc2lvbkZvcmNlWCArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVgpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VZICsgdGhpcy5yZXB1bHNpb25Gb3JjZVkgKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZKSAvIHRoaXMuZml4ZWROb2RlV2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICBpZiAodGhpcy5jaGlsZCAmJiB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbih0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFggKz0gZFg7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFkgKz0gZFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbihkWCwgZFkpO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBhIHNpbXBsZSBub2RlIG9yIGFuIGVtcHR5IGNvbXBvdW5kIG5vZGUsIG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCB8fCB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG5cbiAgICBsYXlvdXQudG90YWxEaXNwbGFjZW1lbnQgKz0gTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSArIE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDYpO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcbnZhciBNYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5TVkQ7XG5cbmZ1bmN0aW9uIENvbnN0cmFpbnRIYW5kbGVyKCkge31cblxuQ29uc3RyYWludEhhbmRsZXIuaGFuZGxlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAobGF5b3V0KSB7XG4gIC8vICBsZXQgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG5cbiAgLy8gZ2V0IGNvbnN0cmFpbnRzIGZyb20gbGF5b3V0XG4gIHZhciBjb25zdHJhaW50cyA9IHt9O1xuICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQ7XG4gIGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludDtcbiAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcblxuICB2YXIgaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBub2RlSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIHhDb29yZHMgPSBbXTtcbiAgdmFyIHlDb29yZHMgPSBbXTtcblxuICB2YXIgYWxsTm9kZXMgPSBsYXlvdXQuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gZmlsbCBpbmRleCBtYXAgYW5kIGNvb3JkaW5hdGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgbm9kZUluZGV4ZXMuc2V0KG5vZGUuaWQsIGluZGV4KyspO1xuICAgICAgeENvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWCgpKTtcbiAgICAgIHlDb29yZHMucHVzaChub2RlLmdldENlbnRlclkoKSk7XG4gICAgICBpZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgZXhpc3RzIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50IHdpdGhvdXQgZ2FwIHZhbHVlLCBzZXQgaXQgdG8gZGVmYXVsdCBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoIWNvbnN0cmFpbnQuZ2FwICYmIGNvbnN0cmFpbnQuZ2FwICE9IDApIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIGNvbnN0cmFpbnQuZ2FwID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQubGVmdCkuZ2V0V2lkdGgoKSAvIDIgKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5yaWdodCkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC50b3ApLmdldEhlaWdodCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LmJvdHRvbSkuZ2V0SGVpZ2h0KCkgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiBhdXhpbGlhcnkgZnVuY3Rpb25zICovXG5cbiAgLy8gY2FsY3VsYXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gcG9zaXRpb24gb2JqZWN0c1xuICB2YXIgY2FsY3VsYXRlUG9zaXRpb25EaWZmID0gZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvczEsIHBvczIpIHtcbiAgICByZXR1cm4geyB4OiBwb3MxLnggLSBwb3MyLngsIHk6IHBvczEueSAtIHBvczIueSB9O1xuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBub2Rlc1xuICB2YXIgY2FsY3VsYXRlQXZnUG9zaXRpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVBdmdQb3NpdGlvbihub2RlSWRTZXQpIHtcbiAgICB2YXIgeFBvc1N1bSA9IDA7XG4gICAgdmFyIHlQb3NTdW0gPSAwO1xuICAgIG5vZGVJZFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgIHhQb3NTdW0gKz0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICB5UG9zU3VtICs9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgeDogeFBvc1N1bSAvIG5vZGVJZFNldC5zaXplLCB5OiB5UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUgfTtcbiAgfTtcblxuICAvLyBmaW5kIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciB0aGUgbm9kZXMgaW4gYSBnaXZlbiBncmFwaCBhY2NvcmRpbmcgdG8gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyB0YWtlcyB0aGUgZml4ZWQgbm9kZXMgYW5kIGFsaWdubWVudCBjb25zdHJhaW50cyBpbnRvIGFjY291bnRcbiAgLy8gZ3JhcGg6IGRhZyB0byBiZSBldmFsdWF0ZWQsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLCBcbiAgLy8gZml4ZWROb2Rlczogc2V0IG9mIGZpeGVkIG5vZGVzIHRvIGNvbnNpZGVyIGR1cmluZyBldmFsdWF0aW9uLCBkdW1teVBvc2l0aW9uczogYXBwcm9wcmlhdGUgY29vcmRpbmF0ZXMgb2YgdGhlIGR1bW15IG5vZGVzICBcbiAgdmFyIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQgPSBmdW5jdGlvbiBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGdyYXBoLCBkaXJlY3Rpb24sIGZpeGVkTm9kZXMsIGR1bW15UG9zaXRpb25zLCBjb21wb25lbnRTb3VyY2VzKSB7XG5cbiAgICAvLyBmaW5kIHVuaW9uIG9mIHR3byBzZXRzXG4gICAgZnVuY3Rpb24gc2V0VW5pb24oc2V0QSwgc2V0Qikge1xuICAgICAgdmFyIHVuaW9uID0gbmV3IFNldChzZXRBKTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBzZXRCW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlbGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB1bmlvbi5hZGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pb247XG4gICAgfVxuXG4gICAgLy8gZmluZCBpbmRlZ3JlZSBjb3VudCBmb3IgZWFjaCBub2RlXG4gICAgdmFyIGluRGVncmVlcyA9IG5ldyBNYXAoKTtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGluRGVncmVlcy5zZXQoa2V5LCAwKTtcbiAgICB9KTtcbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICBpbkRlZ3JlZXMuc2V0KGFkamFjZW50LmlkLCBpbkRlZ3JlZXMuZ2V0KGFkamFjZW50LmlkKSArIDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwb3NpdGlvbiBmb3IgZWFjaCBub2RlXG4gICAgdmFyIHBhc3RNYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwcmVkZWNlc3NvcnMocGFzdCkgb2YgYSBub2RlXG4gICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICBpbkRlZ3JlZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgcXVldWUucHVzaChrZXkpO1xuICAgICAgICBpZiAoIWZpeGVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb25NYXAuc2V0KGtleSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgIHBhc3RNYXAuc2V0KGtleSwgbmV3IFNldChba2V5XSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWxpZ24gc291cmNlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBlbmZvcmNlbWVudCBwaGFzZVxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICBjb21wb25lbnRTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgZml4ZWRJZHMgPSBbXTtcbiAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBmaXhlZElkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpeGVkSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGZpeGVkSWRzLmZvckVhY2goZnVuY3Rpb24gKGZpeGVkSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChmaXhlZElkLCBub2RlSW5kZXhlcy5oYXMoZml4ZWRJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChmaXhlZElkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoZml4ZWRJZCkpO1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBwb3NpdGlvbk1hcC5nZXQoZml4ZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGZpeGVkSWRzLmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAoIWZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5vZGVJZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9wb3NpdGlvbiArPSBub2RlSW5kZXhlcy5oYXMobm9kZUlkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gX3Bvc2l0aW9uIC8gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBfcG9zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlc1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uTWFwLmdldChuZWlnaGJvci5pZCkgPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMgJiYgZml4ZWROb2Rlcy5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBub2RlSW5kZXhlcy5oYXMobmVpZ2hib3IuaWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobmVpZ2hib3IuaWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIGZpeGVkUG9zaXRpb24pOyAvLyBUT0RPOiBtYXkgZG8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgaWYgKGZpeGVkUG9zaXRpb24gPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gcG9zaXRpb25NYXAuZ2V0KGN1cnJlbnROb2RlKSArIG5laWdoYm9yLmdhcCAtIGZpeGVkUG9zaXRpb247XG4gICAgICAgICAgICAgIHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQobm9kZUlkKSAtIGRpZmYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5laWdoYm9yLmlkLCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5EZWdyZWVzLnNldChuZWlnaGJvci5pZCwgaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgLSAxKTtcbiAgICAgICAgaWYgKGluRGVncmVlcy5nZXQobmVpZ2hib3IuaWQpID09IDApIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZml4ZWROb2Rlcykge1xuICAgICAgICAgIHBhc3RNYXAuc2V0KG5laWdoYm9yLmlkLCBzZXRVbmlvbihwYXN0TWFwLmdldChjdXJyZW50Tm9kZSksIHBhc3RNYXAuZ2V0KG5laWdoYm9yLmlkKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIC8vIHJlYWRqdXN0IHBvc2l0aW9uIG9mIHRoZSBub2RlcyBhZnRlciBlbmZvcmNlbWVudFxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICAgIHZhciBzaW5rTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgc2lua05vZGVzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9jb21wb25lbnRzID0gW107XG4gICAgICBwYXN0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHNpbmtOb2Rlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBpc0ZpeGVkQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNGaXhlZENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGlzRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBleGlzdEF0ID0gdm9pZCAwO1xuICAgICAgICAgICAgX2NvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmhhcyhbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZhbHVlKSlbMF0pKSB7XG4gICAgICAgICAgICAgICAgaXNFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhpc3RBdCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNFeGlzdCkge1xuICAgICAgICAgICAgICBfY29tcG9uZW50cy5wdXNoKG5ldyBTZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb25lbnRzW2V4aXN0QXRdLmFkZChlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBtaW5CZWZvcmUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBtaW5BZnRlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEJlZm9yZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEFmdGVyID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBwb3NCZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3NBZnRlciA9IHBvc2l0aW9uTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKHBvc0JlZm9yZSA8IG1pbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtaW5CZWZvcmUgPSBwb3NCZWZvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlID4gbWF4QmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1heEJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA8IG1pbkFmdGVyKSB7XG4gICAgICAgICAgICAgIG1pbkFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQWZ0ZXIgPiBtYXhBZnRlcikge1xuICAgICAgICAgICAgICBtYXhBZnRlciA9IHBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmYgPSAobWluQmVmb3JlICsgbWF4QmVmb3JlKSAvIDIgLSAobWluQWZ0ZXIgKyBtYXhBZnRlcikgLyAyO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoX25vZGVJZCwgcG9zaXRpb25NYXAuZ2V0KF9ub2RlSWQpICsgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbk1hcDtcbiAgfTtcblxuICAvLyBmaW5kIHRyYW5zZm9ybWF0aW9uIGJhc2VkIG9uIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGlmIHRoZXJlIGFyZSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gb3IgaWYgdGhlcmUgYXJlIG9ubHkgcmVsLiBwbGFjZW1lbnQgY29udHJhaW50cyB3aGVyZSB0aGUgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3Qgc3VmZmljaWVudGx5IGxhcmdlXG4gIHZhciBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMpIHtcbiAgICAvLyB2YXJpYWJsZXMgdG8gY291bnQgdm90ZXNcbiAgICB2YXIgcmVmbGVjdE9uWSA9IDAsXG4gICAgICAgIG5vdFJlZmxlY3RPblkgPSAwO1xuICAgIHZhciByZWZsZWN0T25YID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWCA9IDA7XG5cbiAgICByZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC5sZWZ0KV0gLSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LnJpZ2h0KV0gPj0gMCA/IHJlZmxlY3RPblkrKyA6IG5vdFJlZmxlY3RPblkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQudG9wKV0gLSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmJvdHRvbSldID49IDAgPyByZWZsZWN0T25YKysgOiBub3RSZWZsZWN0T25YKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkgJiYgcmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlSW5kZXhlcy5zaXplOyBfaSsrKSB7XG4gICAgICAgIHhDb29yZHNbX2ldID0gLTEgKiB4Q29vcmRzW19pXTtcbiAgICAgICAgeUNvb3Jkc1tfaV0gPSAtMSAqIHlDb29yZHNbX2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRleGVzLnNpemU7IF9pMisrKSB7XG4gICAgICAgIHhDb29yZHNbX2kyXSA9IC0xICogeENvb3Jkc1tfaTJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRleGVzLnNpemU7IF9pMysrKSB7XG4gICAgICAgIHlDb29yZHNbX2kzXSA9IC0xICogeUNvb3Jkc1tfaTNdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiB1bmRpcmVjdGVkIGdyYXBoXG4gIHZhciBmaW5kQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnRzKGdyYXBoKSB7XG4gICAgLy8gZmluZCB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHMgaW4gZGFnXG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgdmFyIF9jdXJyZW50Tm9kZSA9IGtleTtcbiAgICAgICAgcXVldWUucHVzaChfY3VycmVudE5vZGUpO1xuICAgICAgICB2aXNpdGVkLmFkZChfY3VycmVudE5vZGUpO1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKF9jdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgX2N1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KF9jdXJyZW50Tm9kZSk7XG4gICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yLmlkKSkge1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9O1xuXG4gIC8vIHJldHVybiB1bmRpcmVjdGVkIHZlcnNpb24gb2YgZ2l2ZW4gZGFnXG4gIHZhciBkYWdUb1VuZGlyZWN0ZWQgPSBmdW5jdGlvbiBkYWdUb1VuZGlyZWN0ZWQoZGFnKSB7XG4gICAgdmFyIHVuZGlyZWN0ZWQgPSBuZXcgTWFwKCk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdW5kaXJlY3RlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoa2V5KS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1bmRpcmVjdGVkO1xuICB9O1xuXG4gIC8vIHJldHVybiByZXZlcnNlZCAoZGlyZWN0aW9ucyBpbnZlcnRlZCkgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvUmV2ZXJzZWQgPSBmdW5jdGlvbiBkYWdUb1JldmVyc2VkKGRhZykge1xuICAgIHZhciByZXZlcnNlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXZlcnNlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgcmV2ZXJzZWQuZ2V0KGFkamFjZW50LmlkKS5wdXNoKHsgaWQ6IGtleSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gIH07XG5cbiAgLyoqKiogIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBpbml0aWFsIGRyYWZ0IGxheW91dCB0byBiZXR0ZXIgYWxpZ24gd2l0aCBjb25zdHJhaW5lZCBub2RlcyAqKioqL1xuICAvLyBzb2x2ZSB0aGUgT3J0aG9nb25hbCBQcm9jcnVzdGVhbiBQcm9ibGVtIHRvIHJvdGF0ZSBhbmQvb3IgcmVmbGVjdCBpbml0aWFsIGRyYWZ0IGxheW91dFxuICAvLyBoZXJlIHdlIGZvbGxvdyB0aGUgc29sdXRpb24gaW4gQ2hhcHRlciAyMC4yIG9mIEJvcmcsIEkuICYgR3JvZW5lbiwgUC4gKDIwMDUpIE1vZGVybiBNdWx0aWRpbWVuc2lvbmFsIFNjYWxpbmc6IFRoZW9yeSBhbmQgQXBwbGljYXRpb25zIFxuXG4gIC8qIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9ucyAqL1xuXG4gIHZhciB0YXJnZXRNYXRyaXggPSBbXTsgLy8gQSAtIHRhcmdldCBjb25maWd1cmF0aW9uXG4gIHZhciBzb3VyY2VNYXRyaXggPSBbXTsgLy8gQiAtIHNvdXJjZSBjb25maWd1cmF0aW9uIFxuICB2YXIgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlOyAvLyBmYWxzZSBmb3Igbm8gdHJhbnNmb3JtYXRpb24sIHRydWUgZm9yIHN0YW5kYXJ0IChQcm9jcnVzdGVzKSB0cmFuc2Zvcm1hdGlvbiAocm90YXRpb24gYW5kL29yIHJlZmxlY3Rpb24pXG4gIHZhciByZWZsZWN0aW9uVHlwZSA9IGZhbHNlOyAvLyBmYWxzZS90cnVlIGZvciByZWZsZWN0aW9uIGNoZWNrLCAncmVmbGVjdE9uWCcsICdyZWZsZWN0T25ZJyBvciAncmVmbGVjdE9uQm90aCcgZm9yIHJlZmxlY3Rpb24gdHlwZSBpZiBuZWNlc3NhcnlcbiAgdmFyIGZpeGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkYWcgPSBuZXcgTWFwKCk7IC8vIGFkamFjZW5jeSBsaXN0IHRvIGtlZXAgZGlyZWN0ZWQgYWN5Y2xpYyBncmFwaCAoZGFnKSB0aGF0IGNvbnNpc3RzIG9mIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICB2YXIgZGFnVW5kaXJlY3RlZCA9IG5ldyBNYXAoKTsgLy8gdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTsgLy8gd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzXG5cbiAgLy8gZmlsbCBmaXhlZE5vZGVzIGNvbGxlY3Rpb24gdG8gdXNlIGxhdGVyXG4gIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgZml4ZWROb2Rlcy5hZGQobm9kZURhdGEubm9kZUlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBkYWcgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAvLyBjb25zdHJ1Y3QgYm90aCBkaXJlY3RlZCBhbmQgdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LmxlZnQpKSB7XG4gICAgICAgICAgZGFnLmdldChjb25zdHJhaW50LmxlZnQpLnB1c2goeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQubGVmdCwgW3sgaWQ6IGNvbnN0cmFpbnQucmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LnJpZ2h0KSkge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5yaWdodCwgW10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LnRvcCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQudG9wKS5wdXNoKHsgaWQ6IGNvbnN0cmFpbnQuYm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQudG9wLCBbeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhZy5oYXMoY29uc3RyYWludC5ib3R0b20pKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LmJvdHRvbSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkYWdVbmRpcmVjdGVkID0gZGFnVG9VbmRpcmVjdGVkKGRhZyk7XG4gICAgY29tcG9uZW50cyA9IGZpbmRDb21wb25lbnRzKGRhZ1VuZGlyZWN0ZWQpO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBmaXhlZCBub2RlIGNvbnN0cmFpbnRcbiAgICBpZiAoY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCAmJiBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW25vZGVEYXRhLnBvc2l0aW9uLngsIG5vZGVEYXRhLnBvc2l0aW9uLnldO1xuICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldXTtcbiAgICAgIH0pO1xuICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGVuIGNoZWNrIGFsaWdubWVudCBjb25zdHJhaW50XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTQpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbGlnbm1lbnRTZXQpKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIHhQb3MgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgICAgdmVydGljYWxBbGlnbltfaTRdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hQb3MsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHZlcnRpY2FsQWxpZ24ubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgX2xvb3AyKF9pNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhfaTUpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeVBvc107XG4gICAgICAgICAgICAgIHNvdXJjZU1hdHJpeFtjb3VudF0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBob3Jpem9udGFsQWxpZ24ubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgX2xvb3AzKF9pNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICByZWZsZWN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIC8vIGZpbmFsbHkgY2hlY2sgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRcbiAgICAgIC8vIGZpbmQgbGFyZ2VzdCBjb21wb25lbnQgaW4gZGFnXG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudFNpemUgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb21wb25lbnRzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbX2k2XS5sZW5ndGggPiBsYXJnZXN0Q29tcG9uZW50U2l6ZSkge1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRTaXplID0gY29tcG9uZW50c1tfaTZdLmxlbmd0aDtcbiAgICAgICAgICBsYXJnZXN0Q29tcG9uZW50SW5kZXggPSBfaTY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGxhcmdlc3QgY29tcG9uZW50IGlzbid0IGRvbWluYW50LCB0aGVuIHRha2UgdGhlIHZvdGVzIGZvciByZWZsZWN0aW9uXG4gICAgICBpZiAobGFyZ2VzdENvbXBvbmVudFNpemUgPCBkYWdVbmRpcmVjdGVkLnNpemUgLyAyKSB7XG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCk7XG4gICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXJnZXN0IGNvbXBvbmVudCBmb3IgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHN1YmdyYXBocyBpbiB0aGUgbGFyZ2VzdCBjb21wb25lbnRcbiAgICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnQuZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChub2RlSWQpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChhZGphY2VudC5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50LnB1c2goeyBsZWZ0OiBub2RlSWQsIHJpZ2h0OiBhZGphY2VudC5pZCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPblZlcnRpY2FsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IHRvcDogbm9kZUlkLCBib3R0b206IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCk7XG4gICAgICAgIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPbkhvcml6b250YWwsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwVmVydGljYWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHN1YkdyYXBoT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3Qgc291cmNlIGFuZCB0YXJnZXQgY29uZmlndXJhdGlvblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkLCBpKSB7XG4gICAgICAgICAgc291cmNlTWF0cml4W2ldID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW107XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzBdID0gcG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdHJhbnNmb3JtYXRpb24gaXMgcmVxdWlyZWQsIHRoZW4gY2FsY3VsYXRlIGFuZCBhcHBseSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICBpZiAoc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgLyogY2FsY3VsYXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCAqL1xuICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRhcmdldE1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2UodGFyZ2V0TWF0cml4KTsgLy8gQSdcbiAgICAgIHZhciBzb3VyY2VNYXRyaXhUcmFuc3Bvc2UgPSBNYXRyaXgudHJhbnNwb3NlKHNvdXJjZU1hdHJpeCk7IC8vIEInXG5cbiAgICAgIC8vIGNlbnRyYWxpemUgdHJhbnNwb3NlIG1hdHJpY2VzXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCB0YXJnZXRNYXRyaXhUcmFuc3Bvc2UubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICB0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEodGFyZ2V0TWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgICBzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEoc291cmNlTWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyBhY3R1YWwgY2FsY3VsYXRpb24gZm9yIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgdmFyIHRlbXBNYXRyaXggPSBNYXRyaXgubXVsdE1hdCh0YXJnZXRNYXRyaXhUcmFuc3Bvc2UsIE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4VHJhbnNwb3NlKSk7IC8vIHRlbXBNYXRyaXggPSBBJ0JcbiAgICAgIHZhciBTVkRSZXN1bHQgPSBTVkQuc3ZkKHRlbXBNYXRyaXgpOyAvLyBTVkQoQSdCKSA9IFVTVicsIHN2ZCBmdW5jdGlvbiByZXR1cm5zIFUsIFMgYW5kIFYgXG4gICAgICB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KFNWRFJlc3VsdC5WLCBNYXRyaXgudHJhbnNwb3NlKFNWRFJlc3VsdC5VKSk7IC8vIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gVCA9IFZVJ1xuXG4gICAgICAvKiBhcHBseSBmb3VuZCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gb2J0YWluIGZpbmFsIGRyYWZ0IGxheW91dCAqL1xuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2k4KyspIHtcbiAgICAgICAgdmFyIHRlbXAxID0gW3hDb29yZHNbX2k4XSwgeUNvb3Jkc1tfaThdXTtcbiAgICAgICAgdmFyIHRlbXAyID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzBdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVswXV07XG4gICAgICAgIHZhciB0ZW1wMyA9IFt0cmFuc2Zvcm1hdGlvbk1hdHJpeFswXVsxXSwgdHJhbnNmb3JtYXRpb25NYXRyaXhbMV1bMV1dO1xuICAgICAgICB4Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDIpO1xuICAgICAgICB5Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDMpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBsaWVkIG9ubHkgYm90aCBhbGlnbm1lbnQgYW5kIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGV4aXN0XG4gICAgICBpZiAocmVmbGVjdGlvblR5cGUpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTKSB7XG4gICAgLyoqKiogIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHRyYW5zZm9ybWVkIGRyYWZ0IGxheW91dCAqKioqL1xuXG4gICAgLyogZmlyc3QgZW5mb3JjZSBmaXhlZCBub2RlIGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9uQW1vdW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhLCBpKSB7XG4gICAgICAgIHZhciBwb3NJblRoZW9yeSA9IHsgeDogeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHk6IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldIH07XG4gICAgICAgIHZhciBwb3NEZXNpcmVkID0gbm9kZURhdGEucG9zaXRpb247XG4gICAgICAgIHZhciBwb3NEaWZmID0gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvc0Rlc2lyZWQsIHBvc0luVGhlb3J5KTtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueCArPSBwb3NEaWZmLng7XG4gICAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnkgKz0gcG9zRGlmZi55O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC54IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuICAgICAgdHJhbnNsYXRpb25BbW91bnQueSAvPSBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aDtcblxuICAgICAgeENvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB4Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lng7XG4gICAgICB9KTtcblxuICAgICAgeUNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB5Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lnk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSA9IG5vZGVEYXRhLnBvc2l0aW9uLng7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIHRoZW4gZW5mb3JjZSBhbGlnbm1lbnQgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgIHZhciB4QWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgIHZhciBfbG9vcDQgPSBmdW5jdGlvbiBfbG9vcDQoX2k5KSB7XG4gICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB4QWxpZ25bX2k5XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB4UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IHhBbGlnbi5sZW5ndGg7IF9pOSsrKSB7XG4gICAgICAgICAgX2xvb3A0KF9pOSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHlBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICB2YXIgX2xvb3A1ID0gZnVuY3Rpb24gX2xvb3A1KF9pMTApIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHlBbGlnbltfaTEwXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB5UG9zID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeVBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueTtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB5UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgeUFsaWduLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgX2xvb3A1KF9pMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogZmluYWxseSBlbmZvcmNlIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0cyAgICAgIFxuICAgICAgICBmaXhlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKG5vZGVJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICAgIHZhciBfbG9vcDYgPSBmdW5jdGlvbiBfbG9vcDYoX2kxMSkge1xuICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCBbXSk7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50W19pMTFdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgX2kxMSk7XG4gICAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCB4Q29vcmRzW25vZGVJbmRleGVzLmdldCh2ZXJ0aWNhbEFsaWdubWVudFtfaTExXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBfaTExKyspIHtcbiAgICAgICAgICAgICAgX2xvb3A2KF9pMTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNyA9IGZ1bmN0aW9uIF9sb29wNyhfaTEyKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgW10pO1xuICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W19pMTJdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTEyKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIF9pMTIpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaG9yaXpvbnRhbEFsaWdubWVudFtfaTEyXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICAgICAgICBfbG9vcDcoX2kxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3MgKHN1YmdyYXBocykgZnJvbSBvdmVyYWxsIGRhZ1xuICAgICAgICB2YXIgZGFnT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZGFnT25WZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgICB2YXIgX2xvb3A4ID0gZnVuY3Rpb24gX2xvb3A4KG5vZGVJZCkge1xuICAgICAgICAgIGRhZy5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnRbXCJkaXJlY3Rpb25cIl0gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKSA6IG5vZGVJZDtcbiAgICAgICAgICAgICAgaWYgKG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25Ib3Jpem9udGFsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuZ2V0KHNvdXJjZUlkKS5wdXNoKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPbkhvcml6b250YWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldCh0YXJnZXROb2RlLmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdXJjZUlkID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0geyBpZDogbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25WZXJ0aWNhbC5oYXMoc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPblZlcnRpY2FsLmhhcyh0YXJnZXROb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uVmVydGljYWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBkYWcua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDgobm9kZUlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmaW5kIHNvdXJjZSBub2RlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkYWdzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25Ib3Jpem9udGFsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25WZXJ0aWNhbCA9IGRhZ1RvVW5kaXJlY3RlZChkYWdPblZlcnRpY2FsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPbkhvcml6b250YWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPblZlcnRpY2FsID0gZmluZENvbXBvbmVudHModW5kaXJlY3RlZE9uVmVydGljYWwpO1xuICAgICAgICB2YXIgcmV2ZXJzZWREYWdPbkhvcml6b250YWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uVmVydGljYWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uVmVydGljYWwgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzT25Ib3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudHNPblZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbFtpbmRleF0gPSBbXTtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZWREYWdPblZlcnRpY2FsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhcHByb3ByaWF0ZSBwb3NpdGlvbmluZyBmb3Igc3ViZ3JhcGhzXG4gICAgICAgIHZhciBwb3NpdGlvbk1hcEhvcml6b250YWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGRhZ09uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIsIGZpeGVkTm9kZXNPbkhvcml6b250YWwsIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiLCBmaXhlZE5vZGVzT25WZXJ0aWNhbCwgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LCBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgYmFzZWQgb24gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG5cbiAgICAgICAgdmFyIF9sb29wOSA9IGZ1bmN0aW9uIF9sb29wOShrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KSkge1xuICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBwb3NpdGlvbk1hcEhvcml6b250YWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDkoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbG9vcDEwID0gZnVuY3Rpb24gX2xvb3AxMChrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgX2xvb3AxMChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiBuZXcgY29vcmRpbmF0ZXMgdG8gbm9kZXMgYWZ0ZXIgY29uc3RyYWludCBoYW5kbGluZ1xuICBmb3IgKHZhciBfaTEzID0gMDsgX2kxMyA8IGFsbE5vZGVzLmxlbmd0aDsgX2kxMysrKSB7XG4gICAgdmFyIF9ub2RlID0gYWxsTm9kZXNbX2kxM107XG4gICAgaWYgKF9ub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgX25vZGUuc2V0Q2VudGVyKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0pO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50SGFuZGxlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU1MTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTUxX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js\n");

/***/ })

};
;