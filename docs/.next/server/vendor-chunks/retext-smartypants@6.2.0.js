"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/retext-smartypants@6.2.0";
exports.ids = ["vendor-chunks/retext-smartypants@6.2.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ retextSmartypants)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/../node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nlcst-to-string */ \"(rsc)/../node_modules/.pnpm/nlcst-to-string@4.0.0/node_modules/nlcst-to-string/lib/index.js\");\n/**\n * @import {Parents, Punctuation, Root, SentenceContent, Symbol} from 'nlcst'\n */\n\n/**\n * @callback Method\n *   Transform.\n * @param {State} state\n *   Info passed around.\n * @param {Punctuation | Symbol} node\n *   Node.\n * @param {number} index\n *   Position of `node` in `parent`.\n * @param {Parents} parent\n *   Parent of `node`.\n * @returns {boolean | undefined | void}\n *   Whether to remove the node (`true`); or not (otherwise).\n *\n * @typedef Options\n *   Configuration.\n * @property {'all' | boolean | null | undefined} [backticks=true]\n *   Transform backticks (default: `true`); when `true`, turns double\n *   backticks into an opening double quote and double straight single quotes\n *   into a closing double quote; when `'all'`, does that and turns single\n *   backticks into an opening single quote and a straight single quotes into\n *   a closing single smart quote; `quotes: false` must be used with\n *   `backticks: 'all'`.\n * @property {QuoteCharacterMap | null | undefined} [closingQuotes]\n *   Closing quotes to use (default: `{double: '”', single: '’'}`).\n * @property {'inverted' | 'oldschool' | boolean | null | undefined} [dashes=true]\n *   Transform dashes (default: `true`);\n *   when `true`, turns two dashes into an em dash character;\n *   when `'oldschool'`, turns three dashes into an em dash and two into an en\n *   dash;\n *   when `'inverted'`, turns three dashes into an en dash and two into an em\n *   dash.\n * @property {'spaced' | 'unspaced' | boolean | null | undefined} [ellipses=true]\n *   Transform triple dots (default: `true`).\n *   when `'spaced'`, turns triple dots with spaces into ellipses;\n *   when `'unspaced'`, turns triple dots without spaces into ellipses;\n *   when `true`, turns triple dots with or without spaces into ellipses.\n * @property {QuoteCharacterMap | null | undefined} [openingQuotes]\n *   Opening quotes to use (default: `{double: '“', single: '‘'}`).\n * @property {boolean | null | undefined} [quotes=true]\n *   Transform straight quotes into smart quotes (default: `true`).\n *\n * @typedef State\n *   Info passed around.\n * @property {Quotes} close\n *   Closing quotes.\n * @property {Quotes} open\n *   Opening quotes.\n *\n * @typedef QuoteCharacterMap\n *   Quote characters.\n * @property {string} double\n *   Character to use for double quotes.\n * @property {string} single\n *   Character to use for single quotes.\n *\n * @typedef {[string, string]} Quotes\n *   Quotes.\n */\n\n\n\n\n/** @type {Quotes} */\nconst defaultClosingQuotes = ['”', '’']\n/** @type {Quotes} */\nconst defaultOpeningQuotes = ['“', '‘']\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Replace straight punctuation marks with curly ones.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nfunction retextSmartypants(options) {\n  const settings = options || emptyOptions\n  /** @type {Array<Method>} */\n  const methods = []\n\n  if (settings.quotes !== false) {\n    methods.push(quotesDefault)\n  }\n\n  if (settings.ellipses === 'spaced') {\n    methods.push(ellipsesSpaced)\n  } else if (settings.ellipses === 'unspaced') {\n    methods.push(ellipsesUnspaced)\n  } else if (settings.ellipses !== false) {\n    methods.push(ellipsesDefault)\n  }\n\n  if (settings.backticks === 'all') {\n    if (settings.quotes !== false) {\n      throw new Error(\"Cannot accept `backticks: 'all'` with `quotes: true`\")\n    }\n\n    methods.push(backticksAll)\n  } else if (settings.backticks !== false) {\n    methods.push(backticksDefault)\n  }\n\n  if (settings.dashes === 'inverted') {\n    methods.push(dashesInverted)\n  } else if (settings.dashes === 'oldschool') {\n    methods.push(dashesOldschool)\n  } else if (settings.dashes !== false) {\n    methods.push(dashesDefault)\n  }\n\n  /** @type {State} */\n  const state = {\n    close: settings.closingQuotes\n      ? [settings.closingQuotes.double, settings.closingQuotes.single]\n      : defaultClosingQuotes,\n    open: settings.openingQuotes\n      ? [settings.openingQuotes.double, settings.openingQuotes.single]\n      : defaultOpeningQuotes\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, function (node, position, parent) {\n      let index = -1\n\n      if (\n        parent &&\n        position !== undefined &&\n        (node.type === 'PunctuationNode' || node.type === 'SymbolNode')\n      ) {\n        while (++index < methods.length) {\n          const result = methods[index](state, node, position, parent)\n          if (result === true) {\n            console.log('drop', node)\n            parent.children.splice(position, 1)\n            return position\n          }\n        }\n      }\n    })\n  }\n}\n\n/**\n * Transform single and double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksAll(state, node, index, parent) {\n  backticksDefault(state, node, index, parent)\n\n  if (node.value === '`') {\n    node.value = '‘'\n  } else if (node.value === \"'\") {\n    node.value = '’'\n  }\n}\n\n/**\n * Transform double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksDefault(_, node) {\n  if (node.value === '``') {\n    node.value = '“'\n  } else if (node.value === \"''\") {\n    node.value = '”'\n  }\n}\n\n/**\n * Transform two dashes into an em dash.\n *\n * @type {Method}\n */\nfunction dashesDefault(_, node) {\n  if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an en dash, and two into an em dash.\n *\n * @type {Method}\n */\nfunction dashesInverted(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '—' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '–'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '–'\n  } else if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an em dash, and two into an en dash.\n *\n * @type {Method}\n */\nfunction dashesOldschool(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '–' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '—'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '—'\n  } else if (node.value === '--') {\n    node.value = '–'\n  }\n}\n\n/**\n * Transform multiple dots into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesDefault(_, node, index, parent) {\n  ellipsesSpaced(_, node, index, parent)\n  ellipsesUnspaced(_, node, index, parent)\n}\n\n/**\n * Transform multiple dots with spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesSpaced(_, node, index, parent) {\n  const value = node.value\n  const siblings = parent.children\n\n  if (!/^\\.+$/.test(value)) {\n    return\n  }\n\n  // Search for dot-nodes with whitespace between.\n  /** @type {Array<SentenceContent>} */\n  const nodes = []\n  let position = index\n  let count = 1\n\n  // It’s possible that the node is merged with an adjacent word-node.  In that\n  // code, we cannot transform it because there’s no reference to the\n  // grandparent.\n  while (--position > 0) {\n    let sibling = siblings[position]\n\n    if (sibling.type !== 'WhiteSpaceNode') {\n      break\n    }\n\n    const queue = sibling\n    sibling = siblings[--position]\n\n    if (\n      sibling &&\n      (sibling.type === 'PunctuationNode' || sibling.type === 'SymbolNode') &&\n      /^\\.+$/.test(sibling.value)\n    ) {\n      nodes.push(queue, sibling)\n\n      count++\n\n      continue\n    }\n\n    break\n  }\n\n  if (count < 3) {\n    return\n  }\n\n  siblings.splice(index - nodes.length, nodes.length)\n\n  node.value = '…'\n}\n\n/**\n * Transform multiple dots without spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesUnspaced(_, node) {\n  // Simple node with three dots and without whitespace.\n  if (/^\\.{3,}$/.test(node.value)) {\n    node.value = '…'\n  }\n}\n\n/**\n * Transform straight single- and double quotes into smart quotes.\n *\n * @type {Method}\n */\n// eslint-disable-next-line complexity\nfunction quotesDefault(state, node, index, parent) {\n  const siblings = parent.children\n  const value = node.value\n\n  if (value !== '\"' && value !== \"'\") {\n    return\n  }\n\n  const quoteIndex = value === '\"' ? 0 : 1\n  const previous = siblings[index - 1]\n  const next = siblings[index + 1]\n  const nextNext = siblings[index + 2]\n  const nextValue = next ? (0,nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(next) : ''\n\n  if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (!nextNext || nextNext.type !== 'WordNode')\n  ) {\n    // Special case if the very first character is a quote followed by\n    // punctuation at a non-word-break. Close the quotes by brute force.\n    node.value = state.close[quoteIndex]\n  } else if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (nextValue === '\"' || nextValue === \"'\") &&\n    nextNext &&\n    nextNext.type === 'WordNode'\n  ) {\n    // Special case for double sets of quotes:\n    // `He said, \"'Quoted' words in a larger quote.\"`\n    node.value = state.open[quoteIndex]\n    next.value = state.open[nextValue === '\"' ? 0 : 1]\n  } else if (next && /^\\d\\ds$/.test(nextValue)) {\n    // Special case for decade abbreviations: `the '80s`\n    node.value = state.close[quoteIndex]\n  } else if (\n    previous &&\n    (previous.type === 'WhiteSpaceNode' ||\n      previous.type === 'PunctuationNode' ||\n      previous.type === 'SymbolNode') &&\n    next &&\n    next.type === 'WordNode'\n  ) {\n    // Get most opening single quotes.\n    node.value = state.open[quoteIndex]\n  } else if (\n    previous &&\n    previous.type !== 'WhiteSpaceNode' &&\n    previous.type !== 'SymbolNode' &&\n    previous.type !== 'PunctuationNode'\n  ) {\n    // Closing quotes.\n    node.value = state.close[quoteIndex]\n  } else if (\n    !next ||\n    next.type === 'WhiteSpaceNode' ||\n    (value === \"'\" && nextValue === 's')\n  ) {\n    node.value = state.close[quoteIndex]\n  } else {\n    node.value = state.open[quoteIndex]\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldGV4dC1zbWFydHlwYW50c0A2LjIuMC9ub2RlX21vZHVsZXMvcmV0ZXh0LXNtYXJ0eXBhbnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCx1Q0FBdUMseUJBQXlCO0FBQ2hFLGNBQWMsdURBQXVEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQsdUNBQXVDLHlCQUF5QjtBQUNoRSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFc0M7QUFDRTs7QUFFeEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBLFdBQVcsbUJBQW1CO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9yZXRleHQtc21hcnR5cGFudHNANi4yLjAvbm9kZV9tb2R1bGVzL3JldGV4dC1zbWFydHlwYW50cy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtQYXJlbnRzLCBQdW5jdHVhdGlvbiwgUm9vdCwgU2VudGVuY2VDb250ZW50LCBTeW1ib2x9IGZyb20gJ25sY3N0J1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1ldGhvZFxuICogICBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1B1bmN0dWF0aW9uIHwgU3ltYm9sfSBub2RlXG4gKiAgIE5vZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgUG9zaXRpb24gb2YgYG5vZGVgIGluIGBwYXJlbnRgLlxuICogQHBhcmFtIHtQYXJlbnRzfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGBub2RlYC5cbiAqIEByZXR1cm5zIHtib29sZWFuIHwgdW5kZWZpbmVkIHwgdm9pZH1cbiAqICAgV2hldGhlciB0byByZW1vdmUgdGhlIG5vZGUgKGB0cnVlYCk7IG9yIG5vdCAob3RoZXJ3aXNlKS5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkgeydhbGwnIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtiYWNrdGlja3M9dHJ1ZV1cbiAqICAgVHJhbnNmb3JtIGJhY2t0aWNrcyAoZGVmYXVsdDogYHRydWVgKTsgd2hlbiBgdHJ1ZWAsIHR1cm5zIGRvdWJsZVxuICogICBiYWNrdGlja3MgaW50byBhbiBvcGVuaW5nIGRvdWJsZSBxdW90ZSBhbmQgZG91YmxlIHN0cmFpZ2h0IHNpbmdsZSBxdW90ZXNcbiAqICAgaW50byBhIGNsb3NpbmcgZG91YmxlIHF1b3RlOyB3aGVuIGAnYWxsJ2AsIGRvZXMgdGhhdCBhbmQgdHVybnMgc2luZ2xlXG4gKiAgIGJhY2t0aWNrcyBpbnRvIGFuIG9wZW5pbmcgc2luZ2xlIHF1b3RlIGFuZCBhIHN0cmFpZ2h0IHNpbmdsZSBxdW90ZXMgaW50b1xuICogICBhIGNsb3Npbmcgc2luZ2xlIHNtYXJ0IHF1b3RlOyBgcXVvdGVzOiBmYWxzZWAgbXVzdCBiZSB1c2VkIHdpdGhcbiAqICAgYGJhY2t0aWNrczogJ2FsbCdgLlxuICogQHByb3BlcnR5IHtRdW90ZUNoYXJhY3Rlck1hcCB8IG51bGwgfCB1bmRlZmluZWR9IFtjbG9zaW5nUXVvdGVzXVxuICogICBDbG9zaW5nIHF1b3RlcyB0byB1c2UgKGRlZmF1bHQ6IGB7ZG91YmxlOiAn4oCdJywgc2luZ2xlOiAn4oCZJ31gKS5cbiAqIEBwcm9wZXJ0eSB7J2ludmVydGVkJyB8ICdvbGRzY2hvb2wnIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkYXNoZXM9dHJ1ZV1cbiAqICAgVHJhbnNmb3JtIGRhc2hlcyAoZGVmYXVsdDogYHRydWVgKTtcbiAqICAgd2hlbiBgdHJ1ZWAsIHR1cm5zIHR3byBkYXNoZXMgaW50byBhbiBlbSBkYXNoIGNoYXJhY3RlcjtcbiAqICAgd2hlbiBgJ29sZHNjaG9vbCdgLCB0dXJucyB0aHJlZSBkYXNoZXMgaW50byBhbiBlbSBkYXNoIGFuZCB0d28gaW50byBhbiBlblxuICogICBkYXNoO1xuICogICB3aGVuIGAnaW52ZXJ0ZWQnYCwgdHVybnMgdGhyZWUgZGFzaGVzIGludG8gYW4gZW4gZGFzaCBhbmQgdHdvIGludG8gYW4gZW1cbiAqICAgZGFzaC5cbiAqIEBwcm9wZXJ0eSB7J3NwYWNlZCcgfCAndW5zcGFjZWQnIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtlbGxpcHNlcz10cnVlXVxuICogICBUcmFuc2Zvcm0gdHJpcGxlIGRvdHMgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gKiAgIHdoZW4gYCdzcGFjZWQnYCwgdHVybnMgdHJpcGxlIGRvdHMgd2l0aCBzcGFjZXMgaW50byBlbGxpcHNlcztcbiAqICAgd2hlbiBgJ3Vuc3BhY2VkJ2AsIHR1cm5zIHRyaXBsZSBkb3RzIHdpdGhvdXQgc3BhY2VzIGludG8gZWxsaXBzZXM7XG4gKiAgIHdoZW4gYHRydWVgLCB0dXJucyB0cmlwbGUgZG90cyB3aXRoIG9yIHdpdGhvdXQgc3BhY2VzIGludG8gZWxsaXBzZXMuXG4gKiBAcHJvcGVydHkge1F1b3RlQ2hhcmFjdGVyTWFwIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wZW5pbmdRdW90ZXNdXG4gKiAgIE9wZW5pbmcgcXVvdGVzIHRvIHVzZSAoZGVmYXVsdDogYHtkb3VibGU6ICfigJwnLCBzaW5nbGU6ICfigJgnfWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3F1b3Rlcz10cnVlXVxuICogICBUcmFuc2Zvcm0gc3RyYWlnaHQgcXVvdGVzIGludG8gc21hcnQgcXVvdGVzIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqIEB0eXBlZGVmIFN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwcm9wZXJ0eSB7UXVvdGVzfSBjbG9zZVxuICogICBDbG9zaW5nIHF1b3Rlcy5cbiAqIEBwcm9wZXJ0eSB7UXVvdGVzfSBvcGVuXG4gKiAgIE9wZW5pbmcgcXVvdGVzLlxuICpcbiAqIEB0eXBlZGVmIFF1b3RlQ2hhcmFjdGVyTWFwXG4gKiAgIFF1b3RlIGNoYXJhY3RlcnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZG91YmxlXG4gKiAgIENoYXJhY3RlciB0byB1c2UgZm9yIGRvdWJsZSBxdW90ZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2luZ2xlXG4gKiAgIENoYXJhY3RlciB0byB1c2UgZm9yIHNpbmdsZSBxdW90ZXMuXG4gKlxuICogQHR5cGVkZWYge1tzdHJpbmcsIHN0cmluZ119IFF1b3Rlc1xuICogICBRdW90ZXMuXG4gKi9cblxuaW1wb3J0IHt2aXNpdH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdCdcbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJ25sY3N0LXRvLXN0cmluZydcblxuLyoqIEB0eXBlIHtRdW90ZXN9ICovXG5jb25zdCBkZWZhdWx0Q2xvc2luZ1F1b3RlcyA9IFsn4oCdJywgJ+KAmSddXG4vKiogQHR5cGUge1F1b3Rlc30gKi9cbmNvbnN0IGRlZmF1bHRPcGVuaW5nUXVvdGVzID0gWyfigJwnLCAn4oCYJ11cblxuLyoqIEB0eXBlIHtSZWFkb25seTxPcHRpb25zPn0gKi9cbmNvbnN0IGVtcHR5T3B0aW9ucyA9IHt9XG5cbi8qKlxuICogUmVwbGFjZSBzdHJhaWdodCBwdW5jdHVhdGlvbiBtYXJrcyB3aXRoIGN1cmx5IG9uZXMuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxPcHRpb25zPiB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJuc1xuICogICBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJldGV4dFNtYXJ0eXBhbnRzKG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uc1xuICAvKiogQHR5cGUge0FycmF5PE1ldGhvZD59ICovXG4gIGNvbnN0IG1ldGhvZHMgPSBbXVxuXG4gIGlmIChzZXR0aW5ncy5xdW90ZXMgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKHF1b3Rlc0RlZmF1bHQpXG4gIH1cblxuICBpZiAoc2V0dGluZ3MuZWxsaXBzZXMgPT09ICdzcGFjZWQnKSB7XG4gICAgbWV0aG9kcy5wdXNoKGVsbGlwc2VzU3BhY2VkKVxuICB9IGVsc2UgaWYgKHNldHRpbmdzLmVsbGlwc2VzID09PSAndW5zcGFjZWQnKSB7XG4gICAgbWV0aG9kcy5wdXNoKGVsbGlwc2VzVW5zcGFjZWQpXG4gIH0gZWxzZSBpZiAoc2V0dGluZ3MuZWxsaXBzZXMgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKGVsbGlwc2VzRGVmYXVsdClcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5iYWNrdGlja3MgPT09ICdhbGwnKSB7XG4gICAgaWYgKHNldHRpbmdzLnF1b3RlcyAhPT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2NlcHQgYGJhY2t0aWNrczogJ2FsbCdgIHdpdGggYHF1b3RlczogdHJ1ZWBcIilcbiAgICB9XG5cbiAgICBtZXRob2RzLnB1c2goYmFja3RpY2tzQWxsKVxuICB9IGVsc2UgaWYgKHNldHRpbmdzLmJhY2t0aWNrcyAhPT0gZmFsc2UpIHtcbiAgICBtZXRob2RzLnB1c2goYmFja3RpY2tzRGVmYXVsdClcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5kYXNoZXMgPT09ICdpbnZlcnRlZCcpIHtcbiAgICBtZXRob2RzLnB1c2goZGFzaGVzSW52ZXJ0ZWQpXG4gIH0gZWxzZSBpZiAoc2V0dGluZ3MuZGFzaGVzID09PSAnb2xkc2Nob29sJykge1xuICAgIG1ldGhvZHMucHVzaChkYXNoZXNPbGRzY2hvb2wpXG4gIH0gZWxzZSBpZiAoc2V0dGluZ3MuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgIG1ldGhvZHMucHVzaChkYXNoZXNEZWZhdWx0KVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY2xvc2U6IHNldHRpbmdzLmNsb3NpbmdRdW90ZXNcbiAgICAgID8gW3NldHRpbmdzLmNsb3NpbmdRdW90ZXMuZG91YmxlLCBzZXR0aW5ncy5jbG9zaW5nUXVvdGVzLnNpbmdsZV1cbiAgICAgIDogZGVmYXVsdENsb3NpbmdRdW90ZXMsXG4gICAgb3Blbjogc2V0dGluZ3Mub3BlbmluZ1F1b3Rlc1xuICAgICAgPyBbc2V0dGluZ3Mub3BlbmluZ1F1b3Rlcy5kb3VibGUsIHNldHRpbmdzLm9wZW5pbmdRdW90ZXMuc2luZ2xlXVxuICAgICAgOiBkZWZhdWx0T3BlbmluZ1F1b3Rlc1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtSb290fSB0cmVlXG4gICAqICAgVHJlZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uICh0cmVlKSB7XG4gICAgdmlzaXQodHJlZSwgZnVuY3Rpb24gKG5vZGUsIHBvc2l0aW9uLCBwYXJlbnQpIHtcbiAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgIGlmIChcbiAgICAgICAgcGFyZW50ICYmXG4gICAgICAgIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKG5vZGUudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHwgbm9kZS50eXBlID09PSAnU3ltYm9sTm9kZScpXG4gICAgICApIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1ldGhvZHNbaW5kZXhdKHN0YXRlLCBub2RlLCBwb3NpdGlvbiwgcGFyZW50KVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkcm9wJywgbm9kZSlcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UocG9zaXRpb24sIDEpXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHNpbmdsZSBhbmQgZG91YmxlIGJhY2t0aWNrcyBhbmQgc2luZ2xlIHF1b3RlcyBpbnRvIHNtYXJ0IHF1b3Rlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBiYWNrdGlja3NBbGwoc3RhdGUsIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgYmFja3RpY2tzRGVmYXVsdChzdGF0ZSwgbm9kZSwgaW5kZXgsIHBhcmVudClcblxuICBpZiAobm9kZS52YWx1ZSA9PT0gJ2AnKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJgnXG4gIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gXCInXCIpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAmSdcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBkb3VibGUgYmFja3RpY2tzIGFuZCBzaW5nbGUgcXVvdGVzIGludG8gc21hcnQgcXVvdGVzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGJhY2t0aWNrc0RlZmF1bHQoXywgbm9kZSkge1xuICBpZiAobm9kZS52YWx1ZSA9PT0gJ2BgJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCcJ1xuICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09IFwiJydcIikge1xuICAgIG5vZGUudmFsdWUgPSAn4oCdJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHR3byBkYXNoZXMgaW50byBhbiBlbSBkYXNoLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGRhc2hlc0RlZmF1bHQoXywgbm9kZSkge1xuICBpZiAobm9kZS52YWx1ZSA9PT0gJy0tJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCUJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRocmVlIGRhc2hlcyBpbnRvIGFuIGVuIGRhc2gsIGFuZCB0d28gaW50byBhbiBlbSBkYXNoLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGRhc2hlc0ludmVydGVkKF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3QgbmV4dCA9IHBhcmVudC5jaGlsZHJlbltpbmRleCArIDFdXG5cbiAgaWYgKFxuICAgIG5vZGUudmFsdWUgPT09ICfigJQnICYmXG4gICAgbmV4dCAmJlxuICAgIG5leHQudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgJiZcbiAgICBuZXh0LnZhbHVlID09PSAnLSdcbiAgKSB7XG4gICAgbmV4dC52YWx1ZSA9ICfigJMnXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChub2RlLnZhbHVlID09PSAnLS0tJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCTJ1xuICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09ICctLScpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAlCdcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aHJlZSBkYXNoZXMgaW50byBhbiBlbSBkYXNoLCBhbmQgdHdvIGludG8gYW4gZW4gZGFzaC5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBkYXNoZXNPbGRzY2hvb2woXywgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gcGFyZW50LmNoaWxkcmVuW2luZGV4ICsgMV1cblxuICBpZiAoXG4gICAgbm9kZS52YWx1ZSA9PT0gJ+KAkycgJiZcbiAgICBuZXh0ICYmXG4gICAgbmV4dC50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyAmJlxuICAgIG5leHQudmFsdWUgPT09ICctJ1xuICApIHtcbiAgICBuZXh0LnZhbHVlID0gJ+KAlCdcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKG5vZGUudmFsdWUgPT09ICctLS0nKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJQnXG4gIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gJy0tJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCTJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIG11bHRpcGxlIGRvdHMgaW50byB1bmljb2RlIGVsbGlwc2VzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGVsbGlwc2VzRGVmYXVsdChfLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGVsbGlwc2VzU3BhY2VkKF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpXG4gIGVsbGlwc2VzVW5zcGFjZWQoXywgbm9kZSwgaW5kZXgsIHBhcmVudClcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gbXVsdGlwbGUgZG90cyB3aXRoIHNwYWNlcyBpbnRvIHVuaWNvZGUgZWxsaXBzZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZWxsaXBzZXNTcGFjZWQoXywgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWVcbiAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cblxuICBpZiAoIS9eXFwuKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBTZWFyY2ggZm9yIGRvdC1ub2RlcyB3aXRoIHdoaXRlc3BhY2UgYmV0d2Vlbi5cbiAgLyoqIEB0eXBlIHtBcnJheTxTZW50ZW5jZUNvbnRlbnQ+fSAqL1xuICBjb25zdCBub2RlcyA9IFtdXG4gIGxldCBwb3NpdGlvbiA9IGluZGV4XG4gIGxldCBjb3VudCA9IDFcblxuICAvLyBJdOKAmXMgcG9zc2libGUgdGhhdCB0aGUgbm9kZSBpcyBtZXJnZWQgd2l0aCBhbiBhZGphY2VudCB3b3JkLW5vZGUuICBJbiB0aGF0XG4gIC8vIGNvZGUsIHdlIGNhbm5vdCB0cmFuc2Zvcm0gaXQgYmVjYXVzZSB0aGVyZeKAmXMgbm8gcmVmZXJlbmNlIHRvIHRoZVxuICAvLyBncmFuZHBhcmVudC5cbiAgd2hpbGUgKC0tcG9zaXRpb24gPiAwKSB7XG4gICAgbGV0IHNpYmxpbmcgPSBzaWJsaW5nc1twb3NpdGlvbl1cblxuICAgIGlmIChzaWJsaW5nLnR5cGUgIT09ICdXaGl0ZVNwYWNlTm9kZScpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgcXVldWUgPSBzaWJsaW5nXG4gICAgc2libGluZyA9IHNpYmxpbmdzWy0tcG9zaXRpb25dXG5cbiAgICBpZiAoXG4gICAgICBzaWJsaW5nICYmXG4gICAgICAoc2libGluZy50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBzaWJsaW5nLnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICAgIC9eXFwuKyQvLnRlc3Qoc2libGluZy52YWx1ZSlcbiAgICApIHtcbiAgICAgIG5vZGVzLnB1c2gocXVldWUsIHNpYmxpbmcpXG5cbiAgICAgIGNvdW50KytcblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBicmVha1xuICB9XG5cbiAgaWYgKGNvdW50IDwgMykge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2libGluZ3Muc3BsaWNlKGluZGV4IC0gbm9kZXMubGVuZ3RoLCBub2Rlcy5sZW5ndGgpXG5cbiAgbm9kZS52YWx1ZSA9ICfigKYnXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIG11bHRpcGxlIGRvdHMgd2l0aG91dCBzcGFjZXMgaW50byB1bmljb2RlIGVsbGlwc2VzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGVsbGlwc2VzVW5zcGFjZWQoXywgbm9kZSkge1xuICAvLyBTaW1wbGUgbm9kZSB3aXRoIHRocmVlIGRvdHMgYW5kIHdpdGhvdXQgd2hpdGVzcGFjZS5cbiAgaWYgKC9eXFwuezMsfSQvLnRlc3Qobm9kZS52YWx1ZSkpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KApidcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBzdHJhaWdodCBzaW5nbGUtIGFuZCBkb3VibGUgcXVvdGVzIGludG8gc21hcnQgcXVvdGVzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBxdW90ZXNEZWZhdWx0KHN0YXRlLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZVxuXG4gIGlmICh2YWx1ZSAhPT0gJ1wiJyAmJiB2YWx1ZSAhPT0gXCInXCIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHF1b3RlSW5kZXggPSB2YWx1ZSA9PT0gJ1wiJyA/IDAgOiAxXG4gIGNvbnN0IHByZXZpb3VzID0gc2libGluZ3NbaW5kZXggLSAxXVxuICBjb25zdCBuZXh0ID0gc2libGluZ3NbaW5kZXggKyAxXVxuICBjb25zdCBuZXh0TmV4dCA9IHNpYmxpbmdzW2luZGV4ICsgMl1cbiAgY29uc3QgbmV4dFZhbHVlID0gbmV4dCA/IHRvU3RyaW5nKG5leHQpIDogJydcblxuICBpZiAoXG4gICAgbmV4dCAmJlxuICAgIChuZXh0LnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8IG5leHQudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKSAmJlxuICAgICghbmV4dE5leHQgfHwgbmV4dE5leHQudHlwZSAhPT0gJ1dvcmROb2RlJylcbiAgKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGlmIHRoZSB2ZXJ5IGZpcnN0IGNoYXJhY3RlciBpcyBhIHF1b3RlIGZvbGxvd2VkIGJ5XG4gICAgLy8gcHVuY3R1YXRpb24gYXQgYSBub24td29yZC1icmVhay4gQ2xvc2UgdGhlIHF1b3RlcyBieSBicnV0ZSBmb3JjZS5cbiAgICBub2RlLnZhbHVlID0gc3RhdGUuY2xvc2VbcXVvdGVJbmRleF1cbiAgfSBlbHNlIGlmIChcbiAgICBuZXh0ICYmXG4gICAgKG5leHQudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHwgbmV4dC50eXBlID09PSAnU3ltYm9sTm9kZScpICYmXG4gICAgKG5leHRWYWx1ZSA9PT0gJ1wiJyB8fCBuZXh0VmFsdWUgPT09IFwiJ1wiKSAmJlxuICAgIG5leHROZXh0ICYmXG4gICAgbmV4dE5leHQudHlwZSA9PT0gJ1dvcmROb2RlJ1xuICApIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGRvdWJsZSBzZXRzIG9mIHF1b3RlczpcbiAgICAvLyBgSGUgc2FpZCwgXCInUXVvdGVkJyB3b3JkcyBpbiBhIGxhcmdlciBxdW90ZS5cImBcbiAgICBub2RlLnZhbHVlID0gc3RhdGUub3BlbltxdW90ZUluZGV4XVxuICAgIG5leHQudmFsdWUgPSBzdGF0ZS5vcGVuW25leHRWYWx1ZSA9PT0gJ1wiJyA/IDAgOiAxXVxuICB9IGVsc2UgaWYgKG5leHQgJiYgL15cXGRcXGRzJC8udGVzdChuZXh0VmFsdWUpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkZWNhZGUgYWJicmV2aWF0aW9uczogYHRoZSAnODBzYFxuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5jbG9zZVtxdW90ZUluZGV4XVxuICB9IGVsc2UgaWYgKFxuICAgIHByZXZpb3VzICYmXG4gICAgKHByZXZpb3VzLnR5cGUgPT09ICdXaGl0ZVNwYWNlTm9kZScgfHxcbiAgICAgIHByZXZpb3VzLnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8XG4gICAgICBwcmV2aW91cy50eXBlID09PSAnU3ltYm9sTm9kZScpICYmXG4gICAgbmV4dCAmJlxuICAgIG5leHQudHlwZSA9PT0gJ1dvcmROb2RlJ1xuICApIHtcbiAgICAvLyBHZXQgbW9zdCBvcGVuaW5nIHNpbmdsZSBxdW90ZXMuXG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLm9wZW5bcXVvdGVJbmRleF1cbiAgfSBlbHNlIGlmIChcbiAgICBwcmV2aW91cyAmJlxuICAgIHByZXZpb3VzLnR5cGUgIT09ICdXaGl0ZVNwYWNlTm9kZScgJiZcbiAgICBwcmV2aW91cy50eXBlICE9PSAnU3ltYm9sTm9kZScgJiZcbiAgICBwcmV2aW91cy50eXBlICE9PSAnUHVuY3R1YXRpb25Ob2RlJ1xuICApIHtcbiAgICAvLyBDbG9zaW5nIHF1b3Rlcy5cbiAgICBub2RlLnZhbHVlID0gc3RhdGUuY2xvc2VbcXVvdGVJbmRleF1cbiAgfSBlbHNlIGlmIChcbiAgICAhbmV4dCB8fFxuICAgIG5leHQudHlwZSA9PT0gJ1doaXRlU3BhY2VOb2RlJyB8fFxuICAgICh2YWx1ZSA9PT0gXCInXCIgJiYgbmV4dFZhbHVlID09PSAncycpXG4gICkge1xuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5jbG9zZVtxdW90ZUluZGV4XVxuICB9IGVsc2Uge1xuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5vcGVuW3F1b3RlSW5kZXhdXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js\n");

/***/ })

};
;