"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-build-jsx@3.0.1";
exports.ids = ["vendor-chunks/estree-util-build-jsx@3.0.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(rsc)/../node_modules/.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(rsc)/../node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */\n\n\n\n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g\n\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction buildJsx(tree, options) {\n  const config = options || {}\n  let automatic = config.runtime === 'automatic'\n  /** @type {Annotations} */\n  const annotations = {}\n  /** @type {Imports} */\n  const imports = {}\n\n  ;(0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n    enter(node) {\n      if (node.type === 'Program') {\n        const comments = node.comments || []\n        let index = -1\n\n        while (++index < comments.length) {\n          regex.lastIndex = 0\n\n          let match = regex.exec(comments[index].value)\n\n          while (match) {\n            // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n            // runtime is checked later.\n            annotations[match[1]] = match[2]\n            match = regex.exec(comments[index].value)\n          }\n        }\n\n        if (annotations.jsxRuntime) {\n          if (annotations.jsxRuntime === 'automatic') {\n            automatic = true\n\n            if (annotations.jsx) {\n              throw new Error('Unexpected `@jsx` pragma w/ automatic runtime')\n            }\n\n            if (annotations.jsxFrag) {\n              throw new Error(\n                'Unexpected `@jsxFrag` pragma w/ automatic runtime'\n              )\n            }\n          } else if (annotations.jsxRuntime === 'classic') {\n            automatic = false\n\n            if (annotations.jsxImportSource) {\n              throw new Error(\n                'Unexpected `@jsxImportSource` w/ classic runtime'\n              )\n            }\n          } else {\n            throw new Error(\n              'Unexpected `jsxRuntime` `' +\n                annotations.jsxRuntime +\n                '`, expected `automatic` or `classic`'\n            )\n          }\n        }\n      }\n    },\n    // eslint-disable-next-line complexity\n    leave(node) {\n      if (node.type === 'Program') {\n        /** @type {Array<ImportSpecifier>} */\n        const specifiers = []\n\n        if (imports.fragment) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'Fragment'},\n            local: {type: 'Identifier', name: '_Fragment'}\n          })\n        }\n\n        if (imports.jsx) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsx'},\n            local: {type: 'Identifier', name: '_jsx'}\n          })\n        }\n\n        if (imports.jsxs) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxs'},\n            local: {type: 'Identifier', name: '_jsxs'}\n          })\n        }\n\n        if (imports.jsxDEV) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxDEV'},\n            local: {type: 'Identifier', name: '_jsxDEV'}\n          })\n        }\n\n        if (specifiers.length > 0) {\n          let injectIndex = 0\n\n          while (injectIndex < node.body.length) {\n            const child = node.body[injectIndex]\n\n            if ('directive' in child && child.directive) {\n              injectIndex++\n            } else {\n              break\n            }\n          }\n\n          node.body.splice(injectIndex, 0, {\n            type: 'ImportDeclaration',\n            specifiers,\n            source: {\n              type: 'Literal',\n              value:\n                (annotations.jsxImportSource ||\n                  config.importSource ||\n                  'react') +\n                (config.development ? '/jsx-dev-runtime' : '/jsx-runtime')\n            }\n          })\n        }\n      }\n\n      if (node.type !== 'JSXElement' && node.type !== 'JSXFragment') {\n        return\n      }\n\n      /** @type {Array<Expression>} */\n      const children = []\n      let index = -1\n\n      // Figure out `children`.\n      while (++index < node.children.length) {\n        const child = node.children[index]\n\n        if (child.type === 'JSXExpressionContainer') {\n          // Ignore empty expressions.\n          if (child.expression.type !== 'JSXEmptyExpression') {\n            children.push(child.expression)\n          }\n        } else if (child.type === 'JSXText') {\n          const value = child.value\n            // Replace tabs w/ spaces.\n            .replace(/\\t/g, ' ')\n            // Use line feeds, drop spaces around them.\n            .replace(/ *(\\r?\\n|\\r) */g, '\\n')\n            // Collapse multiple line feeds.\n            .replace(/\\n+/g, '\\n')\n            // Drop final line feeds.\n            .replace(/\\n+$/, '')\n            // Drop first line feeds.\n            .replace(/^\\n+/, '')\n            // Replace line feeds with spaces.\n            .replace(/\\n/g, ' ')\n\n          // Ignore collapsible text.\n          if (value) {\n            /** @type {Node} */\n            const text = {type: 'Literal', value}\n            create(child, text)\n            children.push(text)\n          }\n        } else {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n            child.type !== 'JSXElement' &&\n              child.type !== 'JSXFragment' &&\n              child.type !== 'JSXSpreadChild'\n          )\n          children.push(child)\n        }\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let name\n      /** @type {Array<Property | SpreadElement>} */\n      const fields = []\n      /** @type {Array<Expression>} */\n      let parameters = []\n      /** @type {Expression | undefined} */\n      let key\n\n      // Do the stuff needed for elements.\n      if (node.type === 'JSXElement') {\n        name = toIdentifier(node.openingElement.name)\n\n        // If the name could be an identifier, but start with a lowercase letter,\n        // itâ€™s not a component.\n        if (name.type === 'Identifier' && /^[a-z]/.test(name.name)) {\n          /** @type {Node} */\n          const next = {type: 'Literal', value: name.name}\n          create(name, next)\n          name = next\n        }\n\n        /** @type {boolean | undefined} */\n        let spread\n        const attributes = node.openingElement.attributes\n        let index = -1\n\n        // Place props in the right order, because we might have duplicates\n        // in them and whatâ€™s spread in.\n        while (++index < attributes.length) {\n          const attribute = attributes[index]\n\n          if (attribute.type === 'JSXSpreadAttribute') {\n            if (attribute.argument.type === 'ObjectExpression') {\n              fields.push(...attribute.argument.properties)\n            } else {\n              fields.push({type: 'SpreadElement', argument: attribute.argument})\n            }\n\n            spread = true\n          } else {\n            const prop = toProperty(attribute)\n\n            if (\n              automatic &&\n              prop.key.type === 'Identifier' &&\n              prop.key.name === 'key'\n            ) {\n              if (spread) {\n                throw new Error(\n                  'Expected `key` to come before any spread expressions'\n                )\n              }\n\n              const value = prop.value\n\n              ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n                value.type !== 'AssignmentPattern' &&\n                  value.type !== 'ArrayPattern' &&\n                  value.type !== 'ObjectPattern' &&\n                  value.type !== 'RestElement'\n              )\n\n              key = value\n            } else {\n              fields.push(prop)\n            }\n          }\n        }\n      }\n      // â€¦and fragments.\n      else if (automatic) {\n        imports.fragment = true\n        name = {type: 'Identifier', name: '_Fragment'}\n      } else {\n        name = toMemberExpression(\n          annotations.jsxFrag || config.pragmaFrag || 'React.Fragment'\n        )\n      }\n\n      if (automatic) {\n        if (children.length > 0) {\n          fields.push({\n            type: 'Property',\n            key: {type: 'Identifier', name: 'children'},\n            value:\n              children.length > 1\n                ? {type: 'ArrayExpression', elements: children}\n                : children[0],\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed: false\n          })\n        }\n      } else {\n        parameters = children\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let callee\n\n      if (automatic) {\n        parameters.push({type: 'ObjectExpression', properties: fields})\n\n        if (key) {\n          parameters.push(key)\n        } else if (config.development) {\n          parameters.push({type: 'Identifier', name: 'undefined'})\n        }\n\n        const isStaticChildren = children.length > 1\n\n        if (config.development) {\n          imports.jsxDEV = true\n          callee = {\n            type: 'Identifier',\n            name: '_jsxDEV'\n          }\n          parameters.push({type: 'Literal', value: isStaticChildren})\n\n          /** @type {ObjectExpression} */\n          const source = {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'fileName'},\n                value: {\n                  type: 'Literal',\n                  value: config.filePath || '<source.js>'\n                }\n              }\n            ]\n          }\n\n          if (node.loc) {\n            source.properties.push(\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'lineNumber'},\n                value: {type: 'Literal', value: node.loc.start.line}\n              },\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'columnNumber'},\n                value: {type: 'Literal', value: node.loc.start.column + 1}\n              }\n            )\n          }\n\n          parameters.push(source, {type: 'ThisExpression'})\n        } else if (isStaticChildren) {\n          imports.jsxs = true\n          callee = {type: 'Identifier', name: '_jsxs'}\n        } else {\n          imports.jsx = true\n          callee = {type: 'Identifier', name: '_jsx'}\n        }\n      }\n      // Classic.\n      else {\n        if (fields.length > 0) {\n          parameters.unshift({type: 'ObjectExpression', properties: fields})\n        } else if (parameters.length > 0) {\n          parameters.unshift({type: 'Literal', value: null})\n        }\n\n        callee = toMemberExpression(\n          annotations.jsx || config.pragma || 'React.createElement'\n        )\n      }\n\n      parameters.unshift(name)\n      /** @type {Node} */\n      const call = {\n        type: 'CallExpression',\n        callee,\n        arguments: parameters,\n        optional: false\n      }\n      create(node, call)\n      this.replace(call)\n    }\n  })\n}\n\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */\nfunction toProperty(node) {\n  /** @type {Expression} */\n  let value\n\n  if (node.value) {\n    if (node.value.type === 'JSXExpressionContainer') {\n      const valueExpression = node.value.expression\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        valueExpression.type !== 'JSXEmptyExpression',\n        '`JSXEmptyExpression` is not allowed in props.'\n      )\n      value = valueExpression\n    }\n    // Literal or call expression.\n    else {\n      const nodeValue = node.value\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        nodeValue.type !== 'JSXElement' && nodeValue.type !== 'JSXFragment',\n        'JSX{Element,Fragment} are already compiled to `CallExpression`'\n      )\n      value = nodeValue\n      delete value.raw\n    }\n  }\n  // Boolean prop.\n  else {\n    value = {type: 'Literal', value: true}\n  }\n\n  /** @type {Property} */\n  const replacement = {\n    type: 'Property',\n    key: toIdentifier(node.name),\n    value,\n    kind: 'init',\n    method: false,\n    shorthand: false,\n    computed: false\n  }\n  create(node, replacement)\n  return replacement\n}\n\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */\nfunction toIdentifier(node) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let replace\n\n  if (node.type === 'JSXMemberExpression') {\n    // `property` is always a `JSXIdentifier`, but it could be something that\n    // isnâ€™t an ES identifier name.\n    const id = toIdentifier(node.property)\n    replace = {\n      type: 'MemberExpression',\n      object: toIdentifier(node.object),\n      property: id,\n      computed: id.type === 'Literal',\n      optional: false\n    }\n  } else if (node.type === 'JSXNamespacedName') {\n    replace = {\n      type: 'Literal',\n      value: node.namespace.name + ':' + node.name.name\n    }\n  }\n  // Must be `JSXIdentifier`.\n  else {\n    replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name)\n      ? {type: 'Identifier', name: node.name}\n      : {type: 'Literal', value: node.name}\n  }\n\n  create(node, replace)\n  return replace\n}\n\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */\nfunction toMemberExpression(id) {\n  const identifiers = id.split('.')\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let result\n\n  while (++index < identifiers.length) {\n    /** @type {Identifier | Literal} */\n    const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index])\n      ? {type: 'Identifier', name: identifiers[index]}\n      : {type: 'Literal', value: identifiers[index]}\n    result = result\n      ? {\n          type: 'MemberExpression',\n          object: result,\n          property: prop,\n          computed: Boolean(index && prop.type === 'Literal'),\n          optional: false\n        }\n      : prop\n  }\n\n  (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, 'always a result')\n  return result\n}\n\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction create(from, to) {\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n    if (field in from) {\n      // @ts-expect-error: indexable.\n      to[field] = from[field]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWJ1aWxkLWpzeEAzLjAuMS9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGNBQWMs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cG0vZXN0cmVlLXV0aWwtYnVpbGQtanN4QDMuMC4xL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkV4cHJlc3Npb259IEV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5JZGVudGlmaWVyfSBJZGVudGlmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSW1wb3J0U3BlY2lmaWVyfSBJbXBvcnRTcGVjaWZpZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hBdHRyaWJ1dGV9IEpTWEF0dHJpYnV0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWElkZW50aWZpZXJ9IEpTWElkZW50aWZpZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hNZW1iZXJFeHByZXNzaW9ufSBKU1hNZW1iZXJFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYTmFtZXNwYWNlZE5hbWV9IEpTWE5hbWVzcGFjZWROYW1lXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTGl0ZXJhbH0gTGl0ZXJhbFxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk1lbWJlckV4cHJlc3Npb259IE1lbWJlckV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5Ob2RlfSBOb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuT2JqZWN0RXhwcmVzc2lvbn0gT2JqZWN0RXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLlByb3BlcnR5fSBQcm9wZXJ0eVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLlNwcmVhZEVsZW1lbnR9IFNwcmVhZEVsZW1lbnRcbiAqXG4gKiBAdHlwZWRlZiB7J2F1dG9tYXRpYycgfCAnY2xhc3NpYyd9IFJ1bnRpbWVcbiAqICAgSG93IHRvIHRyYW5zZm9ybSBKU1guXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiB5b3UgY2FuIGFsc28gY29uZmlndXJlIGBydW50aW1lYCwgYGltcG9ydFNvdXJjZWAsIGBwcmFnbWFgLFxuICogICA+IGFuZCBgcHJhZ21hRnJhZ2AgZnJvbSB3aXRoaW4gZmlsZXMgdGhyb3VnaCBjb21tZW50cy5cbiAqIEBwcm9wZXJ0eSB7UnVudGltZSB8IG51bGwgfCB1bmRlZmluZWR9IFtydW50aW1lPSdjbGFzc2ljJ11cbiAqICAgQ2hvb3NlIHRoZSBydW50aW1lIChkZWZhdWx0OiBgJ2NsYXNzaWMnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4UnVudGltZSB0aGVSdW50aW1lYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ltcG9ydFNvdXJjZT0ncmVhY3QnXVxuICogICBQbGFjZSB0byBpbXBvcnQgYGpzeGAsIGBqc3hzYCwgYGpzeERFVmAsIGFuZCBgRnJhZ21lbnRgIGZyb20sIHdoZW4gdGhlXG4gKiAgIGVmZmVjdGl2ZSBydW50aW1lIGlzIGF1dG9tYXRpYyAoZGVmYXVsdDogYCdyZWFjdCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hJbXBvcnRTb3VyY2UgdGhlU291cmNlYC5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogYC9qc3gtcnVudGltZWAgb3IgYC9qc3gtZGV2LXJ1bnRpbWVgIGlzIGFwcGVuZGVkIHRvIHRoaXNcbiAqICAgPiBwcm92aWRlZCBzb3VyY2UuXG4gKiAgID4gSW4gQ0pTLCB0aGF0IGNhbiByZXNvbHZlIHRvIGEgZmlsZSAoYXMgaW4gYHRoZVNvdXJjZS9qc3gtcnVudGltZS5qc2ApLFxuICogICA+IGJ1dCBmb3IgRVNNIGFuIGV4cG9ydCBtYXAgbmVlZHMgdG8gYmUgc2V0IHVwIHRvIHBvaW50IHRvIGZpbGVzOlxuICogICA+XG4gKiAgID4gYGBganNcbiAqICAgPiAvLyDigKZcbiAqICAgPiBcImV4cG9ydHNcIjoge1xuICogICA+ICAgLy8g4oCmXG4gKiAgID4gICBcIi4vanN4LXJ1bnRpbWVcIjogXCIuL3BhdGgvdG8vanN4LXJ1bnRpbWUuanNcIixcbiAqICAgPiAgIFwiLi9qc3gtZGV2LXJ1bnRpbWVcIjogXCIuL3BhdGgvdG8vanN4LXJ1bnRpbWUuanNcIlxuICogICA+ICAgLy8g4oCmXG4gKiAgID4gYGBgXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtwcmFnbWE9J1JlYWN0LmNyZWF0ZUVsZW1lbnQnXVxuICogICBJZGVudGlmaWVyIG9yIG1lbWJlciBleHByZXNzaW9uIHRvIGNhbGwgd2hlbiB0aGUgZWZmZWN0aXZlIHJ1bnRpbWUgaXNcbiAqICAgY2xhc3NpYyAoZGVmYXVsdDogYCdSZWFjdC5jcmVhdGVFbGVtZW50J2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeCBpZGVudGlmaWVyYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByYWdtYUZyYWc9J1JlYWN0LkZyYWdtZW50J11cbiAqICAgSWRlbnRpZmllciBvciBtZW1iZXIgZXhwcmVzc2lvbiB0byB1c2UgYXMgYSBzeW1ib2wgZm9yIGZyYWdtZW50cyB3aGVuIHRoZVxuICogICBlZmZlY3RpdmUgcnVudGltZSBpcyBjbGFzc2ljIChkZWZhdWx0OiBgJ1JlYWN0LkZyYWdtZW50J2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeEZyYWcgaWRlbnRpZmllcmAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbZGV2ZWxvcG1lbnQ9ZmFsc2VdXG4gKiAgIFdoZW4gaW4gdGhlIGF1dG9tYXRpYyBydW50aW1lLCB3aGV0aGVyIHRvIGltcG9ydFxuICogICBgdGhlU291cmNlL2pzeC1kZXYtcnVudGltZS5qc2AsIHVzZSBganN4REVWYCwgYW5kIHBhc3MgbG9jYXRpb24gaW5mbyB3aGVuXG4gKiAgIGF2YWlsYWJsZSAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKlxuICogICBUaGlzIGhlbHBzIGRlYnVnZ2luZyBidXQgYWRkcyBhIGxvdCBvZiBjb2RlIHRoYXQgeW91IGRvbuKAmXQgd2FudCBpblxuICogICBwcm9kdWN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbZmlsZVBhdGhdXG4gKiAgIEZpbGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKG9wdGlvbmFsKS5cbiAqXG4gKiAgIFBhc3NlZCBpbiBsb2NhdGlvbiBpbmZvIHRvIGBqc3hERVZgIHdoZW4gdXNpbmcgdGhlIGF1dG9tYXRpYyBydW50aW1lIHdpdGhcbiAqICAgYGRldmVsb3BtZW50OiB0cnVlYC5cbiAqXG4gKiBAdHlwZWRlZiBBbm5vdGF0aW9uc1xuICogICBTdGF0ZSB3aGVyZSBpbmZvIGZyb20gY29tbWVudHMgaXMgZ2F0aGVyZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2pzeF1cbiAqICAgSlNYIGlkZW50aWZpZXIgKGBwcmFnbWFgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbanN4RnJhZ11cbiAqICAgSlNYIGlkZW50aWZpZXIgb2YgZnJhZ21lbnQgKGBwcmFnbWFGcmFnYCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2pzeEltcG9ydFNvdXJjZV1cbiAqICAgV2hlcmUgdG8gaW1wb3J0IGFuIGF1dG9tYXRpYyBKU1ggcnVudGltZSBmcm9tLlxuICogQHByb3BlcnR5IHtSdW50aW1lIHwgdW5kZWZpbmVkfSBbanN4UnVudGltZV1cbiAqICAgUnVudGltZS5cbiAqXG4gKiBAdHlwZWRlZiBJbXBvcnRzXG4gKiAgIFN0YXRlIG9mIHVzZWQgaWRlbnRpZmllcnMgZnJvbSB0aGUgYXV0b21hdGljIHJ1bnRpbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtmcmFnbWVudF1cbiAqICAgU3ltYm9sIG9mIGBGcmFnbWVudGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIFN5bWJvbCBvZiBganN4YC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2pzeHNdXG4gKiAgIFN5bWJvbCBvZiBganN4c2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtqc3hERVZdXG4gKiAgIFN5bWJvbCBvZiBganN4REVWYC5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtuYW1lIGFzIGlzSWRlbnRpZmllck5hbWV9IGZyb20gJ2VzdHJlZS11dGlsLWlzLWlkZW50aWZpZXItbmFtZSdcbmltcG9ydCB7d2Fsa30gZnJvbSAnZXN0cmVlLXdhbGtlcidcblxuY29uc3QgcmVnZXggPSAvQChqc3h8anN4RnJhZ3xqc3hJbXBvcnRTb3VyY2V8anN4UnVudGltZSlcXHMrKFxcUyspL2dcblxuLyoqXG4gKiBUdXJuIEpTWCBpbiBgdHJlZWAgaW50byBmdW5jdGlvbiBjYWxsczogYDx4IC8+YCAtPiBgaCgneCcpYCFcbiAqXG4gKiAjIyMjIyMgQWxnb3JpdGhtXG4gKlxuICogSW4gYWxtb3N0IGFsbCBjYXNlcywgdGhpcyB1dGlsaXR5IGlzIHRoZSBzYW1lIGFzIHRoZSBCYWJlbCBwbHVnaW4sIGV4Y2VwdCB0aGF0XG4gKiB0aGV5IHdvcmsgb24gc2xpZ2h0bHkgZGlmZmVyZW50IHN5bnRheCB0cmVlcy5cbiAqXG4gKiBTb21lIGRpZmZlcmVuY2VzOlxuICpcbiAqICogICBubyBwdXJlIGFubm90YXRpb25zIHRoaW5nc1xuICogKiAgIGB0aGlzYCBpcyBub3QgYSBjb21wb25lbnQ6IGA8dGhpcz5gIC0+IGBoKCd0aGlzJylgLCBub3QgYGgodGhpcylgXG4gKiAqICAgbmFtZXNwYWNlcyBhcmUgc3VwcG9ydGVkOiBgPGE6YiBjOmQ+YCAtPiBgaCgnYTpiJywgeydjOmQnOiB0cnVlfSlgLFxuICogICAgIHdoaWNoIHRocm93cyBieSBkZWZhdWx0IGluIEJhYmVsIG9yIGNhbiBiZSB0dXJuZWQgb24gd2l0aCBgdGhyb3dJZk5hbWVzcGFjZWBcbiAqICogICBubyBgdXNlU3ByZWFkYCwgYHVzZUJ1aWx0SW5zYCwgb3IgYGZpbHRlcmAgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICogICBUcmVlIHRvIHRyYW5zZm9ybSAodHlwaWNhbGx5IGBQcm9ncmFtYCkuXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSnN4KHRyZWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29uZmlnID0gb3B0aW9ucyB8fCB7fVxuICBsZXQgYXV0b21hdGljID0gY29uZmlnLnJ1bnRpbWUgPT09ICdhdXRvbWF0aWMnXG4gIC8qKiBAdHlwZSB7QW5ub3RhdGlvbnN9ICovXG4gIGNvbnN0IGFubm90YXRpb25zID0ge31cbiAgLyoqIEB0eXBlIHtJbXBvcnRzfSAqL1xuICBjb25zdCBpbXBvcnRzID0ge31cblxuICB3YWxrKHRyZWUsIHtcbiAgICBlbnRlcihub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnUHJvZ3JhbScpIHtcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBub2RlLmNvbW1lbnRzIHx8IFtdXG4gICAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSAwXG5cbiAgICAgICAgICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKGNvbW1lbnRzW2luZGV4XS52YWx1ZSlcblxuICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG1hdGNoWzFdYCBpcyBhbHdheXMgYSBrZXksIGBtYXRjaFsyXWAgd2hlblxuICAgICAgICAgICAgLy8gcnVudGltZSBpcyBjaGVja2VkIGxhdGVyLlxuICAgICAgICAgICAgYW5ub3RhdGlvbnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl1cbiAgICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhjb21tZW50c1tpbmRleF0udmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUpIHtcbiAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4UnVudGltZSA9PT0gJ2F1dG9tYXRpYycpIHtcbiAgICAgICAgICAgIGF1dG9tYXRpYyA9IHRydWVcblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYEBqc3hgIHByYWdtYSB3LyBhdXRvbWF0aWMgcnVudGltZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hGcmFnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBgQGpzeEZyYWdgIHByYWdtYSB3LyBhdXRvbWF0aWMgcnVudGltZSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5ub3RhdGlvbnMuanN4UnVudGltZSA9PT0gJ2NsYXNzaWMnKSB7XG4gICAgICAgICAgICBhdXRvbWF0aWMgPSBmYWxzZVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4SW1wb3J0U291cmNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBgQGpzeEltcG9ydFNvdXJjZWAgdy8gY2xhc3NpYyBydW50aW1lJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYGpzeFJ1bnRpbWVgIGAnICtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5qc3hSdW50aW1lICtcbiAgICAgICAgICAgICAgICAnYCwgZXhwZWN0ZWQgYGF1dG9tYXRpY2Agb3IgYGNsYXNzaWNgJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBsZWF2ZShub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnUHJvZ3JhbScpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxJbXBvcnRTcGVjaWZpZXI+fSAqL1xuICAgICAgICBjb25zdCBzcGVjaWZpZXJzID0gW11cblxuICAgICAgICBpZiAoaW1wb3J0cy5mcmFnbWVudCkge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnRnJhZ21lbnQnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX0ZyYWdtZW50J31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4KSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3gnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeCd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeHMpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2pzeHMnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeHMnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3hERVYpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2pzeERFVid9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4REVWJ31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBpbmplY3RJbmRleCA9IDBcblxuICAgICAgICAgIHdoaWxlIChpbmplY3RJbmRleCA8IG5vZGUuYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5ib2R5W2luamVjdEluZGV4XVxuXG4gICAgICAgICAgICBpZiAoJ2RpcmVjdGl2ZScgaW4gY2hpbGQgJiYgY2hpbGQuZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIGluamVjdEluZGV4KytcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5ib2R5LnNwbGljZShpbmplY3RJbmRleCwgMCwge1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgICAgIHNwZWNpZmllcnMsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgICAoYW5ub3RhdGlvbnMuanN4SW1wb3J0U291cmNlIHx8XG4gICAgICAgICAgICAgICAgICBjb25maWcuaW1wb3J0U291cmNlIHx8XG4gICAgICAgICAgICAgICAgICAncmVhY3QnKSArXG4gICAgICAgICAgICAgICAgKGNvbmZpZy5kZXZlbG9wbWVudCA/ICcvanN4LWRldi1ydW50aW1lJyA6ICcvanN4LXJ1bnRpbWUnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmIG5vZGUudHlwZSAhPT0gJ0pTWEZyYWdtZW50Jykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxFeHByZXNzaW9uPn0gKi9cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgYGNoaWxkcmVuYC5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4XVxuXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgaWYgKGNoaWxkLmV4cHJlc3Npb24udHlwZSAhPT0gJ0pTWEVtcHR5RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuZXhwcmVzc2lvbilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gJ0pTWFRleHQnKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGlsZC52YWx1ZVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0YWJzIHcvIHNwYWNlcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgJyAnKVxuICAgICAgICAgICAgLy8gVXNlIGxpbmUgZmVlZHMsIGRyb3Agc3BhY2VzIGFyb3VuZCB0aGVtLlxuICAgICAgICAgICAgLnJlcGxhY2UoLyAqKFxccj9cXG58XFxyKSAqL2csICdcXG4nKVxuICAgICAgICAgICAgLy8gQ29sbGFwc2UgbXVsdGlwbGUgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rL2csICdcXG4nKVxuICAgICAgICAgICAgLy8gRHJvcCBmaW5hbCBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgICAvLyBEcm9wIGZpcnN0IGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcbisvLCAnJylcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgbGluZSBmZWVkcyB3aXRoIHNwYWNlcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyAnKVxuXG4gICAgICAgICAgLy8gSWdub3JlIGNvbGxhcHNpYmxlIHRleHQuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWV9XG4gICAgICAgICAgICBjcmVhdGUoY2hpbGQsIHRleHQpXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRleHQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIGNoaWxkLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJlxuICAgICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYRnJhZ21lbnQnICYmXG4gICAgICAgICAgICAgIGNoaWxkLnR5cGUgIT09ICdKU1hTcHJlYWRDaGlsZCdcbiAgICAgICAgICApXG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgICAgIGxldCBuYW1lXG4gICAgICAvKiogQHR5cGUge0FycmF5PFByb3BlcnR5IHwgU3ByZWFkRWxlbWVudD59ICovXG4gICAgICBjb25zdCBmaWVsZHMgPSBbXVxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxFeHByZXNzaW9uPn0gKi9cbiAgICAgIGxldCBwYXJhbWV0ZXJzID0gW11cbiAgICAgIC8qKiBAdHlwZSB7RXhwcmVzc2lvbiB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBrZXlcblxuICAgICAgLy8gRG8gdGhlIHN0dWZmIG5lZWRlZCBmb3IgZWxlbWVudHMuXG4gICAgICBpZiAobm9kZS50eXBlID09PSAnSlNYRWxlbWVudCcpIHtcbiAgICAgICAgbmFtZSA9IHRvSWRlbnRpZmllcihub2RlLm9wZW5pbmdFbGVtZW50Lm5hbWUpXG5cbiAgICAgICAgLy8gSWYgdGhlIG5hbWUgY291bGQgYmUgYW4gaWRlbnRpZmllciwgYnV0IHN0YXJ0IHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyLFxuICAgICAgICAvLyBpdOKAmXMgbm90IGEgY29tcG9uZW50LlxuICAgICAgICBpZiAobmFtZS50eXBlID09PSAnSWRlbnRpZmllcicgJiYgL15bYS16XS8udGVzdChuYW1lLm5hbWUpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbmFtZS5uYW1lfVxuICAgICAgICAgIGNyZWF0ZShuYW1lLCBuZXh0KVxuICAgICAgICAgIG5hbWUgPSBuZXh0XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCBzcHJlYWRcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUub3BlbmluZ0VsZW1lbnQuYXR0cmlidXRlc1xuICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgIC8vIFBsYWNlIHByb3BzIGluIHRoZSByaWdodCBvcmRlciwgYmVjYXVzZSB3ZSBtaWdodCBoYXZlIGR1cGxpY2F0ZXNcbiAgICAgICAgLy8gaW4gdGhlbSBhbmQgd2hhdOKAmXMgc3ByZWFkIGluLlxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleF1cblxuICAgICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0pTWFNwcmVhZEF0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuYXJndW1lbnQudHlwZSA9PT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKC4uLmF0dHJpYnV0ZS5hcmd1bWVudC5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2goe3R5cGU6ICdTcHJlYWRFbGVtZW50JywgYXJndW1lbnQ6IGF0dHJpYnV0ZS5hcmd1bWVudH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwcmVhZCA9IHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHRvUHJvcGVydHkoYXR0cmlidXRlKVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGF1dG9tYXRpYyAmJlxuICAgICAgICAgICAgICBwcm9wLmtleS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgICAgcHJvcC5rZXkubmFtZSA9PT0gJ2tleSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoc3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGBrZXlgIHRvIGNvbWUgYmVmb3JlIGFueSBzcHJlYWQgZXhwcmVzc2lvbnMnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wLnZhbHVlXG5cbiAgICAgICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgIT09ICdBc3NpZ25tZW50UGF0dGVybicgJiZcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgIT09ICdBcnJheVBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnT2JqZWN0UGF0dGVybicgJiZcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgIT09ICdSZXN0RWxlbWVudCdcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGtleSA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaChwcm9wKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8g4oCmYW5kIGZyYWdtZW50cy5cbiAgICAgIGVsc2UgaWYgKGF1dG9tYXRpYykge1xuICAgICAgICBpbXBvcnRzLmZyYWdtZW50ID0gdHJ1ZVxuICAgICAgICBuYW1lID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19GcmFnbWVudCd9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gdG9NZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIGFubm90YXRpb25zLmpzeEZyYWcgfHwgY29uZmlnLnByYWdtYUZyYWcgfHwgJ1JlYWN0LkZyYWdtZW50J1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChhdXRvbWF0aWMpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnY2hpbGRyZW4nfSxcbiAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgPyB7dHlwZTogJ0FycmF5RXhwcmVzc2lvbicsIGVsZW1lbnRzOiBjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA6IGNoaWxkcmVuWzBdLFxuICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbWV0ZXJzID0gY2hpbGRyZW5cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gICAgICBsZXQgY2FsbGVlXG5cbiAgICAgIGlmIChhdXRvbWF0aWMpIHtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHt0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsIHByb3BlcnRpZXM6IGZpZWxkc30pXG5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChrZXkpXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICd1bmRlZmluZWQnfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzU3RhdGljQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPiAxXG5cbiAgICAgICAgaWYgKGNvbmZpZy5kZXZlbG9wbWVudCkge1xuICAgICAgICAgIGltcG9ydHMuanN4REVWID0gdHJ1ZVxuICAgICAgICAgIGNhbGxlZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgIG5hbWU6ICdfanN4REVWJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IGlzU3RhdGljQ2hpbGRyZW59KVxuXG4gICAgICAgICAgLyoqIEB0eXBlIHtPYmplY3RFeHByZXNzaW9ufSAqL1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnZmlsZU5hbWUnfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbmZpZy5maWxlUGF0aCB8fCAnPHNvdXJjZS5qcz4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgICAgICBzb3VyY2UucHJvcGVydGllcy5wdXNoKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdsaW5lTnVtYmVyJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBub2RlLmxvYy5zdGFydC5saW5lfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdjb2x1bW5OdW1iZXInfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5vZGUubG9jLnN0YXJ0LmNvbHVtbiArIDF9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goc291cmNlLCB7dHlwZTogJ1RoaXNFeHByZXNzaW9uJ30pXG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGltcG9ydHMuanN4cyA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeHMnfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcG9ydHMuanN4ID0gdHJ1ZVxuICAgICAgICAgIGNhbGxlZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4J31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xhc3NpYy5cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQoe3R5cGU6ICdPYmplY3RFeHByZXNzaW9uJywgcHJvcGVydGllczogZmllbGRzfSlcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQoe3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG51bGx9KVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGVlID0gdG9NZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIGFubm90YXRpb25zLmpzeCB8fCBjb25maWcucHJhZ21hIHx8ICdSZWFjdC5jcmVhdGVFbGVtZW50J1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHBhcmFtZXRlcnMudW5zaGlmdChuYW1lKVxuICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgY29uc3QgY2FsbCA9IHtcbiAgICAgICAgdHlwZTogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgY2FsbGVlLFxuICAgICAgICBhcmd1bWVudHM6IHBhcmFtZXRlcnMsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgICAgfVxuICAgICAgY3JlYXRlKG5vZGUsIGNhbGwpXG4gICAgICB0aGlzLnJlcGxhY2UoY2FsbClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogVHVybiBhIEpTWCBhdHRyaWJ1dGUgaW50byBhIEphdmFTY3JpcHQgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtKU1hBdHRyaWJ1dGV9IG5vZGVcbiAqICAgSlNYIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eX1cbiAqICAgSlMgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHRvUHJvcGVydHkobm9kZSkge1xuICAvKiogQHR5cGUge0V4cHJlc3Npb259ICovXG4gIGxldCB2YWx1ZVxuXG4gIGlmIChub2RlLnZhbHVlKSB7XG4gICAgaWYgKG5vZGUudmFsdWUudHlwZSA9PT0gJ0pTWEV4cHJlc3Npb25Db250YWluZXInKSB7XG4gICAgICBjb25zdCB2YWx1ZUV4cHJlc3Npb24gPSBub2RlLnZhbHVlLmV4cHJlc3Npb25cbiAgICAgIGFzc2VydChcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uLnR5cGUgIT09ICdKU1hFbXB0eUV4cHJlc3Npb24nLFxuICAgICAgICAnYEpTWEVtcHR5RXhwcmVzc2lvbmAgaXMgbm90IGFsbG93ZWQgaW4gcHJvcHMuJ1xuICAgICAgKVxuICAgICAgdmFsdWUgPSB2YWx1ZUV4cHJlc3Npb25cbiAgICB9XG4gICAgLy8gTGl0ZXJhbCBvciBjYWxsIGV4cHJlc3Npb24uXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBub2RlVmFsdWUgPSBub2RlLnZhbHVlXG4gICAgICBhc3NlcnQoXG4gICAgICAgIG5vZGVWYWx1ZS50eXBlICE9PSAnSlNYRWxlbWVudCcgJiYgbm9kZVZhbHVlLnR5cGUgIT09ICdKU1hGcmFnbWVudCcsXG4gICAgICAgICdKU1h7RWxlbWVudCxGcmFnbWVudH0gYXJlIGFscmVhZHkgY29tcGlsZWQgdG8gYENhbGxFeHByZXNzaW9uYCdcbiAgICAgIClcbiAgICAgIHZhbHVlID0gbm9kZVZhbHVlXG4gICAgICBkZWxldGUgdmFsdWUucmF3XG4gICAgfVxuICB9XG4gIC8vIEJvb2xlYW4gcHJvcC5cbiAgZWxzZSB7XG4gICAgdmFsdWUgPSB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogdHJ1ZX1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvcGVydHl9ICovXG4gIGNvbnN0IHJlcGxhY2VtZW50ID0ge1xuICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAga2V5OiB0b0lkZW50aWZpZXIobm9kZS5uYW1lKSxcbiAgICB2YWx1ZSxcbiAgICBraW5kOiAnaW5pdCcsXG4gICAgbWV0aG9kOiBmYWxzZSxcbiAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgIGNvbXB1dGVkOiBmYWxzZVxuICB9XG4gIGNyZWF0ZShub2RlLCByZXBsYWNlbWVudClcbiAgcmV0dXJuIHJlcGxhY2VtZW50XG59XG5cbi8qKlxuICogVHVybiBhIEpTWCBpZGVudGlmaWVyIGludG8gYSBub3JtYWwgSlMgaWRlbnRpZmllci5cbiAqXG4gKiBAcGFyYW0ge0pTWElkZW50aWZpZXIgfCBKU1hNZW1iZXJFeHByZXNzaW9uIHwgSlNYTmFtZXNwYWNlZE5hbWV9IG5vZGVcbiAqICAgSlNYIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJucyB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufVxuICogICBKUyBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiB0b0lkZW50aWZpZXIobm9kZSkge1xuICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgbGV0IHJlcGxhY2VcblxuICBpZiAobm9kZS50eXBlID09PSAnSlNYTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAvLyBgcHJvcGVydHlgIGlzIGFsd2F5cyBhIGBKU1hJZGVudGlmaWVyYCwgYnV0IGl0IGNvdWxkIGJlIHNvbWV0aGluZyB0aGF0XG4gICAgLy8gaXNu4oCZdCBhbiBFUyBpZGVudGlmaWVyIG5hbWUuXG4gICAgY29uc3QgaWQgPSB0b0lkZW50aWZpZXIobm9kZS5wcm9wZXJ0eSlcbiAgICByZXBsYWNlID0ge1xuICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgb2JqZWN0OiB0b0lkZW50aWZpZXIobm9kZS5vYmplY3QpLFxuICAgICAgcHJvcGVydHk6IGlkLFxuICAgICAgY29tcHV0ZWQ6IGlkLnR5cGUgPT09ICdMaXRlcmFsJyxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdKU1hOYW1lc3BhY2VkTmFtZScpIHtcbiAgICByZXBsYWNlID0ge1xuICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgdmFsdWU6IG5vZGUubmFtZXNwYWNlLm5hbWUgKyAnOicgKyBub2RlLm5hbWUubmFtZVxuICAgIH1cbiAgfVxuICAvLyBNdXN0IGJlIGBKU1hJZGVudGlmaWVyYC5cbiAgZWxzZSB7XG4gICAgcmVwbGFjZSA9IGlzSWRlbnRpZmllck5hbWUobm9kZS5uYW1lKVxuICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBub2RlLm5hbWV9XG4gICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBub2RlLm5hbWV9XG4gIH1cblxuICBjcmVhdGUobm9kZSwgcmVwbGFjZSlcbiAgcmV0dXJuIHJlcGxhY2Vcbn1cblxuLyoqXG4gKiBUdXJuIGEgZG90dGVkIHN0cmluZyBpbnRvIGEgbWVtYmVyIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiAgIElkZW50aWZpZXJzLlxuICogQHJldHVybnMge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn1cbiAqICAgRXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gdG9NZW1iZXJFeHByZXNzaW9uKGlkKSB7XG4gIGNvbnN0IGlkZW50aWZpZXJzID0gaWQuc3BsaXQoJy4nKVxuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHJlc3VsdFxuXG4gIHdoaWxlICgrK2luZGV4IDwgaWRlbnRpZmllcnMubGVuZ3RoKSB7XG4gICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbH0gKi9cbiAgICBjb25zdCBwcm9wID0gaXNJZGVudGlmaWVyTmFtZShpZGVudGlmaWVyc1tpbmRleF0pXG4gICAgICA/IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6IGlkZW50aWZpZXJzW2luZGV4XX1cbiAgICAgIDoge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IGlkZW50aWZpZXJzW2luZGV4XX1cbiAgICByZXN1bHQgPSByZXN1bHRcbiAgICAgID8ge1xuICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICBvYmplY3Q6IHJlc3VsdCxcbiAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICBjb21wdXRlZDogQm9vbGVhbihpbmRleCAmJiBwcm9wLnR5cGUgPT09ICdMaXRlcmFsJyksXG4gICAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIDogcHJvcFxuICB9XG5cbiAgYXNzZXJ0KHJlc3VsdCwgJ2Fsd2F5cyBhIHJlc3VsdCcpXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBJbmhlcml0IHNvbWUgZmllbGRzIGZyb20gYGZyb21gIGludG8gYHRvYC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGZyb21cbiAqICAgTm9kZSB0byBpbmhlcml0IGZyb20uXG4gKiBAcGFyYW0ge05vZGV9IHRvXG4gKiAgIE5vZGUgdG8gYWRkIHRvLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKGZyb20sIHRvKSB7XG4gIGNvbnN0IGZpZWxkcyA9IFsnc3RhcnQnLCAnZW5kJywgJ2xvYycsICdyYW5nZScsICdjb21tZW50cyddXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBmaWVsZHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaW5kZXhdXG4gICAgaWYgKGZpZWxkIGluIGZyb20pIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluZGV4YWJsZS5cbiAgICAgIHRvW2ZpZWxkXSA9IGZyb21bZmllbGRdXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ })

};
;