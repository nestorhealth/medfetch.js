"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oniguruma-to-es@3.1.1";
exports.ids = ["vendor-chunks/oniguruma-to-es@3.1.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmulatedRegExp: () => (/* binding */ EmulatedRegExp),\n/* harmony export */   toOnigurumaAst: () => (/* binding */ toOnigurumaAst),\n/* harmony export */   toRegExp: () => (/* binding */ toRegExp),\n/* harmony export */   toRegExpDetails: () => (/* binding */ toRegExpDetails)\n/* harmony export */ });\n/* harmony import */ var emoji_regex_xs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! emoji-regex-xs */ \"(rsc)/../node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs\");\n/* harmony import */ var regex_internals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regex/internals */ \"(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/internals.js\");\n/* harmony import */ var regex_recursion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regex-recursion */ \"(rsc)/../node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\");\n// src/utils.js\nvar cp = String.fromCodePoint;\nvar r = String.raw;\nvar envFlags = {\n  flagGroups: (() => {\n    try {\n      new RegExp(\"(?i:)\");\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n  unicodeSets: (() => {\n    try {\n      new RegExp(\"\", \"v\");\n    } catch {\n      return false;\n    }\n    return true;\n  })()\n};\nenvFlags.literalHyphenIncorrectlyCreatesRange = (() => {\n  if (!envFlags.unicodeSets) {\n    return false;\n  }\n  try {\n    new RegExp(r`[\\d\\-a]`, \"v\");\n  } catch {\n    return true;\n  }\n  return false;\n})();\nfunction getNewCurrentFlags(current, { enable, disable }) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)\n  };\n}\nfunction getOrInsert(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? \"Value expected\");\n  }\n  return value;\n}\n\n// src/options.js\nvar EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018\n};\nvar Target = (\n  /** @type {const} */\n  {\n    auto: \"auto\",\n    ES2025: \"ES2025\",\n    ES2024: \"ES2024\",\n    ES2018: \"ES2018\"\n  }\n);\nfunction getOptions(options) {\n  if (options?.target !== void 0 && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`);\n  }\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: \"default\",\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: \"\",\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // Delay regex construction until first use if the transpiled pattern is at least this length.\n    lazyCompileLength: Infinity,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: \"auto\",\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`–`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...options?.rules\n    }\n  };\n  if (opts.target === \"auto\") {\n    opts.target = envFlags.flagGroups ? \"ES2025\" : envFlags.unicodeSets ? \"ES2024\" : \"ES2018\";\n  }\n  return opts;\n}\n\n// src/unicode.js\nvar CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([\n  cp(304),\n  // İ\n  cp(305)\n  // ı\n]);\nfunction getIgnoreCaseMatchChars(char) {\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = /* @__PURE__ */ new Set();\n  const lower = char.toLowerCase();\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\nvar JsUnicodeProperties = new Set(\n  `C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/)\n);\nvar JsUnicodePropertiesMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\nvar JsUnicodePropertiesOfStrings = /* @__PURE__ */ new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  \"Basic_Emoji\",\n  \"Emoji_Keycap_Sequence\",\n  \"RGI_Emoji\",\n  \"RGI_Emoji_Flag_Sequence\",\n  \"RGI_Emoji_Modifier_Sequence\",\n  \"RGI_Emoji_Tag_Sequence\",\n  \"RGI_Emoji_ZWJ_Sequence\"\n]);\nvar JsUnicodePropertiesOfStringsMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\nvar LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([\n  [\"s\", cp(383)],\n  // s, ſ\n  [cp(383), \"s\"]\n  // ſ, s\n]);\nvar LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([\n  [cp(223), cp(7838)],\n  // ß, ẞ\n  [cp(107), cp(8490)],\n  // k, K (Kelvin)\n  [cp(229), cp(8491)],\n  // å, Å (Angstrom)\n  [cp(969), cp(8486)]\n  // ω, Ω (Ohm)\n]);\nvar LowerToTitleCaseMap = new Map([\n  titleEntry(453),\n  titleEntry(456),\n  titleEntry(459),\n  titleEntry(498),\n  ...titleRange(8072, 8079),\n  ...titleRange(8088, 8095),\n  ...titleRange(8104, 8111),\n  titleEntry(8124),\n  titleEntry(8140),\n  titleEntry(8188)\n]);\nvar PosixClassesMap = /* @__PURE__ */ new Map([\n  [\"alnum\", r`[\\p{Alpha}\\p{Nd}]`],\n  [\"alpha\", r`\\p{Alpha}`],\n  [\"ascii\", r`\\p{ASCII}`],\n  [\"blank\", r`[\\p{Zs}\\t]`],\n  [\"cntrl\", r`\\p{cntrl}`],\n  [\"digit\", r`\\p{Nd}`],\n  [\"graph\", r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  [\"lower\", r`\\p{Lower}`],\n  [\"print\", r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  [\"punct\", r`[\\p{P}\\p{S}]`],\n  // New value from Oniguruma 6.9.9\n  [\"space\", r`\\p{space}`],\n  [\"upper\", r`\\p{Upper}`],\n  [\"word\", r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  [\"xdigit\", r`\\p{AHex}`]\n]);\nvar PosixProperties = /* @__PURE__ */ new Set([\n  \"alnum\",\n  \"blank\",\n  \"graph\",\n  \"print\",\n  \"word\",\n  \"xdigit\"\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\nfunction range(start, end) {\n  const range2 = [];\n  for (let i = start; i <= end; i++) {\n    range2.push(i);\n  }\n  return range2;\n}\nfunction slug(name) {\n  return name.replace(/[- _]+/g, \"\").toLowerCase();\n}\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\nfunction titleRange(start, end) {\n  return range(start, end).map((codePoint) => titleEntry(codePoint));\n}\nvar UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([\n  \"Lower\",\n  \"Lowercase\",\n  \"Upper\",\n  \"Uppercase\",\n  \"Ll\",\n  \"Lowercase_Letter\",\n  \"Lt\",\n  \"Titlecase_Letter\",\n  \"Lu\",\n  \"Uppercase_Letter\"\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\n// src/tokenize.js\nvar TokenTypes = (\n  /** @type {const} */\n  {\n    Alternator: \"Alternator\",\n    Assertion: \"Assertion\",\n    Backreference: \"Backreference\",\n    Character: \"Character\",\n    CharacterClassClose: \"CharacterClassClose\",\n    CharacterClassHyphen: \"CharacterClassHyphen\",\n    CharacterClassIntersector: \"CharacterClassIntersector\",\n    CharacterClassOpen: \"CharacterClassOpen\",\n    CharacterSet: \"CharacterSet\",\n    Directive: \"Directive\",\n    GroupClose: \"GroupClose\",\n    GroupOpen: \"GroupOpen\",\n    Subroutine: \"Subroutine\",\n    Quantifier: \"Quantifier\",\n    // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n    VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n    // Intermediate representation not included in results\n    EscapedNumber: \"EscapedNumber\"\n  }\n);\nvar TokenCharacterSetKinds = {\n  any: \"any\",\n  digit: \"digit\",\n  dot: \"dot\",\n  hex: \"hex\",\n  non_newline: \"non_newline\",\n  posix: \"posix\",\n  property: \"property\",\n  space: \"space\",\n  word: \"word\"\n};\nvar TokenDirectiveKinds = {\n  flags: \"flags\",\n  keep: \"keep\"\n};\nvar TokenGroupKinds = {\n  absent_repeater: \"absent_repeater\",\n  atomic: \"atomic\",\n  capturing: \"capturing\",\n  group: \"group\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\"\n};\nvar EscapeCharCodes = /* @__PURE__ */ new Map([\n  [\"a\", 7],\n  // alert/bell (Not available in JS)\n  [\"b\", 8],\n  // backspace (only in char classes)\n  [\"e\", 27],\n  // escape (Not available in JS)\n  [\"f\", 12],\n  // form feed\n  [\"n\", 10],\n  // line feed\n  [\"r\", 13],\n  // carriage return\n  [\"t\", 9],\n  // horizontal tab\n  [\"v\", 11]\n  // vertical tab\n]);\nvar charClassOpenPattern = r`\\[\\^?`;\nvar sharedEscapesPattern = `${// Control char\n\"c.? | C(?:-.?)?\"}|${// Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n// `\\p{gc=L}` are invalid\nr`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`}|${// Hex encoded byte sequence; attempt match before other `\\xNN` hex char\nr`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`}|${// Hex char\nr`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`}|${// Enclosed octal code point\nr`o\\{[^\\}]*\\}?`}|${// Escaped number\nr`\\d{1,3}`}`;\nvar quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nvar tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*\n  )?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nvar charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nfunction tokenize(pattern, flags = \"\", rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    // `ONIG_OPTION_SINGLELINE`\n    singleline: false,\n    ...rules\n  };\n  if (typeof pattern !== \"string\") {\n    throw new Error(\"String expected as pattern\");\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes(\"x\");\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {\n      xStack.pop();\n    },\n    pushModX(isXOn) {\n      xStack.push(isXOn);\n    },\n    replaceCurrentModX(isXOn) {\n      xStack[xStack.length - 1] = isXOn;\n    },\n    singleline: rules.singleline\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while (match = tokenRe.exec(pattern)) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== void 0) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach((t) => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === \"(\") {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  tokens = tokens.map(\n    (t) => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes(\"i\"),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes(\"m\"),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes(\"D\"),\n      spaceIsAscii: flags.includes(\"S\"),\n      wordIsAscii: flags.includes(\"W\")\n    },\n    rules\n  };\n}\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1] = m;\n  if (m0 === \"[\") {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex\n    };\n  }\n  if (m0 === \"\\\\\") {\n    if (\"AbBGzZ\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m\n        })\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m)\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m)\n      };\n    }\n    if (m1 === \"K\") {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep\n        })\n      };\n    }\n    if (m1 === \"N\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline\n        })\n      };\n    }\n    if (m1 === \"O\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any\n        })\n      };\n    }\n    if (\"RX\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m\n        })\n      };\n    }\n    if (\"yY\".includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    const result = createTokenForSharedEscape(m, { inCharClass: false });\n    return Array.isArray(result) ? { tokens: result } : { token: result };\n  }\n  if (m0 === \"(\") {\n    if (m === \"(*\") {\n      throw new Error(`Unsupported named callout \"${m}\"`);\n    }\n    if (m === \"(?{\") {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    if (m === \"(?#\") {\n      if (pattern[lastIndex] !== \")\") {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1\n      };\n    }\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: createTokenForFlagMod(m, context)\n      };\n    }\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      m === \"(\" && !context.captureGroup || // Noncapturing group\n      m === \"(?:\"\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group\n        })\n      };\n    }\n    if (m === \"(?>\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic\n        })\n      };\n    }\n    if (m === \"(?=\" || m === \"(?!\" || m === \"(?<=\" || m === \"(?<!\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m[2] === \"<\" ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith(\"!\")\n        })\n      };\n    }\n    if (m === \"(\" && context.captureGroup || m.startsWith(\"(?<\") && m.endsWith(\">\") || m.startsWith(\"(?'\") && m.endsWith(\"'\")) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing\n        // Will add `number` prop in a second pass\n      });\n      if (m !== \"(\") {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token\n      };\n    }\n    if (m.startsWith(\"(?~\")) {\n      if (m === \"(?~|\") {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater\n        })\n      };\n    }\n    if (m === \"(?(\") {\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === \")\") {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m)\n    };\n  }\n  if (m === \"#\" && context.getCurrentModX()) {\n    const end = pattern.indexOf(\"\\n\", lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex\n    };\n  }\n  if (m === \".\") {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot\n      })\n    };\n  }\n  if (m === \"^\" || m === \"$\") {\n    const kind = context.singleline ? {\n      \"^\": r`\\A`,\n      \"$\": r`\\Z`\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind\n      })\n    };\n  }\n  if (m === \"|\") {\n    return {\n      token: createToken(TokenTypes.Alternator, m)\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m)\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0)\n    })\n  };\n}\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === \"^\"\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while (match = charClassTokenRe.exec(pattern)) {\n    const m = match[0];\n    if (m[0] === \"[\" && m[1] !== \":\") {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === \"^\"\n      }));\n    } else if (m === \"]\") {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length\n  };\n}\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === \"\\\\\") {\n    return createTokenForSharedEscape(raw, { inCharClass: true });\n  }\n  if (raw[0] === \"[\") {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name\n    });\n  }\n  if (raw === \"-\") {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === \"&&\") {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0)\n  });\n}\nfunction createTokenForSharedEscape(raw, { inCharClass }) {\n  const char1 = raw[1];\n  if (char1 === \"c\" || char1 === \"C\") {\n    return createTokenForControlChar(raw);\n  }\n  if (\"dDhHsSwW\".includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map((hex) => parseInt(hex, 16));\n      const decoded = new TextDecoder(\"utf-8\", {\n        ignoreBOM: true,\n        fatal: true\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map((char) => {\n        const raw2 = [...encoder.encode(char)].map((byte) => `\\\\x${byte.toString(16)}`).join(\"\");\n        return createToken(TokenTypes.Character, raw2, {\n          value: char.codePointAt(0)\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === \"u\" || char1 === \"x\") {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw)\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1)\n    });\n  }\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass\n    });\n  }\n  if (raw === \"\\\\\") {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  if (char1 === \"M\") {\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1)\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data\n  };\n}\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === \"c\" ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64\n  });\n}\nfunction createTokenForFlagMod(raw, context) {\n  let { on, off } = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw).groups;\n  off ??= \"\";\n  const isXOn = (context.getCurrentModX() || on.includes(\"x\")) && !off.includes(\"x\");\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  if (raw.endsWith(\")\")) {\n    context.replaceCurrentModX(isXOn);\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges\n    });\n  }\n  if (raw.endsWith(\":\")) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === \"{\") {\n    const { min, max } = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 1e5;\n    if (+min > limit || +max > limit) {\n      throw new Error(\"Quantifier value unsupported in Oniguruma\");\n    }\n    data.min = +min;\n    data.max = max === void 0 ? +min : max === \"\" ? Infinity : +max;\n    data.greedy = !raw.endsWith(\"?\");\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === \"+\" ? 1 : 0;\n    data.max = raw[0] === \"?\" ? 1 : Infinity;\n    data.greedy = raw[1] !== \"?\";\n    data.possessive = raw[1] === \"+\";\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      \"d\": TokenCharacterSetKinds.digit,\n      \"h\": TokenCharacterSetKinds.hex,\n      // Not available in JS\n      \"s\": TokenCharacterSetKinds.space,\n      // Different than JS\n      \"w\": TokenCharacterSetKinds.word\n    }[lower],\n    negate: raw[1] !== lower\n  });\n}\nfunction createTokenForUnicodeProperty(raw) {\n  const { p, neg, value } = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = p === \"P\" && !neg || p === \"p\" && !!neg;\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value\n  });\n}\nfunction getFlagPropsForToken(flags) {\n  const obj = {};\n  if (flags.includes(\"i\")) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes(\"m\")) {\n    obj.dotAll = true;\n  }\n  if (flags.includes(\"x\")) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\nfunction getValidatedHexCharCode(raw) {\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  const hex = raw[2] === \"{\" ? /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex : raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\nfunction splitEscapedNumToken(token, numCaptures) {\n  const { raw, inCharClass } = token;\n  const value = raw.slice(1);\n  if (!inCharClass && // Single digit 1-9 outside a char class is always treated as a backref\n  (value !== \"0\" && value.length === 1 || // Leading 0 makes it octal; backrefs can't include following literal digits\n  value[0] !== \"0\" && +value <= numCaptures)) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value2;\n    if (i === 0 && m !== \"8\" && m !== \"9\") {\n      value2 = parseInt(m, 8);\n      if (value2 > 127) {\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value2 = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? \"\\\\\" : \"\") + m, {\n      value: value2\n    }));\n  }\n  return tokens;\n}\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\n// src/utils-ast.js\nfunction hasOnlyChild({ alternatives }, kidFn) {\n  return alternatives.length === 1 && alternatives[0].elements.length === 1 && (!kidFn || kidFn(alternatives[0].elements[0]));\n}\nfunction isAlwaysZeroLength({ type }) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive;\n}\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    AstTypes.Character,\n    AstTypes.CharacterClass,\n    AstTypes.CharacterSet\n  ];\n  return types.includes(node.type) || node.type === AstTypes.Quantifier && node.min && types.includes(node.element.type);\n}\nfunction isConsumptiveGroup({ type }) {\n  return type === AstTypes.CapturingGroup || type === AstTypes.Group;\n}\nfunction isLookaround({ type, kind }) {\n  return type === AstTypes.Assertion && (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind);\n}\n\n// src/traverse.js\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path2 = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, \"Container expected\").splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, \"Container expected\").splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, \"Container expected\").splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      }\n    };\n    const visitorKey = getAstTypeAliases(node).find((key2) => !!visitor[key2]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === \"function\" ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path2, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, \"pattern\");\n          traverseNode(node.flags, node, \"flags\");\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.AbsentFunction:\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, \"min\");\n          traverseNode(node.max, node, \"max\");\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, \"element\");\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path2, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\nvar AstTypeAliases = {\n  AnyGroup: \"AnyGroup\",\n  AnyNode: \"AnyNode\"\n};\nfunction getAstTypeAliases(node) {\n  const types = [AstTypeAliases.AnyNode];\n  if (isConsumptiveGroup(node) || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(node.type);\n  return types;\n}\nfunction setParent(node, parent) {\n  if (\"parent\" in parent) {\n    node.parent = parent;\n  }\n}\n\n// src/parse.js\nvar AstTypes = {\n  AbsentFunction: \"AbsentFunction\",\n  Alternative: \"Alternative\",\n  Assertion: \"Assertion\",\n  Backreference: \"Backreference\",\n  CapturingGroup: \"CapturingGroup\",\n  Character: \"Character\",\n  CharacterClass: \"CharacterClass\",\n  CharacterClassIntersection: \"CharacterClassIntersection\",\n  CharacterClassRange: \"CharacterClassRange\",\n  CharacterSet: \"CharacterSet\",\n  Directive: \"Directive\",\n  Flags: \"Flags\",\n  Group: \"Group\",\n  Pattern: \"Pattern\",\n  Quantifier: \"Quantifier\",\n  Regex: \"Regex\",\n  Subroutine: \"Subroutine\",\n  VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: \"Recursion\"\n};\nvar AstAbsentFunctionKinds = {\n  // See <github.com/slevithan/oniguruma-to-es/issues/13>\n  repeater: \"repeater\"\n};\nvar AstAssertionKinds = {\n  line_end: \"line_end\",\n  line_start: \"line_start\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\",\n  search_start: \"search_start\",\n  string_end: \"string_end\",\n  string_end_newline: \"string_end_newline\",\n  string_start: \"string_start\",\n  word_boundary: \"word_boundary\"\n};\nvar AstCharacterSetKinds = TokenCharacterSetKinds;\nvar AstDirectiveKinds = TokenDirectiveKinds;\nvar AstVariableLengthCharacterSetKinds = {\n  grapheme: \"grapheme\",\n  newline: \"newline\"\n};\nfunction parse({ tokens, flags, rules }, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: /* @__PURE__ */ new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk\n  };\n  function walk(parent, state) {\n    const token = tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, { useLastValid: !!state.isCheckingRangeEnd });\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  const { capturingGroups, hasNumberedRef, namedGroupsByName, subroutines } = context;\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error(\"Numbered backref/subroutine not allowed when using named capture\");\n  }\n  for (const { ref } of subroutines) {\n    if (typeof ref === \"number\") {\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  traverse({ node: ast }, null, {\n    AnyNode({ node, parent }) {\n      node.parent = parent;\n    }\n  });\n  return ast;\n}\nfunction parseBackreference(context) {\n  const { raw } = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    if (num > numCapturesToLeft) {\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, { orphan });\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\nfunction parseCharacterClassHyphen(context, state) {\n  const { parent, tokens, walk } = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (!state.isCheckingRangeEnd && prevSiblingNode && prevSiblingNode.type !== AstTypes.CharacterClass && prevSiblingNode.type !== AstTypes.CharacterClassRange && nextToken && nextToken.type !== TokenTypes.CharacterClassOpen && nextToken.type !== TokenTypes.CharacterClassClose && nextToken.type !== TokenTypes.CharacterClassIntersector) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true\n    });\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error(\"Invalid character class range\");\n  }\n  return createCharacter(45);\n}\nfunction parseCharacterClassOpen(context, state) {\n  const { token, tokens, verbose, walk } = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({ negate: token.negate });\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({ negate: false, baseOnly: true }));\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  context.current++;\n  return node;\n}\nfunction parseCharacterSet({ token, skipPropertyNameValidation }) {\n  let { kind, negate, value } = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value\n    };\n  }\n  return createCharacterSet(kind, { negate });\n}\nfunction parseGroupOpen(context, state) {\n  const { token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, verbose, walk } = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === AstTypes.AbsentFunction;\n  const isLookbehind = node.kind === AstAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrInsert(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    throw new Error(\"Nested absent function not supported by Oniguruma\");\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind\n      });\n      alt.elements.push(child);\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        const msg = \"Lookbehind includes a pattern not allowed by Oniguruma\";\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          if (child.kind === AstAssertionKinds.lookahead || child.type === AstTypes.CapturingGroup) {\n            throw new Error(msg);\n          }\n        } else {\n          if (child.kind === AstAssertionKinds.lookahead || child.kind === AstAssertionKinds.lookbehind && child.negate) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  context.current++;\n  return node;\n}\nfunction parseQuantifier({ token, parent }) {\n  const { min, max, greedy, possessive: possessive2 } = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (!quantifiedNode || quantifiedNode.type === AstTypes.Assertion || quantifiedNode.type === AstTypes.Directive) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive2);\n  parent.elements.pop();\n  return node;\n}\nfunction parseSubroutine(context) {\n  const { token, capturingGroups, subroutines } = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      \"\": num,\n      \"+\": numCapturesToLeft + num,\n      \"-\": numCapturesToLeft + 1 - num\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error(\"Invalid subroutine number\");\n    }\n  } else if (ref === \"0\") {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\nfunction createAbsentFunction(kind) {\n  if (kind !== AstAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: AstTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: []\n  };\n}\nfunction createAssertion(kind, options) {\n  const negate = !!options?.negate;\n  return {\n    type: AstTypes.Assertion,\n    kind,\n    ...kind === AstAssertionKinds.word_boundary && { negate }\n  };\n}\nfunction createAssertionFromToken({ kind }) {\n  return createAssertion(\n    throwIfNot({\n      \"^\": AstAssertionKinds.line_start,\n      \"$\": AstAssertionKinds.line_end,\n      \"\\\\A\": AstAssertionKinds.string_start,\n      \"\\\\b\": AstAssertionKinds.word_boundary,\n      \"\\\\B\": AstAssertionKinds.word_boundary,\n      \"\\\\G\": AstAssertionKinds.search_start,\n      \"\\\\z\": AstAssertionKinds.string_end,\n      \"\\\\Z\": AstAssertionKinds.string_end_newline\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    { negate: kind === r`\\B` }\n  );\n}\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...orphan && { orphan },\n    ref\n  };\n}\nfunction createByGroupKind({ flags, kind, name, negate, number }) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(AstAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({ atomic: true });\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({ flags });\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaround({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== void 0;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...hasName && { name },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options\n  };\n  if (charCode > 1114111) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 1114111;\n    } else if (charCode > 1310719) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: AstTypes.Character,\n    value: charCode\n  };\n}\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()]\n  };\n}\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({ negate: false, baseOnly: true })]\n  };\n}\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error(\"Character class range out of order\");\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max\n  };\n}\nfunction createCharacterSet(kind, { negate }) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`)\n  };\n  if (kind === TokenCharacterSetKinds.digit || kind === TokenCharacterSetKinds.hex || kind === TokenCharacterSetKinds.space || kind === TokenCharacterSetKinds.word) {\n    node.negate = negate;\n  }\n  return node;\n}\nfunction createDirectiveFromToken({ kind, flags }) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`)\n  };\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\nfunction createFlags({ ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii\n  };\n}\nfunction createGroup(options) {\n  const atomic2 = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...atomic2 && { atomic: atomic2 },\n    ...flags && { flags },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createQuantifier(element, min, max, greedy = true, possessive2 = false) {\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive: possessive2,\n    element\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      possessive: true\n    };\n  }\n  return node;\n}\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags\n  };\n}\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref\n  };\n}\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate\n  };\n}\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      \"\\\\R\": AstVariableLengthCharacterSetKinds.newline,\n      \"\\\\X\": AstVariableLengthCharacterSetKinds.grapheme\n    }[kind], `Unexpected varcharset kind \"${kind}\"`)\n  };\n}\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  return value.trim().replace(/[- _]+/g, \"_\").replace(/[A-Z][a-z]+(?=[A-Z])/g, \"$&_\").replace(/[A-Za-z]+/g, (m) => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (node.type === AstTypes.Group && hasOnlyChild(node, (kid) => kid.type === AstTypes.Group) && !(node.atomic && firstAltFirstEl.flags) && !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\nfunction isValidGroupNameOniguruma(name) {\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? \"Empty\" : \"Unclosed\"} character class`\n  );\n}\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, \"Unclosed group\");\n}\n\n// src/transform.js\n\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: \"default\",\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: \"ES2025\",\n    ...options\n  };\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: /* @__PURE__ */ new Map(),\n    jsGroupNameMap: /* @__PURE__ */ new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, \"ES2024\"),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: /* @__PURE__ */ new Map(),\n    supportedGNodes: /* @__PURE__ */ new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii\n  };\n  traverse({ node: ast }, firstPassState, FirstPassVisitor);\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase\n  };\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: /* @__PURE__ */ new Map(),\n    groupsByName: /* @__PURE__ */ new Map(),\n    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),\n    openRefs: /* @__PURE__ */ new Map(),\n    reffedNodesByReferencer: /* @__PURE__ */ new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap\n  };\n  traverse({ node: ast }, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer\n  };\n  traverse({ node: ast }, thirdPassState, ThirdPassVisitor);\n  ast._originMap = secondPassState.groupOriginByCopy;\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\nvar FirstPassVisitor = {\n  AbsentFunction({ node, replaceWith }) {\n    const group = prepContainer(createGroup(), [\n      adoptAndSwapKids(createLookaround({ negate: true }), node.alternatives),\n      createUnicodeProperty(\"Any\")\n    ]);\n    const quantifier = createQuantifier(group, 0, Infinity);\n    group.parent = quantifier;\n    replaceWith(prepContainer(createGroup(), [quantifier]));\n  },\n  Alternative: {\n    enter({ node, parent, key }, { flagDirectivesByAlt }) {\n      const flagDirectives = node.elements.filter((el) => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({ node }, { flagDirectivesByAlt }) {\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({ flags }), node.elements);\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    }\n  },\n  Assertion({ node, key, container, ast, remove, replaceWith }, state) {\n    const { kind, negate } = node;\n    const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;\n    if (kind === AstAssertionKinds.line_end) {\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`, { skipLookbehindValidation: true }));\n    } else if (kind === AstAssertionKinds.lookbehind) {\n      state.passedLookbehind = true;\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1];\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(prepContainer(createLookaround({ negate: true })));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(createAssertion(AstAssertionKinds.string_start));\n          state.strategy = \"clip_search\";\n        }\n      }\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n  },\n  Backreference({ node }, { jsGroupNameMap }) {\n    let { ref } = node;\n    if (typeof ref === \"string\" && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n  CapturingGroup({ node }, { jsGroupNameMap, subroutineRefMap }) {\n    let { name } = node;\n    if (name && !isValidGroupNameJs(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n  CharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n    const { kind, negate, value } = node;\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === \"digit\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, { negate }));\n      return;\n    }\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === \"space\")) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === \"word\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, { negate }));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty(\"Any\"));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty(\"Nd\", { negate }));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty(\"AHex\", { negate }));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      replaceWith(createUnicodeProperty(\"space\", { negate }));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        node.key = \"sc\";\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === \"graph\" || value === \"print\")) {\n        if (accuracy === \"strict\") {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: \"!-~\",\n          print: \" -~\"\n        }[value];\n        if (negate) {\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n  Directive(path, state) {\n    const { node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings } = path;\n    const { kind, flags } = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({ flags }), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      const firstAltFirstEl = ast.pattern.alternatives[0].elements[0];\n      const hasWrapperGroup = (\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(ast.pattern, (kid) => kid.type === AstTypes.Group) && firstAltFirstEl.alternatives.length === 1\n      );\n      const topLevel = hasWrapperGroup ? firstAltFirstEl : ast.pattern;\n      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({ behind: true }), removeAllPrevSiblings()));\n    }\n  },\n  Flags({ node, parent }) {\n    [\n      \"digitIsAscii\",\n      // Flag D\n      \"extended\",\n      // Flag x\n      \"spaceIsAscii\",\n      // Flag S\n      \"wordIsAscii\"\n      // Flag W\n    ].forEach((f) => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true\n      }\n    };\n  },\n  Group({ node }) {\n    if (!node.flags) {\n      return;\n    }\n    const { enable, disable } = node.flags;\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n  Pattern: {\n    enter({ node }, { supportedGNodes }) {\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.alternatives) {\n        if (alt.elements.length === 1 && alt.elements[0].kind === AstAssertionKinds.search_start) {\n          alt.elements.pop();\n        } else {\n          const leadingG = getLeadingG(alt.elements);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        leadingGs.forEach((g) => supportedGNodes.add(g));\n      }\n    },\n    exit(_, { accuracy, passedLookbehind, strategy }) {\n      if (accuracy === \"strict\" && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    }\n  },\n  Quantifier({ node }) {\n    if (node.element.type === AstTypes.Quantifier) {\n      const group = prepContainer(createGroup(), [node.element]);\n      group.parent = node;\n      node.element = group;\n    }\n  },\n  Subroutine({ node }, { jsGroupNameMap }) {\n    let { ref } = node;\n    if (typeof ref === \"string\" && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n  VariableLengthCharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024 }) {\n    const { kind } = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment(\"(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])\"));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === \"strict\") {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : (0,emoji_regex_xs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, { skipPropertyNameValidation: true }));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  }\n};\nvar SecondPassVisitor = {\n  Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {\n    const { orphan, ref } = node;\n    if (!orphan) {\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);\n    }\n  },\n  CapturingGroup: {\n    enter({\n      node,\n      replaceWith,\n      skip\n    }, {\n      groupOriginByCopy,\n      groupsByName,\n      multiplexCapturesToLeftByRef,\n      openRefs,\n      reffedNodesByReferencer\n    }) {\n      const origin = groupOriginByCopy.get(node);\n      if (origin && openRefs.has(node.number)) {\n        const recursion2 = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));\n        replaceWith(recursion2);\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrInsert(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({ node, origin });\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({ node, origin });\n      }\n      if (node.name) {\n        const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, { node, hasDuplicateNameToRemove });\n      }\n    },\n    exit({ node }, { openRefs }) {\n      openRefs.delete(node.number);\n    }\n  },\n  Group: {\n    enter({ node }, state) {\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    }\n  },\n  Recursion({ node, parent }, { reffedNodesByReferencer }) {\n    const { ref } = node;\n    let reffed = parent;\n    while (reffed = reffed.parent) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    reffedNodesByReferencer.set(node, reffed);\n  },\n  Subroutine(path, state) {\n    const { node, replaceWith } = path;\n    const { ref } = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : (\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null)\n    );\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (node2) => {\n        return node2.type === AstTypes.Group && !!node2.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags)\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  }\n};\nvar ThirdPassVisitor = {\n  Backreference({ node, replaceWith }, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node));\n    if (!participants.length) {\n      replaceWith(prepContainer(createLookaround({ negate: true })));\n    } else if (participants.length > 1) {\n      const alts = participants.map((reffed) => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n  CapturingGroup({ node }, state) {\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n  Recursion({ node }, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n  Regex: {\n    exit({ node }, state) {\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    }\n  }\n};\nvar asciiSpaceChar = \"[\t-\\r ]\";\nvar defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach((kid) => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\nfunction canParticipateWithNode(capture, node) {\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while (rightmostPoint = rightmostPoint.parent);\n  throw new Error(\"Unexpected path\");\n}\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === \"parent\") {\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === \"object\") {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === \"type\" && value === AstTypes.CapturingGroup) {\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref\n  };\n}\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while (node = node.parent) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, \"_\")}`;\n  map.set(name, jsName);\n  return jsName;\n}\nfunction getContainerAccessor(node) {\n  for (const accessor of [\"alternatives\", \"classes\", \"elements\"]) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = [\"dotAll\", \"ignoreCase\"];\n  const combinedFlags = { enable: {}, disable: {} };\n  flagNodes.forEach(({ flags }) => {\n    flagProps.forEach((prop) => {\n      if (flags.enable?.[prop]) {\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\nfunction getFlagModsFromFlags({ dotAll, ignoreCase }) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\nfunction getKids(node) {\n  if (!node) {\n    throw new Error(\"Node expected\");\n  }\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\nfunction getLeadingG(els) {\n  const firstToConsider = els.find((el) => el.kind === AstAssertionKinds.search_start || isLoneGLookaround(el, { negate: false }) || !isAlwaysZeroLength(el));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (isConsumptiveGroup(firstToConsider)) {\n    const gNodesForGroup = [];\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        return null;\n      }\n      Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (kid === descendant || hasDescendant(kid, descendant)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options\n  };\n  return isLookaround(node) && (opts.negate === null || node.negate === opts.negate) && hasOnlyChild(node, (kid) => kid.kind === AstAssertionKinds.search_start);\n}\nfunction isValidGroupNameJs(name) {\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\nfunction traverseReplacement(replacement, { parent, key, container }, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container\n  }, state, visitor);\n}\n\n// src/generate.js\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, \"ES2024\");\n  const minTargetEs2025 = isMinTarget(opts.target, \"ES2025\");\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error(\"Invalid recursionLimit; use 2-20\");\n  }\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({ node: ast }, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {\n        iStack.pop();\n      },\n      pushModI(isIOn) {\n        iStack.push(isIOn);\n      },\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      }\n    }, FlagModifierVisitor);\n  }\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    captureMap: /* @__PURE__ */ new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase\n    },\n    inCharClass: false,\n    lastNode,\n    originMap: ast._originMap,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: { ...node.options }\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join(\"\");\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error(\"Use of class intersection requires min target ES2024\");\n        }\n        return node.classes.map(gen).join(\"&&\");\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join(\"|\");\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  result._captureTransfers = /* @__PURE__ */ new Map();\n  result._hiddenCaptures = [];\n  state.captureMap.forEach((value, key) => {\n    if (value.hidden) {\n      result._hiddenCaptures.push(key);\n    }\n    if (value.transferTo) {\n      getOrInsert(result._captureTransfers, value.transferTo, []).push(key);\n    }\n  });\n  return result;\n}\nvar FlagModifierVisitor = {\n  AnyGroup: {\n    enter({ node }, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    }\n  },\n  Backreference(_, state) {\n    state.setHasCasedChar();\n  },\n  Character({ node }, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({ node, skip }, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({ node }, state) {\n    if (node.kind === AstCharacterSetKinds.property && UnicodePropertiesWithSpecificCase.has(node.value)) {\n      state.setHasCasedChar();\n    }\n  }\n};\nvar BaseEscapeChars = /* @__PURE__ */ new Set([\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\"\n]);\nvar CharClassEscapeChars = /* @__PURE__ */ new Set([\n  \"-\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  \"[\"\n]);\nvar CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([\n  \"(\",\n  \")\",\n  \"-\",\n  \"/\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\",\n  // Double punctuators; also includes already-listed `-` and `^`\n  \"!\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"+\",\n  \",\",\n  \".\",\n  \":\",\n  \";\",\n  \"<\",\n  \"=\",\n  \">\",\n  \"?\",\n  \"@\",\n  \"`\",\n  \"~\"\n]);\nvar CharCodeEscapeMap = /* @__PURE__ */ new Map([\n  [9, r`\\t`],\n  // horizontal tab\n  [10, r`\\n`],\n  // line feed\n  [11, r`\\v`],\n  // vertical tab\n  [12, r`\\f`],\n  // form feed\n  [13, r`\\r`],\n  // carriage return\n  [8232, r`\\u2028`],\n  // line separator\n  [8233, r`\\u2029`],\n  // paragraph separator\n  [65279, r`\\uFEFF`]\n  // ZWNBSP/BOM\n]);\nvar casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\nfunction genAssertion(node, _, gen) {\n  const { kind, negate, alternatives } = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? \"\" : \"<\"}${negate ? \"!\" : \"=\"}`;\n    return `(?${prefix}${alternatives.map(gen).join(\"|\")})`;\n  }\n  if (kind === AstAssertionKinds.string_end) {\n    return \"$\";\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return \"^\";\n  }\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\nfunction genBackreference({ ref }, state) {\n  if (typeof ref !== \"number\") {\n    throw new Error(\"Unexpected named backref in transformed AST\");\n  }\n  if (!state.useFlagMods && state.accuracy === \"strict\" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {\n    throw new Error(\"Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy\");\n  }\n  return \"\\\\\" + ref;\n}\nfunction genCapturingGroup(node, state, gen) {\n  const { name, number, alternatives } = node;\n  const data = { ignoreCase: state.currentFlags.ignoreCase };\n  const origin = state.originMap.get(node);\n  if (origin) {\n    data.hidden = true;\n    if (number > origin.number) {\n      data.transferTo = origin.number;\n    }\n  }\n  state.captureMap.set(number, data);\n  return `(${name ? `?<${name}>` : \"\"}${alternatives.map(gen).join(\"|\")})`;\n}\nfunction genCharacter({ value }, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ? cases.join(\"\") : cases.length > 1 ? `[${cases.join(\"\")}]` : cases[0];\n  }\n  return char;\n}\nfunction genCharacterClass({ negate, parent, elements }, state, gen) {\n  if (envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV && elements.some(isLiteralHyphen)) {\n    elements = elements.filter((node) => !isLiteralHyphen(node));\n    elements.push(createCharacter(45));\n  }\n  const genClass = () => `[${negate ? \"^\" : \"\"}${elements.map(gen).join(\"\")}]`;\n  if (!state.inCharClass) {\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  const firstType = elements[0]?.type;\n  if (!negate && firstType && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n  ((!state.useFlagV || !state.verbose) && parent.type === AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassIntersection && !(envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV) || !state.verbose && parent.type === AstTypes.CharacterClassIntersection && // JS doesn't allow intersection with union or ranges\n  elements.length === 1 && firstType !== AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassRange)) {\n    return elements.map(gen).join(\"\");\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error(\"Use of nested character class requires min target ES2024\");\n  }\n  return genClass();\n}\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = /* @__PURE__ */ new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach((value) => {\n      extraChars.add(\n        Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts)\n      );\n    });\n  }\n  return `${minStr}-${maxStr}${[...extraChars].join(\"\")}`;\n}\nfunction genCharacterSet({ kind, negate, value, key }, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? \".\" : \"[^]\" : (\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`\n    );\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : \"\"}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? \"i\" : \"\") + (node.dotAll ? \"s\" : \"\") + (node.sticky ? \"y\" : \"\")\n  );\n}\nfunction genGroup({ atomic: atomic2, flags, parent, alternatives }, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join(\"|\");\n  const result = !state.verbose && alternatives.length === 1 && parent.type !== AstTypes.Quantifier && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\nfunction genRecursion({ ref }, state) {\n  const limit = state.recursionLimit;\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\nfunction getCharEscape(codePoint, { isAfterBackref, inCharClass, useFlagV }) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    isAfterBackref && isDigitCharCode(codePoint)\n  ) {\n    return codePoint > 255 ? `\\\\u{${codePoint.toString(16).toUpperCase()}}` : `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, \"0\")}`;\n  }\n  const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? \"\\\\\" : \"\") + char;\n}\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map((char) => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\nfunction getGroupPrefix(atomic2, flagMods, useFlagMods) {\n  if (atomic2) {\n    return \">\";\n  }\n  let mods = \"\";\n  if (flagMods && useFlagMods) {\n    const { enable, disable } = flagMods;\n    mods = (enable?.ignoreCase ? \"i\" : \"\") + (enable?.dotAll ? \"s\" : \"\") + (disable ? \"-\" : \"\") + (disable?.ignoreCase ? \"i\" : \"\") + (disable?.dotAll ? \"s\" : \"\");\n  }\n  return `${mods}:`;\n}\nfunction getQuantifierStr({ min, max, greedy, possessive: possessive2 }) {\n  let base;\n  if (!min && max === 1) {\n    base = \"?\";\n  } else if (!min && max === Infinity) {\n    base = \"*\";\n  } else if (min === 1 && max === Infinity) {\n    base = \"+\";\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? \"\" : max}}`;\n  }\n  return base + (possessive2 ? \"+\" : greedy ? \"\" : \"?\");\n}\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\nfunction isLiteralHyphen({ type, value }) {\n  return type === AstTypes.Character && value === 45;\n}\n\n// src/subclass.js\nvar EmulatedRegExp = class _EmulatedRegExp extends RegExp {\n  /**\n  @type {Map<number, {\n    hidden?: true;\n    transferTo?: number;\n  }>}\n  */\n  #captureMap = /* @__PURE__ */ new Map();\n  /**\n  @type {RegExp | EmulatedRegExp | null}\n  */\n  #compiled = null;\n  /**\n  @type {string}\n  */\n  #pattern;\n  /**\n  @type {Map<number, string>?}\n  */\n  #nameMap = null;\n  /**\n  @type {string?}\n  */\n  #strategy = null;\n  /**\n  Can be used to serialize the instance.\n  @type {EmulatedRegExpOptions}\n  */\n  rawOptions = {};\n  // Override the getter with one that works with lazy-compiled regexes\n  get source() {\n    return this.#pattern || \"(?:)\";\n  }\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    const lazyCompile = !!options?.lazyCompile;\n    if (pattern instanceof RegExp) {\n      if (options) {\n        throw new Error(\"Cannot provide options when copying a regexp\");\n      }\n      const re = pattern;\n      super(re, flags);\n      this.#pattern = re.source;\n      if (re instanceof _EmulatedRegExp) {\n        this.#captureMap = re.#captureMap;\n        this.#nameMap = re.#nameMap;\n        this.#strategy = re.#strategy;\n        this.rawOptions = re.rawOptions;\n      }\n    } else {\n      const opts = {\n        hiddenCaptures: [],\n        strategy: null,\n        transfers: [],\n        ...options\n      };\n      super(lazyCompile ? \"\" : pattern, flags);\n      this.#pattern = pattern;\n      this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);\n      this.#strategy = opts.strategy;\n      this.rawOptions = options ?? {};\n    }\n    if (!lazyCompile) {\n      this.#compiled = this;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray?}\n  */\n  exec(str) {\n    if (!this.#compiled) {\n      const { lazyCompile, ...rest } = this.rawOptions;\n      this.#compiled = new _EmulatedRegExp(this.#pattern, this.flags, rest);\n    }\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n    if (this.#strategy === \"clip_search\" && useLastIndex && pos) {\n      this.lastIndex = 0;\n      const match = this.#execCore(str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n    return this.#execCore(str);\n  }\n  /**\n  Adds support for hidden and transfer captures.\n  @param {string} str\n  @returns\n  */\n  #execCore(str) {\n    this.#compiled.lastIndex = this.lastIndex;\n    const match = super.exec.call(this.#compiled, str);\n    this.lastIndex = this.#compiled.lastIndex;\n    if (!match || !this.#captureMap.size) {\n      return match;\n    }\n    const matchCopy = [...match];\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    const mappedNums = [0];\n    for (let i = 1; i < matchCopy.length; i++) {\n      const { hidden, transferTo } = this.#captureMap.get(i) ?? {};\n      if (hidden) {\n        mappedNums.push(null);\n      } else {\n        mappedNums.push(match.length);\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n      if (transferTo && matchCopy[i] !== void 0) {\n        const to = throwIfNot(mappedNums[transferTo]);\n        match[to] = matchCopy[i];\n        if (this.hasIndices) {\n          match.indices[to] = indicesCopy[i];\n        }\n        if (match.groups) {\n          if (!this.#nameMap) {\n            this.#nameMap = createNameMap(this.source);\n          }\n          const name = this.#nameMap.get(transferTo);\n          if (name) {\n            match.groups[name] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[name] = indicesCopy[i];\n            }\n          }\n        }\n      }\n    }\n    return match;\n  }\n};\nfunction adjustMatchDetailsForOffset(match, offset, input, hasIndices) {\n  match.index += offset;\n  match.input = input;\n  if (hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach((key) => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\nfunction createCaptureMap(hiddenCaptures, transfers) {\n  const captureMap = /* @__PURE__ */ new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true\n    });\n  }\n  for (const [to, from] of transfers) {\n    for (const num of from) {\n      getOrInsert(captureMap, num, {}).transferTo = to;\n    }\n  }\n  return captureMap;\n}\nfunction createNameMap(pattern) {\n  const re = /(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?./gsu;\n  const map = /* @__PURE__ */ new Map();\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  while (match = re.exec(pattern)) {\n    const { 0: m, groups: { capture, name } } = match;\n    if (m === \"[\") {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (capture) {\n        numCaptures++;\n        if (name) {\n          map.set(numCaptures, name);\n        }\n      }\n    } else if (m === \"]\") {\n      numCharClassesOpen--;\n    }\n  }\n  return map;\n}\n\n// src/index.js\n\n\nfunction toOnigurumaAst(pattern, options) {\n  const opts = {\n    flags: options?.flags ?? \"\",\n    rules: {\n      captureGroup: false,\n      singleline: false,\n      ...options?.rules\n    }\n  };\n  return parse(tokenize(pattern, opts.flags, opts.rules));\n}\nfunction toRegExp(pattern, options) {\n  const d = toRegExpDetails(pattern, options);\n  if (d.options) {\n    return new EmulatedRegExp(d.pattern, d.flags, d.options);\n  }\n  return new RegExp(d.pattern, d.flags);\n}\nfunction toRegExpDetails(pattern, options) {\n  const opts = getOptions(options);\n  const tokenized = tokenize(pattern, opts.flags, {\n    captureGroup: opts.rules.captureGroup,\n    singleline: opts.rules.singleline\n  });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    bestEffortTarget: opts.target\n  });\n  const generated = generate(regexAst, opts);\n  const recursionResult = (0,regex_recursion__WEBPACK_IMPORTED_MODULE_2__.recursion)(generated.pattern, {\n    captureTransfers: generated._captureTransfers,\n    hiddenCaptures: generated._hiddenCaptures,\n    mode: \"external\"\n  });\n  const possessiveResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_1__.possessive)(recursionResult.pattern);\n  const atomicResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_1__.atomic)(possessiveResult.pattern, {\n    captureTransfers: recursionResult.captureTransfers,\n    hiddenCaptures: recursionResult.hiddenCaptures\n  });\n  const details = {\n    pattern: atomicResult.pattern,\n    flags: `${opts.hasIndices ? \"d\" : \"\"}${opts.global ? \"g\" : \"\"}${generated.flags}${generated.options.disable.v ? \"u\" : \"v\"}`\n  };\n  if (opts.avoidSubclass) {\n    if (opts.lazyCompileLength !== Infinity) {\n      throw new Error(\"Lazy compilation requires subclass\");\n    }\n  } else {\n    const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b) => a - b);\n    const transfers = Array.from(atomicResult.captureTransfers);\n    const strategy = regexAst._strategy;\n    const lazyCompile = details.pattern.length >= opts.lazyCompileLength;\n    if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {\n      details.options = {\n        ...hiddenCaptures.length && { hiddenCaptures },\n        ...transfers.length && { transfers },\n        ...strategy && { strategy },\n        ...lazyCompile && { lazyCompile }\n      };\n    }\n  }\n  return details;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL29uaWd1cnVtYS10by1lc0AzLjEuMS9ub2RlX21vZHVsZXMvb25pZ3VydW1hLXRvLWVzL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSxHQUFHLEdBQUc7QUFDOUIsaUJBQWlCLE1BQU07QUFDdkIsaUJBQWlCLE1BQU07QUFDdkIsa0JBQWtCLEdBQUc7QUFDckIsaUJBQWlCLE1BQU07QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEIsa0JBQWtCLE1BQU0sS0FBSyxN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBDQUEwQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLGtCQUFrQixJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0Isa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDcUQ7QUFDVDtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCLDBEQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsMkRBQVU7QUFDckMsdUJBQXVCLHVEQUFNO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLEVBQUUsdUJBQXVCLEVBQUUsZ0JBQWdCLEVBQUUsd0NBQXdDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RCxpQ0FBaUMsV0FBVztBQUM1Qyx5QkFBeUIsVUFBVTtBQUNuQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL29uaWd1cnVtYS10by1lc0AzLjEuMS9ub2RlX21vZHVsZXMvb25pZ3VydW1hLXRvLWVzL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy5qc1xudmFyIGNwID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG52YXIgciA9IFN0cmluZy5yYXc7XG52YXIgZW52RmxhZ3MgPSB7XG4gIGZsYWdHcm91cHM6ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAoXCIoP2k6KVwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKCksXG4gIHVuaWNvZGVTZXRzOiAoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgUmVnRXhwKFwiXCIsIFwidlwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKClcbn07XG5lbnZGbGFncy5saXRlcmFsSHlwaGVuSW5jb3JyZWN0bHlDcmVhdGVzUmFuZ2UgPSAoKCkgPT4ge1xuICBpZiAoIWVudkZsYWdzLnVuaWNvZGVTZXRzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChyYFtcXGRcXC1hXWAsIFwidlwiKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKTtcbmZ1bmN0aW9uIGdldE5ld0N1cnJlbnRGbGFncyhjdXJyZW50LCB7IGVuYWJsZSwgZGlzYWJsZSB9KSB7XG4gIHJldHVybiB7XG4gICAgZG90QWxsOiAhZGlzYWJsZT8uZG90QWxsICYmICEhKGVuYWJsZT8uZG90QWxsIHx8IGN1cnJlbnQuZG90QWxsKSxcbiAgICBpZ25vcmVDYXNlOiAhZGlzYWJsZT8uaWdub3JlQ2FzZSAmJiAhIShlbmFibGU/Lmlnbm9yZUNhc2UgfHwgY3VycmVudC5pZ25vcmVDYXNlKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JJbnNlcnQobWFwLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoIW1hcC5oYXMoa2V5KSkge1xuICAgIG1hcC5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9XG4gIHJldHVybiBtYXAuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBpc01pblRhcmdldCh0YXJnZXQsIG1pbikge1xuICByZXR1cm4gRXNWZXJzaW9uW3RhcmdldF0gPj0gRXNWZXJzaW9uW21pbl07XG59XG5mdW5jdGlvbiB0aHJvd0lmTm90KHZhbHVlLCBtc2cpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgPz8gXCJWYWx1ZSBleHBlY3RlZFwiKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9vcHRpb25zLmpzXG52YXIgRXNWZXJzaW9uID0ge1xuICBFUzIwMjU6IDIwMjUsXG4gIEVTMjAyNDogMjAyNCxcbiAgRVMyMDE4OiAyMDE4XG59O1xudmFyIFRhcmdldCA9IChcbiAgLyoqIEB0eXBlIHtjb25zdH0gKi9cbiAge1xuICAgIGF1dG86IFwiYXV0b1wiLFxuICAgIEVTMjAyNTogXCJFUzIwMjVcIixcbiAgICBFUzIwMjQ6IFwiRVMyMDI0XCIsXG4gICAgRVMyMDE4OiBcIkVTMjAxOFwiXG4gIH1cbik7XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnM/LnRhcmdldCAhPT0gdm9pZCAwICYmICFUYXJnZXRbb3B0aW9ucy50YXJnZXRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRhcmdldCBcIiR7b3B0aW9ucy50YXJnZXR9XCJgKTtcbiAgfVxuICBjb25zdCBvcHRzID0ge1xuICAgIC8vIFNldHMgdGhlIGxldmVsIG9mIGVtdWxhdGlvbiByaWdvci9zdHJpY3RuZXNzLlxuICAgIGFjY3VyYWN5OiBcImRlZmF1bHRcIixcbiAgICAvLyBEaXNhYmxlcyBhZHZhbmNlZCBlbXVsYXRpb24gdGhhdCByZWxpZXMgb24gcmV0dXJuaW5nIGEgYFJlZ0V4cGAgc3ViY2xhc3MsIHJlc3VsdGluZyBpblxuICAgIC8vIGNlcnRhaW4gcGF0dGVybnMgbm90IGJlaW5nIGVtdWxhdGFibGUuXG4gICAgYXZvaWRTdWJjbGFzczogZmFsc2UsXG4gICAgLy8gT25pZ3VydW1hIGZsYWdzOyBhIHN0cmluZyB3aXRoIGBpYCwgYG1gLCBgeGAsIGBEYCwgYFNgLCBgV2AgaW4gYW55IG9yZGVyIChhbGwgb3B0aW9uYWwpLlxuICAgIC8vIE9uaWd1cnVtYSdzIGBtYCBpcyBlcXVpdmFsZW50IHRvIEphdmFTY3JpcHQncyBgc2AgKGBkb3RBbGxgKS5cbiAgICBmbGFnczogXCJcIixcbiAgICAvLyBJbmNsdWRlIEphdmFTY3JpcHQgZmxhZyBgZ2AgKGBnbG9iYWxgKSBpbiB0aGUgcmVzdWx0LlxuICAgIGdsb2JhbDogZmFsc2UsXG4gICAgLy8gSW5jbHVkZSBKYXZhU2NyaXB0IGZsYWcgYGRgIChgaGFzSW5kaWNlc2ApIGluIHRoZSByZXN1bHQuXG4gICAgaGFzSW5kaWNlczogZmFsc2UsXG4gICAgLy8gRGVsYXkgcmVnZXggY29uc3RydWN0aW9uIHVudGlsIGZpcnN0IHVzZSBpZiB0aGUgdHJhbnNwaWxlZCBwYXR0ZXJuIGlzIGF0IGxlYXN0IHRoaXMgbGVuZ3RoLlxuICAgIGxhenlDb21waWxlTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBKYXZhU2NyaXB0IHZlcnNpb24gdXNlZCBmb3IgZ2VuZXJhdGVkIHJlZ2V4ZXMuIFVzaW5nIGBhdXRvYCBkZXRlY3RzIHRoZSBiZXN0IHZhbHVlIGJhc2VkIG9uXG4gICAgLy8geW91ciBlbnZpcm9ubWVudC4gTGF0ZXIgdGFyZ2V0cyBhbGxvdyBmYXN0ZXIgcHJvY2Vzc2luZywgc2ltcGxlciBnZW5lcmF0ZWQgc291cmNlLCBhbmRcbiAgICAvLyBzdXBwb3J0IGZvciBhZGRpdGlvbmFsIGZlYXR1cmVzLlxuICAgIHRhcmdldDogXCJhdXRvXCIsXG4gICAgLy8gRGlzYWJsZXMgb3B0aW1pemF0aW9ucyB0aGF0IHNpbXBsaWZ5IHRoZSBwYXR0ZXJuIHdoZW4gaXQgZG9lc24ndCBjaGFuZ2UgdGhlIG1lYW5pbmcuXG4gICAgdmVyYm9zZTogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBBZHZhbmNlZCBvcHRpb25zIHRoYXQgb3ZlcnJpZGUgc3RhbmRhcmQgYmVoYXZpb3IsIGVycm9yIGNoZWNraW5nLCBhbmQgZmxhZ3Mgd2hlbiBlbmFibGVkLlxuICAgIHJ1bGVzOiB7XG4gICAgICAvLyBVc2VmdWwgd2l0aCBUZXh0TWF0ZSBncmFtbWFycyB0aGF0IG1lcmdlIGJhY2tyZWZlcmVuY2VzIGFjcm9zcyBwYXR0ZXJucy5cbiAgICAgIGFsbG93T3JwaGFuQmFja3JlZnM6IGZhbHNlLFxuICAgICAgLy8gVXNlIEFTQ0lJLWJhc2VkIGBcXGJgIGFuZCBgXFxCYCwgd2hpY2ggaW5jcmVhc2VzIHNlYXJjaCBwZXJmb3JtYW5jZSBvZiBnZW5lcmF0ZWQgcmVnZXhlcy5cbiAgICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgLy8gQWxsb3cgdW5uYW1lZCBjYXB0dXJlcyBhbmQgbnVtYmVyZWQgY2FsbHMgKGJhY2tyZWZlcmVuY2VzIGFuZCBzdWJyb3V0aW5lcykgd2hlbiB1c2luZ1xuICAgICAgLy8gbmFtZWQgY2FwdHVyZS4gVGhpcyBpcyBPbmlndXJ1bWEgb3B0aW9uIGBPTklHX09QVElPTl9DQVBUVVJFX0dST1VQYDsgb24gYnkgZGVmYXVsdCBpblxuICAgICAgLy8gYHZzY29kZS1vbmlndXJ1bWFgLlxuICAgICAgY2FwdHVyZUdyb3VwOiBmYWxzZSxcbiAgICAgIC8vIENoYW5nZSB0aGUgcmVjdXJzaW9uIGRlcHRoIGxpbWl0IGZyb20gT25pZ3VydW1hJ3MgYDIwYCB0byBhbiBpbnRlZ2VyIGAyYOKAk2AyMGAuXG4gICAgICByZWN1cnNpb25MaW1pdDogMjAsXG4gICAgICAvLyBgXmAgYXMgYFxcQWA7IGAkYCBhc2BcXFpgLiBJbXByb3ZlcyBzZWFyY2ggcGVyZm9ybWFuY2Ugb2YgZ2VuZXJhdGVkIHJlZ2V4ZXMgd2l0aG91dCBjaGFuZ2luZ1xuICAgICAgLy8gbWVhbmluZyBpZiBzZWFyY2hpbmcgbGluZSBieSBsaW5lLiBUaGlzIGlzIE9uaWd1cnVtYSBvcHRpb24gYE9OSUdfT1BUSU9OX1NJTkdMRUxJTkVgLlxuICAgICAgc2luZ2xlbGluZTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zPy5ydWxlc1xuICAgIH1cbiAgfTtcbiAgaWYgKG9wdHMudGFyZ2V0ID09PSBcImF1dG9cIikge1xuICAgIG9wdHMudGFyZ2V0ID0gZW52RmxhZ3MuZmxhZ0dyb3VwcyA/IFwiRVMyMDI1XCIgOiBlbnZGbGFncy51bmljb2RlU2V0cyA/IFwiRVMyMDI0XCIgOiBcIkVTMjAxOFwiO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuXG4vLyBzcmMvdW5pY29kZS5qc1xudmFyIENoYXJzV2l0aG91dElnbm9yZUNhc2VFeHBhbnNpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIGNwKDMwNCksXG4gIC8vIMSwXG4gIGNwKDMwNSlcbiAgLy8gxLFcbl0pO1xuZnVuY3Rpb24gZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMoY2hhcikge1xuICBpZiAoQ2hhcnNXaXRob3V0SWdub3JlQ2FzZUV4cGFuc2lvbi5oYXMoY2hhcikpIHtcbiAgICByZXR1cm4gW2NoYXJdO1xuICB9XG4gIGNvbnN0IHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGxvd2VyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCB1cHBlciA9IGxvd2VyLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHRpdGxlID0gTG93ZXJUb1RpdGxlQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBjb25zdCBhbHRMb3dlciA9IExvd2VyVG9BbHRlcm5hdGl2ZUxvd2VyQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBjb25zdCBhbHRVcHBlciA9IExvd2VyVG9BbHRlcm5hdGl2ZVVwcGVyQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBpZiAoWy4uLnVwcGVyXS5sZW5ndGggPT09IDEpIHtcbiAgICBzZXQuYWRkKHVwcGVyKTtcbiAgfVxuICBhbHRVcHBlciAmJiBzZXQuYWRkKGFsdFVwcGVyKTtcbiAgdGl0bGUgJiYgc2V0LmFkZCh0aXRsZSk7XG4gIHNldC5hZGQobG93ZXIpO1xuICBhbHRMb3dlciAmJiBzZXQuYWRkKGFsdExvd2VyKTtcbiAgcmV0dXJuIFsuLi5zZXRdO1xufVxudmFyIEpzVW5pY29kZVByb3BlcnRpZXMgPSBuZXcgU2V0KFxuICBgQyBPdGhlclxuQ2MgQ29udHJvbCBjbnRybFxuQ2YgRm9ybWF0XG5DbiBVbmFzc2lnbmVkXG5DbyBQcml2YXRlX1VzZVxuQ3MgU3Vycm9nYXRlXG5MIExldHRlclxuTEMgQ2FzZWRfTGV0dGVyXG5MbCBMb3dlcmNhc2VfTGV0dGVyXG5MbSBNb2RpZmllcl9MZXR0ZXJcbkxvIE90aGVyX0xldHRlclxuTHQgVGl0bGVjYXNlX0xldHRlclxuTHUgVXBwZXJjYXNlX0xldHRlclxuTSBNYXJrIENvbWJpbmluZ19NYXJrXG5NYyBTcGFjaW5nX01hcmtcbk1lIEVuY2xvc2luZ19NYXJrXG5NbiBOb25zcGFjaW5nX01hcmtcbk4gTnVtYmVyXG5OZCBEZWNpbWFsX051bWJlciBkaWdpdFxuTmwgTGV0dGVyX051bWJlclxuTm8gT3RoZXJfTnVtYmVyXG5QIFB1bmN0dWF0aW9uIHB1bmN0XG5QYyBDb25uZWN0b3JfUHVuY3R1YXRpb25cblBkIERhc2hfUHVuY3R1YXRpb25cblBlIENsb3NlX1B1bmN0dWF0aW9uXG5QZiBGaW5hbF9QdW5jdHVhdGlvblxuUGkgSW5pdGlhbF9QdW5jdHVhdGlvblxuUG8gT3RoZXJfUHVuY3R1YXRpb25cblBzIE9wZW5fUHVuY3R1YXRpb25cblMgU3ltYm9sXG5TYyBDdXJyZW5jeV9TeW1ib2xcblNrIE1vZGlmaWVyX1N5bWJvbFxuU20gTWF0aF9TeW1ib2xcblNvIE90aGVyX1N5bWJvbFxuWiBTZXBhcmF0b3JcblpsIExpbmVfU2VwYXJhdG9yXG5acCBQYXJhZ3JhcGhfU2VwYXJhdG9yXG5acyBTcGFjZV9TZXBhcmF0b3JcbkFTQ0lJXG5BU0NJSV9IZXhfRGlnaXQgQUhleFxuQWxwaGFiZXRpYyBBbHBoYVxuQW55XG5Bc3NpZ25lZFxuQmlkaV9Db250cm9sIEJpZGlfQ1xuQmlkaV9NaXJyb3JlZCBCaWRpX01cbkNhc2VfSWdub3JhYmxlIENJXG5DYXNlZFxuQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRlxuQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTVxuQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMXG5DaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGXG5DaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1RcbkNoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVVxuRGFzaFxuRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESVxuRGVwcmVjYXRlZCBEZXBcbkRpYWNyaXRpYyBEaWFcbkVtb2ppXG5FbW9qaV9Db21wb25lbnQgRUNvbXBcbkVtb2ppX01vZGlmaWVyIEVNb2RcbkVtb2ppX01vZGlmaWVyX0Jhc2UgRUJhc2VcbkVtb2ppX1ByZXNlbnRhdGlvbiBFUHJlc1xuRXh0ZW5kZWRfUGljdG9ncmFwaGljIEV4dFBpY3RcbkV4dGVuZGVyIEV4dFxuR3JhcGhlbWVfQmFzZSBHcl9CYXNlXG5HcmFwaGVtZV9FeHRlbmQgR3JfRXh0XG5IZXhfRGlnaXQgSGV4XG5JRFNfQmluYXJ5X09wZXJhdG9yIElEU0JcbklEU19UcmluYXJ5X09wZXJhdG9yIElEU1RcbklEX0NvbnRpbnVlIElEQ1xuSURfU3RhcnQgSURTXG5JZGVvZ3JhcGhpYyBJZGVvXG5Kb2luX0NvbnRyb2wgSm9pbl9DXG5Mb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0Vcbkxvd2VyY2FzZSBMb3dlclxuTWF0aFxuTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXJcblBhdHRlcm5fU3ludGF4IFBhdF9TeW5cblBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTXG5RdW90YXRpb25fTWFyayBRTWFya1xuUmFkaWNhbFxuUmVnaW9uYWxfSW5kaWNhdG9yIFJJXG5TZW50ZW5jZV9UZXJtaW5hbCBTVGVybVxuU29mdF9Eb3R0ZWQgU0RcblRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm1cblVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvXG5VcHBlcmNhc2UgVXBwZXJcblZhcmlhdGlvbl9TZWxlY3RvciBWU1xuV2hpdGVfU3BhY2Ugc3BhY2VcblhJRF9Db250aW51ZSBYSURDXG5YSURfU3RhcnQgWElEU2Auc3BsaXQoL1xccy8pXG4pO1xudmFyIEpzVW5pY29kZVByb3BlcnRpZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZm9yIChjb25zdCBwIG9mIEpzVW5pY29kZVByb3BlcnRpZXMpIHtcbiAgSnNVbmljb2RlUHJvcGVydGllc01hcC5zZXQoc2x1ZyhwKSwgcCk7XG59XG52YXIgSnNVbmljb2RlUHJvcGVydGllc09mU3RyaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgLy8gRVMyMDI0IHByb3BlcnRpZXMgb2Ygc3RyaW5nczsgbm9uZSBhcmUgc3VwcG9ydGVkIGJ5IE9uaWd1cnVtYVxuICBcIkJhc2ljX0Vtb2ppXCIsXG4gIFwiRW1vamlfS2V5Y2FwX1NlcXVlbmNlXCIsXG4gIFwiUkdJX0Vtb2ppXCIsXG4gIFwiUkdJX0Vtb2ppX0ZsYWdfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlfTW9kaWZpZXJfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlfVGFnX1NlcXVlbmNlXCIsXG4gIFwiUkdJX0Vtb2ppX1pXSl9TZXF1ZW5jZVwiXG5dKTtcbnZhciBKc1VuaWNvZGVQcm9wZXJ0aWVzT2ZTdHJpbmdzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZvciAoY29uc3QgcCBvZiBKc1VuaWNvZGVQcm9wZXJ0aWVzT2ZTdHJpbmdzKSB7XG4gIEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3NNYXAuc2V0KHNsdWcocCksIHApO1xufVxudmFyIExvd2VyVG9BbHRlcm5hdGl2ZUxvd2VyQ2FzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wic1wiLCBjcCgzODMpXSxcbiAgLy8gcywgxb9cbiAgW2NwKDM4MyksIFwic1wiXVxuICAvLyDFvywgc1xuXSk7XG52YXIgTG93ZXJUb0FsdGVybmF0aXZlVXBwZXJDYXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbY3AoMjIzKSwgY3AoNzgzOCldLFxuICAvLyDDnywg4bqeXG4gIFtjcCgxMDcpLCBjcCg4NDkwKV0sXG4gIC8vIGssIOKEqiAoS2VsdmluKVxuICBbY3AoMjI5KSwgY3AoODQ5MSldLFxuICAvLyDDpSwg4oSrIChBbmdzdHJvbSlcbiAgW2NwKDk2OSksIGNwKDg0ODYpXVxuICAvLyDPiSwg4oSmIChPaG0pXG5dKTtcbnZhciBMb3dlclRvVGl0bGVDYXNlTWFwID0gbmV3IE1hcChbXG4gIHRpdGxlRW50cnkoNDUzKSxcbiAgdGl0bGVFbnRyeSg0NTYpLFxuICB0aXRsZUVudHJ5KDQ1OSksXG4gIHRpdGxlRW50cnkoNDk4KSxcbiAgLi4udGl0bGVSYW5nZSg4MDcyLCA4MDc5KSxcbiAgLi4udGl0bGVSYW5nZSg4MDg4LCA4MDk1KSxcbiAgLi4udGl0bGVSYW5nZSg4MTA0LCA4MTExKSxcbiAgdGl0bGVFbnRyeSg4MTI0KSxcbiAgdGl0bGVFbnRyeSg4MTQwKSxcbiAgdGl0bGVFbnRyeSg4MTg4KVxuXSk7XG52YXIgUG9zaXhDbGFzc2VzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJhbG51bVwiLCByYFtcXHB7QWxwaGF9XFxwe05kfV1gXSxcbiAgW1wiYWxwaGFcIiwgcmBcXHB7QWxwaGF9YF0sXG4gIFtcImFzY2lpXCIsIHJgXFxwe0FTQ0lJfWBdLFxuICBbXCJibGFua1wiLCByYFtcXHB7WnN9XFx0XWBdLFxuICBbXCJjbnRybFwiLCByYFxccHtjbnRybH1gXSxcbiAgW1wiZGlnaXRcIiwgcmBcXHB7TmR9YF0sXG4gIFtcImdyYXBoXCIsIHJgW1xcUHtzcGFjZX0mJlxcUHtjbnRybH0mJlxcUHtDbn0mJlxcUHtDc31dYF0sXG4gIFtcImxvd2VyXCIsIHJgXFxwe0xvd2VyfWBdLFxuICBbXCJwcmludFwiLCByYFtbXFxQe3NwYWNlfSYmXFxQe2NudHJsfSYmXFxQe0NufSYmXFxQe0NzfV1cXHB7WnN9XWBdLFxuICBbXCJwdW5jdFwiLCByYFtcXHB7UH1cXHB7U31dYF0sXG4gIC8vIE5ldyB2YWx1ZSBmcm9tIE9uaWd1cnVtYSA2LjkuOVxuICBbXCJzcGFjZVwiLCByYFxccHtzcGFjZX1gXSxcbiAgW1widXBwZXJcIiwgcmBcXHB7VXBwZXJ9YF0sXG4gIFtcIndvcmRcIiwgcmBbXFxwe0FscGhhfVxccHtNfVxccHtOZH1cXHB7UGN9XWBdLFxuICBbXCJ4ZGlnaXRcIiwgcmBcXHB7QUhleH1gXVxuXSk7XG52YXIgUG9zaXhQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImFsbnVtXCIsXG4gIFwiYmxhbmtcIixcbiAgXCJncmFwaFwiLFxuICBcInByaW50XCIsXG4gIFwid29yZFwiLFxuICBcInhkaWdpdFwiXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGF2YWlsYWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gSlMgKHNlZSBgSnNVbmljb2RlUHJvcGVydGllc2ApLCBzbyBjYW4gYmVcbiAgLy8gaGFuZGxlZCBhcyBzdGFuZGFyZCBVbmljb2RlIHByb3BlcnRpZXNcbiAgLy8gJ2FscGhhJywgLy8gKEpTOiBBbHBoYSlcbiAgLy8gJ2FzY2lpJywgLy8gKEpTOiBBU0NJSSlcbiAgLy8gJ2NudHJsJywgLy8gKEpTOiBjbnRybClcbiAgLy8gJ2RpZ2l0JywgLy8gKEpTOiBkaWdpdClcbiAgLy8gJ2xvd2VyJywgLy8gKEpTOiBMb3dlcilcbiAgLy8gJ3B1bmN0JywgLy8gKEpTOiBwdW5jdClcbiAgLy8gJ3NwYWNlJywgLy8gKEpTOiBzcGFjZSlcbiAgLy8gJ3VwcGVyJywgLy8gKEpTOiBVcHBlcilcbl0pO1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCkge1xuICBjb25zdCByYW5nZTIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgcmFuZ2UyLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlMjtcbn1cbmZ1bmN0aW9uIHNsdWcobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bLSBfXSsvZywgXCJcIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRpdGxlRW50cnkoY29kZVBvaW50KSB7XG4gIGNvbnN0IGNoYXIgPSBjcChjb2RlUG9pbnQpO1xuICByZXR1cm4gW2NoYXIudG9Mb3dlckNhc2UoKSwgY2hhcl07XG59XG5mdW5jdGlvbiB0aXRsZVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHJhbmdlKHN0YXJ0LCBlbmQpLm1hcCgoY29kZVBvaW50KSA9PiB0aXRsZUVudHJ5KGNvZGVQb2ludCkpO1xufVxudmFyIFVuaWNvZGVQcm9wZXJ0aWVzV2l0aFNwZWNpZmljQ2FzZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJMb3dlclwiLFxuICBcIkxvd2VyY2FzZVwiLFxuICBcIlVwcGVyXCIsXG4gIFwiVXBwZXJjYXNlXCIsXG4gIFwiTGxcIixcbiAgXCJMb3dlcmNhc2VfTGV0dGVyXCIsXG4gIFwiTHRcIixcbiAgXCJUaXRsZWNhc2VfTGV0dGVyXCIsXG4gIFwiTHVcIixcbiAgXCJVcHBlcmNhc2VfTGV0dGVyXCJcbiAgLy8gVGhlIGBDaGFuZ2VzX1doZW5fKmAgcHJvcGVydGllcyAoYW5kIHRoZWlyIGFsaWFzZXMpIGNvdWxkIGJlIGluY2x1ZGVkLCBidXQgdGhleSdyZSB2ZXJ5IHJhcmUuXG4gIC8vIFNvbWUgb3RoZXIgcHJvcGVydGllcyBpbmNsdWRlIGEgaGFuZGZ1bCBvZiBjaGFycyB3aXRoIHNwZWNpZmljIGNhc2VzIG9ubHksIGJ1dCB0aGVzZSBjaGFycyBhcmVcbiAgLy8gZ2VuZXJhbGx5IGV4dHJlbWUgZWRnZSBjYXNlcyBhbmQgdXNpbmcgc3VjaCBwcm9wZXJ0aWVzIGNhc2UgaW5zZW5zaXRpdmVseSBnZW5lcmFsbHkgcHJvZHVjZXNcbiAgLy8gdW5kZXNpcmVkIGJlaGF2aW9yIGFueXdheVxuXSk7XG5cbi8vIHNyYy90b2tlbml6ZS5qc1xudmFyIFRva2VuVHlwZXMgPSAoXG4gIC8qKiBAdHlwZSB7Y29uc3R9ICovXG4gIHtcbiAgICBBbHRlcm5hdG9yOiBcIkFsdGVybmF0b3JcIixcbiAgICBBc3NlcnRpb246IFwiQXNzZXJ0aW9uXCIsXG4gICAgQmFja3JlZmVyZW5jZTogXCJCYWNrcmVmZXJlbmNlXCIsXG4gICAgQ2hhcmFjdGVyOiBcIkNoYXJhY3RlclwiLFxuICAgIENoYXJhY3RlckNsYXNzQ2xvc2U6IFwiQ2hhcmFjdGVyQ2xhc3NDbG9zZVwiLFxuICAgIENoYXJhY3RlckNsYXNzSHlwaGVuOiBcIkNoYXJhY3RlckNsYXNzSHlwaGVuXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3RvcjogXCJDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NPcGVuOiBcIkNoYXJhY3RlckNsYXNzT3BlblwiLFxuICAgIENoYXJhY3RlclNldDogXCJDaGFyYWN0ZXJTZXRcIixcbiAgICBEaXJlY3RpdmU6IFwiRGlyZWN0aXZlXCIsXG4gICAgR3JvdXBDbG9zZTogXCJHcm91cENsb3NlXCIsXG4gICAgR3JvdXBPcGVuOiBcIkdyb3VwT3BlblwiLFxuICAgIFN1YnJvdXRpbmU6IFwiU3Vicm91dGluZVwiLFxuICAgIFF1YW50aWZpZXI6IFwiUXVhbnRpZmllclwiLFxuICAgIC8vIFRoZXNlIGFyZW4ndCBhbGxvd2VkIGluIGNoYXIgY2xhc3Nlcywgc28gdGhleSBhcmVuJ3QgZXF1aXZhbGVudCB0byBKUyBgW1xccXt9XWBcbiAgICBWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldDogXCJWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldFwiLFxuICAgIC8vIEludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvbiBub3QgaW5jbHVkZWQgaW4gcmVzdWx0c1xuICAgIEVzY2FwZWROdW1iZXI6IFwiRXNjYXBlZE51bWJlclwiXG4gIH1cbik7XG52YXIgVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcyA9IHtcbiAgYW55OiBcImFueVwiLFxuICBkaWdpdDogXCJkaWdpdFwiLFxuICBkb3Q6IFwiZG90XCIsXG4gIGhleDogXCJoZXhcIixcbiAgbm9uX25ld2xpbmU6IFwibm9uX25ld2xpbmVcIixcbiAgcG9zaXg6IFwicG9zaXhcIixcbiAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgc3BhY2U6IFwic3BhY2VcIixcbiAgd29yZDogXCJ3b3JkXCJcbn07XG52YXIgVG9rZW5EaXJlY3RpdmVLaW5kcyA9IHtcbiAgZmxhZ3M6IFwiZmxhZ3NcIixcbiAga2VlcDogXCJrZWVwXCJcbn07XG52YXIgVG9rZW5Hcm91cEtpbmRzID0ge1xuICBhYnNlbnRfcmVwZWF0ZXI6IFwiYWJzZW50X3JlcGVhdGVyXCIsXG4gIGF0b21pYzogXCJhdG9taWNcIixcbiAgY2FwdHVyaW5nOiBcImNhcHR1cmluZ1wiLFxuICBncm91cDogXCJncm91cFwiLFxuICBsb29rYWhlYWQ6IFwibG9va2FoZWFkXCIsXG4gIGxvb2tiZWhpbmQ6IFwibG9va2JlaGluZFwiXG59O1xudmFyIEVzY2FwZUNoYXJDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiYVwiLCA3XSxcbiAgLy8gYWxlcnQvYmVsbCAoTm90IGF2YWlsYWJsZSBpbiBKUylcbiAgW1wiYlwiLCA4XSxcbiAgLy8gYmFja3NwYWNlIChvbmx5IGluIGNoYXIgY2xhc3NlcylcbiAgW1wiZVwiLCAyN10sXG4gIC8vIGVzY2FwZSAoTm90IGF2YWlsYWJsZSBpbiBKUylcbiAgW1wiZlwiLCAxMl0sXG4gIC8vIGZvcm0gZmVlZFxuICBbXCJuXCIsIDEwXSxcbiAgLy8gbGluZSBmZWVkXG4gIFtcInJcIiwgMTNdLFxuICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgW1widFwiLCA5XSxcbiAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgW1widlwiLCAxMV1cbiAgLy8gdmVydGljYWwgdGFiXG5dKTtcbnZhciBjaGFyQ2xhc3NPcGVuUGF0dGVybiA9IHJgXFxbXFxeP2A7XG52YXIgc2hhcmVkRXNjYXBlc1BhdHRlcm4gPSBgJHsvLyBDb250cm9sIGNoYXJcblwiYy4/IHwgQyg/Oi0uPyk/XCJ9fCR7Ly8gVW5pY29kZSBwcm9wZXJ0eTsgT25pZyBjb25zaWRlcnMgYFxccGAgYW4gaWRlbnRpdHkgZXNjYXBlLCBidXQgZS5nLiBgXFxwe2AsIGBcXHB7IF5MfWAsIGFuZFxuLy8gYFxccHtnYz1MfWAgYXJlIGludmFsaWRcbnJgW3BQXVxceyg/OlxcXj9bLVxceDIwX10qW0EtWmEtel1bLVxceDIwXFx3XSpcXH0pP2B9fCR7Ly8gSGV4IGVuY29kZWQgYnl0ZSBzZXF1ZW5jZTsgYXR0ZW1wdCBtYXRjaCBiZWZvcmUgb3RoZXIgYFxceE5OYCBoZXggY2hhclxucmB4Wzg5QS1GYS1mXVxccHtBSGV4fSg/OlxcXFx4Wzg5QS1GYS1mXVxccHtBSGV4fSkqYH18JHsvLyBIZXggY2hhclxucmB1KD86XFxwe0FIZXh9ezR9KT8gfCB4XFx7W15cXH1dKlxcfT8gfCB4XFxwe0FIZXh9ezAsMn1gfXwkey8vIEVuY2xvc2VkIG9jdGFsIGNvZGUgcG9pbnRcbnJgb1xce1teXFx9XSpcXH0/YH18JHsvLyBFc2NhcGVkIG51bWJlclxucmBcXGR7MSwzfWB9YDtcbnZhciBxdWFudGlmaWVyUmUgPSAvWz8qK11bPytdP3xcXHsoPzpcXGQrKD86LFxcZCopP3wsXFxkKylcXH1cXD8/LztcbnZhciB0b2tlblJlID0gbmV3IFJlZ0V4cChyYFxuICBcXFxcICg/OlxuICAgICR7c2hhcmVkRXNjYXBlc1BhdHRlcm59XG4gICAgfCBbZ2tdPFtePl0qPj9cbiAgICB8IFtna10nW14nXSonP1xuICAgIHwgLlxuICApXG4gIHwgXFwoICg/OlxuICAgIFxcPyAoPzpcbiAgICAgIFs6PSE+KHtdXG4gICAgICB8IDxbPSFdXG4gICAgICB8IDxbXj5dKj5cbiAgICAgIHwgJ1teJ10qJ1xuICAgICAgfCB+XFx8P1xuICAgICAgfCAjKD86W14pXFxcXF18XFxcXC4/KSpcbiAgICAgIHwgW146KV0qWzopXVxuICAgICk/XG4gICAgfCBcXCpcbiAgKT9cbiAgfCAke3F1YW50aWZpZXJSZS5zb3VyY2V9XG4gIHwgJHtjaGFyQ2xhc3NPcGVuUGF0dGVybn1cbiAgfCAuXG5gLnJlcGxhY2UoL1xccysvZywgXCJcIiksIFwiZ3N1XCIpO1xudmFyIGNoYXJDbGFzc1Rva2VuUmUgPSBuZXcgUmVnRXhwKHJgXG4gIFxcXFwgKD86XG4gICAgJHtzaGFyZWRFc2NhcGVzUGF0dGVybn1cbiAgICB8IC5cbiAgKVxuICB8IFxcWzooPzpcXF4/XFxwe0FscGhhfSt8XFxeKTpcXF1cbiAgfCAke2NoYXJDbGFzc09wZW5QYXR0ZXJufVxuICB8ICYmXG4gIHwgLlxuYC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpLCBcImdzdVwiKTtcbmZ1bmN0aW9uIHRva2VuaXplKHBhdHRlcm4sIGZsYWdzID0gXCJcIiwgcnVsZXMpIHtcbiAgcnVsZXMgPSB7XG4gICAgLy8gYE9OSUdfT1BUSU9OX0NBUFRVUkVfR1JPVVBgXG4gICAgY2FwdHVyZUdyb3VwOiBmYWxzZSxcbiAgICAvLyBgT05JR19PUFRJT05fU0lOR0xFTElORWBcbiAgICBzaW5nbGVsaW5lOiBmYWxzZSxcbiAgICAuLi5ydWxlc1xuICB9O1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgZXhwZWN0ZWQgYXMgcGF0dGVyblwiKTtcbiAgfVxuICBpZiAoIS9eW2lteERTV10qJC8udGVzdChmbGFncykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZsYWdzIFwiJHtmbGFnc31cIiBpbmNsdWRlcyB1bnN1cHBvcnRlZCB2YWx1ZWApO1xuICB9XG4gIGNvbnN0IGV4dGVuZGVkID0gZmxhZ3MuaW5jbHVkZXMoXCJ4XCIpO1xuICBjb25zdCB4U3RhY2sgPSBbZXh0ZW5kZWRdO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGNhcHR1cmVHcm91cDogcnVsZXMuY2FwdHVyZUdyb3VwLFxuICAgIGdldEN1cnJlbnRNb2RYOiAoKSA9PiB4U3RhY2suYXQoLTEpLFxuICAgIG51bU9wZW5Hcm91cHM6IDAsXG4gICAgcG9wTW9kWCgpIHtcbiAgICAgIHhTdGFjay5wb3AoKTtcbiAgICB9LFxuICAgIHB1c2hNb2RYKGlzWE9uKSB7XG4gICAgICB4U3RhY2sucHVzaChpc1hPbik7XG4gICAgfSxcbiAgICByZXBsYWNlQ3VycmVudE1vZFgoaXNYT24pIHtcbiAgICAgIHhTdGFja1t4U3RhY2subGVuZ3RoIC0gMV0gPSBpc1hPbjtcbiAgICB9LFxuICAgIHNpbmdsZWxpbmU6IHJ1bGVzLnNpbmdsZWxpbmVcbiAgfTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgbWF0Y2g7XG4gIHRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKG1hdGNoID0gdG9rZW5SZS5leGVjKHBhdHRlcm4pKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0VG9rZW5XaXRoRGV0YWlscyhjb250ZXh0LCBwYXR0ZXJuLCBtYXRjaFswXSwgdG9rZW5SZS5sYXN0SW5kZXgpO1xuICAgIGlmIChyZXN1bHQudG9rZW5zKSB7XG4gICAgICB0b2tlbnMucHVzaCguLi5yZXN1bHQudG9rZW5zKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC50b2tlbikge1xuICAgICAgdG9rZW5zLnB1c2gocmVzdWx0LnRva2VuKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sYXN0SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSByZXN1bHQubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuICBjb25zdCBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2VucyA9IFtdO1xuICBsZXQgbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcyA9IDA7XG4gIHRva2Vucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgaWYgKHQudHlwZSA9PT0gVG9rZW5UeXBlcy5Hcm91cE9wZW4pIHtcbiAgICAgIGlmICh0LmtpbmQgPT09IFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmcpIHtcbiAgICAgICAgdC5udW1iZXIgPSArK251bU5hbWVkQW5kT3B0SW5Vbm5hbWVkQ2FwdHVyZXM7XG4gICAgICB9IGVsc2UgaWYgKHQucmF3ID09PSBcIihcIikge1xuICAgICAgICBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2Vucy5wdXNoKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmICghbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcykge1xuICAgIHBvdGVudGlhbFVubmFtZWRDYXB0dXJlVG9rZW5zLmZvckVhY2goKHQsIGkpID0+IHtcbiAgICAgIHQua2luZCA9IFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmc7XG4gICAgICB0Lm51bWJlciA9IGkgKyAxO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG51bUNhcHR1cmVzID0gbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcyB8fCBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2Vucy5sZW5ndGg7XG4gIHRva2VucyA9IHRva2Vucy5tYXAoXG4gICAgKHQpID0+IHQudHlwZSA9PT0gVG9rZW5UeXBlcy5Fc2NhcGVkTnVtYmVyID8gc3BsaXRFc2NhcGVkTnVtVG9rZW4odCwgbnVtQ2FwdHVyZXMpIDogdFxuICApLmZsYXQoKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbnMsXG4gICAgZmxhZ3M6IHtcbiAgICAgIGlnbm9yZUNhc2U6IGZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICAgIC8vIEZsYWcgbSBpcyBjYWxsZWQgYG11bHRpbGluZWAgaW4gT25pZywgYnV0IHRoYXQgaGFzIGEgZGlmZmVyZW50IG1lYW5pbmcgaW4gSlMuIE9uaWcgZmxhZyBtXG4gICAgICAvLyBpcyBlcXVpdmFsZW50IHRvIEpTIGZsYWcgc1xuICAgICAgZG90QWxsOiBmbGFncy5pbmNsdWRlcyhcIm1cIiksXG4gICAgICAvLyBGbGFnIHggaXMgZnVsbHkgaGFuZGxlZCBkdXJpbmcgdG9rZW5pemF0aW9uXG4gICAgICBleHRlbmRlZCxcbiAgICAgIC8vIEZsYWdzIEQsIFMsIFcgYXJlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBhcyB0b3AtbGV2ZWwgZmxhZ3NcbiAgICAgIGRpZ2l0SXNBc2NpaTogZmxhZ3MuaW5jbHVkZXMoXCJEXCIpLFxuICAgICAgc3BhY2VJc0FzY2lpOiBmbGFncy5pbmNsdWRlcyhcIlNcIiksXG4gICAgICB3b3JkSXNBc2NpaTogZmxhZ3MuaW5jbHVkZXMoXCJXXCIpXG4gICAgfSxcbiAgICBydWxlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5XaXRoRGV0YWlscyhjb250ZXh0LCBwYXR0ZXJuLCBtLCBsYXN0SW5kZXgpIHtcbiAgY29uc3QgW20wLCBtMV0gPSBtO1xuICBpZiAobTAgPT09IFwiW1wiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QWxsVG9rZW5zRm9yQ2hhckNsYXNzKHBhdHRlcm4sIG0sIGxhc3RJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEFycmF5IG9mIGFsbCBvZiB0aGUgY2hhciBjbGFzcydzIHRva2Vuc1xuICAgICAgdG9rZW5zOiByZXN1bHQudG9rZW5zLFxuICAgICAgLy8gSnVtcCBmb3J3YXJkIHRvIHRoZSBlbmQgb2YgdGhlIGNoYXIgY2xhc3NcbiAgICAgIGxhc3RJbmRleDogcmVzdWx0Lmxhc3RJbmRleFxuICAgIH07XG4gIH1cbiAgaWYgKG0wID09PSBcIlxcXFxcIikge1xuICAgIGlmIChcIkFiQkd6WlwiLmluY2x1ZGVzKG0xKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQXNzZXJ0aW9uLCBtLCB7XG4gICAgICAgICAga2luZDogbVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKC9eXFxcXGdbPCddLy50ZXN0KG0pKSB7XG4gICAgICBpZiAoIS9eXFxcXGcoPzo8W14+XSs+fCdbXiddKycpJC8udGVzdChtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3JvdXAgbmFtZSBcIiR7bX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuU3Vicm91dGluZSwgbSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICgvXlxcXFxrWzwnXS8udGVzdChtKSkge1xuICAgICAgaWYgKCEvXlxcXFxrKD86PFtePl0rPnwnW14nXSsnKSQvLnRlc3QobSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdyb3VwIG5hbWUgXCIke219XCJgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkJhY2tyZWZlcmVuY2UsIG0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobTEgPT09IFwiS1wiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5EaXJlY3RpdmUsIG0sIHtcbiAgICAgICAgICBraW5kOiBUb2tlbkRpcmVjdGl2ZUtpbmRzLmtlZXBcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtMSA9PT0gXCJOXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgbSwge1xuICAgICAgICAgIGtpbmQ6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMubm9uX25ld2xpbmVcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtMSA9PT0gXCJPXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgbSwge1xuICAgICAgICAgIGtpbmQ6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuYW55XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXCJSWFwiLmluY2x1ZGVzKG0xKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQsIG0sIHtcbiAgICAgICAgICBraW5kOiBtXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXCJ5WVwiLmluY2x1ZGVzKG0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBncmFwaGVtZSBib3VuZGFyeSBcIiR7bX1cImApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVUb2tlbkZvclNoYXJlZEVzY2FwZShtLCB7IGluQ2hhckNsYXNzOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXN1bHQpID8geyB0b2tlbnM6IHJlc3VsdCB9IDogeyB0b2tlbjogcmVzdWx0IH07XG4gIH1cbiAgaWYgKG0wID09PSBcIihcIikge1xuICAgIGlmIChtID09PSBcIigqXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmFtZWQgY2FsbG91dCBcIiR7bX1cImApO1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoP3tcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjYWxsb3V0IFwiJHttfVwiYCk7XG4gICAgfVxuICAgIGlmIChtID09PSBcIig/I1wiKSB7XG4gICAgICBpZiAocGF0dGVybltsYXN0SW5kZXhdICE9PSBcIilcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIGNvbW1lbnQgZ3JvdXAgXCIoPyNcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdEluZGV4OiBsYXN0SW5kZXggKyAxXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoL15cXChcXD9bLWlteF0rWzopXSQvLnRlc3QobSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbkZvckZsYWdNb2QobSwgY29udGV4dClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnRleHQucHVzaE1vZFgoY29udGV4dC5nZXRDdXJyZW50TW9kWCgpKTtcbiAgICBjb250ZXh0Lm51bU9wZW5Hcm91cHMrKztcbiAgICBpZiAoXG4gICAgICAvLyBVbm5hbWVkIGNhcHR1cmUgaWYgbm8gbmFtZWQgY2FwdHVyZXMgcHJlc2VudCBhbmQgYGNhcHR1cmVHcm91cGAgbm90IGVuYWJsZWQsIGVsc2VcbiAgICAgIC8vIG5vbmNhcHR1cmluZyBncm91cFxuICAgICAgbSA9PT0gXCIoXCIgJiYgIWNvbnRleHQuY2FwdHVyZUdyb3VwIHx8IC8vIE5vbmNhcHR1cmluZyBncm91cFxuICAgICAgbSA9PT0gXCIoPzpcIlxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBPcGVuLCBtLCB7XG4gICAgICAgICAgLy8gRm9yIGAoYCwgd2lsbCBsYXRlciBjaGFuZ2UgdG8gYGNhcHR1cmluZ2AgYW5kIGFkZCBgbnVtYmVyYCBwcm9wIGlmIG5vIG5hbWVkIGNhcHR1cmVzXG4gICAgICAgICAga2luZDogVG9rZW5Hcm91cEtpbmRzLmdyb3VwXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoPz5cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBPcGVuLCBtLCB7XG4gICAgICAgICAga2luZDogVG9rZW5Hcm91cEtpbmRzLmF0b21pY1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0gPT09IFwiKD89XCIgfHwgbSA9PT0gXCIoPyFcIiB8fCBtID09PSBcIig/PD1cIiB8fCBtID09PSBcIig/PCFcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBPcGVuLCBtLCB7XG4gICAgICAgICAga2luZDogbVsyXSA9PT0gXCI8XCIgPyBUb2tlbkdyb3VwS2luZHMubG9va2JlaGluZCA6IFRva2VuR3JvdXBLaW5kcy5sb29rYWhlYWQsXG4gICAgICAgICAgbmVnYXRlOiBtLmVuZHNXaXRoKFwiIVwiKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0gPT09IFwiKFwiICYmIGNvbnRleHQuY2FwdHVyZUdyb3VwIHx8IG0uc3RhcnRzV2l0aChcIig/PFwiKSAmJiBtLmVuZHNXaXRoKFwiPlwiKSB8fCBtLnN0YXJ0c1dpdGgoXCIoPydcIikgJiYgbS5lbmRzV2l0aChcIidcIikpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cE9wZW4sIG0sIHtcbiAgICAgICAga2luZDogVG9rZW5Hcm91cEtpbmRzLmNhcHR1cmluZ1xuICAgICAgICAvLyBXaWxsIGFkZCBgbnVtYmVyYCBwcm9wIGluIGEgc2Vjb25kIHBhc3NcbiAgICAgIH0pO1xuICAgICAgaWYgKG0gIT09IFwiKFwiKSB7XG4gICAgICAgIHRva2VuLm5hbWUgPSBtLnNsaWNlKDMsIC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobS5zdGFydHNXaXRoKFwiKD9+XCIpKSB7XG4gICAgICBpZiAobSA9PT0gXCIoP358XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhYnNlbnQgZnVuY3Rpb24ga2luZCBcIiR7bX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBPcGVuLCBtLCB7XG4gICAgICAgICAga2luZDogVG9rZW5Hcm91cEtpbmRzLmFic2VudF9yZXBlYXRlclxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0gPT09IFwiKD8oXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29uZGl0aW9uYWwgXCIke219XCJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGdyb3VwIG9wdGlvbiBcIiR7bX1cImApO1xuICB9XG4gIGlmIChtID09PSBcIilcIikge1xuICAgIGNvbnRleHQucG9wTW9kWCgpO1xuICAgIGNvbnRleHQubnVtT3Blbkdyb3Vwcy0tO1xuICAgIGlmIChjb250ZXh0Lm51bU9wZW5Hcm91cHMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VubWF0Y2hlZCBcIilcIicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBDbG9zZSwgbSlcbiAgICB9O1xuICB9XG4gIGlmIChtID09PSBcIiNcIiAmJiBjb250ZXh0LmdldEN1cnJlbnRNb2RYKCkpIHtcbiAgICBjb25zdCBlbmQgPSBwYXR0ZXJuLmluZGV4T2YoXCJcXG5cIiwgbGFzdEluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gSnVtcCBmb3J3YXJkIHRvIHRoZSBlbmQgb2YgdGhlIGNvbW1lbnRcbiAgICAgIGxhc3RJbmRleDogZW5kID09PSAtMSA/IHBhdHRlcm4ubGVuZ3RoIDogZW5kXG4gICAgfTtcbiAgfVxuICBpZiAoL15cXHMkLy50ZXN0KG0pICYmIGNvbnRleHQuZ2V0Q3VycmVudE1vZFgoKSkge1xuICAgIGNvbnN0IHJlID0gL1xccysveTtcbiAgICByZS5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgY29uc3QgcmVzdCA9IHJlLmV4ZWMocGF0dGVybik7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEp1bXAgZm9yd2FyZCB0byB0aGUgZW5kIG9mIHRoZSB3aGl0ZXNwYWNlXG4gICAgICBsYXN0SW5kZXg6IHJlc3QgPyByZS5sYXN0SW5kZXggOiBsYXN0SW5kZXhcbiAgICB9O1xuICB9XG4gIGlmIChtID09PSBcIi5cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQsIG0sIHtcbiAgICAgICAga2luZDogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5kb3RcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBpZiAobSA9PT0gXCJeXCIgfHwgbSA9PT0gXCIkXCIpIHtcbiAgICBjb25zdCBraW5kID0gY29udGV4dC5zaW5nbGVsaW5lID8ge1xuICAgICAgXCJeXCI6IHJgXFxBYCxcbiAgICAgIFwiJFwiOiByYFxcWmBcbiAgICB9W21dIDogbTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQXNzZXJ0aW9uLCBtLCB7XG4gICAgICAgIGtpbmRcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBpZiAobSA9PT0gXCJ8XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQWx0ZXJuYXRvciwgbSlcbiAgICB9O1xuICB9XG4gIGlmIChxdWFudGlmaWVyUmUudGVzdChtKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogY3JlYXRlVG9rZW5Gb3JRdWFudGlmaWVyKG0pXG4gICAgfTtcbiAgfVxuICBhc3NlcnRTaW5nbGVDb2RlUG9pbnQobSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCBtLCB7XG4gICAgICB2YWx1ZTogbS5jb2RlUG9pbnRBdCgwKVxuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGxUb2tlbnNGb3JDaGFyQ2xhc3MocGF0dGVybiwgb3BlbmVyLCBsYXN0SW5kZXgpIHtcbiAgY29uc3QgdG9rZW5zID0gW2NyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NPcGVuLCBvcGVuZXIsIHtcbiAgICBuZWdhdGU6IG9wZW5lclsxXSA9PT0gXCJeXCJcbiAgfSldO1xuICBsZXQgbnVtQ2hhckNsYXNzZXNPcGVuID0gMTtcbiAgbGV0IG1hdGNoO1xuICBjaGFyQ2xhc3NUb2tlblJlLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgd2hpbGUgKG1hdGNoID0gY2hhckNsYXNzVG9rZW5SZS5leGVjKHBhdHRlcm4pKSB7XG4gICAgY29uc3QgbSA9IG1hdGNoWzBdO1xuICAgIGlmIChtWzBdID09PSBcIltcIiAmJiBtWzFdICE9PSBcIjpcIikge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuKys7XG4gICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzT3BlbiwgbSwge1xuICAgICAgICBuZWdhdGU6IG1bMV0gPT09IFwiXlwiXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmIChtID09PSBcIl1cIikge1xuICAgICAgaWYgKHRva2Vucy5hdCgtMSkudHlwZSA9PT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc09wZW4pIHtcbiAgICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIG0sIHtcbiAgICAgICAgICB2YWx1ZTogOTNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NDbG9zZSwgbSkpO1xuICAgICAgICBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRva2VuRm9yQW55VG9rZW5XaXRoaW5DaGFyQ2xhc3MobSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbnMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2VucyxcbiAgICBsYXN0SW5kZXg6IGNoYXJDbGFzc1Rva2VuUmUubGFzdEluZGV4IHx8IHBhdHRlcm4ubGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvckFueVRva2VuV2l0aGluQ2hhckNsYXNzKHJhdykge1xuICBpZiAocmF3WzBdID09PSBcIlxcXFxcIikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkZvclNoYXJlZEVzY2FwZShyYXcsIHsgaW5DaGFyQ2xhc3M6IHRydWUgfSk7XG4gIH1cbiAgaWYgKHJhd1swXSA9PT0gXCJbXCIpIHtcbiAgICBjb25zdCBwb3NpeCA9IC9cXFs6KD88bmVnYXRlPlxcXj8pKD88bmFtZT5bYS16XSspOlxcXS8uZXhlYyhyYXcpO1xuICAgIGlmICghcG9zaXggfHwgIVBvc2l4Q2xhc3Nlc01hcC5nZXQocG9zaXguZ3JvdXBzLm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgUE9TSVggY2xhc3MgXCIke3Jhd31cImApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQsIHJhdywge1xuICAgICAga2luZDogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5wb3NpeCxcbiAgICAgIG5lZ2F0ZTogISFwb3NpeC5ncm91cHMubmVnYXRlLFxuICAgICAgdmFsdWU6IHBvc2l4Lmdyb3Vwcy5uYW1lXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJhdyA9PT0gXCItXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0h5cGhlbiwgcmF3KTtcbiAgfVxuICBpZiAocmF3ID09PSBcIiYmXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yLCByYXcpO1xuICB9XG4gIGFzc2VydFNpbmdsZUNvZGVQb2ludChyYXcpO1xuICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdywge1xuICAgIHZhbHVlOiByYXcuY29kZVBvaW50QXQoMClcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvclNoYXJlZEVzY2FwZShyYXcsIHsgaW5DaGFyQ2xhc3MgfSkge1xuICBjb25zdCBjaGFyMSA9IHJhd1sxXTtcbiAgaWYgKGNoYXIxID09PSBcImNcIiB8fCBjaGFyMSA9PT0gXCJDXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW5Gb3JDb250cm9sQ2hhcihyYXcpO1xuICB9XG4gIGlmIChcImREaEhzU3dXXCIuaW5jbHVkZXMoY2hhcjEpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuRm9yU2hvcnRoYW5kQ2hhckNsYXNzKHJhdyk7XG4gIH1cbiAgaWYgKHJhdy5zdGFydHNXaXRoKHJgXFxve2ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBsZXRlLCBpbnZhbGlkLCBvciB1bnN1cHBvcnRlZCBvY3RhbCBjb2RlIHBvaW50IFwiJHtyYXd9XCJgKTtcbiAgfVxuICBpZiAoL15cXFxcW3BQXVxcey8udGVzdChyYXcpKSB7XG4gICAgaWYgKHJhdy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wbGV0ZSBvciBpbnZhbGlkIFVuaWNvZGUgcHJvcGVydHkgXCIke3Jhd31cImApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVG9rZW5Gb3JVbmljb2RlUHJvcGVydHkocmF3KTtcbiAgfVxuICBpZiAoL15cXFxceFs4OUEtRmEtZl1cXHB7QUhleH0vdS50ZXN0KHJhdykpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnl0ZXMgPSByYXcuc3BsaXQoL1xcXFx4Lykuc2xpY2UoMSkubWFwKChoZXgpID0+IHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7XG4gICAgICAgIGlnbm9yZUJPTTogdHJ1ZSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pLmRlY29kZShuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3QgdG9rZW5zID0gWy4uLmRlY29kZWRdLm1hcCgoY2hhcikgPT4ge1xuICAgICAgICBjb25zdCByYXcyID0gWy4uLmVuY29kZXIuZW5jb2RlKGNoYXIpXS5tYXAoKGJ5dGUpID0+IGBcXFxceCR7Ynl0ZS50b1N0cmluZygxNil9YCkuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcyLCB7XG4gICAgICAgICAgdmFsdWU6IGNoYXIuY29kZVBvaW50QXQoMClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpYnl0ZSBjb2RlIFwiJHtyYXd9XCIgaW5jb21wbGV0ZSBvciBpbnZhbGlkIGluIE9uaWd1cnVtYWApO1xuICAgIH1cbiAgfVxuICBpZiAoY2hhcjEgPT09IFwidVwiIHx8IGNoYXIxID09PSBcInhcIikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3LCB7XG4gICAgICB2YWx1ZTogZ2V0VmFsaWRhdGVkSGV4Q2hhckNvZGUocmF3KVxuICAgIH0pO1xuICB9XG4gIGlmIChFc2NhcGVDaGFyQ29kZXMuaGFzKGNoYXIxKSkge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3LCB7XG4gICAgICB2YWx1ZTogRXNjYXBlQ2hhckNvZGVzLmdldChjaGFyMSlcbiAgICB9KTtcbiAgfVxuICBpZiAoL1xcZC8udGVzdChjaGFyMSkpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Fc2NhcGVkTnVtYmVyLCByYXcsIHtcbiAgICAgIGluQ2hhckNsYXNzXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJhdyA9PT0gXCJcXFxcXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocmBJbmNvbXBsZXRlIGVzY2FwZSBcIlxcXCJgKTtcbiAgfVxuICBpZiAoY2hhcjEgPT09IFwiTVwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtZXRhIFwiJHtyYXd9XCJgKTtcbiAgfVxuICBpZiAoWy4uLnJhd10ubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcsIHtcbiAgICAgIHZhbHVlOiByYXcuY29kZVBvaW50QXQoMSlcbiAgICB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXNjYXBlIFwiJHtyYXd9XCJgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuKHR5cGUsIHJhdywgZGF0YSkge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgcmF3LFxuICAgIC4uLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yQ29udHJvbENoYXIocmF3KSB7XG4gIGNvbnN0IGNoYXIgPSByYXdbMV0gPT09IFwiY1wiID8gcmF3WzJdIDogcmF3WzNdO1xuICBpZiAoIWNoYXIgfHwgIS9bQS1aYS16XS8udGVzdChjaGFyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udHJvbCBjaGFyYWN0ZXIgXCIke3Jhd31cImApO1xuICB9XG4gIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3LCB7XG4gICAgdmFsdWU6IGNoYXIudG9VcHBlckNhc2UoKS5jb2RlUG9pbnRBdCgwKSAtIDY0XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JGbGFnTW9kKHJhdywgY29udGV4dCkge1xuICBsZXQgeyBvbiwgb2ZmIH0gPSAvXlxcKFxcPyg/PG9uPltpbXhdKikoPzotKD88b2ZmPlstaW14XSopKT8vLmV4ZWMocmF3KS5ncm91cHM7XG4gIG9mZiA/Pz0gXCJcIjtcbiAgY29uc3QgaXNYT24gPSAoY29udGV4dC5nZXRDdXJyZW50TW9kWCgpIHx8IG9uLmluY2x1ZGVzKFwieFwiKSkgJiYgIW9mZi5pbmNsdWRlcyhcInhcIik7XG4gIGNvbnN0IGVuYWJsZWRGbGFncyA9IGdldEZsYWdQcm9wc0ZvclRva2VuKG9uKTtcbiAgY29uc3QgZGlzYWJsZWRGbGFncyA9IGdldEZsYWdQcm9wc0ZvclRva2VuKG9mZik7XG4gIGNvbnN0IGZsYWdDaGFuZ2VzID0ge307XG4gIGVuYWJsZWRGbGFncyAmJiAoZmxhZ0NoYW5nZXMuZW5hYmxlID0gZW5hYmxlZEZsYWdzKTtcbiAgZGlzYWJsZWRGbGFncyAmJiAoZmxhZ0NoYW5nZXMuZGlzYWJsZSA9IGRpc2FibGVkRmxhZ3MpO1xuICBpZiAocmF3LmVuZHNXaXRoKFwiKVwiKSkge1xuICAgIGNvbnRleHQucmVwbGFjZUN1cnJlbnRNb2RYKGlzWE9uKTtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5EaXJlY3RpdmUsIHJhdywge1xuICAgICAga2luZDogVG9rZW5EaXJlY3RpdmVLaW5kcy5mbGFncyxcbiAgICAgIGZsYWdzOiBmbGFnQ2hhbmdlc1xuICAgIH0pO1xuICB9XG4gIGlmIChyYXcuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgY29udGV4dC5wdXNoTW9kWChpc1hPbik7XG4gICAgY29udGV4dC5udW1PcGVuR3JvdXBzKys7XG4gICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgcmF3LCB7XG4gICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuZ3JvdXBcbiAgICB9KTtcbiAgICBpZiAoZW5hYmxlZEZsYWdzIHx8IGRpc2FibGVkRmxhZ3MpIHtcbiAgICAgIHRva2VuLmZsYWdzID0gZmxhZ0NoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZmxhZyBtb2RpZmllciBcIiR7cmF3fVwiYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvclF1YW50aWZpZXIocmF3KSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgaWYgKHJhd1swXSA9PT0gXCJ7XCIpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSAvXlxceyg/PG1pbj5cXGQqKSg/OiwoPzxtYXg+XFxkKikpPy8uZXhlYyhyYXcpLmdyb3VwcztcbiAgICBjb25zdCBsaW1pdCA9IDFlNTtcbiAgICBpZiAoK21pbiA+IGxpbWl0IHx8ICttYXggPiBsaW1pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVhbnRpZmllciB2YWx1ZSB1bnN1cHBvcnRlZCBpbiBPbmlndXJ1bWFcIik7XG4gICAgfVxuICAgIGRhdGEubWluID0gK21pbjtcbiAgICBkYXRhLm1heCA9IG1heCA9PT0gdm9pZCAwID8gK21pbiA6IG1heCA9PT0gXCJcIiA/IEluZmluaXR5IDogK21heDtcbiAgICBkYXRhLmdyZWVkeSA9ICFyYXcuZW5kc1dpdGgoXCI/XCIpO1xuICAgIGRhdGEucG9zc2Vzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGRhdGEubWluID0gcmF3WzBdID09PSBcIitcIiA/IDEgOiAwO1xuICAgIGRhdGEubWF4ID0gcmF3WzBdID09PSBcIj9cIiA/IDEgOiBJbmZpbml0eTtcbiAgICBkYXRhLmdyZWVkeSA9IHJhd1sxXSAhPT0gXCI/XCI7XG4gICAgZGF0YS5wb3NzZXNzaXZlID0gcmF3WzFdID09PSBcIitcIjtcbiAgfVxuICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5RdWFudGlmaWVyLCByYXcsIGRhdGEpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JTaG9ydGhhbmRDaGFyQ2xhc3MocmF3KSB7XG4gIGNvbnN0IGxvd2VyID0gcmF3WzFdLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgcmF3LCB7XG4gICAga2luZDoge1xuICAgICAgXCJkXCI6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuZGlnaXQsXG4gICAgICBcImhcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5oZXgsXG4gICAgICAvLyBOb3QgYXZhaWxhYmxlIGluIEpTXG4gICAgICBcInNcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5zcGFjZSxcbiAgICAgIC8vIERpZmZlcmVudCB0aGFuIEpTXG4gICAgICBcIndcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy53b3JkXG4gICAgfVtsb3dlcl0sXG4gICAgbmVnYXRlOiByYXdbMV0gIT09IGxvd2VyXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JVbmljb2RlUHJvcGVydHkocmF3KSB7XG4gIGNvbnN0IHsgcCwgbmVnLCB2YWx1ZSB9ID0gL15cXFxcKD88cD5bcFBdKVxceyg/PG5lZz5cXF4/KSg/PHZhbHVlPltefV0rKS8uZXhlYyhyYXcpLmdyb3VwcztcbiAgY29uc3QgbmVnYXRlID0gcCA9PT0gXCJQXCIgJiYgIW5lZyB8fCBwID09PSBcInBcIiAmJiAhIW5lZztcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCByYXcsIHtcbiAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5LFxuICAgIG5lZ2F0ZSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZsYWdQcm9wc0ZvclRva2VuKGZsYWdzKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBpZiAoZmxhZ3MuaW5jbHVkZXMoXCJpXCIpKSB7XG4gICAgb2JqLmlnbm9yZUNhc2UgPSB0cnVlO1xuICB9XG4gIGlmIChmbGFncy5pbmNsdWRlcyhcIm1cIikpIHtcbiAgICBvYmouZG90QWxsID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3MuaW5jbHVkZXMoXCJ4XCIpKSB7XG4gICAgb2JqLmV4dGVuZGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPyBvYmogOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkSGV4Q2hhckNvZGUocmF3KSB7XG4gIGlmICgvXig/OlxcXFx1KD8hXFxwe0FIZXh9ezR9KXxcXFxceCg/IVxccHtBSGV4fXsxLDJ9fFxce1xccHtBSGV4fXsxLDh9XFx9KSkvdS50ZXN0KHJhdykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGxldGUgb3IgaW52YWxpZCBlc2NhcGUgXCIke3Jhd31cImApO1xuICB9XG4gIGNvbnN0IGhleCA9IHJhd1syXSA9PT0gXCJ7XCIgPyAvXlxcXFx4XFx7XFxzKig/PGhleD5cXHB7QUhleH0rKS91LmV4ZWMocmF3KS5ncm91cHMuaGV4IDogcmF3LnNsaWNlKDIpO1xuICBjb25zdCBkZWMgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgcmV0dXJuIGRlYztcbn1cbmZ1bmN0aW9uIHNwbGl0RXNjYXBlZE51bVRva2VuKHRva2VuLCBudW1DYXB0dXJlcykge1xuICBjb25zdCB7IHJhdywgaW5DaGFyQ2xhc3MgfSA9IHRva2VuO1xuICBjb25zdCB2YWx1ZSA9IHJhdy5zbGljZSgxKTtcbiAgaWYgKCFpbkNoYXJDbGFzcyAmJiAvLyBTaW5nbGUgZGlnaXQgMS05IG91dHNpZGUgYSBjaGFyIGNsYXNzIGlzIGFsd2F5cyB0cmVhdGVkIGFzIGEgYmFja3JlZlxuICAodmFsdWUgIT09IFwiMFwiICYmIHZhbHVlLmxlbmd0aCA9PT0gMSB8fCAvLyBMZWFkaW5nIDAgbWFrZXMgaXQgb2N0YWw7IGJhY2tyZWZzIGNhbid0IGluY2x1ZGUgZm9sbG93aW5nIGxpdGVyYWwgZGlnaXRzXG4gIHZhbHVlWzBdICE9PSBcIjBcIiAmJiArdmFsdWUgPD0gbnVtQ2FwdHVyZXMpKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVUb2tlbihUb2tlblR5cGVzLkJhY2tyZWZlcmVuY2UsIHJhdyldO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goL15bMC03XSt8XFxkL2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtID0gbWF0Y2hlc1tpXTtcbiAgICBsZXQgdmFsdWUyO1xuICAgIGlmIChpID09PSAwICYmIG0gIT09IFwiOFwiICYmIG0gIT09IFwiOVwiKSB7XG4gICAgICB2YWx1ZTIgPSBwYXJzZUludChtLCA4KTtcbiAgICAgIGlmICh2YWx1ZTIgPiAxMjcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgT2N0YWwgZW5jb2RlZCBieXRlIGFib3ZlIDE3NyB1bnN1cHBvcnRlZCBcIiR7cmF3fVwiYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlMiA9IG0uY29kZVBvaW50QXQoMCk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCAoaSA9PT0gMCA/IFwiXFxcXFwiIDogXCJcIikgKyBtLCB7XG4gICAgICB2YWx1ZTogdmFsdWUyXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBhc3NlcnRTaW5nbGVDb2RlUG9pbnQocmF3KSB7XG4gIGlmIChbLi4ucmF3XS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiJHtyYXd9XCIgdG8gYmUgYSBzaW5nbGUgY29kZSBwb2ludGApO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy1hc3QuanNcbmZ1bmN0aW9uIGhhc09ubHlDaGlsZCh7IGFsdGVybmF0aXZlcyB9LCBraWRGbikge1xuICByZXR1cm4gYWx0ZXJuYXRpdmVzLmxlbmd0aCA9PT0gMSAmJiBhbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHMubGVuZ3RoID09PSAxICYmICgha2lkRm4gfHwga2lkRm4oYWx0ZXJuYXRpdmVzWzBdLmVsZW1lbnRzWzBdKSk7XG59XG5mdW5jdGlvbiBpc0Fsd2F5c1plcm9MZW5ndGgoeyB0eXBlIH0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IEFzdFR5cGVzLkFzc2VydGlvbiB8fCB0eXBlID09PSBBc3RUeXBlcy5EaXJlY3RpdmU7XG59XG5mdW5jdGlvbiBpc0Fsd2F5c05vblplcm9MZW5ndGgobm9kZSkge1xuICBjb25zdCB0eXBlcyA9IFtcbiAgICBBc3RUeXBlcy5DaGFyYWN0ZXIsXG4gICAgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MsXG4gICAgQXN0VHlwZXMuQ2hhcmFjdGVyU2V0XG4gIF07XG4gIHJldHVybiB0eXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpIHx8IG5vZGUudHlwZSA9PT0gQXN0VHlwZXMuUXVhbnRpZmllciAmJiBub2RlLm1pbiAmJiB0eXBlcy5pbmNsdWRlcyhub2RlLmVsZW1lbnQudHlwZSk7XG59XG5mdW5jdGlvbiBpc0NvbnN1bXB0aXZlR3JvdXAoeyB0eXBlIH0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwIHx8IHR5cGUgPT09IEFzdFR5cGVzLkdyb3VwO1xufVxuZnVuY3Rpb24gaXNMb29rYXJvdW5kKHsgdHlwZSwga2luZCB9KSB7XG4gIHJldHVybiB0eXBlID09PSBBc3RUeXBlcy5Bc3NlcnRpb24gJiYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCB8fCBraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYmVoaW5kKTtcbn1cblxuLy8gc3JjL3RyYXZlcnNlLmpzXG5mdW5jdGlvbiB0cmF2ZXJzZShwYXRoLCBzdGF0ZSwgdmlzaXRvcikge1xuICBsZXQgYXN0ID0gcGF0aC5ub2RlO1xuICB3aGlsZSAoYXN0LnBhcmVudCkge1xuICAgIGFzdCA9IGFzdC5wYXJlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdHJhdmVyc2VBcnJheShhcnJheSwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5U2hpZnQgPSB0cmF2ZXJzZU5vZGUoYXJyYXlbaV0sIHBhcmVudCwgaSwgYXJyYXkpO1xuICAgICAgaSA9IE1hdGgubWF4KC0xLCBpICsga2V5U2hpZnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgcGFyZW50ID0gbnVsbCwga2V5ID0gbnVsbCwgY29udGFpbmVyID0gbnVsbCkge1xuICAgIGxldCBrZXlTaGlmdCA9IDA7XG4gICAgbGV0IHNraXBUcmF2ZXJzaW5nS2lkc09mUGF0aCA9IGZhbHNlO1xuICAgIGNvbnN0IHBhdGgyID0ge1xuICAgICAgbm9kZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIGtleSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFzdCxcbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhyb3dJZk5vdChjb250YWluZXIsIFwiQ29udGFpbmVyIGV4cGVjdGVkXCIpLnNwbGljZShNYXRoLm1heCgwLCBrZXkgKyBrZXlTaGlmdCksIDEpO1xuICAgICAgICBrZXlTaGlmdCAtPSAxO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbE5leHRTaWJsaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRocm93SWZOb3QoY29udGFpbmVyLCBcIkNvbnRhaW5lciBleHBlY3RlZFwiKS5zcGxpY2Uoa2V5ICsgMSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsUHJldlNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBzaGlmdGVkID0ga2V5ICsga2V5U2hpZnQ7XG4gICAgICAgIGtleVNoaWZ0IC09IHNoaWZ0ZWQ7XG4gICAgICAgIHJldHVybiB0aHJvd0lmTm90KGNvbnRhaW5lciwgXCJDb250YWluZXIgZXhwZWN0ZWRcIikuc3BsaWNlKDAsIE1hdGgubWF4KDAsIHNoaWZ0ZWQpKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlV2l0aChuZXdOb2RlKSB7XG4gICAgICAgIHNldFBhcmVudChuZXdOb2RlLCBwYXJlbnQpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyW01hdGgubWF4KDAsIGtleSArIGtleVNoaWZ0KV0gPSBuZXdOb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFtrZXldID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNraXAoKSB7XG4gICAgICAgIHNraXBUcmF2ZXJzaW5nS2lkc09mUGF0aCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB2aXNpdG9yS2V5ID0gZ2V0QXN0VHlwZUFsaWFzZXMobm9kZSkuZmluZCgoa2V5MikgPT4gISF2aXNpdG9yW2tleTJdKTtcbiAgICBjb25zdCBtZXRob2RzID0gdmlzaXRvcktleSAmJiB2aXNpdG9yW3Zpc2l0b3JLZXldO1xuICAgIGNvbnN0IGVudGVyRm4gPSB0eXBlb2YgbWV0aG9kcyA9PT0gXCJmdW5jdGlvblwiID8gbWV0aG9kcyA6IG1ldGhvZHM/LmVudGVyO1xuICAgIGNvbnN0IGV4aXRGbiA9IG1ldGhvZHM/LmV4aXQ7XG4gICAgZW50ZXJGbj8uKHBhdGgyLCBzdGF0ZSk7XG4gICAgaWYgKCFza2lwVHJhdmVyc2luZ0tpZHNPZlBhdGgpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuUmVnZXg6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUucGF0dGVybiwgbm9kZSwgXCJwYXR0ZXJuXCIpO1xuICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmZsYWdzLCBub2RlLCBcImZsYWdzXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkFsdGVybmF0aXZlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzOlxuICAgICAgICAgIHRyYXZlcnNlQXJyYXkobm9kZS5lbGVtZW50cywgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQXNzZXJ0aW9uOlxuICAgICAgICAgIGlmIChpc0xvb2thcm91bmQobm9kZSkpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQXJyYXkobm9kZS5hbHRlcm5hdGl2ZXMsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5CYWNrcmVmZXJlbmNlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlcjpcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQ6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuRGlyZWN0aXZlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkZsYWdzOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlJlY3Vyc2lvbjpcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5TdWJyb3V0aW5lOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkFic2VudEZ1bmN0aW9uOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkdyb3VwOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlBhdHRlcm46XG4gICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmFsdGVybmF0aXZlcywgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb246XG4gICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmNsYXNzZXMsIG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2U6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUubWluLCBub2RlLCBcIm1pblwiKTtcbiAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5tYXgsIG5vZGUsIFwibWF4XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLlF1YW50aWZpZXI6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuZWxlbWVudCwgbm9kZSwgXCJlbGVtZW50XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBub2RlIHR5cGUgXCIke25vZGUudHlwZX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBleGl0Rm4/LihwYXRoMiwgc3RhdGUpO1xuICAgIHJldHVybiBrZXlTaGlmdDtcbiAgfVxuICB0cmF2ZXJzZU5vZGUocGF0aC5ub2RlLCBwYXRoLnBhcmVudCwgcGF0aC5rZXksIHBhdGguY29udGFpbmVyKTtcbn1cbnZhciBBc3RUeXBlQWxpYXNlcyA9IHtcbiAgQW55R3JvdXA6IFwiQW55R3JvdXBcIixcbiAgQW55Tm9kZTogXCJBbnlOb2RlXCJcbn07XG5mdW5jdGlvbiBnZXRBc3RUeXBlQWxpYXNlcyhub2RlKSB7XG4gIGNvbnN0IHR5cGVzID0gW0FzdFR5cGVBbGlhc2VzLkFueU5vZGVdO1xuICBpZiAoaXNDb25zdW1wdGl2ZUdyb3VwKG5vZGUpIHx8IGlzTG9va2Fyb3VuZChub2RlKSkge1xuICAgIHR5cGVzLnB1c2goQXN0VHlwZUFsaWFzZXMuQW55R3JvdXApO1xuICB9XG4gIHR5cGVzLnB1c2gobm9kZS50eXBlKTtcbiAgcmV0dXJuIHR5cGVzO1xufVxuZnVuY3Rpb24gc2V0UGFyZW50KG5vZGUsIHBhcmVudCkge1xuICBpZiAoXCJwYXJlbnRcIiBpbiBwYXJlbnQpIHtcbiAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UuanNcbnZhciBBc3RUeXBlcyA9IHtcbiAgQWJzZW50RnVuY3Rpb246IFwiQWJzZW50RnVuY3Rpb25cIixcbiAgQWx0ZXJuYXRpdmU6IFwiQWx0ZXJuYXRpdmVcIixcbiAgQXNzZXJ0aW9uOiBcIkFzc2VydGlvblwiLFxuICBCYWNrcmVmZXJlbmNlOiBcIkJhY2tyZWZlcmVuY2VcIixcbiAgQ2FwdHVyaW5nR3JvdXA6IFwiQ2FwdHVyaW5nR3JvdXBcIixcbiAgQ2hhcmFjdGVyOiBcIkNoYXJhY3RlclwiLFxuICBDaGFyYWN0ZXJDbGFzczogXCJDaGFyYWN0ZXJDbGFzc1wiLFxuICBDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbjogXCJDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvblwiLFxuICBDaGFyYWN0ZXJDbGFzc1JhbmdlOiBcIkNoYXJhY3RlckNsYXNzUmFuZ2VcIixcbiAgQ2hhcmFjdGVyU2V0OiBcIkNoYXJhY3RlclNldFwiLFxuICBEaXJlY3RpdmU6IFwiRGlyZWN0aXZlXCIsXG4gIEZsYWdzOiBcIkZsYWdzXCIsXG4gIEdyb3VwOiBcIkdyb3VwXCIsXG4gIFBhdHRlcm46IFwiUGF0dGVyblwiLFxuICBRdWFudGlmaWVyOiBcIlF1YW50aWZpZXJcIixcbiAgUmVnZXg6IFwiUmVnZXhcIixcbiAgU3Vicm91dGluZTogXCJTdWJyb3V0aW5lXCIsXG4gIFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OiBcIlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0XCIsXG4gIC8vIFVzZWQgb25seSBieSB0aGUgdHJhbnNmb3JtZXIgZm9yIFJlZ2V4KyBBU1RzXG4gIFJlY3Vyc2lvbjogXCJSZWN1cnNpb25cIlxufTtcbnZhciBBc3RBYnNlbnRGdW5jdGlvbktpbmRzID0ge1xuICAvLyBTZWUgPGdpdGh1Yi5jb20vc2xldml0aGFuL29uaWd1cnVtYS10by1lcy9pc3N1ZXMvMTM+XG4gIHJlcGVhdGVyOiBcInJlcGVhdGVyXCJcbn07XG52YXIgQXN0QXNzZXJ0aW9uS2luZHMgPSB7XG4gIGxpbmVfZW5kOiBcImxpbmVfZW5kXCIsXG4gIGxpbmVfc3RhcnQ6IFwibGluZV9zdGFydFwiLFxuICBsb29rYWhlYWQ6IFwibG9va2FoZWFkXCIsXG4gIGxvb2tiZWhpbmQ6IFwibG9va2JlaGluZFwiLFxuICBzZWFyY2hfc3RhcnQ6IFwic2VhcmNoX3N0YXJ0XCIsXG4gIHN0cmluZ19lbmQ6IFwic3RyaW5nX2VuZFwiLFxuICBzdHJpbmdfZW5kX25ld2xpbmU6IFwic3RyaW5nX2VuZF9uZXdsaW5lXCIsXG4gIHN0cmluZ19zdGFydDogXCJzdHJpbmdfc3RhcnRcIixcbiAgd29yZF9ib3VuZGFyeTogXCJ3b3JkX2JvdW5kYXJ5XCJcbn07XG52YXIgQXN0Q2hhcmFjdGVyU2V0S2luZHMgPSBUb2tlbkNoYXJhY3RlclNldEtpbmRzO1xudmFyIEFzdERpcmVjdGl2ZUtpbmRzID0gVG9rZW5EaXJlY3RpdmVLaW5kcztcbnZhciBBc3RWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldEtpbmRzID0ge1xuICBncmFwaGVtZTogXCJncmFwaGVtZVwiLFxuICBuZXdsaW5lOiBcIm5ld2xpbmVcIlxufTtcbmZ1bmN0aW9uIHBhcnNlKHsgdG9rZW5zLCBmbGFncywgcnVsZXMgfSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIHNraXBCYWNrcmVmVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgdmVyYm9zZTogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGNhcHR1cmluZ0dyb3VwczogW10sXG4gICAgY3VycmVudDogMCxcbiAgICBoYXNOdW1iZXJlZFJlZjogZmFsc2UsXG4gICAgbmFtZWRHcm91cHNCeU5hbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcGFyZW50OiBudWxsLFxuICAgIHNraXBCYWNrcmVmVmFsaWRhdGlvbjogb3B0cy5za2lwQmFja3JlZlZhbGlkYXRpb24sXG4gICAgc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uOiBvcHRzLnNraXBMb29rYmVoaW5kVmFsaWRhdGlvbixcbiAgICBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbjogb3B0cy5za2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbixcbiAgICBzdWJyb3V0aW5lczogW10sXG4gICAgdG9rZW46IG51bGwsXG4gICAgdG9rZW5zLFxuICAgIHZlcmJvc2U6IG9wdHMudmVyYm9zZSxcbiAgICB3YWxrXG4gIH07XG4gIGZ1bmN0aW9uIHdhbGsocGFyZW50LCBzdGF0ZSkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2NvbnRleHQuY3VycmVudF07XG4gICAgY29udGV4dC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgY29udGV4dC50b2tlbiA9IHRva2VuO1xuICAgIGNvbnRleHQuY3VycmVudCsrO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkFsdGVybmF0b3I6XG4gICAgICAgIHJldHVybiBjcmVhdGVBbHRlcm5hdGl2ZSgpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkFzc2VydGlvbjpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFzc2VydGlvbkZyb21Ub2tlbih0b2tlbik7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQmFja3JlZmVyZW5jZTpcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFja3JlZmVyZW5jZShjb250ZXh0KTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5DaGFyYWN0ZXI6XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXIodG9rZW4udmFsdWUsIHsgdXNlTGFzdFZhbGlkOiAhIXN0YXRlLmlzQ2hlY2tpbmdSYW5nZUVuZCB9KTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0h5cGhlbjpcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hhcmFjdGVyQ2xhc3NIeXBoZW4oY29udGV4dCwgc3RhdGUpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzT3BlbjpcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hhcmFjdGVyQ2xhc3NPcGVuKGNvbnRleHQsIHN0YXRlKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQ6XG4gICAgICAgIHJldHVybiBwYXJzZUNoYXJhY3RlclNldChjb250ZXh0KTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5EaXJlY3RpdmU6XG4gICAgICAgIHJldHVybiBjcmVhdGVEaXJlY3RpdmVGcm9tVG9rZW4odG9rZW4pO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkdyb3VwT3BlbjpcbiAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBPcGVuKGNvbnRleHQsIHN0YXRlKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5RdWFudGlmaWVyOlxuICAgICAgICByZXR1cm4gcGFyc2VRdWFudGlmaWVyKGNvbnRleHQpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLlN1YnJvdXRpbmU6XG4gICAgICAgIHJldHVybiBwYXJzZVN1YnJvdXRpbmUoY29udGV4dCk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQ6XG4gICAgICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldCh0b2tlbi5raW5kKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0b2tlbiB0eXBlIFwiJHt0b2tlbi50eXBlfVwiYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFzdCA9IGNyZWF0ZVJlZ2V4KGNyZWF0ZVBhdHRlcm4oKSwgY3JlYXRlRmxhZ3MoZmxhZ3MpKTtcbiAgbGV0IHRvcCA9IGFzdC5wYXR0ZXJuLmFsdGVybmF0aXZlc1swXTtcbiAgd2hpbGUgKGNvbnRleHQuY3VycmVudCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICBjb25zdCBub2RlID0gd2Fsayh0b3AsIHt9KTtcbiAgICBpZiAobm9kZS50eXBlID09PSBBc3RUeXBlcy5BbHRlcm5hdGl2ZSkge1xuICAgICAgYXN0LnBhdHRlcm4uYWx0ZXJuYXRpdmVzLnB1c2gobm9kZSk7XG4gICAgICB0b3AgPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AuZWxlbWVudHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgeyBjYXB0dXJpbmdHcm91cHMsIGhhc051bWJlcmVkUmVmLCBuYW1lZEdyb3Vwc0J5TmFtZSwgc3Vicm91dGluZXMgfSA9IGNvbnRleHQ7XG4gIGlmIChoYXNOdW1iZXJlZFJlZiAmJiBuYW1lZEdyb3Vwc0J5TmFtZS5zaXplICYmICFydWxlcy5jYXB0dXJlR3JvdXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJlZCBiYWNrcmVmL3N1YnJvdXRpbmUgbm90IGFsbG93ZWQgd2hlbiB1c2luZyBuYW1lZCBjYXB0dXJlXCIpO1xuICB9XG4gIGZvciAoY29uc3QgeyByZWYgfSBvZiBzdWJyb3V0aW5lcykge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAocmVmID4gY2FwdHVyaW5nR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YnJvdXRpbmUgdXNlcyBhIGdyb3VwIG51bWJlciB0aGF0J3Mgbm90IGRlZmluZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFuYW1lZEdyb3Vwc0J5TmFtZS5oYXMocmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJgU3Vicm91dGluZSB1c2VzIGEgZ3JvdXAgbmFtZSB0aGF0J3Mgbm90IGRlZmluZWQgXCJcXGc8JHtyZWZ9PlwiYCk7XG4gICAgfSBlbHNlIGlmIChuYW1lZEdyb3Vwc0J5TmFtZS5nZXQocmVmKS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmBTdWJyb3V0aW5lIHVzZXMgYSBkdXBsaWNhdGUgZ3JvdXAgbmFtZSBcIlxcZzwke3JlZn0+XCJgKTtcbiAgICB9XG4gIH1cbiAgdHJhdmVyc2UoeyBub2RlOiBhc3QgfSwgbnVsbCwge1xuICAgIEFueU5vZGUoeyBub2RlLCBwYXJlbnQgfSkge1xuICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFzdDtcbn1cbmZ1bmN0aW9uIHBhcnNlQmFja3JlZmVyZW5jZShjb250ZXh0KSB7XG4gIGNvbnN0IHsgcmF3IH0gPSBjb250ZXh0LnRva2VuO1xuICBjb25zdCBoYXNLV3JhcHBlciA9IC9eXFxcXGtbPCddLy50ZXN0KHJhdyk7XG4gIGNvbnN0IHJlZiA9IGhhc0tXcmFwcGVyID8gcmF3LnNsaWNlKDMsIC0xKSA6IHJhdy5zbGljZSgxKTtcbiAgY29uc3QgZnJvbU51bSA9IChudW0sIGlzUmVsYXRpdmUgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IG51bUNhcHR1cmVzVG9MZWZ0ID0gY29udGV4dC5jYXB0dXJpbmdHcm91cHMubGVuZ3RoO1xuICAgIGxldCBvcnBoYW4gPSBmYWxzZTtcbiAgICBpZiAobnVtID4gbnVtQ2FwdHVyZXNUb0xlZnQpIHtcbiAgICAgIGlmIChjb250ZXh0LnNraXBCYWNrcmVmVmFsaWRhdGlvbikge1xuICAgICAgICBvcnBoYW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZW5vdWdoIGNhcHR1cmluZyBncm91cHMgZGVmaW5lZCB0byB0aGUgbGVmdCBcIiR7cmF3fVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQuaGFzTnVtYmVyZWRSZWYgPSB0cnVlO1xuICAgIHJldHVybiBjcmVhdGVCYWNrcmVmZXJlbmNlKGlzUmVsYXRpdmUgPyBudW1DYXB0dXJlc1RvTGVmdCArIDEgLSBudW0gOiBudW0sIHsgb3JwaGFuIH0pO1xuICB9O1xuICBpZiAoaGFzS1dyYXBwZXIpIHtcbiAgICBjb25zdCBudW1iZXJlZFJlZiA9IC9eKD88c2lnbj4tPykwKig/PG51bT5bMS05XVxcZCopJC8uZXhlYyhyZWYpO1xuICAgIGlmIChudW1iZXJlZFJlZikge1xuICAgICAgcmV0dXJuIGZyb21OdW0oK251bWJlcmVkUmVmLmdyb3Vwcy5udW0sICEhbnVtYmVyZWRSZWYuZ3JvdXBzLnNpZ24pO1xuICAgIH1cbiAgICBpZiAoL1stK10vLnRlc3QocmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhY2tyZWYgbmFtZSBcIiR7cmF3fVwiYCk7XG4gICAgfVxuICAgIGlmICghY29udGV4dC5uYW1lZEdyb3Vwc0J5TmFtZS5oYXMocmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHcm91cCBuYW1lIG5vdCBkZWZpbmVkIHRvIHRoZSBsZWZ0IFwiJHtyYXd9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUJhY2tyZWZlcmVuY2UocmVmKTtcbiAgfVxuICByZXR1cm4gZnJvbU51bSgrcmVmKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyQ2xhc3NIeXBoZW4oY29udGV4dCwgc3RhdGUpIHtcbiAgY29uc3QgeyBwYXJlbnQsIHRva2Vucywgd2FsayB9ID0gY29udGV4dDtcbiAgY29uc3QgcHJldlNpYmxpbmdOb2RlID0gcGFyZW50LmVsZW1lbnRzLmF0KC0xKTtcbiAgY29uc3QgbmV4dFRva2VuID0gdG9rZW5zW2NvbnRleHQuY3VycmVudF07XG4gIGlmICghc3RhdGUuaXNDaGVja2luZ1JhbmdlRW5kICYmIHByZXZTaWJsaW5nTm9kZSAmJiBwcmV2U2libGluZ05vZGUudHlwZSAhPT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MgJiYgcHJldlNpYmxpbmdOb2RlLnR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2UgJiYgbmV4dFRva2VuICYmIG5leHRUb2tlbi50eXBlICE9PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzT3BlbiAmJiBuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0Nsb3NlICYmIG5leHRUb2tlbi50eXBlICE9PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0b3IpIHtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IHdhbGsocGFyZW50LCB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGlzQ2hlY2tpbmdSYW5nZUVuZDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChwcmV2U2libGluZ05vZGUudHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyICYmIG5leHROb2RlLnR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3Rlcikge1xuICAgICAgcGFyZW50LmVsZW1lbnRzLnBvcCgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlckNsYXNzUmFuZ2UocHJldlNpYmxpbmdOb2RlLCBuZXh0Tm9kZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzIHJhbmdlXCIpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFyYWN0ZXIoNDUpO1xufVxuZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJDbGFzc09wZW4oY29udGV4dCwgc3RhdGUpIHtcbiAgY29uc3QgeyB0b2tlbiwgdG9rZW5zLCB2ZXJib3NlLCB3YWxrIH0gPSBjb250ZXh0O1xuICBjb25zdCBmaXJzdENsYXNzVG9rZW4gPSB0b2tlbnNbY29udGV4dC5jdXJyZW50XTtcbiAgbGV0IG5vZGUgPSBjcmVhdGVDaGFyYWN0ZXJDbGFzcyh7IG5lZ2F0ZTogdG9rZW4ubmVnYXRlIH0pO1xuICBjb25zdCBpbnRlcnNlY3Rpb24gPSBub2RlLmVsZW1lbnRzWzBdO1xuICBsZXQgbmV4dFRva2VuID0gdGhyb3dJZlVuY2xvc2VkQ2hhcmFjdGVyQ2xhc3MoZmlyc3RDbGFzc1Rva2VuKTtcbiAgd2hpbGUgKG5leHRUb2tlbi50eXBlICE9PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzQ2xvc2UpIHtcbiAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rvcikge1xuICAgICAgaW50ZXJzZWN0aW9uLmNsYXNzZXMucHVzaChjcmVhdGVDaGFyYWN0ZXJDbGFzcyh7IG5lZ2F0ZTogZmFsc2UsIGJhc2VPbmx5OiB0cnVlIH0pKTtcbiAgICAgIGNvbnRleHQuY3VycmVudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYyA9IGludGVyc2VjdGlvbi5jbGFzc2VzLmF0KC0xKTtcbiAgICAgIGNjLmVsZW1lbnRzLnB1c2god2FsayhjYywgc3RhdGUpKTtcbiAgICB9XG4gICAgbmV4dFRva2VuID0gdGhyb3dJZlVuY2xvc2VkQ2hhcmFjdGVyQ2xhc3ModG9rZW5zW2NvbnRleHQuY3VycmVudF0sIGZpcnN0Q2xhc3NUb2tlbik7XG4gIH1cbiAgaWYgKCF2ZXJib3NlKSB7XG4gICAgb3B0aW1pemVDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24pO1xuICB9XG4gIGlmIChpbnRlcnNlY3Rpb24uY2xhc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBjYyA9IGludGVyc2VjdGlvbi5jbGFzc2VzWzBdO1xuICAgIGNjLm5lZ2F0ZSA9IG5vZGUubmVnYXRlICE9PSBjYy5uZWdhdGU7XG4gICAgbm9kZSA9IGNjO1xuICB9XG4gIGNvbnRleHQuY3VycmVudCsrO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyU2V0KHsgdG9rZW4sIHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uIH0pIHtcbiAgbGV0IHsga2luZCwgbmVnYXRlLCB2YWx1ZSB9ID0gdG9rZW47XG4gIGlmIChraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHNsdWcodmFsdWUpO1xuICAgIGlmIChQb3NpeFByb3BlcnRpZXMuaGFzKG5vcm1hbGl6ZWQpKSB7XG4gICAgICBraW5kID0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5wb3NpeDtcbiAgICAgIHZhbHVlID0gbm9ybWFsaXplZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eSh2YWx1ZSwge1xuICAgICAgICBuZWdhdGUsXG4gICAgICAgIHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMucG9zaXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyU2V0LFxuICAgICAga2luZDogQXN0Q2hhcmFjdGVyU2V0S2luZHMucG9zaXgsXG4gICAgICBuZWdhdGUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlclNldChraW5kLCB7IG5lZ2F0ZSB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JvdXBPcGVuKGNvbnRleHQsIHN0YXRlKSB7XG4gIGNvbnN0IHsgdG9rZW4sIHRva2VucywgY2FwdHVyaW5nR3JvdXBzLCBuYW1lZEdyb3Vwc0J5TmFtZSwgc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uLCB2ZXJib3NlLCB3YWxrIH0gPSBjb250ZXh0O1xuICBsZXQgbm9kZSA9IGNyZWF0ZUJ5R3JvdXBLaW5kKHRva2VuKTtcbiAgY29uc3QgaXNBYnNlbnRGdW5jdGlvbiA9IG5vZGUudHlwZSA9PT0gQXN0VHlwZXMuQWJzZW50RnVuY3Rpb247XG4gIGNvbnN0IGlzTG9va2JlaGluZCA9IG5vZGUua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2JlaGluZDtcbiAgY29uc3QgaXNOZWdMb29rYmVoaW5kID0gaXNMb29rYmVoaW5kICYmIG5vZGUubmVnYXRlO1xuICBpZiAobm9kZS50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCkge1xuICAgIGNhcHR1cmluZ0dyb3Vwcy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgIGdldE9ySW5zZXJ0KG5hbWVkR3JvdXBzQnlOYW1lLCBub2RlLm5hbWUsIFtdKS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNBYnNlbnRGdW5jdGlvbiAmJiBzdGF0ZS5pc0luQWJzZW50RnVuY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXN0ZWQgYWJzZW50IGZ1bmN0aW9uIG5vdCBzdXBwb3J0ZWQgYnkgT25pZ3VydW1hXCIpO1xuICB9XG4gIGxldCBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRHcm91cCh0b2tlbnNbY29udGV4dC5jdXJyZW50XSk7XG4gIHdoaWxlIChuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5Hcm91cENsb3NlKSB7XG4gICAgaWYgKG5leHRUb2tlbi50eXBlID09PSBUb2tlblR5cGVzLkFsdGVybmF0b3IpIHtcbiAgICAgIG5vZGUuYWx0ZXJuYXRpdmVzLnB1c2goY3JlYXRlQWx0ZXJuYXRpdmUoKSk7XG4gICAgICBjb250ZXh0LmN1cnJlbnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWx0ID0gbm9kZS5hbHRlcm5hdGl2ZXMuYXQoLTEpO1xuICAgICAgY29uc3QgY2hpbGQgPSB3YWxrKGFsdCwge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNJbkFic2VudEZ1bmN0aW9uOiBzdGF0ZS5pc0luQWJzZW50RnVuY3Rpb24gfHwgaXNBYnNlbnRGdW5jdGlvbixcbiAgICAgICAgaXNJbkxvb2tiZWhpbmQ6IHN0YXRlLmlzSW5Mb29rYmVoaW5kIHx8IGlzTG9va2JlaGluZCxcbiAgICAgICAgaXNJbk5lZ0xvb2tiZWhpbmQ6IHN0YXRlLmlzSW5OZWdMb29rYmVoaW5kIHx8IGlzTmVnTG9va2JlaGluZFxuICAgICAgfSk7XG4gICAgICBhbHQuZWxlbWVudHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoKGlzTG9va2JlaGluZCB8fCBzdGF0ZS5pc0luTG9va2JlaGluZCkgJiYgIXNraXBMb29rYmVoaW5kVmFsaWRhdGlvbikge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkxvb2tiZWhpbmQgaW5jbHVkZXMgYSBwYXR0ZXJuIG5vdCBhbGxvd2VkIGJ5IE9uaWd1cnVtYVwiO1xuICAgICAgICBpZiAoaXNOZWdMb29rYmVoaW5kIHx8IHN0YXRlLmlzSW5OZWdMb29rYmVoaW5kKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCB8fCBjaGlsZC50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYWhlYWQgfHwgY2hpbGQua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2JlaGluZCAmJiBjaGlsZC5uZWdhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRHcm91cCh0b2tlbnNbY29udGV4dC5jdXJyZW50XSk7XG4gIH1cbiAgaWYgKCF2ZXJib3NlKSB7XG4gICAgbm9kZSA9IGdldE9wdGltaXplZEdyb3VwKG5vZGUpO1xuICB9XG4gIGNvbnRleHQuY3VycmVudCsrO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVhbnRpZmllcih7IHRva2VuLCBwYXJlbnQgfSkge1xuICBjb25zdCB7IG1pbiwgbWF4LCBncmVlZHksIHBvc3Nlc3NpdmU6IHBvc3Nlc3NpdmUyIH0gPSB0b2tlbjtcbiAgY29uc3QgcXVhbnRpZmllZE5vZGUgPSBwYXJlbnQuZWxlbWVudHMuYXQoLTEpO1xuICBpZiAoIXF1YW50aWZpZWROb2RlIHx8IHF1YW50aWZpZWROb2RlLnR5cGUgPT09IEFzdFR5cGVzLkFzc2VydGlvbiB8fCBxdWFudGlmaWVkTm9kZS50eXBlID09PSBBc3RUeXBlcy5EaXJlY3RpdmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFF1YW50aWZpZXIgcmVxdWlyZXMgYSByZXBlYXRhYmxlIHRva2VuYCk7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZVF1YW50aWZpZXIocXVhbnRpZmllZE5vZGUsIG1pbiwgbWF4LCBncmVlZHksIHBvc3Nlc3NpdmUyKTtcbiAgcGFyZW50LmVsZW1lbnRzLnBvcCgpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3Vicm91dGluZShjb250ZXh0KSB7XG4gIGNvbnN0IHsgdG9rZW4sIGNhcHR1cmluZ0dyb3Vwcywgc3Vicm91dGluZXMgfSA9IGNvbnRleHQ7XG4gIGxldCByZWYgPSB0b2tlbi5yYXcuc2xpY2UoMywgLTEpO1xuICBjb25zdCBudW1iZXJlZFJlZiA9IC9eKD88c2lnbj5bLStdPykwKig/PG51bT5bMS05XVxcZCopJC8uZXhlYyhyZWYpO1xuICBpZiAobnVtYmVyZWRSZWYpIHtcbiAgICBjb25zdCBudW0gPSArbnVtYmVyZWRSZWYuZ3JvdXBzLm51bTtcbiAgICBjb25zdCBudW1DYXB0dXJlc1RvTGVmdCA9IGNhcHR1cmluZ0dyb3Vwcy5sZW5ndGg7XG4gICAgY29udGV4dC5oYXNOdW1iZXJlZFJlZiA9IHRydWU7XG4gICAgcmVmID0ge1xuICAgICAgXCJcIjogbnVtLFxuICAgICAgXCIrXCI6IG51bUNhcHR1cmVzVG9MZWZ0ICsgbnVtLFxuICAgICAgXCItXCI6IG51bUNhcHR1cmVzVG9MZWZ0ICsgMSAtIG51bVxuICAgIH1bbnVtYmVyZWRSZWYuZ3JvdXBzLnNpZ25dO1xuICAgIGlmIChyZWYgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN1YnJvdXRpbmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWYgPT09IFwiMFwiKSB7XG4gICAgcmVmID0gMDtcbiAgfVxuICBjb25zdCBub2RlID0gY3JlYXRlU3Vicm91dGluZShyZWYpO1xuICBzdWJyb3V0aW5lcy5wdXNoKG5vZGUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFic2VudEZ1bmN0aW9uKGtpbmQpIHtcbiAgaWYgKGtpbmQgIT09IEFzdEFic2VudEZ1bmN0aW9uS2luZHMucmVwZWF0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYWJzZW50IGZ1bmN0aW9uIGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkFic2VudEZ1bmN0aW9uLFxuICAgIGtpbmQsXG4gICAgYWx0ZXJuYXRpdmVzOiBbY3JlYXRlQWx0ZXJuYXRpdmUoKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFsdGVybmF0aXZlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkFsdGVybmF0aXZlLFxuICAgIGVsZW1lbnRzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXNzZXJ0aW9uKGtpbmQsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmVnYXRlID0gISFvcHRpb25zPy5uZWdhdGU7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQXNzZXJ0aW9uLFxuICAgIGtpbmQsXG4gICAgLi4ua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSAmJiB7IG5lZ2F0ZSB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBc3NlcnRpb25Gcm9tVG9rZW4oeyBraW5kIH0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzc2VydGlvbihcbiAgICB0aHJvd0lmTm90KHtcbiAgICAgIFwiXlwiOiBBc3RBc3NlcnRpb25LaW5kcy5saW5lX3N0YXJ0LFxuICAgICAgXCIkXCI6IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfZW5kLFxuICAgICAgXCJcXFxcQVwiOiBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfc3RhcnQsXG4gICAgICBcIlxcXFxiXCI6IEFzdEFzc2VydGlvbktpbmRzLndvcmRfYm91bmRhcnksXG4gICAgICBcIlxcXFxCXCI6IEFzdEFzc2VydGlvbktpbmRzLndvcmRfYm91bmRhcnksXG4gICAgICBcIlxcXFxHXCI6IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCxcbiAgICAgIFwiXFxcXHpcIjogQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX2VuZCxcbiAgICAgIFwiXFxcXFpcIjogQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX2VuZF9uZXdsaW5lXG4gICAgfVtraW5kXSwgYFVuZXhwZWN0ZWQgYXNzZXJ0aW9uIGtpbmQgXCIke2tpbmR9XCJgKSxcbiAgICB7IG5lZ2F0ZToga2luZCA9PT0gcmBcXEJgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tyZWZlcmVuY2UocmVmLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9ycGhhbiA9ICEhb3B0aW9ucz8ub3JwaGFuO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkJhY2tyZWZlcmVuY2UsXG4gICAgLi4ub3JwaGFuICYmIHsgb3JwaGFuIH0sXG4gICAgcmVmXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCeUdyb3VwS2luZCh7IGZsYWdzLCBraW5kLCBuYW1lLCBuZWdhdGUsIG51bWJlciB9KSB7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgVG9rZW5Hcm91cEtpbmRzLmFic2VudF9yZXBlYXRlcjpcbiAgICAgIHJldHVybiBjcmVhdGVBYnNlbnRGdW5jdGlvbihBc3RBYnNlbnRGdW5jdGlvbktpbmRzLnJlcGVhdGVyKTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5hdG9taWM6XG4gICAgICByZXR1cm4gY3JlYXRlR3JvdXAoeyBhdG9taWM6IHRydWUgfSk7XG4gICAgY2FzZSBUb2tlbkdyb3VwS2luZHMuY2FwdHVyaW5nOlxuICAgICAgcmV0dXJuIGNyZWF0ZUNhcHR1cmluZ0dyb3VwKG51bWJlciwgbmFtZSk7XG4gICAgY2FzZSBUb2tlbkdyb3VwS2luZHMuZ3JvdXA6XG4gICAgICByZXR1cm4gY3JlYXRlR3JvdXAoeyBmbGFncyB9KTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5sb29rYWhlYWQ6XG4gICAgY2FzZSBUb2tlbkdyb3VwS2luZHMubG9va2JlaGluZDpcbiAgICAgIHJldHVybiBjcmVhdGVMb29rYXJvdW5kKHtcbiAgICAgICAgYmVoaW5kOiBraW5kID09PSBUb2tlbkdyb3VwS2luZHMubG9va2JlaGluZCxcbiAgICAgICAgbmVnYXRlXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGdyb3VwIGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyaW5nR3JvdXAobnVtYmVyLCBuYW1lKSB7XG4gIGNvbnN0IGhhc05hbWUgPSBuYW1lICE9PSB2b2lkIDA7XG4gIGlmIChoYXNOYW1lICYmICFpc1ZhbGlkR3JvdXBOYW1lT25pZ3VydW1hKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHcm91cCBuYW1lIFwiJHtuYW1lfVwiIGludmFsaWQgaW4gT25pZ3VydW1hYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCxcbiAgICBudW1iZXIsXG4gICAgLi4uaGFzTmFtZSAmJiB7IG5hbWUgfSxcbiAgICBhbHRlcm5hdGl2ZXM6IFtjcmVhdGVBbHRlcm5hdGl2ZSgpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyKGNoYXJDb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgdXNlTGFzdFZhbGlkOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmIChjaGFyQ29kZSA+IDExMTQxMTEpIHtcbiAgICBjb25zdCBoZXggPSBjaGFyQ29kZS50b1N0cmluZygxNik7XG4gICAgaWYgKG9wdHMudXNlTGFzdFZhbGlkKSB7XG4gICAgICBjaGFyQ29kZSA9IDExMTQxMTE7XG4gICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+IDEzMTA3MTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2RlIHBvaW50IG91dCBvZiByYW5nZSBcIlxcXFx4eyR7aGV4fX1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29kZSBwb2ludCBvdXQgb2YgcmFuZ2UgaW4gSlMgXCJcXFxceHske2hleH19XCJgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXIsXG4gICAgdmFsdWU6IGNoYXJDb2RlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzcyhvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYmFzZU9ubHk6IGZhbHNlLFxuICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzLFxuICAgIG5lZ2F0ZTogb3B0cy5uZWdhdGUsXG4gICAgZWxlbWVudHM6IG9wdHMuYmFzZU9ubHkgPyBbXSA6IFtjcmVhdGVDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbigpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb24sXG4gICAgY2xhc3NlczogW2NyZWF0ZUNoYXJhY3RlckNsYXNzKHsgbmVnYXRlOiBmYWxzZSwgYmFzZU9ubHk6IHRydWUgfSldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc1JhbmdlKG1pbiwgbWF4KSB7XG4gIGlmIChtYXgudmFsdWUgPCBtaW4udmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFyYWN0ZXIgY2xhc3MgcmFuZ2Ugb3V0IG9mIG9yZGVyXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NSYW5nZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJTZXQoa2luZCwgeyBuZWdhdGUgfSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlclNldCxcbiAgICBraW5kOiB0aHJvd0lmTm90KEFzdENoYXJhY3RlclNldEtpbmRzW2tpbmRdLCBgVW5leHBlY3RlZCBjaGFyYWN0ZXIgc2V0IGtpbmQgXCIke2tpbmR9XCJgKVxuICB9O1xuICBpZiAoa2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCB8fCBraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLmhleCB8fCBraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnNwYWNlIHx8IGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMud29yZCkge1xuICAgIG5vZGUubmVnYXRlID0gbmVnYXRlO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlRGlyZWN0aXZlRnJvbVRva2VuKHsga2luZCwgZmxhZ3MgfSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkRpcmVjdGl2ZSxcbiAgICBraW5kOiB0aHJvd0lmTm90KEFzdERpcmVjdGl2ZUtpbmRzW2tpbmRdLCBgVW5leHBlY3RlZCBkaXJlY3RpdmUga2luZCBcIiR7a2luZH1cImApXG4gIH07XG4gIGlmIChraW5kID09PSBUb2tlbkRpcmVjdGl2ZUtpbmRzLmZsYWdzKSB7XG4gICAgbm9kZS5mbGFncyA9IGZsYWdzO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlRmxhZ3MoeyBpZ25vcmVDYXNlLCBkb3RBbGwsIGV4dGVuZGVkLCBkaWdpdElzQXNjaWksIHNwYWNlSXNBc2NpaSwgd29yZElzQXNjaWkgfSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkZsYWdzLFxuICAgIGlnbm9yZUNhc2UsXG4gICAgZG90QWxsLFxuICAgIGV4dGVuZGVkLFxuICAgIGRpZ2l0SXNBc2NpaSxcbiAgICBzcGFjZUlzQXNjaWksXG4gICAgd29yZElzQXNjaWlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwKG9wdGlvbnMpIHtcbiAgY29uc3QgYXRvbWljMiA9IG9wdGlvbnM/LmF0b21pYztcbiAgY29uc3QgZmxhZ3MgPSBvcHRpb25zPy5mbGFncztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5Hcm91cCxcbiAgICAuLi5hdG9taWMyICYmIHsgYXRvbWljOiBhdG9taWMyIH0sXG4gICAgLi4uZmxhZ3MgJiYgeyBmbGFncyB9LFxuICAgIGFsdGVybmF0aXZlczogW2NyZWF0ZUFsdGVybmF0aXZlKCldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMb29rYXJvdW5kKG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBiZWhpbmQ6IGZhbHNlLFxuICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkFzc2VydGlvbixcbiAgICBraW5kOiBvcHRzLmJlaGluZCA/IEFzdEFzc2VydGlvbktpbmRzLmxvb2tiZWhpbmQgOiBBc3RBc3NlcnRpb25LaW5kcy5sb29rYWhlYWQsXG4gICAgbmVnYXRlOiBvcHRzLm5lZ2F0ZSxcbiAgICBhbHRlcm5hdGl2ZXM6IFtjcmVhdGVBbHRlcm5hdGl2ZSgpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5QYXR0ZXJuLFxuICAgIGFsdGVybmF0aXZlczogW2NyZWF0ZUFsdGVybmF0aXZlKCldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVRdWFudGlmaWVyKGVsZW1lbnQsIG1pbiwgbWF4LCBncmVlZHkgPSB0cnVlLCBwb3NzZXNzaXZlMiA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogQXN0VHlwZXMuUXVhbnRpZmllcixcbiAgICBtaW4sXG4gICAgbWF4LFxuICAgIGdyZWVkeSxcbiAgICBwb3NzZXNzaXZlOiBwb3NzZXNzaXZlMixcbiAgICBlbGVtZW50XG4gIH07XG4gIGlmIChtYXggPCBtaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubm9kZSxcbiAgICAgIG1pbjogbWF4LFxuICAgICAgbWF4OiBtaW4sXG4gICAgICBwb3NzZXNzaXZlOiB0cnVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2V4KHBhdHRlcm4sIGZsYWdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuUmVnZXgsXG4gICAgcGF0dGVybixcbiAgICBmbGFnc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3Vicm91dGluZShyZWYpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5TdWJyb3V0aW5lLFxuICAgIHJlZlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVW5pY29kZVByb3BlcnR5KHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgbmVnYXRlOiBmYWxzZSxcbiAgICBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlclNldCxcbiAgICBraW5kOiBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5wcm9wZXJ0eSxcbiAgICB2YWx1ZTogb3B0cy5za2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbiA/IHZhbHVlIDogZ2V0SnNVbmljb2RlUHJvcGVydHlOYW1lKHZhbHVlKSxcbiAgICBuZWdhdGU6IG9wdHMubmVnYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldChraW5kKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQsXG4gICAga2luZDogdGhyb3dJZk5vdCh7XG4gICAgICBcIlxcXFxSXCI6IEFzdFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0S2luZHMubmV3bGluZSxcbiAgICAgIFwiXFxcXFhcIjogQXN0VmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRLaW5kcy5ncmFwaGVtZVxuICAgIH1ba2luZF0sIGBVbmV4cGVjdGVkIHZhcmNoYXJzZXQga2luZCBcIiR7a2luZH1cImApXG4gIH07XG59XG5mdW5jdGlvbiBnZXRKc1VuaWNvZGVQcm9wZXJ0eU5hbWUodmFsdWUpIHtcbiAgY29uc3Qgc2x1Z2dlZCA9IHNsdWcodmFsdWUpO1xuICBpZiAoSnNVbmljb2RlUHJvcGVydGllc09mU3RyaW5nc01hcC5oYXMoc2x1Z2dlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocmBVbmljb2RlIHByb3BlcnR5IFwiXFxweyR7dmFsdWV9fVwiIHVuc3VwcG9ydGVkIGluIE9uaWd1cnVtYWApO1xuICB9XG4gIGNvbnN0IGpzTmFtZSA9IEpzVW5pY29kZVByb3BlcnRpZXNNYXAuZ2V0KHNsdWdnZWQpO1xuICBpZiAoanNOYW1lKSB7XG4gICAgcmV0dXJuIGpzTmFtZTtcbiAgfVxuICByZXR1cm4gdmFsdWUudHJpbSgpLnJlcGxhY2UoL1stIF9dKy9nLCBcIl9cIikucmVwbGFjZSgvW0EtWl1bYS16XSsoPz1bQS1aXSkvZywgXCIkJl9cIikucmVwbGFjZSgvW0EtWmEtel0rL2csIChtKSA9PiBtWzBdLnRvVXBwZXJDYXNlKCkgKyBtLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gZ2V0T3B0aW1pemVkR3JvdXAobm9kZSkge1xuICBjb25zdCBmaXJzdEFsdEZpcnN0RWwgPSBub2RlLmFsdGVybmF0aXZlc1swXS5lbGVtZW50c1swXTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXAgJiYgaGFzT25seUNoaWxkKG5vZGUsIChraWQpID0+IGtpZC50eXBlID09PSBBc3RUeXBlcy5Hcm91cCkgJiYgIShub2RlLmF0b21pYyAmJiBmaXJzdEFsdEZpcnN0RWwuZmxhZ3MpICYmICEobm9kZS5mbGFncyAmJiAoZmlyc3RBbHRGaXJzdEVsLmF0b21pYyB8fCBmaXJzdEFsdEZpcnN0RWwuZmxhZ3MpKSkge1xuICAgIGlmIChub2RlLmF0b21pYykge1xuICAgICAgZmlyc3RBbHRGaXJzdEVsLmF0b21pYyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLmZsYWdzKSB7XG4gICAgICBmaXJzdEFsdEZpcnN0RWwuZmxhZ3MgPSBub2RlLmZsYWdzO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RBbHRGaXJzdEVsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEdyb3VwTmFtZU9uaWd1cnVtYShuYW1lKSB7XG4gIHJldHVybiAvXltcXHB7QWxwaGF9XFxwe1BjfV1bXildKiQvdS50ZXN0KG5hbWUpO1xufVxuZnVuY3Rpb24gb3B0aW1pemVDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlcnNlY3Rpb24uY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNjID0gaW50ZXJzZWN0aW9uLmNsYXNzZXNbaV07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGNjLmVsZW1lbnRzWzBdO1xuICAgIGlmIChjYy5lbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcykge1xuICAgICAgaW50ZXJzZWN0aW9uLmNsYXNzZXNbaV0gPSBmaXJzdENoaWxkO1xuICAgICAgZmlyc3RDaGlsZC5uZWdhdGUgPSBjYy5uZWdhdGUgIT09IGZpcnN0Q2hpbGQubmVnYXRlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dJZlVuY2xvc2VkQ2hhcmFjdGVyQ2xhc3ModG9rZW4sIGZpcnN0Q2xhc3NUb2tlbikge1xuICByZXR1cm4gdGhyb3dJZk5vdChcbiAgICB0b2tlbixcbiAgICAvLyBFYXNpZXIgdG8gdW5kZXJzdGFuZCBlcnJvciB3aGVuIGFwcGxpY2FibGVcbiAgICBgJHtmaXJzdENsYXNzVG9rZW4/LnZhbHVlID09PSA5MyA/IFwiRW1wdHlcIiA6IFwiVW5jbG9zZWRcIn0gY2hhcmFjdGVyIGNsYXNzYFxuICApO1xufVxuZnVuY3Rpb24gdGhyb3dJZlVuY2xvc2VkR3JvdXAodG9rZW4pIHtcbiAgcmV0dXJuIHRocm93SWZOb3QodG9rZW4sIFwiVW5jbG9zZWQgZ3JvdXBcIik7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0uanNcbmltcG9ydCBlbW9qaVJlZ2V4IGZyb20gXCJlbW9qaS1yZWdleC14c1wiO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGFzdCwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIC8vIEEgY291cGxlIGVkZ2UgY2FzZXMgZXhpc3Qgd2hlcmUgb3B0aW9ucyBgYWNjdXJhY3lgIGFuZCBgYmVzdEVmZm9ydFRhcmdldGAgYXJlIHVzZWQ6XG4gICAgLy8gLSBgVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRgIGtpbmQgYGdyYXBoZW1lYCAoYFxcWGApOiBBbiBleGFjdCByZXByZXNlbnRhdGlvbiB3b3VsZCByZXF1aXJlXG4gICAgLy8gICBoZWF2eSBVbmljb2RlIGRhdGE7IGEgYmVzdC1lZmZvcnQgYXBwcm94aW1hdGlvbiByZXF1aXJlcyBrbm93aW5nIHRoZSB0YXJnZXQuXG4gICAgLy8gLSBgQ2hhcmFjdGVyU2V0YCBraW5kIGBwb3NpeGAgd2l0aCB2YWx1ZXMgYGdyYXBoYCBhbmQgYHByaW50YDogVGhlaXIgY29tcGxleCBVbmljb2RlLWJhc2VkXG4gICAgLy8gICByZXByZXNlbnRhdGlvbnMgd291bGQgYmUgaGFyZCB0byBjaGFuZ2UgdG8gQVNDSUktYmFzZWQgYWZ0ZXIgdGhlIGZhY3QgaW4gdGhlIGdlbmVyYXRvclxuICAgIC8vICAgYmFzZWQgb24gYHRhcmdldGAvYGFjY3VyYWN5YCwgc28gcHJvZHVjZSB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlIGhlcmUuXG4gICAgYWNjdXJhY3k6IFwiZGVmYXVsdFwiLFxuICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IGZhbHNlLFxuICAgIGF2b2lkU3ViY2xhc3M6IGZhbHNlLFxuICAgIGJlc3RFZmZvcnRUYXJnZXQ6IFwiRVMyMDI1XCIsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBmaXJzdFBhc3NTdGF0ZSA9IHtcbiAgICBhY2N1cmFjeTogb3B0cy5hY2N1cmFjeSxcbiAgICBhc2NpaVdvcmRCb3VuZGFyaWVzOiBvcHRzLmFzY2lpV29yZEJvdW5kYXJpZXMsXG4gICAgYXZvaWRTdWJjbGFzczogb3B0cy5hdm9pZFN1YmNsYXNzLFxuICAgIGZsYWdEaXJlY3RpdmVzQnlBbHQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAganNHcm91cE5hbWVNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgbWluVGFyZ2V0RXMyMDI0OiBpc01pblRhcmdldChvcHRzLmJlc3RFZmZvcnRUYXJnZXQsIFwiRVMyMDI0XCIpLFxuICAgIHBhc3NlZExvb2tiZWhpbmQ6IGZhbHNlLFxuICAgIHN0cmF0ZWd5OiBudWxsLFxuICAgIC8vIFN1YnJvdXRpbmVzIGNhbiBhcHBlYXIgYmVmb3JlIHRoZSBncm91cHMgdGhleSByZWYsIHNvIGNvbGxlY3QgcmVmZmVkIG5vZGVzIGZvciBhIHNlY29uZCBwYXNzIFxuICAgIHN1YnJvdXRpbmVSZWZNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3VwcG9ydGVkR05vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIGRpZ2l0SXNBc2NpaTogYXN0LmZsYWdzLmRpZ2l0SXNBc2NpaSxcbiAgICBzcGFjZUlzQXNjaWk6IGFzdC5mbGFncy5zcGFjZUlzQXNjaWksXG4gICAgd29yZElzQXNjaWk6IGFzdC5mbGFncy53b3JkSXNBc2NpaVxuICB9O1xuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCBmaXJzdFBhc3NTdGF0ZSwgRmlyc3RQYXNzVmlzaXRvcik7XG4gIGNvbnN0IGdsb2JhbEZsYWdzID0ge1xuICAgIGRvdEFsbDogYXN0LmZsYWdzLmRvdEFsbCxcbiAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICB9O1xuICBjb25zdCBzZWNvbmRQYXNzU3RhdGUgPSB7XG4gICAgY3VycmVudEZsYWdzOiBnbG9iYWxGbGFncyxcbiAgICBwcmV2RmxhZ3M6IG51bGwsXG4gICAgZ2xvYmFsRmxhZ3MsXG4gICAgZ3JvdXBPcmlnaW5CeUNvcHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZ3JvdXBzQnlOYW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWY6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgb3BlblJlZnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3Vicm91dGluZVJlZk1hcDogZmlyc3RQYXNzU3RhdGUuc3Vicm91dGluZVJlZk1hcFxuICB9O1xuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCBzZWNvbmRQYXNzU3RhdGUsIFNlY29uZFBhc3NWaXNpdG9yKTtcbiAgY29uc3QgdGhpcmRQYXNzU3RhdGUgPSB7XG4gICAgZ3JvdXBzQnlOYW1lOiBzZWNvbmRQYXNzU3RhdGUuZ3JvdXBzQnlOYW1lLFxuICAgIGhpZ2hlc3RPcnBoYW5CYWNrcmVmOiAwLFxuICAgIG51bUNhcHR1cmVzVG9MZWZ0OiAwLFxuICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyOiBzZWNvbmRQYXNzU3RhdGUucmVmZmVkTm9kZXNCeVJlZmVyZW5jZXJcbiAgfTtcbiAgdHJhdmVyc2UoeyBub2RlOiBhc3QgfSwgdGhpcmRQYXNzU3RhdGUsIFRoaXJkUGFzc1Zpc2l0b3IpO1xuICBhc3QuX29yaWdpbk1hcCA9IHNlY29uZFBhc3NTdGF0ZS5ncm91cE9yaWdpbkJ5Q29weTtcbiAgYXN0Ll9zdHJhdGVneSA9IGZpcnN0UGFzc1N0YXRlLnN0cmF0ZWd5O1xuICByZXR1cm4gYXN0O1xufVxudmFyIEZpcnN0UGFzc1Zpc2l0b3IgPSB7XG4gIEFic2VudEZ1bmN0aW9uKHsgbm9kZSwgcmVwbGFjZVdpdGggfSkge1xuICAgIGNvbnN0IGdyb3VwID0gcHJlcENvbnRhaW5lcihjcmVhdGVHcm91cCgpLCBbXG4gICAgICBhZG9wdEFuZFN3YXBLaWRzKGNyZWF0ZUxvb2thcm91bmQoeyBuZWdhdGU6IHRydWUgfSksIG5vZGUuYWx0ZXJuYXRpdmVzKSxcbiAgICAgIGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIkFueVwiKVxuICAgIF0pO1xuICAgIGNvbnN0IHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKGdyb3VwLCAwLCBJbmZpbml0eSk7XG4gICAgZ3JvdXAucGFyZW50ID0gcXVhbnRpZmllcjtcbiAgICByZXBsYWNlV2l0aChwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKCksIFtxdWFudGlmaWVyXSkpO1xuICB9LFxuICBBbHRlcm5hdGl2ZToge1xuICAgIGVudGVyKHsgbm9kZSwgcGFyZW50LCBrZXkgfSwgeyBmbGFnRGlyZWN0aXZlc0J5QWx0IH0pIHtcbiAgICAgIGNvbnN0IGZsYWdEaXJlY3RpdmVzID0gbm9kZS5lbGVtZW50cy5maWx0ZXIoKGVsKSA9PiBlbC5raW5kID09PSBBc3REaXJlY3RpdmVLaW5kcy5mbGFncyk7XG4gICAgICBmb3IgKGxldCBpID0ga2V5ICsgMTsgaSA8IHBhcmVudC5hbHRlcm5hdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZm9yd2FyZFNpYmxpbmdBbHQgPSBwYXJlbnQuYWx0ZXJuYXRpdmVzW2ldO1xuICAgICAgICBnZXRPckluc2VydChmbGFnRGlyZWN0aXZlc0J5QWx0LCBmb3J3YXJkU2libGluZ0FsdCwgW10pLnB1c2goLi4uZmxhZ0RpcmVjdGl2ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdCh7IG5vZGUgfSwgeyBmbGFnRGlyZWN0aXZlc0J5QWx0IH0pIHtcbiAgICAgIGlmIChmbGFnRGlyZWN0aXZlc0J5QWx0LmdldChub2RlKT8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMoZmxhZ0RpcmVjdGl2ZXNCeUFsdC5nZXQobm9kZSkpO1xuICAgICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICBjb25zdCBmbGFnR3JvdXAgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKHsgZmxhZ3MgfSksIG5vZGUuZWxlbWVudHMpO1xuICAgICAgICAgIGZsYWdHcm91cC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSBbZmxhZ0dyb3VwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgQXNzZXJ0aW9uKHsgbm9kZSwga2V5LCBjb250YWluZXIsIGFzdCwgcmVtb3ZlLCByZXBsYWNlV2l0aCB9LCBzdGF0ZSkge1xuICAgIGNvbnN0IHsga2luZCwgbmVnYXRlIH0gPSBub2RlO1xuICAgIGNvbnN0IHsgYXNjaWlXb3JkQm91bmRhcmllcywgYXZvaWRTdWJjbGFzcywgc3VwcG9ydGVkR05vZGVzLCB3b3JkSXNBc2NpaSB9ID0gc3RhdGU7XG4gICAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfZW5kKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD89XFx6fFxcbilgKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5saW5lX3N0YXJ0KSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD88PVxcQXxcXG4oPyFcXHopKWAsIHsgc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uOiB0cnVlIH0pKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2tiZWhpbmQpIHtcbiAgICAgIHN0YXRlLnBhc3NlZExvb2tiZWhpbmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0KSB7XG4gICAgICBpZiAoc3VwcG9ydGVkR05vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICBhc3QuZmxhZ3Muc3RpY2t5ID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2ID0gY29udGFpbmVyW2tleSAtIDFdO1xuICAgICAgICBpZiAocHJldiAmJiBpc0Fsd2F5c05vblplcm9MZW5ndGgocHJldikpIHtcbiAgICAgICAgICByZXBsYWNlV2l0aChwcmVwQ29udGFpbmVyKGNyZWF0ZUxvb2thcm91bmQoeyBuZWdhdGU6IHRydWUgfSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdm9pZFN1YmNsYXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlcyBcIlxcR1wiIGluIGEgd2F5IHRoYXQgcmVxdWlyZXMgYSBzdWJjbGFzc2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZUFzc2VydGlvbihBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfc3RhcnQpKTtcbiAgICAgICAgICBzdGF0ZS5zdHJhdGVneSA9IFwiY2xpcF9zZWFyY2hcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX2VuZF9uZXdsaW5lKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD89XFxuP1xceilgKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy53b3JkX2JvdW5kYXJ5ICYmICF3b3JkSXNBc2NpaSAmJiAhYXNjaWlXb3JkQm91bmRhcmllcykge1xuICAgICAgY29uc3QgYiA9IGAoPzooPzw9JHtkZWZhdWx0V29yZENoYXJ9KSg/ISR7ZGVmYXVsdFdvcmRDaGFyfSl8KD88ISR7ZGVmYXVsdFdvcmRDaGFyfSkoPz0ke2RlZmF1bHRXb3JkQ2hhcn0pKWA7XG4gICAgICBjb25zdCBCID0gYCg/Oig/PD0ke2RlZmF1bHRXb3JkQ2hhcn0pKD89JHtkZWZhdWx0V29yZENoYXJ9KXwoPzwhJHtkZWZhdWx0V29yZENoYXJ9KSg/ISR7ZGVmYXVsdFdvcmRDaGFyfSkpYDtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQobmVnYXRlID8gQiA6IGIpKTtcbiAgICB9XG4gIH0sXG4gIEJhY2tyZWZlcmVuY2UoeyBub2RlIH0sIHsganNHcm91cE5hbWVNYXAgfSkge1xuICAgIGxldCB7IHJlZiB9ID0gbm9kZTtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIiAmJiAhaXNWYWxpZEdyb3VwTmFtZUpzKHJlZikpIHtcbiAgICAgIHJlZiA9IGdldEFuZFN0b3JlSnNHcm91cE5hbWUocmVmLCBqc0dyb3VwTmFtZU1hcCk7XG4gICAgICBub2RlLnJlZiA9IHJlZjtcbiAgICB9XG4gIH0sXG4gIENhcHR1cmluZ0dyb3VwKHsgbm9kZSB9LCB7IGpzR3JvdXBOYW1lTWFwLCBzdWJyb3V0aW5lUmVmTWFwIH0pIHtcbiAgICBsZXQgeyBuYW1lIH0gPSBub2RlO1xuICAgIGlmIChuYW1lICYmICFpc1ZhbGlkR3JvdXBOYW1lSnMobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBnZXRBbmRTdG9yZUpzR3JvdXBOYW1lKG5hbWUsIGpzR3JvdXBOYW1lTWFwKTtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHN1YnJvdXRpbmVSZWZNYXAuc2V0KG5vZGUubnVtYmVyLCBub2RlKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgc3Vicm91dGluZVJlZk1hcC5zZXQobmFtZSwgbm9kZSk7XG4gICAgfVxuICB9LFxuICBDaGFyYWN0ZXJTZXQoeyBub2RlLCByZXBsYWNlV2l0aCB9LCB7IGFjY3VyYWN5LCBtaW5UYXJnZXRFczIwMjQsIGRpZ2l0SXNBc2NpaSwgc3BhY2VJc0FzY2lpLCB3b3JkSXNBc2NpaSB9KSB7XG4gICAgY29uc3QgeyBraW5kLCBuZWdhdGUsIHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChkaWdpdElzQXNjaWkgJiYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmRpZ2l0IHx8IHZhbHVlID09PSBcImRpZ2l0XCIpKSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVDaGFyYWN0ZXJTZXQoQXN0Q2hhcmFjdGVyU2V0S2luZHMuZGlnaXQsIHsgbmVnYXRlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNwYWNlSXNBc2NpaSAmJiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuc3BhY2UgfHwgdmFsdWUgPT09IFwic3BhY2VcIikpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldE5lZ2F0ZShwYXJzZUZyYWdtZW50KGFzY2lpU3BhY2VDaGFyKSwgbmVnYXRlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3b3JkSXNBc2NpaSAmJiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMud29yZCB8fCB2YWx1ZSA9PT0gXCJ3b3JkXCIpKSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVDaGFyYWN0ZXJTZXQoQXN0Q2hhcmFjdGVyU2V0S2luZHMud29yZCwgeyBuZWdhdGUgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuYW55KSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJBbnlcIikpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuZGlnaXQpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIk5kXCIsIHsgbmVnYXRlIH0pKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmhleCkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlVW5pY29kZVByb3BlcnR5KFwiQUhleFwiLCB7IG5lZ2F0ZSB9KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5ub25fbmV3bGluZSkge1xuICAgICAgcmVwbGFjZVdpdGgocGFyc2VGcmFnbWVudChyYFteXFxuXWApKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnNwYWNlKSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJzcGFjZVwiLCB7IG5lZ2F0ZSB9KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy53b3JkKSB7XG4gICAgICByZXBsYWNlV2l0aChzZXROZWdhdGUocGFyc2VGcmFnbWVudChkZWZhdWx0V29yZENoYXIpLCBuZWdhdGUpKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5KSB7XG4gICAgICBpZiAoIUpzVW5pY29kZVByb3BlcnRpZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBub2RlLmtleSA9IFwic2NcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnBvc2l4KSB7XG4gICAgICBpZiAoIW1pblRhcmdldEVzMjAyNCAmJiAodmFsdWUgPT09IFwiZ3JhcGhcIiB8fCB2YWx1ZSA9PT0gXCJwcmludFwiKSkge1xuICAgICAgICBpZiAoYWNjdXJhY3kgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBPU0lYIGNsYXNzIFwiJHt2YWx1ZX1cIiByZXF1aXJlcyBtaW4gdGFyZ2V0IEVTMjAyNCBvciBub24tc3RyaWN0IGFjY3VyYWN5YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzY2lpID0ge1xuICAgICAgICAgIGdyYXBoOiBcIiEtflwiLFxuICAgICAgICAgIHByaW50OiBcIiAtflwiXG4gICAgICAgIH1bdmFsdWVdO1xuICAgICAgICBpZiAobmVnYXRlKSB7XG4gICAgICAgICAgYXNjaWkgPSBgXFwwLSR7Y3AoYXNjaWkuY29kZVBvaW50QXQoMCkgLSAxKX0ke2NwKGFzY2lpLmNvZGVQb2ludEF0KDIpICsgMSl9LVxcdXsxMEZGRkZ9YDtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KGBbJHthc2NpaX1dYCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZVdpdGgoc2V0TmVnYXRlKHBhcnNlRnJhZ21lbnQoUG9zaXhDbGFzc2VzTWFwLmdldCh2YWx1ZSkpLCBuZWdhdGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIERpcmVjdGl2ZShwYXRoLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgbm9kZSwgcGFyZW50LCBhc3QsIHJlbW92ZSwgcmVwbGFjZVdpdGgsIHJlbW92ZUFsbFByZXZTaWJsaW5ncywgcmVtb3ZlQWxsTmV4dFNpYmxpbmdzIH0gPSBwYXRoO1xuICAgIGNvbnN0IHsga2luZCwgZmxhZ3MgfSA9IG5vZGU7XG4gICAgaWYgKGtpbmQgPT09IEFzdERpcmVjdGl2ZUtpbmRzLmZsYWdzKSB7XG4gICAgICBpZiAoIWZsYWdzLmVuYWJsZSAmJiAhZmxhZ3MuZGlzYWJsZSkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZsYWdHcm91cCA9IHByZXBDb250YWluZXIoY3JlYXRlR3JvdXAoeyBmbGFncyB9KSwgcmVtb3ZlQWxsTmV4dFNpYmxpbmdzKCkpO1xuICAgICAgICByZXBsYWNlV2l0aChmbGFnR3JvdXApO1xuICAgICAgICB0cmF2ZXJzZVJlcGxhY2VtZW50KGZsYWdHcm91cCwgcGF0aCwgc3RhdGUsIEZpcnN0UGFzc1Zpc2l0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0RGlyZWN0aXZlS2luZHMua2VlcCkge1xuICAgICAgY29uc3QgZmlyc3RBbHRGaXJzdEVsID0gYXN0LnBhdHRlcm4uYWx0ZXJuYXRpdmVzWzBdLmVsZW1lbnRzWzBdO1xuICAgICAgY29uc3QgaGFzV3JhcHBlckdyb3VwID0gKFxuICAgICAgICAvLyBOb3QgZW11bGF0YWJsZSBpZiB3aXRoaW4gYSBgQ2FwdHVyaW5nR3JvdXBgXG4gICAgICAgIGhhc09ubHlDaGlsZChhc3QucGF0dGVybiwgKGtpZCkgPT4ga2lkLnR5cGUgPT09IEFzdFR5cGVzLkdyb3VwKSAmJiBmaXJzdEFsdEZpcnN0RWwuYWx0ZXJuYXRpdmVzLmxlbmd0aCA9PT0gMVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRvcExldmVsID0gaGFzV3JhcHBlckdyb3VwID8gZmlyc3RBbHRGaXJzdEVsIDogYXN0LnBhdHRlcm47XG4gICAgICBpZiAocGFyZW50LnBhcmVudCAhPT0gdG9wTGV2ZWwgfHwgdG9wTGV2ZWwuYWx0ZXJuYXRpdmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlcyBcIlxcS1wiIGluIGEgd2F5IHRoYXQncyB1bnN1cHBvcnRlZGApO1xuICAgICAgfVxuICAgICAgcmVwbGFjZVdpdGgocHJlcENvbnRhaW5lcihjcmVhdGVMb29rYXJvdW5kKHsgYmVoaW5kOiB0cnVlIH0pLCByZW1vdmVBbGxQcmV2U2libGluZ3MoKSkpO1xuICAgIH1cbiAgfSxcbiAgRmxhZ3MoeyBub2RlLCBwYXJlbnQgfSkge1xuICAgIFtcbiAgICAgIFwiZGlnaXRJc0FzY2lpXCIsXG4gICAgICAvLyBGbGFnIERcbiAgICAgIFwiZXh0ZW5kZWRcIixcbiAgICAgIC8vIEZsYWcgeFxuICAgICAgXCJzcGFjZUlzQXNjaWlcIixcbiAgICAgIC8vIEZsYWcgU1xuICAgICAgXCJ3b3JkSXNBc2NpaVwiXG4gICAgICAvLyBGbGFnIFdcbiAgICBdLmZvckVhY2goKGYpID0+IGRlbGV0ZSBub2RlW2ZdKTtcbiAgICBPYmplY3QuYXNzaWduKG5vZGUsIHtcbiAgICAgIC8vIEpTIGZsYWcgZzsgbm8gT25pZyBlcXVpdlxuICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgZDsgbm8gT25pZyBlcXVpdlxuICAgICAgaGFzSW5kaWNlczogZmFsc2UsXG4gICAgICAvLyBKUyBmbGFnIG07IG5vIE9uaWcgZXF1aXYgYnV0IGl0cyBiZWhhdmlvciBpcyBhbHdheXMgb24gaW4gT25pZy4gT25pZydzIG9ubHkgbGluZSBicmVha1xuICAgICAgLy8gY2hhciBpcyBsaW5lIGZlZWQsIHVubGlrZSBKUywgc28gdGhpcyBmbGFnIGlzbid0IHVzZWQgc2luY2UgaXQgd291bGQgcHJvZHVjZSBpbmFjY3VyYXRlXG4gICAgICAvLyByZXN1bHRzIChhbHNvIGFsbG93cyBgXmAgYW5kIGAkYCB0byBiZSB1c2VkIGluIHRoZSBnZW5lcmF0b3IgZm9yIHN0cmluZyBzdGFydCBhbmQgZW5kKVxuICAgICAgbXVsdGlsaW5lOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgeTsgbm8gT25pZyBlcXVpdiwgYnV0IHVzZWQgZm9yIGBcXEdgIGVtdWxhdGlvblxuICAgICAgc3RpY2t5OiBub2RlLnN0aWNreSA/PyBmYWxzZVxuICAgICAgLy8gTm90ZTogUmVnZXgrIGRvZXNuJ3QgYWxsb3cgZXhwbGljaXRseSBhZGRpbmcgZmxhZ3MgaXQgaGFuZGxlcyBpbXBsaWNpdGx5LCBzbyBsZWF2ZSBvdXRcbiAgICAgIC8vIHByb3BlcnRpZXMgYHVuaWNvZGVgIChKUyBmbGFnIHUpIGFuZCBgdW5pY29kZVNldHNgIChKUyBmbGFnIHYpLiBLZWVwIHRoZSBleGlzdGluZyB2YWx1ZXNcbiAgICAgIC8vIGZvciBgaWdub3JlQ2FzZWAgKGZsYWcgaSkgYW5kIGBkb3RBbGxgIChKUyBmbGFnIHMsIGJ1dCBPbmlnIGZsYWcgbSlcbiAgICB9KTtcbiAgICBwYXJlbnQub3B0aW9ucyA9IHtcbiAgICAgIGRpc2FibGU6IHtcbiAgICAgICAgLy8gT25pZyB1c2VzIGRpZmZlcmVudCBydWxlcyBmb3IgZmxhZyB4IHRoYW4gUmVnZXgrLCBzbyBkaXNhYmxlIHRoZSBpbXBsaWNpdCBmbGFnXG4gICAgICAgIHg6IHRydWUsXG4gICAgICAgIC8vIE9uaWcgaGFzIG5vIGZsYWcgdG8gY29udHJvbCBcIm5hbWVkIGNhcHR1cmUgb25seVwiIG1vZGUgYnV0IGNvbnRleHR1YWxseSBhcHBsaWVzIGl0c1xuICAgICAgICAvLyBiZWhhdmlvciB3aGVuIG5hbWVkIGNhcHR1cmluZyBpcyB1c2VkLCBzbyBkaXNhYmxlIFJlZ2V4KydzIGltcGxpY2l0IGZsYWcgZm9yIGl0XG4gICAgICAgIG46IHRydWVcbiAgICAgIH0sXG4gICAgICBmb3JjZToge1xuICAgICAgICAvLyBBbHdheXMgYWRkIGZsYWcgdiBiZWNhdXNlIHdlJ3JlIGdlbmVyYXRpbmcgYW4gQVNUIHRoYXQgcmVsaWVzIG9uIGl0IChpdCBlbmFibGVzIEpTXG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIE9uaWcgZmVhdHVyZXMgbmVzdGVkIGNsYXNzZXMsIHNldCBpbnRlcnNlY3Rpb24sIFVuaWNvZGUgcHJvcGVydGllcywgZXRjLikuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBnZW5lcmF0b3IgbWlnaHQgZGlzYWJsZSBmbGFnIHYgYmFzZWQgb24gaXRzIGB0YXJnZXRgIG9wdGlvblxuICAgICAgICB2OiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgR3JvdXAoeyBub2RlIH0pIHtcbiAgICBpZiAoIW5vZGUuZmxhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBlbmFibGUsIGRpc2FibGUgfSA9IG5vZGUuZmxhZ3M7XG4gICAgZW5hYmxlPy5leHRlbmRlZCAmJiBkZWxldGUgZW5hYmxlLmV4dGVuZGVkO1xuICAgIGRpc2FibGU/LmV4dGVuZGVkICYmIGRlbGV0ZSBkaXNhYmxlLmV4dGVuZGVkO1xuICAgIGVuYWJsZT8uZG90QWxsICYmIGRpc2FibGU/LmRvdEFsbCAmJiBkZWxldGUgZW5hYmxlLmRvdEFsbDtcbiAgICBlbmFibGU/Lmlnbm9yZUNhc2UgJiYgZGlzYWJsZT8uaWdub3JlQ2FzZSAmJiBkZWxldGUgZW5hYmxlLmlnbm9yZUNhc2U7XG4gICAgZW5hYmxlICYmICFPYmplY3Qua2V5cyhlbmFibGUpLmxlbmd0aCAmJiBkZWxldGUgbm9kZS5mbGFncy5lbmFibGU7XG4gICAgZGlzYWJsZSAmJiAhT2JqZWN0LmtleXMoZGlzYWJsZSkubGVuZ3RoICYmIGRlbGV0ZSBub2RlLmZsYWdzLmRpc2FibGU7XG4gICAgIW5vZGUuZmxhZ3MuZW5hYmxlICYmICFub2RlLmZsYWdzLmRpc2FibGUgJiYgZGVsZXRlIG5vZGUuZmxhZ3M7XG4gIH0sXG4gIFBhdHRlcm46IHtcbiAgICBlbnRlcih7IG5vZGUgfSwgeyBzdXBwb3J0ZWRHTm9kZXMgfSkge1xuICAgICAgY29uc3QgbGVhZGluZ0dzID0gW107XG4gICAgICBsZXQgaGFzQWx0V2l0aExlYWRHID0gZmFsc2U7XG4gICAgICBsZXQgaGFzQWx0V2l0aG91dExlYWRHID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGFsdCBvZiBub2RlLmFsdGVybmF0aXZlcykge1xuICAgICAgICBpZiAoYWx0LmVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhbHQuZWxlbWVudHNbMF0ua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0KSB7XG4gICAgICAgICAgYWx0LmVsZW1lbnRzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxlYWRpbmdHID0gZ2V0TGVhZGluZ0coYWx0LmVsZW1lbnRzKTtcbiAgICAgICAgICBpZiAobGVhZGluZ0cpIHtcbiAgICAgICAgICAgIGhhc0FsdFdpdGhMZWFkRyA9IHRydWU7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGxlYWRpbmdHKSA/IGxlYWRpbmdHcy5wdXNoKC4uLmxlYWRpbmdHKSA6IGxlYWRpbmdHcy5wdXNoKGxlYWRpbmdHKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzQWx0V2l0aG91dExlYWRHID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNBbHRXaXRoTGVhZEcgJiYgIWhhc0FsdFdpdGhvdXRMZWFkRykge1xuICAgICAgICBsZWFkaW5nR3MuZm9yRWFjaCgoZykgPT4gc3VwcG9ydGVkR05vZGVzLmFkZChnKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0KF8sIHsgYWNjdXJhY3ksIHBhc3NlZExvb2tiZWhpbmQsIHN0cmF0ZWd5IH0pIHtcbiAgICAgIGlmIChhY2N1cmFjeSA9PT0gXCJzdHJpY3RcIiAmJiBwYXNzZWRMb29rYmVoaW5kICYmIHN0cmF0ZWd5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyYFVzZXMgXCJcXEdcIiBpbiBhIHdheSB0aGF0IHJlcXVpcmVzIG5vbi1zdHJpY3QgYWNjdXJhY3lgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFF1YW50aWZpZXIoeyBub2RlIH0pIHtcbiAgICBpZiAobm9kZS5lbGVtZW50LnR5cGUgPT09IEFzdFR5cGVzLlF1YW50aWZpZXIpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gcHJlcENvbnRhaW5lcihjcmVhdGVHcm91cCgpLCBbbm9kZS5lbGVtZW50XSk7XG4gICAgICBncm91cC5wYXJlbnQgPSBub2RlO1xuICAgICAgbm9kZS5lbGVtZW50ID0gZ3JvdXA7XG4gICAgfVxuICB9LFxuICBTdWJyb3V0aW5lKHsgbm9kZSB9LCB7IGpzR3JvdXBOYW1lTWFwIH0pIHtcbiAgICBsZXQgeyByZWYgfSA9IG5vZGU7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIgJiYgIWlzVmFsaWRHcm91cE5hbWVKcyhyZWYpKSB7XG4gICAgICByZWYgPSBnZXRBbmRTdG9yZUpzR3JvdXBOYW1lKHJlZiwganNHcm91cE5hbWVNYXApO1xuICAgICAgbm9kZS5yZWYgPSByZWY7XG4gICAgfVxuICB9LFxuICBWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldCh7IG5vZGUsIHJlcGxhY2VXaXRoIH0sIHsgYWNjdXJhY3ksIG1pblRhcmdldEVzMjAyNCB9KSB7XG4gICAgY29uc3QgeyBraW5kIH0gPSBub2RlO1xuICAgIGlmIChraW5kID09PSBBc3RWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldEtpbmRzLm5ld2xpbmUpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQoXCIoPz5cXHJcXG4/fFtcXG5cXHZcXGZcXHg4NVxcdTIwMjhcXHUyMDI5XSlcIikpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0VmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRLaW5kcy5ncmFwaGVtZSkge1xuICAgICAgaWYgKGFjY3VyYWN5ID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyYFVzZSBvZiBcIlxcWFwiIHJlcXVpcmVzIG5vbi1zdHJpY3QgYWNjdXJhY3lgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVtb2ppID0gbWluVGFyZ2V0RXMyMDI0ID8gcmBcXHB7UkdJX0Vtb2ppfWAgOiBlbW9qaVJlZ2V4KCkuc291cmNlLnJlcGxhY2UoL1xcXFx1XFx7L2csIGBcXFxceHtgKTtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQocmAoPz5cXHJcXG58JHtlbW9qaX18XFxQe019XFxwe019KilgLCB7IHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uOiB0cnVlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhcmNoYXJzZXQga2luZCBcIiR7a2luZH1cImApO1xuICAgIH1cbiAgfVxufTtcbnZhciBTZWNvbmRQYXNzVmlzaXRvciA9IHtcbiAgQmFja3JlZmVyZW5jZSh7IG5vZGUgfSwgeyBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLCByZWZmZWROb2Rlc0J5UmVmZXJlbmNlciB9KSB7XG4gICAgY29uc3QgeyBvcnBoYW4sIHJlZiB9ID0gbm9kZTtcbiAgICBpZiAoIW9ycGhhbikge1xuICAgICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuc2V0KG5vZGUsIFsuLi5tdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLmdldChyZWYpLm1hcCgoeyBub2RlOiBub2RlMiB9KSA9PiBub2RlMildKTtcbiAgICB9XG4gIH0sXG4gIENhcHR1cmluZ0dyb3VwOiB7XG4gICAgZW50ZXIoe1xuICAgICAgbm9kZSxcbiAgICAgIHJlcGxhY2VXaXRoLFxuICAgICAgc2tpcFxuICAgIH0sIHtcbiAgICAgIGdyb3VwT3JpZ2luQnlDb3B5LFxuICAgICAgZ3JvdXBzQnlOYW1lLFxuICAgICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZixcbiAgICAgIG9wZW5SZWZzLFxuICAgICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXJcbiAgICB9KSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBncm91cE9yaWdpbkJ5Q29weS5nZXQobm9kZSk7XG4gICAgICBpZiAob3JpZ2luICYmIG9wZW5SZWZzLmhhcyhub2RlLm51bWJlcikpIHtcbiAgICAgICAgY29uc3QgcmVjdXJzaW9uMiA9IGNyZWF0ZVJlY3Vyc2lvbihub2RlLm51bWJlcik7XG4gICAgICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLnNldChyZWN1cnNpb24yLCBvcGVuUmVmcy5nZXQobm9kZS5udW1iZXIpKTtcbiAgICAgICAgcmVwbGFjZVdpdGgocmVjdXJzaW9uMik7XG4gICAgICAgIHNraXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3BlblJlZnMuc2V0KG5vZGUubnVtYmVyLCBub2RlKTtcbiAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuc2V0KG5vZGUubnVtYmVyLCBbXSk7XG4gICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgIGdldE9ySW5zZXJ0KG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYsIG5vZGUubmFtZSwgW10pO1xuICAgICAgfVxuICAgICAgY29uc3QgbXVsdGlwbGV4Tm9kZXMgPSBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLmdldChub2RlLm5hbWUgPz8gbm9kZS5udW1iZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdWx0aXBsZXhOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtdWx0aXBsZXggPSBtdWx0aXBsZXhOb2Rlc1tpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFRoaXMgZ3JvdXAgaXMgZnJvbSBzdWJyb3V0aW5lIGV4cGFuc2lvbiwgYW5kIHRoZXJlJ3MgYSBtdWx0aXBsZXggdmFsdWUgZnJvbSBlaXRoZXIgdGhlXG4gICAgICAgICAgLy8gb3JpZ2luIG5vZGUgb3IgYSBwcmlvciBzdWJyb3V0aW5lIGV4cGFuc2lvbiBncm91cCB3aXRoIHRoZSBzYW1lIG9yaWdpblxuICAgICAgICAgIG9yaWdpbiA9PT0gbXVsdGlwbGV4Lm5vZGUgfHwgb3JpZ2luICYmIG9yaWdpbiA9PT0gbXVsdGlwbGV4Lm9yaWdpbiB8fCAvLyBUaGlzIGdyb3VwIGlzIG5vdCBmcm9tIHN1YnJvdXRpbmUgZXhwYW5zaW9uLCBhbmQgaXQgY29tZXMgYWZ0ZXIgYSBzdWJyb3V0aW5lIGV4cGFuc2lvblxuICAgICAgICAgIC8vIGdyb3VwIHRoYXQgcmVmZXJzIHRvIHRoaXMgZ3JvdXBcbiAgICAgICAgICBub2RlID09PSBtdWx0aXBsZXgub3JpZ2luXG4gICAgICAgICkge1xuICAgICAgICAgIG11bHRpcGxleE5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQobm9kZS5udW1iZXIpLnB1c2goeyBub2RlLCBvcmlnaW4gfSk7XG4gICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuZ2V0KG5vZGUubmFtZSkucHVzaCh7IG5vZGUsIG9yaWdpbiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzV2l0aFNhbWVOYW1lID0gZ2V0T3JJbnNlcnQoZ3JvdXBzQnlOYW1lLCBub2RlLm5hbWUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICBsZXQgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICBoYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZ3JvdXBJbmZvIG9mIGdyb3Vwc1dpdGhTYW1lTmFtZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFncm91cEluZm8uaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBncm91cHNCeU5hbWUuZ2V0KG5vZGUubmFtZSkuc2V0KG5vZGUsIHsgbm9kZSwgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdCh7IG5vZGUgfSwgeyBvcGVuUmVmcyB9KSB7XG4gICAgICBvcGVuUmVmcy5kZWxldGUobm9kZS5udW1iZXIpO1xuICAgIH1cbiAgfSxcbiAgR3JvdXA6IHtcbiAgICBlbnRlcih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnByZXZGbGFncyA9IHN0YXRlLmN1cnJlbnRGbGFncztcbiAgICAgIGlmIChub2RlLmZsYWdzKSB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnRGbGFncyA9IGdldE5ld0N1cnJlbnRGbGFncyhzdGF0ZS5jdXJyZW50RmxhZ3MsIG5vZGUuZmxhZ3MpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdChfLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEZsYWdzID0gc3RhdGUucHJldkZsYWdzO1xuICAgIH1cbiAgfSxcbiAgUmVjdXJzaW9uKHsgbm9kZSwgcGFyZW50IH0sIHsgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIgfSkge1xuICAgIGNvbnN0IHsgcmVmIH0gPSBub2RlO1xuICAgIGxldCByZWZmZWQgPSBwYXJlbnQ7XG4gICAgd2hpbGUgKHJlZmZlZCA9IHJlZmZlZC5wYXJlbnQpIHtcbiAgICAgIGlmIChyZWZmZWQudHlwZSA9PT0gQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXAgJiYgKHJlZmZlZC5uYW1lID09PSByZWYgfHwgcmVmZmVkLm51bWJlciA9PT0gcmVmKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuc2V0KG5vZGUsIHJlZmZlZCk7XG4gIH0sXG4gIFN1YnJvdXRpbmUocGF0aCwgc3RhdGUpIHtcbiAgICBjb25zdCB7IG5vZGUsIHJlcGxhY2VXaXRoIH0gPSBwYXRoO1xuICAgIGNvbnN0IHsgcmVmIH0gPSBub2RlO1xuICAgIGNvbnN0IHJlZmZlZEdyb3VwTm9kZSA9IHN0YXRlLnN1YnJvdXRpbmVSZWZNYXAuZ2V0KHJlZik7XG4gICAgY29uc3QgaXNHbG9iYWxSZWN1cnNpb24gPSByZWYgPT09IDA7XG4gICAgY29uc3QgZXhwYW5kZWRTdWJyb3V0aW5lID0gaXNHbG9iYWxSZWN1cnNpb24gPyBjcmVhdGVSZWN1cnNpb24oMCkgOiAoXG4gICAgICAvLyBUaGUgcmVmZmVkIGdyb3VwIG1pZ2h0IGl0c2VsZiBjb250YWluIHN1YnJvdXRpbmVzLCB3aGljaCBhcmUgZXhwYW5kZWQgZHVyaW5nIHN1Yi10cmF2ZXJzYWxcbiAgICAgIGNsb25lQ2FwdHVyaW5nR3JvdXAocmVmZmVkR3JvdXBOb2RlLCBzdGF0ZS5ncm91cE9yaWdpbkJ5Q29weSwgbnVsbClcbiAgICApO1xuICAgIGxldCByZXBsYWNlbWVudCA9IGV4cGFuZGVkU3Vicm91dGluZTtcbiAgICBpZiAoIWlzR2xvYmFsUmVjdXJzaW9uKSB7XG4gICAgICBjb25zdCByZWZmZWRHcm91cEZsYWdNb2RzID0gZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMoZ2V0QWxsUGFyZW50cyhyZWZmZWRHcm91cE5vZGUsIChub2RlMikgPT4ge1xuICAgICAgICByZXR1cm4gbm9kZTIudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXAgJiYgISFub2RlMi5mbGFncztcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IHJlZmZlZEdyb3VwRmxhZ3MgPSByZWZmZWRHcm91cEZsYWdNb2RzID8gZ2V0TmV3Q3VycmVudEZsYWdzKHN0YXRlLmdsb2JhbEZsYWdzLCByZWZmZWRHcm91cEZsYWdNb2RzKSA6IHN0YXRlLmdsb2JhbEZsYWdzO1xuICAgICAgaWYgKCFhcmVGbGFnc0VxdWFsKHJlZmZlZEdyb3VwRmxhZ3MsIHN0YXRlLmN1cnJlbnRGbGFncykpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKHtcbiAgICAgICAgICBmbGFnczogZ2V0RmxhZ01vZHNGcm9tRmxhZ3MocmVmZmVkR3JvdXBGbGFncylcbiAgICAgICAgfSksIFtleHBhbmRlZFN1YnJvdXRpbmVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpO1xuICAgIGlmICghaXNHbG9iYWxSZWN1cnNpb24pIHtcbiAgICAgIHRyYXZlcnNlUmVwbGFjZW1lbnQocmVwbGFjZW1lbnQsIHBhdGgsIHN0YXRlLCBTZWNvbmRQYXNzVmlzaXRvcik7XG4gICAgfVxuICB9XG59O1xudmFyIFRoaXJkUGFzc1Zpc2l0b3IgPSB7XG4gIEJhY2tyZWZlcmVuY2UoeyBub2RlLCByZXBsYWNlV2l0aCB9LCBzdGF0ZSkge1xuICAgIGlmIChub2RlLm9ycGhhbikge1xuICAgICAgc3RhdGUuaGlnaGVzdE9ycGhhbkJhY2tyZWYgPSBNYXRoLm1heChzdGF0ZS5oaWdoZXN0T3JwaGFuQmFja3JlZiwgbm9kZS5yZWYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWZmZWROb2RlcyA9IHN0YXRlLnJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLmdldChub2RlKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSByZWZmZWROb2Rlcy5maWx0ZXIoKHJlZmZlZCkgPT4gY2FuUGFydGljaXBhdGVXaXRoTm9kZShyZWZmZWQsIG5vZGUpKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50cy5sZW5ndGgpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHByZXBDb250YWluZXIoY3JlYXRlTG9va2Fyb3VuZCh7IG5lZ2F0ZTogdHJ1ZSB9KSkpO1xuICAgIH0gZWxzZSBpZiAocGFydGljaXBhbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGFsdHMgPSBwYXJ0aWNpcGFudHMubWFwKChyZWZmZWQpID0+IGFkb3B0QW5kU3dhcEtpZHMoXG4gICAgICAgIGNyZWF0ZUFsdGVybmF0aXZlKCksXG4gICAgICAgIFtjcmVhdGVCYWNrcmVmZXJlbmNlKHJlZmZlZC5udW1iZXIpXVxuICAgICAgKSk7XG4gICAgICByZXBsYWNlV2l0aChhZG9wdEFuZFN3YXBLaWRzKGNyZWF0ZUdyb3VwKCksIGFsdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZWYgPSBwYXJ0aWNpcGFudHNbMF0ubnVtYmVyO1xuICAgIH1cbiAgfSxcbiAgQ2FwdHVyaW5nR3JvdXAoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgbm9kZS5udW1iZXIgPSArK3N0YXRlLm51bUNhcHR1cmVzVG9MZWZ0O1xuICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgIGlmIChzdGF0ZS5ncm91cHNCeU5hbWUuZ2V0KG5vZGUubmFtZSkuZ2V0KG5vZGUpLmhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSkge1xuICAgICAgICBkZWxldGUgbm9kZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgUmVjdXJzaW9uKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnJlZiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnJlZiA9IHN0YXRlLnJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLmdldChub2RlKS5udW1iZXI7XG4gIH0sXG4gIFJlZ2V4OiB7XG4gICAgZXhpdCh7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICAgIGNvbnN0IG51bUNhcHNOZWVkZWQgPSBNYXRoLm1heChzdGF0ZS5oaWdoZXN0T3JwaGFuQmFja3JlZiAtIHN0YXRlLm51bUNhcHR1cmVzVG9MZWZ0LCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2Fwc05lZWRlZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5Q2FwdHVyZSA9IGNyZWF0ZUNhcHR1cmluZ0dyb3VwKCk7XG4gICAgICAgIG5vZGUucGF0dGVybi5hbHRlcm5hdGl2ZXMuYXQoLTEpLmVsZW1lbnRzLnB1c2goZW1wdHlDYXB0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgYXNjaWlTcGFjZUNoYXIgPSBcIltcdC1cXHIgXVwiO1xudmFyIGRlZmF1bHRXb3JkQ2hhciA9IHJgW1xccHtMfVxccHtNfVxccHtOfVxccHtQY31dYDtcbmZ1bmN0aW9uIGFkb3B0QW5kU3dhcEtpZHMocGFyZW50LCBraWRzKSB7XG4gIGtpZHMuZm9yRWFjaCgoa2lkKSA9PiBraWQucGFyZW50ID0gcGFyZW50KTtcbiAgcGFyZW50W2dldENvbnRhaW5lckFjY2Vzc29yKHBhcmVudCldID0ga2lkcztcbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIGFyZUZsYWdzRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5kb3RBbGwgPT09IGIuZG90QWxsICYmIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlO1xufVxuZnVuY3Rpb24gY2FuUGFydGljaXBhdGVXaXRoTm9kZShjYXB0dXJlLCBub2RlKSB7XG4gIGxldCByaWdodG1vc3RQb2ludCA9IG5vZGU7XG4gIGRvIHtcbiAgICBpZiAocmlnaHRtb3N0UG9pbnQudHlwZSA9PT0gQXN0VHlwZXMuUGF0dGVybikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmlnaHRtb3N0UG9pbnQudHlwZSA9PT0gQXN0VHlwZXMuQWx0ZXJuYXRpdmUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocmlnaHRtb3N0UG9pbnQgPT09IGNhcHR1cmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qga2lkc09mUGFyZW50ID0gZ2V0S2lkcyhyaWdodG1vc3RQb2ludC5wYXJlbnQpO1xuICAgIGZvciAoY29uc3Qga2lkIG9mIGtpZHNPZlBhcmVudCkge1xuICAgICAgaWYgKGtpZCA9PT0gcmlnaHRtb3N0UG9pbnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoa2lkID09PSBjYXB0dXJlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0Rlc2NlbmRhbnQoa2lkLCBjYXB0dXJlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKHJpZ2h0bW9zdFBvaW50ID0gcmlnaHRtb3N0UG9pbnQucGFyZW50KTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXRoXCIpO1xufVxuZnVuY3Rpb24gY2xvbmVDYXB0dXJpbmdHcm91cChvYmosIG9yaWdpbk1hcCwgdXAsIHVwMikge1xuICBjb25zdCBzdG9yZSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAoa2V5ID09PSBcInBhcmVudFwiKSB7XG4gICAgICBzdG9yZS5wYXJlbnQgPSBBcnJheS5pc0FycmF5KHVwKSA/IHVwMiA6IHVwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBzdG9yZVtrZXldID0gY2xvbmVDYXB0dXJpbmdHcm91cCh2YWx1ZSwgb3JpZ2luTWFwLCBzdG9yZSwgdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiB2YWx1ZSA9PT0gQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXApIHtcbiAgICAgICAgb3JpZ2luTWFwLnNldChzdG9yZSwgb3JpZ2luTWFwLmdldChvYmopID8/IG9iaik7XG4gICAgICB9XG4gICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY3Vyc2lvbihyZWYpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5SZWN1cnNpb24sXG4gICAgcmVmXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGxQYXJlbnRzKG5vZGUsIGZpbHRlckZuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgIGlmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4obm9kZSkpIHtcbiAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBnZXRBbmRTdG9yZUpzR3JvdXBOYW1lKG5hbWUsIG1hcCkge1xuICBpZiAobWFwLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBtYXAuZ2V0KG5hbWUpO1xuICB9XG4gIGNvbnN0IGpzTmFtZSA9IGAkJHttYXAuc2l6ZX1fJHtuYW1lLnJlcGxhY2UoL15bXiRfXFxwe0lEU31dfFteJFxcdTIwMENcXHUyMDBEXFxwe0lEQ31dL3VnLCBcIl9cIil9YDtcbiAgbWFwLnNldChuYW1lLCBqc05hbWUpO1xuICByZXR1cm4ganNOYW1lO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSkge1xuICBmb3IgKGNvbnN0IGFjY2Vzc29yIG9mIFtcImFsdGVybmF0aXZlc1wiLCBcImNsYXNzZXNcIiwgXCJlbGVtZW50c1wiXSkge1xuICAgIGlmIChub2RlW2FjY2Vzc29yXSkge1xuICAgICAgcmV0dXJuIGFjY2Vzc29yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkRmxhZ01vZHNGcm9tRmxhZ05vZGVzKGZsYWdOb2Rlcykge1xuICBjb25zdCBmbGFnUHJvcHMgPSBbXCJkb3RBbGxcIiwgXCJpZ25vcmVDYXNlXCJdO1xuICBjb25zdCBjb21iaW5lZEZsYWdzID0geyBlbmFibGU6IHt9LCBkaXNhYmxlOiB7fSB9O1xuICBmbGFnTm9kZXMuZm9yRWFjaCgoeyBmbGFncyB9KSA9PiB7XG4gICAgZmxhZ1Byb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChmbGFncy5lbmFibGU/Lltwcm9wXSkge1xuICAgICAgICBkZWxldGUgY29tYmluZWRGbGFncy5kaXNhYmxlW3Byb3BdO1xuICAgICAgICBjb21iaW5lZEZsYWdzLmVuYWJsZVtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuZGlzYWJsZT8uW3Byb3BdKSB7XG4gICAgICAgIGNvbWJpbmVkRmxhZ3MuZGlzYWJsZVtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIU9iamVjdC5rZXlzKGNvbWJpbmVkRmxhZ3MuZW5hYmxlKS5sZW5ndGgpIHtcbiAgICBkZWxldGUgY29tYmluZWRGbGFncy5lbmFibGU7XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhjb21iaW5lZEZsYWdzLmRpc2FibGUpLmxlbmd0aCkge1xuICAgIGRlbGV0ZSBjb21iaW5lZEZsYWdzLmRpc2FibGU7XG4gIH1cbiAgaWYgKGNvbWJpbmVkRmxhZ3MuZW5hYmxlIHx8IGNvbWJpbmVkRmxhZ3MuZGlzYWJsZSkge1xuICAgIHJldHVybiBjb21iaW5lZEZsYWdzO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RmxhZ01vZHNGcm9tRmxhZ3MoeyBkb3RBbGwsIGlnbm9yZUNhc2UgfSkge1xuICBjb25zdCBtb2RzID0ge307XG4gIGlmIChkb3RBbGwgfHwgaWdub3JlQ2FzZSkge1xuICAgIG1vZHMuZW5hYmxlID0ge307XG4gICAgZG90QWxsICYmIChtb2RzLmVuYWJsZS5kb3RBbGwgPSB0cnVlKTtcbiAgICBpZ25vcmVDYXNlICYmIChtb2RzLmVuYWJsZS5pZ25vcmVDYXNlID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKCFkb3RBbGwgfHwgIWlnbm9yZUNhc2UpIHtcbiAgICBtb2RzLmRpc2FibGUgPSB7fTtcbiAgICAhZG90QWxsICYmIChtb2RzLmRpc2FibGUuZG90QWxsID0gdHJ1ZSk7XG4gICAgIWlnbm9yZUNhc2UgJiYgKG1vZHMuZGlzYWJsZS5pZ25vcmVDYXNlID0gdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG1vZHM7XG59XG5mdW5jdGlvbiBnZXRLaWRzKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBleHBlY3RlZFwiKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBBc3RUeXBlcy5RdWFudGlmaWVyKSB7XG4gICAgcmV0dXJuIFtub2RlLmVsZW1lbnRdO1xuICB9XG4gIGNvbnN0IGFjY2Vzc29yID0gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSk7XG4gIHJldHVybiBhY2Nlc3NvciAmJiBub2RlW2FjY2Vzc29yXTtcbn1cbmZ1bmN0aW9uIGdldExlYWRpbmdHKGVscykge1xuICBjb25zdCBmaXJzdFRvQ29uc2lkZXIgPSBlbHMuZmluZCgoZWwpID0+IGVsLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCB8fCBpc0xvbmVHTG9va2Fyb3VuZChlbCwgeyBuZWdhdGU6IGZhbHNlIH0pIHx8ICFpc0Fsd2F5c1plcm9MZW5ndGgoZWwpKTtcbiAgaWYgKCFmaXJzdFRvQ29uc2lkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZmlyc3RUb0NvbnNpZGVyLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCkge1xuICAgIHJldHVybiBmaXJzdFRvQ29uc2lkZXI7XG4gIH1cbiAgaWYgKGlzTG9va2Fyb3VuZChmaXJzdFRvQ29uc2lkZXIpKSB7XG4gICAgcmV0dXJuIGZpcnN0VG9Db25zaWRlci5hbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHNbMF07XG4gIH1cbiAgaWYgKGlzQ29uc3VtcHRpdmVHcm91cChmaXJzdFRvQ29uc2lkZXIpKSB7XG4gICAgY29uc3QgZ05vZGVzRm9yR3JvdXAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBmaXJzdFRvQ29uc2lkZXIuYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBsZWFkaW5nRyA9IGdldExlYWRpbmdHKGFsdC5lbGVtZW50cyk7XG4gICAgICBpZiAoIWxlYWRpbmdHKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgQXJyYXkuaXNBcnJheShsZWFkaW5nRykgPyBnTm9kZXNGb3JHcm91cC5wdXNoKC4uLmxlYWRpbmdHKSA6IGdOb2Rlc0Zvckdyb3VwLnB1c2gobGVhZGluZ0cpO1xuICAgIH1cbiAgICByZXR1cm4gZ05vZGVzRm9yR3JvdXA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYXNEZXNjZW5kYW50KG5vZGUsIGRlc2NlbmRhbnQpIHtcbiAgY29uc3Qga2lkcyA9IGdldEtpZHMobm9kZSkgPz8gW107XG4gIGZvciAoY29uc3Qga2lkIG9mIGtpZHMpIHtcbiAgICBpZiAoa2lkID09PSBkZXNjZW5kYW50IHx8IGhhc0Rlc2NlbmRhbnQoa2lkLCBkZXNjZW5kYW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTG9uZUdMb29rYXJvdW5kKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBuZWdhdGU6IG51bGwsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4gaXNMb29rYXJvdW5kKG5vZGUpICYmIChvcHRzLm5lZ2F0ZSA9PT0gbnVsbCB8fCBub2RlLm5lZ2F0ZSA9PT0gb3B0cy5uZWdhdGUpICYmIGhhc09ubHlDaGlsZChub2RlLCAoa2lkKSA9PiBraWQua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRHcm91cE5hbWVKcyhuYW1lKSB7XG4gIHJldHVybiAvXlskX1xccHtJRFN9XVskXFx1MjAwQ1xcdTIwMERcXHB7SURDfV0qJC91LnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBwYXJzZUZyYWdtZW50KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodG9rZW5pemUocGF0dGVybiksIG9wdGlvbnMpO1xuICBjb25zdCBhbHRzID0gYXN0LnBhdHRlcm4uYWx0ZXJuYXRpdmVzO1xuICBpZiAoYWx0cy5sZW5ndGggPiAxIHx8IGFsdHNbMF0uZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBhZG9wdEFuZFN3YXBLaWRzKGNyZWF0ZUdyb3VwKCksIGFsdHMpO1xuICB9XG4gIHJldHVybiBhbHRzWzBdLmVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gcHJlcENvbnRhaW5lcihub2RlLCBraWRzKSB7XG4gIGNvbnN0IGFjY2Vzc29yID0gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSk7XG4gIG5vZGVbYWNjZXNzb3JdWzBdLnBhcmVudCA9IG5vZGU7XG4gIGlmIChraWRzKSB7XG4gICAgYWRvcHRBbmRTd2FwS2lkcyhub2RlW2FjY2Vzc29yXVswXSwga2lkcyk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXROZWdhdGUobm9kZSwgbmVnYXRlKSB7XG4gIG5vZGUubmVnYXRlID0gbmVnYXRlO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUmVwbGFjZW1lbnQocmVwbGFjZW1lbnQsIHsgcGFyZW50LCBrZXksIGNvbnRhaW5lciB9LCBzdGF0ZSwgdmlzaXRvcikge1xuICB0cmF2ZXJzZSh7XG4gICAgLy8gRG9uJ3QgdXNlIHRoZSBgbm9kZWAgZnJvbSBgcGF0aGBcbiAgICBub2RlOiByZXBsYWNlbWVudCxcbiAgICBwYXJlbnQsXG4gICAga2V5LFxuICAgIGNvbnRhaW5lclxuICB9LCBzdGF0ZSwgdmlzaXRvcik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS5qc1xuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBtaW5UYXJnZXRFczIwMjQgPSBpc01pblRhcmdldChvcHRzLnRhcmdldCwgXCJFUzIwMjRcIik7XG4gIGNvbnN0IG1pblRhcmdldEVzMjAyNSA9IGlzTWluVGFyZ2V0KG9wdHMudGFyZ2V0LCBcIkVTMjAyNVwiKTtcbiAgY29uc3QgcmVjdXJzaW9uTGltaXQgPSBvcHRzLnJ1bGVzLnJlY3Vyc2lvbkxpbWl0O1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIocmVjdXJzaW9uTGltaXQpIHx8IHJlY3Vyc2lvbkxpbWl0IDwgMiB8fCByZWN1cnNpb25MaW1pdCA+IDIwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWN1cnNpb25MaW1pdDsgdXNlIDItMjBcIik7XG4gIH1cbiAgbGV0IGhhc0Nhc2VJbnNlbnNpdGl2ZU5vZGUgPSBudWxsO1xuICBsZXQgaGFzQ2FzZVNlbnNpdGl2ZU5vZGUgPSBudWxsO1xuICBpZiAoIW1pblRhcmdldEVzMjAyNSkge1xuICAgIGNvbnN0IGlTdGFjayA9IFthc3QuZmxhZ3MuaWdub3JlQ2FzZV07XG4gICAgdHJhdmVyc2UoeyBub2RlOiBhc3QgfSwge1xuICAgICAgZ2V0Q3VycmVudE1vZEk6ICgpID0+IGlTdGFjay5hdCgtMSksXG4gICAgICBwb3BNb2RJKCkge1xuICAgICAgICBpU3RhY2sucG9wKCk7XG4gICAgICB9LFxuICAgICAgcHVzaE1vZEkoaXNJT24pIHtcbiAgICAgICAgaVN0YWNrLnB1c2goaXNJT24pO1xuICAgICAgfSxcbiAgICAgIHNldEhhc0Nhc2VkQ2hhcigpIHtcbiAgICAgICAgaWYgKGlTdGFjay5hdCgtMSkpIHtcbiAgICAgICAgICBoYXNDYXNlSW5zZW5zaXRpdmVOb2RlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNDYXNlU2Vuc2l0aXZlTm9kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBGbGFnTW9kaWZpZXJWaXNpdG9yKTtcbiAgfVxuICBjb25zdCBhcHBsaWVkR2xvYmFsRmxhZ3MgPSB7XG4gICAgZG90QWxsOiBhc3QuZmxhZ3MuZG90QWxsLFxuICAgIC8vIC0gVHVybiBnbG9iYWwgZmxhZyBpIG9uIGlmIGEgY2FzZSBpbnNlbnNpdGl2ZSBub2RlIHdhcyB1c2VkIGFuZCBubyBjYXNlIHNlbnNpdGl2ZSBub2RlcyB3ZXJlXG4gICAgLy8gICB1c2VkICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBub2RlIGV4cGFuc2lvbikuXG4gICAgLy8gLSBUdXJuIGdsb2JhbCBmbGFnIGkgb2ZmIGlmIGEgY2FzZSBzZW5zaXRpdmUgbm9kZSB3YXMgdXNlZCAoc2luY2UgY2FzZSBzZW5zaXRpdml0eSBjYW4ndCBiZVxuICAgIC8vICAgZm9yY2VkIHdpdGhvdXQgdGhlIHVzZSBvZiBFUzIwMjUgZmxhZyBncm91cHMpXG4gICAgaWdub3JlQ2FzZTogISEoKGFzdC5mbGFncy5pZ25vcmVDYXNlIHx8IGhhc0Nhc2VJbnNlbnNpdGl2ZU5vZGUpICYmICFoYXNDYXNlU2Vuc2l0aXZlTm9kZSlcbiAgfTtcbiAgbGV0IGxhc3ROb2RlID0gbnVsbDtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgYWNjdXJhY3k6IG9wdHMuYWNjdXJhY3ksXG4gICAgYXBwbGllZEdsb2JhbEZsYWdzLFxuICAgIGNhcHR1cmVNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY3VycmVudEZsYWdzOiB7XG4gICAgICBkb3RBbGw6IGFzdC5mbGFncy5kb3RBbGwsXG4gICAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICAgIH0sXG4gICAgaW5DaGFyQ2xhc3M6IGZhbHNlLFxuICAgIGxhc3ROb2RlLFxuICAgIG9yaWdpbk1hcDogYXN0Ll9vcmlnaW5NYXAsXG4gICAgcmVjdXJzaW9uTGltaXQsXG4gICAgdXNlQXBwbGllZElnbm9yZUNhc2U6ICEhKCFtaW5UYXJnZXRFczIwMjUgJiYgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSAmJiBoYXNDYXNlU2Vuc2l0aXZlTm9kZSksXG4gICAgdXNlRmxhZ01vZHM6IG1pblRhcmdldEVzMjAyNSxcbiAgICB1c2VGbGFnVjogbWluVGFyZ2V0RXMyMDI0LFxuICAgIHZlcmJvc2U6IG9wdHMudmVyYm9zZVxuICB9O1xuICBmdW5jdGlvbiBnZW4obm9kZSkge1xuICAgIHN0YXRlLmxhc3ROb2RlID0gbGFzdE5vZGU7XG4gICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIEFzdFR5cGVzLlJlZ2V4OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdHRlcm46IGdlbihub2RlLnBhdHRlcm4pLFxuICAgICAgICAgIGZsYWdzOiBnZW4obm9kZS5mbGFncyksXG4gICAgICAgICAgb3B0aW9uczogeyAuLi5ub2RlLm9wdGlvbnMgfVxuICAgICAgICB9O1xuICAgICAgY2FzZSBBc3RUeXBlcy5BbHRlcm5hdGl2ZTpcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHMubWFwKGdlbikuam9pbihcIlwiKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQXNzZXJ0aW9uOlxuICAgICAgICByZXR1cm4gZ2VuQXNzZXJ0aW9uKG5vZGUsIHN0YXRlLCBnZW4pO1xuICAgICAgY2FzZSBBc3RUeXBlcy5CYWNrcmVmZXJlbmNlOlxuICAgICAgICByZXR1cm4gZ2VuQmFja3JlZmVyZW5jZShub2RlLCBzdGF0ZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwOlxuICAgICAgICByZXR1cm4gZ2VuQ2FwdHVyaW5nR3JvdXAobm9kZSwgc3RhdGUsIGdlbik7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlcjpcbiAgICAgICAgcmV0dXJuIGdlbkNoYXJhY3Rlcihub2RlLCBzdGF0ZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzOlxuICAgICAgICByZXR1cm4gZ2VuQ2hhcmFjdGVyQ2xhc3Mobm9kZSwgc3RhdGUsIGdlbik7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uOlxuICAgICAgICBpZiAoIXN0YXRlLnVzZUZsYWdWKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIG9mIGNsYXNzIGludGVyc2VjdGlvbiByZXF1aXJlcyBtaW4gdGFyZ2V0IEVTMjAyNFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc2VzLm1hcChnZW4pLmpvaW4oXCImJlwiKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NSYW5nZTpcbiAgICAgICAgcmV0dXJuIGdlbkNoYXJhY3RlckNsYXNzUmFuZ2Uobm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQ6XG4gICAgICAgIHJldHVybiBnZW5DaGFyYWN0ZXJTZXQobm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5GbGFnczpcbiAgICAgICAgcmV0dXJuIGdlbkZsYWdzKG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuR3JvdXA6XG4gICAgICAgIHJldHVybiBnZW5Hcm91cChub2RlLCBzdGF0ZSwgZ2VuKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuUGF0dGVybjpcbiAgICAgICAgcmV0dXJuIG5vZGUuYWx0ZXJuYXRpdmVzLm1hcChnZW4pLmpvaW4oXCJ8XCIpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5RdWFudGlmaWVyOlxuICAgICAgICByZXR1cm4gZ2VuKG5vZGUuZWxlbWVudCkgKyBnZXRRdWFudGlmaWVyU3RyKG5vZGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5SZWN1cnNpb246XG4gICAgICAgIHJldHVybiBnZW5SZWN1cnNpb24obm9kZSwgc3RhdGUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIiR7bm9kZS50eXBlfVwiYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlbihhc3QpO1xuICBpZiAoIW1pblRhcmdldEVzMjAyNCkge1xuICAgIGRlbGV0ZSByZXN1bHQub3B0aW9ucy5mb3JjZS52O1xuICAgIHJlc3VsdC5vcHRpb25zLmRpc2FibGUudiA9IHRydWU7XG4gICAgcmVzdWx0Lm9wdGlvbnMudW5pY29kZVNldHNQbHVnaW4gPSBudWxsO1xuICB9XG4gIHJlc3VsdC5fY2FwdHVyZVRyYW5zZmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJlc3VsdC5faGlkZGVuQ2FwdHVyZXMgPSBbXTtcbiAgc3RhdGUuY2FwdHVyZU1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmhpZGRlbikge1xuICAgICAgcmVzdWx0Ll9oaWRkZW5DYXB0dXJlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50cmFuc2ZlclRvKSB7XG4gICAgICBnZXRPckluc2VydChyZXN1bHQuX2NhcHR1cmVUcmFuc2ZlcnMsIHZhbHVlLnRyYW5zZmVyVG8sIFtdKS5wdXNoKGtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBGbGFnTW9kaWZpZXJWaXNpdG9yID0ge1xuICBBbnlHcm91cDoge1xuICAgIGVudGVyKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgICAgY29uc3QgY3VycmVudE1vZEkgPSBzdGF0ZS5nZXRDdXJyZW50TW9kSSgpO1xuICAgICAgc3RhdGUucHVzaE1vZEkoXG4gICAgICAgIG5vZGUuZmxhZ3MgPyBnZXROZXdDdXJyZW50RmxhZ3MoeyBpZ25vcmVDYXNlOiBjdXJyZW50TW9kSSB9LCBub2RlLmZsYWdzKS5pZ25vcmVDYXNlIDogY3VycmVudE1vZElcbiAgICAgICk7XG4gICAgfSxcbiAgICBleGl0KF8sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5wb3BNb2RJKCk7XG4gICAgfVxuICB9LFxuICBCYWNrcmVmZXJlbmNlKF8sIHN0YXRlKSB7XG4gICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gIH0sXG4gIENoYXJhY3Rlcih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICBpZiAoY2hhckhhc0Nhc2UoY3Aobm9kZS52YWx1ZSkpKSB7XG4gICAgICBzdGF0ZS5zZXRIYXNDYXNlZENoYXIoKTtcbiAgICB9XG4gIH0sXG4gIENoYXJhY3RlckNsYXNzUmFuZ2UoeyBub2RlLCBza2lwIH0sIHN0YXRlKSB7XG4gICAgc2tpcCgpO1xuICAgIGlmIChnZXRDYXNlc091dHNpZGVDaGFyQ2xhc3NSYW5nZShub2RlLCB7IGZpcnN0T25seTogdHJ1ZSB9KS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLnNldEhhc0Nhc2VkQ2hhcigpO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyU2V0KHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmIChub2RlLmtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5ICYmIFVuaWNvZGVQcm9wZXJ0aWVzV2l0aFNwZWNpZmljQ2FzZS5oYXMobm9kZS52YWx1ZSkpIHtcbiAgICAgIHN0YXRlLnNldEhhc0Nhc2VkQ2hhcigpO1xuICAgIH1cbiAgfVxufTtcbnZhciBCYXNlRXNjYXBlQ2hhcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiJFwiLFxuICBcIihcIixcbiAgXCIpXCIsXG4gIFwiKlwiLFxuICBcIitcIixcbiAgXCIuXCIsXG4gIFwiP1wiLFxuICBcIltcIixcbiAgXCJcXFxcXCIsXG4gIFwiXVwiLFxuICBcIl5cIixcbiAgXCJ7XCIsXG4gIFwifFwiLFxuICBcIn1cIlxuXSk7XG52YXIgQ2hhckNsYXNzRXNjYXBlQ2hhcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiLVwiLFxuICBcIlxcXFxcIixcbiAgXCJdXCIsXG4gIFwiXlwiLFxuICAvLyBMaXRlcmFsIGBbYCBkb2Vzbid0IHJlcXVpcmUgZXNjYXBpbmcgd2l0aCBmbGFnIHUsIGJ1dCB0aGlzIGNhbiBoZWxwIHdvcmsgYXJvdW5kIHJlZ2V4IHNvdXJjZVxuICAvLyBsaW50ZXJzIGFuZCByZWdleCBzeW50YXggcHJvY2Vzc29ycyB0aGF0IGV4cGVjdCB1bmVzY2FwZWQgYFtgIHRvIGNyZWF0ZSBhIG5lc3RlZCBjbGFzc1xuICBcIltcIlxuXSk7XG52YXIgQ2hhckNsYXNzRXNjYXBlQ2hhcnNGbGFnViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCIoXCIsXG4gIFwiKVwiLFxuICBcIi1cIixcbiAgXCIvXCIsXG4gIFwiW1wiLFxuICBcIlxcXFxcIixcbiAgXCJdXCIsXG4gIFwiXlwiLFxuICBcIntcIixcbiAgXCJ8XCIsXG4gIFwifVwiLFxuICAvLyBEb3VibGUgcHVuY3R1YXRvcnM7IGFsc28gaW5jbHVkZXMgYWxyZWFkeS1saXN0ZWQgYC1gIGFuZCBgXmBcbiAgXCIhXCIsXG4gIFwiI1wiLFxuICBcIiRcIixcbiAgXCIlXCIsXG4gIFwiJlwiLFxuICBcIipcIixcbiAgXCIrXCIsXG4gIFwiLFwiLFxuICBcIi5cIixcbiAgXCI6XCIsXG4gIFwiO1wiLFxuICBcIjxcIixcbiAgXCI9XCIsXG4gIFwiPlwiLFxuICBcIj9cIixcbiAgXCJAXCIsXG4gIFwiYFwiLFxuICBcIn5cIlxuXSk7XG52YXIgQ2hhckNvZGVFc2NhcGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFs5LCByYFxcdGBdLFxuICAvLyBob3Jpem9udGFsIHRhYlxuICBbMTAsIHJgXFxuYF0sXG4gIC8vIGxpbmUgZmVlZFxuICBbMTEsIHJgXFx2YF0sXG4gIC8vIHZlcnRpY2FsIHRhYlxuICBbMTIsIHJgXFxmYF0sXG4gIC8vIGZvcm0gZmVlZFxuICBbMTMsIHJgXFxyYF0sXG4gIC8vIGNhcnJpYWdlIHJldHVyblxuICBbODIzMiwgcmBcXHUyMDI4YF0sXG4gIC8vIGxpbmUgc2VwYXJhdG9yXG4gIFs4MjMzLCByYFxcdTIwMjlgXSxcbiAgLy8gcGFyYWdyYXBoIHNlcGFyYXRvclxuICBbNjUyNzksIHJgXFx1RkVGRmBdXG4gIC8vIFpXTkJTUC9CT01cbl0pO1xudmFyIGNhc2VkUmUgPSAvXlxccHtDYXNlZH0kL3U7XG5mdW5jdGlvbiBjaGFySGFzQ2FzZShjaGFyKSB7XG4gIHJldHVybiBjYXNlZFJlLnRlc3QoY2hhcik7XG59XG5mdW5jdGlvbiBnZW5Bc3NlcnRpb24obm9kZSwgXywgZ2VuKSB7XG4gIGNvbnN0IHsga2luZCwgbmVnYXRlLCBhbHRlcm5hdGl2ZXMgfSA9IG5vZGU7XG4gIGlmIChpc0xvb2thcm91bmQobm9kZSkpIHtcbiAgICBjb25zdCBwcmVmaXggPSBgJHtraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYWhlYWQgPyBcIlwiIDogXCI8XCJ9JHtuZWdhdGUgPyBcIiFcIiA6IFwiPVwifWA7XG4gICAgcmV0dXJuIGAoPyR7cHJlZml4fSR7YWx0ZXJuYXRpdmVzLm1hcChnZW4pLmpvaW4oXCJ8XCIpfSlgO1xuICB9XG4gIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfZW5kKSB7XG4gICAgcmV0dXJuIFwiJFwiO1xuICB9XG4gIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfc3RhcnQpIHtcbiAgICByZXR1cm4gXCJeXCI7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLndvcmRfYm91bmRhcnkpIHtcbiAgICByZXR1cm4gbmVnYXRlID8gcmBcXEJgIDogcmBcXGJgO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhc3NlcnRpb24ga2luZCBcIiR7a2luZH1cImApO1xufVxuZnVuY3Rpb24gZ2VuQmFja3JlZmVyZW5jZSh7IHJlZiB9LCBzdGF0ZSkge1xuICBpZiAodHlwZW9mIHJlZiAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbmFtZWQgYmFja3JlZiBpbiB0cmFuc2Zvcm1lZCBBU1RcIik7XG4gIH1cbiAgaWYgKCFzdGF0ZS51c2VGbGFnTW9kcyAmJiBzdGF0ZS5hY2N1cmFjeSA9PT0gXCJzdHJpY3RcIiAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSAmJiAhc3RhdGUuY2FwdHVyZU1hcC5nZXQocmVmKS5pZ25vcmVDYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIG9mIGNhc2UtaW5zZW5zaXRpdmUgYmFja3JlZiB0byBjYXNlLXNlbnNpdGl2ZSBncm91cCByZXF1aXJlcyB0YXJnZXQgRVMyMDI1IG9yIG5vbi1zdHJpY3QgYWNjdXJhY3lcIik7XG4gIH1cbiAgcmV0dXJuIFwiXFxcXFwiICsgcmVmO1xufVxuZnVuY3Rpb24gZ2VuQ2FwdHVyaW5nR3JvdXAobm9kZSwgc3RhdGUsIGdlbikge1xuICBjb25zdCB7IG5hbWUsIG51bWJlciwgYWx0ZXJuYXRpdmVzIH0gPSBub2RlO1xuICBjb25zdCBkYXRhID0geyBpZ25vcmVDYXNlOiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSB9O1xuICBjb25zdCBvcmlnaW4gPSBzdGF0ZS5vcmlnaW5NYXAuZ2V0KG5vZGUpO1xuICBpZiAob3JpZ2luKSB7XG4gICAgZGF0YS5oaWRkZW4gPSB0cnVlO1xuICAgIGlmIChudW1iZXIgPiBvcmlnaW4ubnVtYmVyKSB7XG4gICAgICBkYXRhLnRyYW5zZmVyVG8gPSBvcmlnaW4ubnVtYmVyO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5jYXB0dXJlTWFwLnNldChudW1iZXIsIGRhdGEpO1xuICByZXR1cm4gYCgke25hbWUgPyBgPzwke25hbWV9PmAgOiBcIlwifSR7YWx0ZXJuYXRpdmVzLm1hcChnZW4pLmpvaW4oXCJ8XCIpfSlgO1xufVxuZnVuY3Rpb24gZ2VuQ2hhcmFjdGVyKHsgdmFsdWUgfSwgc3RhdGUpIHtcbiAgY29uc3QgY2hhciA9IGNwKHZhbHVlKTtcbiAgY29uc3QgZXNjYXBlZCA9IGdldENoYXJFc2NhcGUodmFsdWUsIHtcbiAgICBpc0FmdGVyQmFja3JlZjogc3RhdGUubGFzdE5vZGUudHlwZSA9PT0gQXN0VHlwZXMuQmFja3JlZmVyZW5jZSxcbiAgICBpbkNoYXJDbGFzczogc3RhdGUuaW5DaGFyQ2xhc3MsXG4gICAgdXNlRmxhZ1Y6IHN0YXRlLnVzZUZsYWdWXG4gIH0pO1xuICBpZiAoZXNjYXBlZCAhPT0gY2hhcikge1xuICAgIHJldHVybiBlc2NhcGVkO1xuICB9XG4gIGlmIChzdGF0ZS51c2VBcHBsaWVkSWdub3JlQ2FzZSAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSAmJiBjaGFySGFzQ2FzZShjaGFyKSkge1xuICAgIGNvbnN0IGNhc2VzID0gZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMoY2hhcik7XG4gICAgcmV0dXJuIHN0YXRlLmluQ2hhckNsYXNzID8gY2FzZXMuam9pbihcIlwiKSA6IGNhc2VzLmxlbmd0aCA+IDEgPyBgWyR7Y2FzZXMuam9pbihcIlwiKX1dYCA6IGNhc2VzWzBdO1xuICB9XG4gIHJldHVybiBjaGFyO1xufVxuZnVuY3Rpb24gZ2VuQ2hhcmFjdGVyQ2xhc3MoeyBuZWdhdGUsIHBhcmVudCwgZWxlbWVudHMgfSwgc3RhdGUsIGdlbikge1xuICBpZiAoZW52RmxhZ3MubGl0ZXJhbEh5cGhlbkluY29ycmVjdGx5Q3JlYXRlc1JhbmdlICYmIHN0YXRlLnVzZUZsYWdWICYmIGVsZW1lbnRzLnNvbWUoaXNMaXRlcmFsSHlwaGVuKSkge1xuICAgIGVsZW1lbnRzID0gZWxlbWVudHMuZmlsdGVyKChub2RlKSA9PiAhaXNMaXRlcmFsSHlwaGVuKG5vZGUpKTtcbiAgICBlbGVtZW50cy5wdXNoKGNyZWF0ZUNoYXJhY3Rlcig0NSkpO1xuICB9XG4gIGNvbnN0IGdlbkNsYXNzID0gKCkgPT4gYFske25lZ2F0ZSA/IFwiXlwiIDogXCJcIn0ke2VsZW1lbnRzLm1hcChnZW4pLmpvaW4oXCJcIil9XWA7XG4gIGlmICghc3RhdGUuaW5DaGFyQ2xhc3MpIHtcbiAgICBzdGF0ZS5pbkNoYXJDbGFzcyA9IHRydWU7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2VuQ2xhc3MoKTtcbiAgICBzdGF0ZS5pbkNoYXJDbGFzcyA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgZmlyc3RUeXBlID0gZWxlbWVudHNbMF0/LnR5cGU7XG4gIGlmICghbmVnYXRlICYmIGZpcnN0VHlwZSAmJiAvLyBBbGxvd3MgbWFueSBuZXN0ZWQgY2xhc3NlcyB0byB3b3JrIHdpdGggYHRhcmdldGAgRVMyMDE4IHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBuZXN0aW5nXG4gICgoIXN0YXRlLnVzZUZsYWdWIHx8ICFzdGF0ZS52ZXJib3NlKSAmJiBwYXJlbnQudHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MgJiYgZmlyc3RUeXBlICE9PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbiAmJiAhKGVudkZsYWdzLmxpdGVyYWxIeXBoZW5JbmNvcnJlY3RseUNyZWF0ZXNSYW5nZSAmJiBzdGF0ZS51c2VGbGFnVikgfHwgIXN0YXRlLnZlcmJvc2UgJiYgcGFyZW50LnR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uICYmIC8vIEpTIGRvZXNuJ3QgYWxsb3cgaW50ZXJzZWN0aW9uIHdpdGggdW5pb24gb3IgcmFuZ2VzXG4gIGVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBmaXJzdFR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzICYmIGZpcnN0VHlwZSAhPT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NSYW5nZSkpIHtcbiAgICByZXR1cm4gZWxlbWVudHMubWFwKGdlbikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoIXN0YXRlLnVzZUZsYWdWICYmIHBhcmVudC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzIHJlcXVpcmVzIG1pbiB0YXJnZXQgRVMyMDI0XCIpO1xuICB9XG4gIHJldHVybiBnZW5DbGFzcygpO1xufVxuZnVuY3Rpb24gZ2VuQ2hhcmFjdGVyQ2xhc3NSYW5nZShub2RlLCBzdGF0ZSkge1xuICBjb25zdCBtaW4gPSBub2RlLm1pbi52YWx1ZTtcbiAgY29uc3QgbWF4ID0gbm9kZS5tYXgudmFsdWU7XG4gIGNvbnN0IGVzY09wdHMgPSB7XG4gICAgaXNBZnRlckJhY2tyZWY6IGZhbHNlLFxuICAgIGluQ2hhckNsYXNzOiB0cnVlLFxuICAgIHVzZUZsYWdWOiBzdGF0ZS51c2VGbGFnVlxuICB9O1xuICBjb25zdCBtaW5TdHIgPSBnZXRDaGFyRXNjYXBlKG1pbiwgZXNjT3B0cyk7XG4gIGNvbnN0IG1heFN0ciA9IGdldENoYXJFc2NhcGUobWF4LCBlc2NPcHRzKTtcbiAgY29uc3QgZXh0cmFDaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzdGF0ZS51c2VBcHBsaWVkSWdub3JlQ2FzZSAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSkge1xuICAgIGNvbnN0IGNoYXJzT3V0c2lkZVJhbmdlID0gZ2V0Q2FzZXNPdXRzaWRlQ2hhckNsYXNzUmFuZ2Uobm9kZSk7XG4gICAgY29uc3QgcmFuZ2VzID0gZ2V0Q29kZVBvaW50UmFuZ2VzRnJvbUNoYXJzKGNoYXJzT3V0c2lkZVJhbmdlKTtcbiAgICByYW5nZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGV4dHJhQ2hhcnMuYWRkKFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGAke2dldENoYXJFc2NhcGUodmFsdWVbMF0sIGVzY09wdHMpfS0ke2dldENoYXJFc2NhcGUodmFsdWVbMV0sIGVzY09wdHMpfWAgOiBnZXRDaGFyRXNjYXBlKHZhbHVlLCBlc2NPcHRzKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYCR7bWluU3RyfS0ke21heFN0cn0ke1suLi5leHRyYUNoYXJzXS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBnZW5DaGFyYWN0ZXJTZXQoeyBraW5kLCBuZWdhdGUsIHZhbHVlLCBrZXkgfSwgc3RhdGUpIHtcbiAgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmRvdCkge1xuICAgIHJldHVybiBzdGF0ZS5jdXJyZW50RmxhZ3MuZG90QWxsID8gc3RhdGUuYXBwbGllZEdsb2JhbEZsYWdzLmRvdEFsbCB8fCBzdGF0ZS51c2VGbGFnTW9kcyA/IFwiLlwiIDogXCJbXl1cIiA6IChcbiAgICAgIC8vIE9uaWcncyBvbmx5IGxpbmUgYnJlYWsgY2hhciBpcyBsaW5lIGZlZWQsIHVubGlrZSBKU1xuICAgICAgcmBbXlxcbl1gXG4gICAgKTtcbiAgfVxuICBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuZGlnaXQpIHtcbiAgICByZXR1cm4gbmVnYXRlID8gcmBcXERgIDogcmBcXGRgO1xuICB9XG4gIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5wcm9wZXJ0eSkge1xuICAgIGlmIChzdGF0ZS51c2VBcHBsaWVkSWdub3JlQ2FzZSAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSAmJiBVbmljb2RlUHJvcGVydGllc1dpdGhTcGVjaWZpY0Nhc2UuaGFzKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmljb2RlIHByb3BlcnR5IFwiJHt2YWx1ZX1cIiBjYW4ndCBiZSBjYXNlLWluc2Vuc2l0aXZlIHdoZW4gb3RoZXIgY2hhcnMgaGF2ZSBzcGVjaWZpYyBjYXNlYCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtuZWdhdGUgPyByYFxcUGAgOiByYFxccGB9eyR7a2V5ID8gYCR7a2V5fT1gIDogXCJcIn0ke3ZhbHVlfX1gO1xuICB9XG4gIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy53b3JkKSB7XG4gICAgcmV0dXJuIG5lZ2F0ZSA/IHJgXFxXYCA6IHJgXFx3YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIHNldCBraW5kIFwiJHtraW5kfVwiYCk7XG59XG5mdW5jdGlvbiBnZW5GbGFncyhub2RlLCBzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIC8vIFRoZSB0cmFuc2Zvcm1lciBzaG91bGQgbmV2ZXIgdHVybiBvbiB0aGUgcHJvcGVydGllcyBmb3IgZmxhZ3MgZCwgZywgYW5kIG0gc2luY2UgT25pZyBkb2Vzbid0XG4gICAgLy8gaGF2ZSBlcXVpdnMuIEZsYWcgbSBpcyBuZXZlciByZWxpZWQgb24gc2luY2UgT25pZyB1c2VzIGRpZmZlcmVudCBsaW5lIGJyZWFrIGNoYXJzIHRoYW4gSlNcbiAgICAvLyAobm9kZS5oYXNJbmRpY2VzID8gJ2QnIDogJycpICtcbiAgICAvLyAobm9kZS5nbG9iYWwgPyAnZycgOiAnJykgK1xuICAgIC8vIChub2RlLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgKHN0YXRlLmFwcGxpZWRHbG9iYWxGbGFncy5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChub2RlLmRvdEFsbCA/IFwic1wiIDogXCJcIikgKyAobm9kZS5zdGlja3kgPyBcInlcIiA6IFwiXCIpXG4gICk7XG59XG5mdW5jdGlvbiBnZW5Hcm91cCh7IGF0b21pYzogYXRvbWljMiwgZmxhZ3MsIHBhcmVudCwgYWx0ZXJuYXRpdmVzIH0sIHN0YXRlLCBnZW4pIHtcbiAgY29uc3QgY3VycmVudEZsYWdzID0gc3RhdGUuY3VycmVudEZsYWdzO1xuICBpZiAoZmxhZ3MpIHtcbiAgICBzdGF0ZS5jdXJyZW50RmxhZ3MgPSBnZXROZXdDdXJyZW50RmxhZ3MoY3VycmVudEZsYWdzLCBmbGFncyk7XG4gIH1cbiAgY29uc3QgY29udGVudHMgPSBhbHRlcm5hdGl2ZXMubWFwKGdlbikuam9pbihcInxcIik7XG4gIGNvbnN0IHJlc3VsdCA9ICFzdGF0ZS52ZXJib3NlICYmIGFsdGVybmF0aXZlcy5sZW5ndGggPT09IDEgJiYgcGFyZW50LnR5cGUgIT09IEFzdFR5cGVzLlF1YW50aWZpZXIgJiYgIWF0b21pYzIgJiYgKCFzdGF0ZS51c2VGbGFnTW9kcyB8fCAhZmxhZ3MpID8gY29udGVudHMgOiBgKD8ke2dldEdyb3VwUHJlZml4KGF0b21pYzIsIGZsYWdzLCBzdGF0ZS51c2VGbGFnTW9kcyl9JHtjb250ZW50c30pYDtcbiAgc3RhdGUuY3VycmVudEZsYWdzID0gY3VycmVudEZsYWdzO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuUmVjdXJzaW9uKHsgcmVmIH0sIHN0YXRlKSB7XG4gIGNvbnN0IGxpbWl0ID0gc3RhdGUucmVjdXJzaW9uTGltaXQ7XG4gIHJldHVybiByZWYgPT09IDAgPyBgKD9SPSR7bGltaXR9KWAgOiByYFxcZzwke3JlZn0mUj0ke2xpbWl0fT5gO1xufVxuZnVuY3Rpb24gZ2V0Q2FzZXNPdXRzaWRlQ2hhckNsYXNzUmFuZ2Uobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBmaXJzdE9ubHkgPSAhIW9wdGlvbnM/LmZpcnN0T25seTtcbiAgY29uc3QgbWluID0gbm9kZS5taW4udmFsdWU7XG4gIGNvbnN0IG1heCA9IG5vZGUubWF4LnZhbHVlO1xuICBjb25zdCBmb3VuZCA9IFtdO1xuICBpZiAobWluIDwgNjUgJiYgKG1heCA9PT0gNjU1MzUgfHwgbWF4ID49IDEzMTA3MSkgfHwgbWluID09PSA2NTUzNiAmJiBtYXggPj0gMTMxMDcxKSB7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGZvciAobGV0IGkgPSBtaW47IGkgPD0gbWF4OyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gY3AoaSk7XG4gICAgaWYgKCFjaGFySGFzQ2FzZShjaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzT3V0c2lkZVJhbmdlID0gZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMoY2hhcikuZmlsdGVyKChjYXNlT2ZDaGFyKSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBjYXNlT2ZDaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgcmV0dXJuIG51bSA8IG1pbiB8fCBudW0gPiBtYXg7XG4gICAgfSk7XG4gICAgaWYgKGNoYXJzT3V0c2lkZVJhbmdlLmxlbmd0aCkge1xuICAgICAgZm91bmQucHVzaCguLi5jaGFyc091dHNpZGVSYW5nZSk7XG4gICAgICBpZiAoZmlyc3RPbmx5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBnZXRDaGFyRXNjYXBlKGNvZGVQb2ludCwgeyBpc0FmdGVyQmFja3JlZiwgaW5DaGFyQ2xhc3MsIHVzZUZsYWdWIH0pIHtcbiAgaWYgKENoYXJDb2RlRXNjYXBlTWFwLmhhcyhjb2RlUG9pbnQpKSB7XG4gICAgcmV0dXJuIENoYXJDb2RlRXNjYXBlTWFwLmdldChjb2RlUG9pbnQpO1xuICB9XG4gIGlmIChcbiAgICAvLyBDb250cm9sIGNoYXJzLCBldGMuOyBjb25kaXRpb24gbW9kZWxlZCBvbiB0aGUgQ2hyb21lIGRldmVsb3BlciBjb25zb2xlJ3MgZGlzcGxheSBmb3Igc3RyaW5nc1xuICAgIGNvZGVQb2ludCA8IDMyIHx8IGNvZGVQb2ludCA+IDEyNiAmJiBjb2RlUG9pbnQgPCAxNjAgfHwgLy8gVW5pY29kZSBwbGFuZXMgNC0xNjsgdW5hc3NpZ25lZCwgc3BlY2lhbCBwdXJwb3NlLCBhbmQgcHJpdmF0ZSB1c2UgYXJlYVxuICAgIGNvZGVQb2ludCA+IDI2MjE0MyB8fCAvLyBBdm9pZCBjb3JydXB0aW5nIGEgcHJlY2VkaW5nIGJhY2tyZWYgYnkgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGl0IHdpdGggYSBsaXRlcmFsIGRpZ2l0XG4gICAgaXNBZnRlckJhY2tyZWYgJiYgaXNEaWdpdENoYXJDb2RlKGNvZGVQb2ludClcbiAgKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludCA+IDI1NSA/IGBcXFxcdXske2NvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX19YCA6IGBcXFxceCR7Y29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xuICB9XG4gIGNvbnN0IGVzY2FwZUNoYXJzID0gaW5DaGFyQ2xhc3MgPyB1c2VGbGFnViA/IENoYXJDbGFzc0VzY2FwZUNoYXJzRmxhZ1YgOiBDaGFyQ2xhc3NFc2NhcGVDaGFycyA6IEJhc2VFc2NhcGVDaGFycztcbiAgY29uc3QgY2hhciA9IGNwKGNvZGVQb2ludCk7XG4gIHJldHVybiAoZXNjYXBlQ2hhcnMuaGFzKGNoYXIpID8gXCJcXFxcXCIgOiBcIlwiKSArIGNoYXI7XG59XG5mdW5jdGlvbiBnZXRDb2RlUG9pbnRSYW5nZXNGcm9tQ2hhcnMoY2hhcnMpIHtcbiAgY29uc3QgY29kZVBvaW50cyA9IGNoYXJzLm1hcCgoY2hhcikgPT4gY2hhci5jb2RlUG9pbnRBdCgwKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvZGVQb2ludHNbaSArIDFdID09PSBjb2RlUG9pbnRzW2ldICsgMSkge1xuICAgICAgc3RhcnQgPz89IGNvZGVQb2ludHNbaV07XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgdmFsdWVzLnB1c2goY29kZVBvaW50c1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcy5wdXNoKFtzdGFydCwgY29kZVBvaW50c1tpXV0pO1xuICAgICAgc3RhcnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0R3JvdXBQcmVmaXgoYXRvbWljMiwgZmxhZ01vZHMsIHVzZUZsYWdNb2RzKSB7XG4gIGlmIChhdG9taWMyKSB7XG4gICAgcmV0dXJuIFwiPlwiO1xuICB9XG4gIGxldCBtb2RzID0gXCJcIjtcbiAgaWYgKGZsYWdNb2RzICYmIHVzZUZsYWdNb2RzKSB7XG4gICAgY29uc3QgeyBlbmFibGUsIGRpc2FibGUgfSA9IGZsYWdNb2RzO1xuICAgIG1vZHMgPSAoZW5hYmxlPy5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChlbmFibGU/LmRvdEFsbCA/IFwic1wiIDogXCJcIikgKyAoZGlzYWJsZSA/IFwiLVwiIDogXCJcIikgKyAoZGlzYWJsZT8uaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoZGlzYWJsZT8uZG90QWxsID8gXCJzXCIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gYCR7bW9kc306YDtcbn1cbmZ1bmN0aW9uIGdldFF1YW50aWZpZXJTdHIoeyBtaW4sIG1heCwgZ3JlZWR5LCBwb3NzZXNzaXZlOiBwb3NzZXNzaXZlMiB9KSB7XG4gIGxldCBiYXNlO1xuICBpZiAoIW1pbiAmJiBtYXggPT09IDEpIHtcbiAgICBiYXNlID0gXCI/XCI7XG4gIH0gZWxzZSBpZiAoIW1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgYmFzZSA9IFwiKlwiO1xuICB9IGVsc2UgaWYgKG1pbiA9PT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgYmFzZSA9IFwiK1wiO1xuICB9IGVsc2UgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgYmFzZSA9IGB7JHttaW59fWA7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IGB7JHttaW59LCR7bWF4ID09PSBJbmZpbml0eSA/IFwiXCIgOiBtYXh9fWA7XG4gIH1cbiAgcmV0dXJuIGJhc2UgKyAocG9zc2Vzc2l2ZTIgPyBcIitcIiA6IGdyZWVkeSA/IFwiXCIgOiBcIj9cIik7XG59XG5mdW5jdGlvbiBpc0RpZ2l0Q2hhckNvZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID4gNDcgJiYgdmFsdWUgPCA1ODtcbn1cbmZ1bmN0aW9uIGlzTGl0ZXJhbEh5cGhlbih7IHR5cGUsIHZhbHVlIH0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3RlciAmJiB2YWx1ZSA9PT0gNDU7XG59XG5cbi8vIHNyYy9zdWJjbGFzcy5qc1xudmFyIEVtdWxhdGVkUmVnRXhwID0gY2xhc3MgX0VtdWxhdGVkUmVnRXhwIGV4dGVuZHMgUmVnRXhwIHtcbiAgLyoqXG4gIEB0eXBlIHtNYXA8bnVtYmVyLCB7XG4gICAgaGlkZGVuPzogdHJ1ZTtcbiAgICB0cmFuc2ZlclRvPzogbnVtYmVyO1xuICB9Pn1cbiAgKi9cbiAgI2NhcHR1cmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgQHR5cGUge1JlZ0V4cCB8IEVtdWxhdGVkUmVnRXhwIHwgbnVsbH1cbiAgKi9cbiAgI2NvbXBpbGVkID0gbnVsbDtcbiAgLyoqXG4gIEB0eXBlIHtzdHJpbmd9XG4gICovXG4gICNwYXR0ZXJuO1xuICAvKipcbiAgQHR5cGUge01hcDxudW1iZXIsIHN0cmluZz4/fVxuICAqL1xuICAjbmFtZU1hcCA9IG51bGw7XG4gIC8qKlxuICBAdHlwZSB7c3RyaW5nP31cbiAgKi9cbiAgI3N0cmF0ZWd5ID0gbnVsbDtcbiAgLyoqXG4gIENhbiBiZSB1c2VkIHRvIHNlcmlhbGl6ZSB0aGUgaW5zdGFuY2UuXG4gIEB0eXBlIHtFbXVsYXRlZFJlZ0V4cE9wdGlvbnN9XG4gICovXG4gIHJhd09wdGlvbnMgPSB7fTtcbiAgLy8gT3ZlcnJpZGUgdGhlIGdldHRlciB3aXRoIG9uZSB0aGF0IHdvcmtzIHdpdGggbGF6eS1jb21waWxlZCByZWdleGVzXG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BhdHRlcm4gfHwgXCIoPzopXCI7XG4gIH1cbiAgLyoqXG4gIEBvdmVybG9hZFxuICBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICBAcGFyYW0ge0VtdWxhdGVkUmVnRXhwT3B0aW9uc30gW29wdGlvbnNdXG4gICovXG4gIC8qKlxuICBAb3ZlcmxvYWRcbiAgQHBhcmFtIHtFbXVsYXRlZFJlZ0V4cH0gcGF0dGVyblxuICBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAqL1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBmbGFncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhenlDb21waWxlID0gISFvcHRpb25zPy5sYXp5Q29tcGlsZTtcbiAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb3ZpZGUgb3B0aW9ucyB3aGVuIGNvcHlpbmcgYSByZWdleHBcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZSA9IHBhdHRlcm47XG4gICAgICBzdXBlcihyZSwgZmxhZ3MpO1xuICAgICAgdGhpcy4jcGF0dGVybiA9IHJlLnNvdXJjZTtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIF9FbXVsYXRlZFJlZ0V4cCkge1xuICAgICAgICB0aGlzLiNjYXB0dXJlTWFwID0gcmUuI2NhcHR1cmVNYXA7XG4gICAgICAgIHRoaXMuI25hbWVNYXAgPSByZS4jbmFtZU1hcDtcbiAgICAgICAgdGhpcy4jc3RyYXRlZ3kgPSByZS4jc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMucmF3T3B0aW9ucyA9IHJlLnJhd09wdGlvbnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGhpZGRlbkNhcHR1cmVzOiBbXSxcbiAgICAgICAgc3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIHRyYW5zZmVyczogW10sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBzdXBlcihsYXp5Q29tcGlsZSA/IFwiXCIgOiBwYXR0ZXJuLCBmbGFncyk7XG4gICAgICB0aGlzLiNwYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgIHRoaXMuI2NhcHR1cmVNYXAgPSBjcmVhdGVDYXB0dXJlTWFwKG9wdHMuaGlkZGVuQ2FwdHVyZXMsIG9wdHMudHJhbnNmZXJzKTtcbiAgICAgIHRoaXMuI3N0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneTtcbiAgICAgIHRoaXMucmF3T3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG4gICAgfVxuICAgIGlmICghbGF6eUNvbXBpbGUpIHtcbiAgICAgIHRoaXMuI2NvbXBpbGVkID0gdGhpcztcbiAgICB9XG4gIH1cbiAgLyoqXG4gIENhbGxlZCBpbnRlcm5hbGx5IGJ5IGFsbCBTdHJpbmcvUmVnRXhwIG1ldGhvZHMgdGhhdCB1c2UgcmVnZXhlcy5cbiAgQG92ZXJyaWRlXG4gIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheT99XG4gICovXG4gIGV4ZWMoc3RyKSB7XG4gICAgaWYgKCF0aGlzLiNjb21waWxlZCkge1xuICAgICAgY29uc3QgeyBsYXp5Q29tcGlsZSwgLi4ucmVzdCB9ID0gdGhpcy5yYXdPcHRpb25zO1xuICAgICAgdGhpcy4jY29tcGlsZWQgPSBuZXcgX0VtdWxhdGVkUmVnRXhwKHRoaXMuI3BhdHRlcm4sIHRoaXMuZmxhZ3MsIHJlc3QpO1xuICAgIH1cbiAgICBjb25zdCB1c2VMYXN0SW5kZXggPSB0aGlzLmdsb2JhbCB8fCB0aGlzLnN0aWNreTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmxhc3RJbmRleDtcbiAgICBpZiAodGhpcy4jc3RyYXRlZ3kgPT09IFwiY2xpcF9zZWFyY2hcIiAmJiB1c2VMYXN0SW5kZXggJiYgcG9zKSB7XG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMuI2V4ZWNDb3JlKHN0ci5zbGljZShwb3MpKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBhZGp1c3RNYXRjaERldGFpbHNGb3JPZmZzZXQobWF0Y2gsIHBvcywgc3RyLCB0aGlzLmhhc0luZGljZXMpO1xuICAgICAgICB0aGlzLmxhc3RJbmRleCArPSBwb3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNleGVjQ29yZShzdHIpO1xuICB9XG4gIC8qKlxuICBBZGRzIHN1cHBvcnQgZm9yIGhpZGRlbiBhbmQgdHJhbnNmZXIgY2FwdHVyZXMuXG4gIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgQHJldHVybnNcbiAgKi9cbiAgI2V4ZWNDb3JlKHN0cikge1xuICAgIHRoaXMuI2NvbXBpbGVkLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4O1xuICAgIGNvbnN0IG1hdGNoID0gc3VwZXIuZXhlYy5jYWxsKHRoaXMuI2NvbXBpbGVkLCBzdHIpO1xuICAgIHRoaXMubGFzdEluZGV4ID0gdGhpcy4jY29tcGlsZWQubGFzdEluZGV4O1xuICAgIGlmICghbWF0Y2ggfHwgIXRoaXMuI2NhcHR1cmVNYXAuc2l6ZSkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaENvcHkgPSBbLi4ubWF0Y2hdO1xuICAgIG1hdGNoLmxlbmd0aCA9IDE7XG4gICAgbGV0IGluZGljZXNDb3B5O1xuICAgIGlmICh0aGlzLmhhc0luZGljZXMpIHtcbiAgICAgIGluZGljZXNDb3B5ID0gWy4uLm1hdGNoLmluZGljZXNdO1xuICAgICAgbWF0Y2guaW5kaWNlcy5sZW5ndGggPSAxO1xuICAgIH1cbiAgICBjb25zdCBtYXBwZWROdW1zID0gWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0Y2hDb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGhpZGRlbiwgdHJhbnNmZXJUbyB9ID0gdGhpcy4jY2FwdHVyZU1hcC5nZXQoaSkgPz8ge307XG4gICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgIG1hcHBlZE51bXMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZE51bXMucHVzaChtYXRjaC5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5wdXNoKG1hdGNoQ29weVtpXSk7XG4gICAgICAgIGlmICh0aGlzLmhhc0luZGljZXMpIHtcbiAgICAgICAgICBtYXRjaC5pbmRpY2VzLnB1c2goaW5kaWNlc0NvcHlbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmZXJUbyAmJiBtYXRjaENvcHlbaV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCB0byA9IHRocm93SWZOb3QobWFwcGVkTnVtc1t0cmFuc2ZlclRvXSk7XG4gICAgICAgIG1hdGNoW3RvXSA9IG1hdGNoQ29weVtpXTtcbiAgICAgICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgICAgIG1hdGNoLmluZGljZXNbdG9dID0gaW5kaWNlc0NvcHlbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmdyb3Vwcykge1xuICAgICAgICAgIGlmICghdGhpcy4jbmFtZU1hcCkge1xuICAgICAgICAgICAgdGhpcy4jbmFtZU1hcCA9IGNyZWF0ZU5hbWVNYXAodGhpcy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy4jbmFtZU1hcC5nZXQodHJhbnNmZXJUbyk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIG1hdGNoLmdyb3Vwc1tuYW1lXSA9IG1hdGNoQ29weVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0luZGljZXMpIHtcbiAgICAgICAgICAgICAgbWF0Y2guaW5kaWNlcy5ncm91cHNbbmFtZV0gPSBpbmRpY2VzQ29weVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9XG59O1xuZnVuY3Rpb24gYWRqdXN0TWF0Y2hEZXRhaWxzRm9yT2Zmc2V0KG1hdGNoLCBvZmZzZXQsIGlucHV0LCBoYXNJbmRpY2VzKSB7XG4gIG1hdGNoLmluZGV4ICs9IG9mZnNldDtcbiAgbWF0Y2guaW5wdXQgPSBpbnB1dDtcbiAgaWYgKGhhc0luZGljZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gbWF0Y2guaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyciA9IGluZGljZXNbaV07XG4gICAgICBpZiAoYXJyKSB7XG4gICAgICAgIGluZGljZXNbaV0gPSBbYXJyWzBdICsgb2Zmc2V0LCBhcnJbMV0gKyBvZmZzZXRdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBncm91cEluZGljZXMgPSBpbmRpY2VzLmdyb3VwcztcbiAgICBpZiAoZ3JvdXBJbmRpY2VzKSB7XG4gICAgICBPYmplY3Qua2V5cyhncm91cEluZGljZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBncm91cEluZGljZXNba2V5XTtcbiAgICAgICAgaWYgKGFycikge1xuICAgICAgICAgIGdyb3VwSW5kaWNlc1trZXldID0gW2FyclswXSArIG9mZnNldCwgYXJyWzFdICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlTWFwKGhpZGRlbkNhcHR1cmVzLCB0cmFuc2ZlcnMpIHtcbiAgY29uc3QgY2FwdHVyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbnVtIG9mIGhpZGRlbkNhcHR1cmVzKSB7XG4gICAgY2FwdHVyZU1hcC5zZXQobnVtLCB7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFt0bywgZnJvbV0gb2YgdHJhbnNmZXJzKSB7XG4gICAgZm9yIChjb25zdCBudW0gb2YgZnJvbSkge1xuICAgICAgZ2V0T3JJbnNlcnQoY2FwdHVyZU1hcCwgbnVtLCB7fSkudHJhbnNmZXJUbyA9IHRvO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FwdHVyZU1hcDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVNYXAocGF0dGVybikge1xuICBjb25zdCByZSA9IC8oPzxjYXB0dXJlPlxcKCg/OlxcPzwoPyFbPSFdKSg/PG5hbWU+W14+XSspPnwoPyFcXD8pKSl8XFxcXD8uL2dzdTtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCBudW1DYXB0dXJlcyA9IDA7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGNvbnN0IHsgMDogbSwgZ3JvdXBzOiB7IGNhcHR1cmUsIG5hbWUgfSB9ID0gbWF0Y2g7XG4gICAgaWYgKG0gPT09IFwiW1wiKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgIG51bUNhcHR1cmVzKys7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgbWFwLnNldChudW1DYXB0dXJlcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG0gPT09IFwiXVwiKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4tLTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLy8gc3JjL2luZGV4LmpzXG5pbXBvcnQgeyBhdG9taWMsIHBvc3Nlc3NpdmUgfSBmcm9tIFwicmVnZXgvaW50ZXJuYWxzXCI7XG5pbXBvcnQgeyByZWN1cnNpb24gfSBmcm9tIFwicmVnZXgtcmVjdXJzaW9uXCI7XG5mdW5jdGlvbiB0b09uaWd1cnVtYUFzdChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgZmxhZ3M6IG9wdGlvbnM/LmZsYWdzID8/IFwiXCIsXG4gICAgcnVsZXM6IHtcbiAgICAgIGNhcHR1cmVHcm91cDogZmFsc2UsXG4gICAgICBzaW5nbGVsaW5lOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnM/LnJ1bGVzXG4gICAgfVxuICB9O1xuICByZXR1cm4gcGFyc2UodG9rZW5pemUocGF0dGVybiwgb3B0cy5mbGFncywgb3B0cy5ydWxlcykpO1xufVxuZnVuY3Rpb24gdG9SZWdFeHAocGF0dGVybiwgb3B0aW9ucykge1xuICBjb25zdCBkID0gdG9SZWdFeHBEZXRhaWxzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBpZiAoZC5vcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBFbXVsYXRlZFJlZ0V4cChkLnBhdHRlcm4sIGQuZmxhZ3MsIGQub3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAoZC5wYXR0ZXJuLCBkLmZsYWdzKTtcbn1cbmZ1bmN0aW9uIHRvUmVnRXhwRGV0YWlscyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCB0b2tlbml6ZWQgPSB0b2tlbml6ZShwYXR0ZXJuLCBvcHRzLmZsYWdzLCB7XG4gICAgY2FwdHVyZUdyb3VwOiBvcHRzLnJ1bGVzLmNhcHR1cmVHcm91cCxcbiAgICBzaW5nbGVsaW5lOiBvcHRzLnJ1bGVzLnNpbmdsZWxpbmVcbiAgfSk7XG4gIGNvbnN0IG9uaWd1cnVtYUFzdCA9IHBhcnNlKHRva2VuaXplZCwge1xuICAgIHNraXBCYWNrcmVmVmFsaWRhdGlvbjogb3B0cy5ydWxlcy5hbGxvd09ycGhhbkJhY2tyZWZzLFxuICAgIHZlcmJvc2U6IG9wdHMudmVyYm9zZVxuICB9KTtcbiAgY29uc3QgcmVnZXhBc3QgPSB0cmFuc2Zvcm0ob25pZ3VydW1hQXN0LCB7XG4gICAgYWNjdXJhY3k6IG9wdHMuYWNjdXJhY3ksXG4gICAgYXNjaWlXb3JkQm91bmRhcmllczogb3B0cy5ydWxlcy5hc2NpaVdvcmRCb3VuZGFyaWVzLFxuICAgIGF2b2lkU3ViY2xhc3M6IG9wdHMuYXZvaWRTdWJjbGFzcyxcbiAgICBiZXN0RWZmb3J0VGFyZ2V0OiBvcHRzLnRhcmdldFxuICB9KTtcbiAgY29uc3QgZ2VuZXJhdGVkID0gZ2VuZXJhdGUocmVnZXhBc3QsIG9wdHMpO1xuICBjb25zdCByZWN1cnNpb25SZXN1bHQgPSByZWN1cnNpb24oZ2VuZXJhdGVkLnBhdHRlcm4sIHtcbiAgICBjYXB0dXJlVHJhbnNmZXJzOiBnZW5lcmF0ZWQuX2NhcHR1cmVUcmFuc2ZlcnMsXG4gICAgaGlkZGVuQ2FwdHVyZXM6IGdlbmVyYXRlZC5faGlkZGVuQ2FwdHVyZXMsXG4gICAgbW9kZTogXCJleHRlcm5hbFwiXG4gIH0pO1xuICBjb25zdCBwb3NzZXNzaXZlUmVzdWx0ID0gcG9zc2Vzc2l2ZShyZWN1cnNpb25SZXN1bHQucGF0dGVybik7XG4gIGNvbnN0IGF0b21pY1Jlc3VsdCA9IGF0b21pYyhwb3NzZXNzaXZlUmVzdWx0LnBhdHRlcm4sIHtcbiAgICBjYXB0dXJlVHJhbnNmZXJzOiByZWN1cnNpb25SZXN1bHQuY2FwdHVyZVRyYW5zZmVycyxcbiAgICBoaWRkZW5DYXB0dXJlczogcmVjdXJzaW9uUmVzdWx0LmhpZGRlbkNhcHR1cmVzXG4gIH0pO1xuICBjb25zdCBkZXRhaWxzID0ge1xuICAgIHBhdHRlcm46IGF0b21pY1Jlc3VsdC5wYXR0ZXJuLFxuICAgIGZsYWdzOiBgJHtvcHRzLmhhc0luZGljZXMgPyBcImRcIiA6IFwiXCJ9JHtvcHRzLmdsb2JhbCA/IFwiZ1wiIDogXCJcIn0ke2dlbmVyYXRlZC5mbGFnc30ke2dlbmVyYXRlZC5vcHRpb25zLmRpc2FibGUudiA/IFwidVwiIDogXCJ2XCJ9YFxuICB9O1xuICBpZiAob3B0cy5hdm9pZFN1YmNsYXNzKSB7XG4gICAgaWYgKG9wdHMubGF6eUNvbXBpbGVMZW5ndGggIT09IEluZmluaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXp5IGNvbXBpbGF0aW9uIHJlcXVpcmVzIHN1YmNsYXNzXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoaWRkZW5DYXB0dXJlcyA9IGF0b21pY1Jlc3VsdC5oaWRkZW5DYXB0dXJlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgY29uc3QgdHJhbnNmZXJzID0gQXJyYXkuZnJvbShhdG9taWNSZXN1bHQuY2FwdHVyZVRyYW5zZmVycyk7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSByZWdleEFzdC5fc3RyYXRlZ3k7XG4gICAgY29uc3QgbGF6eUNvbXBpbGUgPSBkZXRhaWxzLnBhdHRlcm4ubGVuZ3RoID49IG9wdHMubGF6eUNvbXBpbGVMZW5ndGg7XG4gICAgaWYgKGhpZGRlbkNhcHR1cmVzLmxlbmd0aCB8fCB0cmFuc2ZlcnMubGVuZ3RoIHx8IHN0cmF0ZWd5IHx8IGxhenlDb21waWxlKSB7XG4gICAgICBkZXRhaWxzLm9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmhpZGRlbkNhcHR1cmVzLmxlbmd0aCAmJiB7IGhpZGRlbkNhcHR1cmVzIH0sXG4gICAgICAgIC4uLnRyYW5zZmVycy5sZW5ndGggJiYgeyB0cmFuc2ZlcnMgfSxcbiAgICAgICAgLi4uc3RyYXRlZ3kgJiYgeyBzdHJhdGVneSB9LFxuICAgICAgICAuLi5sYXp5Q29tcGlsZSAmJiB7IGxhenlDb21waWxlIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXRhaWxzO1xufVxuZXhwb3J0IHtcbiAgRW11bGF0ZWRSZWdFeHAsXG4gIHRvT25pZ3VydW1hQXN0LFxuICB0b1JlZ0V4cCxcbiAgdG9SZWdFeHBEZXRhaWxzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js\n");

/***/ })

};
;