"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code@0.14.1_shiki@2.5.0";
exports.ids = ["vendor-chunks/rehype-pretty-code@0.14.1_shiki@2.5.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/rehype-pretty-code@0.14.1_shiki@2.5.0/node_modules/rehype-pretty-code/dist/index.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/rehype-pretty-code@0.14.1_shiki@2.5.0/node_modules/rehype-pretty-code/dist/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! shiki */ \"(rsc)/../node_modules/.pnpm/shiki@2.5.0/node_modules/shiki/dist/bundle-full.mjs\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/../node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/../node_modules/.pnpm/hast-util-to-string@3.0.1/node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/../node_modules/.pnpm/parse-numeric-range@1.3.0/node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unified */ \"(rsc)/../node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/../node_modules/.pnpm/rehype-parse@9.0.1/node_modules/rehype-parse/lib/index.js\");\n\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n  return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n  return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n  return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent, bypass = false) {\n  if (bypass) {\n    return false;\n  }\n  return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n  return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n  const placeholder = \"\\0\";\n  let temp = meta.replace(/\\\\\\\\/g, placeholder);\n  temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n  const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n  return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n  let meta = filter(\n    element.data?.meta ?? element.properties?.metastring ?? \"\"\n  );\n  const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n  const title = titleMatch?.[1] ?? null;\n  meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n  const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n  const caption = captionMatch?.[1] ?? null;\n  meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n  let lang = defaultFallback;\n  if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n    lang = element.properties.className[0].replace(\"language-\", \"\");\n  }\n  return {\n    title,\n    caption,\n    lang,\n    meta\n  };\n}\nfunction getThemeNames(theme) {\n  if (isJSONTheme(theme)) {\n    return [theme.name];\n  }\n  if (typeof theme === \"string\") {\n    return [theme];\n  }\n  return Object.values(theme).map(\n    (theme2) => typeof theme2 === \"string\" ? theme2 : theme2.name\n  );\n}\nfunction replaceLineClass(element) {\n  if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n    const className = element.properties.className.filter((c) => c !== \"line\");\n    element.properties.className = className.length > 0 ? className : void 0;\n    element.properties[\"data-line\"] = \"\";\n  }\n}\nfunction getLineId(lineNumber, meta) {\n  const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n  if (!segments) return null;\n  for (const segment of segments) {\n    const [range, id] = segment.split(\"#\");\n    if (!(range && id)) continue;\n    const match = range.match(/\\{(.*?)\\}/);\n    const capture = match?.[1];\n    if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__(capture).includes(lineNumber)) {\n      return id;\n    }\n  }\n  return null;\n}\n\n// src/chars/splitElement.ts\nfunction splitElement({\n  elements,\n  elementToWrap,\n  innerString,\n  rightString,\n  leftString,\n  rest,\n  nextElementContinues,\n  index,\n  ignoreChars\n}) {\n  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n    return [elementToWrap, index];\n  }\n  let newIndex = index;\n  const textElement = elementToWrap.children[0];\n  if (isText(textElement)) {\n    textElement.value = innerString;\n  }\n  let rightStr = rightString;\n  const leftStr = leftString;\n  if (rest.length > 0) {\n    rightStr += rest.map((s) => s === \"\" ? innerString : innerString + s).join(\"\");\n  }\n  if (leftStr.length > 0) {\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: leftStr }]\n    });\n  }\n  if (rightStr.length > 0 && !nextElementContinues) {\n    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: rightStr }]\n    });\n  }\n  return [elementToWrap, index + 1];\n}\nfunction nextElementMaybeContinuesChars({\n  elements,\n  nextIndex,\n  remainingPart\n}) {\n  if (remainingPart === \"\") {\n    return false;\n  }\n  const nextNode = elements[nextIndex];\n  const content = getContent(nextNode);\n  if (!content) {\n    return false;\n  }\n  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n  const overlap = findOverlap(content, remainingPart);\n  if (overlap === remainingPart && content.startsWith(remainingPart)) {\n    return true;\n  }\n  if (includesNext) {\n    return nextElementMaybeContinuesChars({\n      elements,\n      nextIndex: nextIndex + 1,\n      remainingPart: remainingPart.replace(content, \"\")\n    });\n  }\n  return false;\n}\nfunction getContent(node) {\n  if (!node) return;\n  return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(node);\n}\nfunction findOverlap(a, b) {\n  if (b.length === 0) {\n    return \"\";\n  }\n  if (a.endsWith(b)) {\n    return b;\n  }\n  if (a.indexOf(b) >= 0) {\n    return b;\n  }\n  return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n  return s.split(\"\").reverse().join(\"\");\n}\n\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n  const toWrap = [];\n  let charsSoFar = \"\";\n  if (element.children) {\n    const elements = element.children;\n    for (let i = startIndex; i < elements.length; i++) {\n      const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n      if (remaining === \"\") {\n        return toWrap;\n      }\n      const maybeElement = elements[i];\n      if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n      Object.hasOwn(\n        maybeElement.properties ?? {},\n        \"rehype-pretty-code-visited\"\n      )) {\n        continue;\n      }\n      const content = getContent(maybeElement) || \"\";\n      if (content === chars || charsSoFar + content === chars) {\n        toWrap.push({ element: maybeElement, index: i });\n        return toWrap;\n      }\n      if (chars.startsWith(charsSoFar + content)) {\n        if (nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: remaining.replace(content, \"\")\n        })) {\n          toWrap.push({ element: elements[i], index: i });\n          charsSoFar += content;\n          continue;\n        }\n      }\n      const overlap = findOverlap(content, remaining);\n      const partialMatch = overlap && remaining.startsWith(overlap);\n      if (partialMatch) {\n        const nextPart = remaining.replace(overlap, \"\");\n        if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: nextPart\n        })) {\n          continue;\n        }\n        const splitParts = content.split(overlap);\n        const [leftPart, rightPart, ...rest] = splitParts;\n        if (rightPart || leftPart || rest.length > 0) {\n          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n          const nextNodeOverlap = findOverlap(withNextNode, remaining);\n          const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n            const rightString = rightPart.replace(overlap, \"\");\n            const innerString = overlap;\n            const leftString = content.substring(0, splitIndex);\n            const nextElementContinues = nextElementMaybeContinuesChars({\n              elements,\n              nextIndex: i + 1,\n              remainingPart: nextPart\n            });\n            const [newElement, updatedIndex] = splitElement({\n              elements,\n              elementToWrap: elements[i],\n              innerString,\n              rightString,\n              leftString,\n              rest,\n              nextElementContinues,\n              index: i,\n              ignoreChars\n            });\n            charsSoFar += overlap;\n            toWrap.push({\n              element: newElement,\n              index: updatedIndex\n            });\n          }\n        }\n      }\n    }\n  }\n  return toWrap;\n}\n\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n  if (!elementsToWrap || elementsToWrap.length === 0) {\n    return;\n  }\n  const [{ element }] = elementsToWrap;\n  if (ignoreWord) {\n    if (element.properties) {\n      element.properties[\"rehype-pretty-code-visited\"] = \"\";\n    }\n    return;\n  }\n  if (elementsToWrap.length > 1) {\n    parentElement.children.splice(\n      elementsToWrap[0].index,\n      elementsToWrap.length,\n      {\n        type: \"element\",\n        tagName: \"mark\",\n        properties: { \"data-highlighted-chars-mark\": \"\" },\n        children: elementsToWrap.map(({ element: element3 }) => element3)\n      }\n    );\n    const element2 = parentElement.children[elementsToWrap[0].index];\n    if (!isElement(element2)) {\n      return;\n    }\n    const wordStr = element2.children.reduce((acc, node) => {\n      const textElement = isElement(node) ? node.children[0] : null;\n      if (isText(textElement)) {\n        return acc + textElement.value;\n      }\n      return acc;\n    }, \"\");\n    const id = options.idsMap.get(wordStr);\n    element2.properties = element2.properties || {};\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    onVisitHighlightedChars?.(element2, id);\n  } else {\n    const [{ element: element2 }] = elementsToWrap;\n    const textElement = element2.children[0];\n    if (!isText(textElement)) {\n      return;\n    }\n    const id = options.idsMap.get(textElement.value);\n    element2.properties = element2.properties || {};\n    element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    element2.children = [\n      {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          style: element2.properties.style\n        },\n        children: element2.children\n      }\n    ];\n    element2.properties.style = void 0;\n    onVisitHighlightedChars?.(element2, id);\n  }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n  const { ranges = [] } = options;\n  const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(element);\n  charsList.forEach((chars, index) => {\n    if (chars && textContent?.includes(chars)) {\n      let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(element);\n      let startIndex = 0;\n      while (textContent2.includes(chars)) {\n        const currentCharsRange = ranges[index] || [];\n        const id = `${chars}-${index}`;\n        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n        const elementsToWrap = getElementsToHighlight(\n          element,\n          chars,\n          startIndex,\n          ignoreChars\n        );\n        if (elementsToWrap.length === 0) break;\n        wrapHighlightedChars(\n          element,\n          elementsToWrap,\n          options,\n          ignoreChars,\n          onVisitHighlightedChars\n        );\n        startIndex = Math.max(\n          elementsToWrap[elementsToWrap.length - 1].index - 2,\n          0\n        );\n        textContent2 = element.children.map((childNode) => {\n          const props = isElement(childNode) ? childNode.properties : {};\n          if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n            return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(childNode);\n          }\n        }).join(\"\");\n      }\n    }\n  });\n  element.children.forEach((childNode) => {\n    if (!isElement(childNode)) return;\n    if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n      childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n    }\n  });\n}\n\n// src/index.ts\nfunction apply(element, {\n  tree,\n  lang,\n  title,\n  caption,\n  inline = false,\n  keepBackground = true,\n  grid = true,\n  lineNumbersMaxDigits = 1,\n  theme,\n  onVisitTitle,\n  onVisitCaption\n}) {\n  element.tagName = inline ? \"span\" : \"figure\";\n  element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n  const codeData = element.children[0]?.data;\n  element.children = [tree].flatMap((tree2) => {\n    const pre = tree2.children[0];\n    const themeNames = getThemeNames(theme);\n    const themeNamesString = themeNames.join(\" \");\n    if (!(isElement(pre) && pre.properties)) {\n      return [];\n    }\n    const code = pre.children[0];\n    if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n      const className = pre.properties.className.filter(\n        (c) => c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true)\n      );\n      pre.properties.className = className.length > 0 ? className : void 0;\n    }\n    if (!keepBackground) {\n      pre.properties.style = void 0;\n    }\n    pre.properties[\"data-language\"] = lang;\n    pre.properties[\"data-theme\"] = themeNamesString;\n    if (!(isElement(code) && code.properties)) {\n      return [];\n    }\n    code.properties[\"data-language\"] = lang;\n    code.properties[\"data-theme\"] = themeNamesString;\n    code.data = codeData;\n    if (inline) {\n      if (keepBackground) {\n        code.properties.style = pre.properties.style;\n      }\n      return code;\n    }\n    if (grid) {\n      if (code.properties.style) {\n        code.properties.style += \"display: grid;\";\n      } else {\n        code.properties.style = \"display: grid;\";\n      }\n    }\n    if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n      code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n    }\n    const fragments = [];\n    if (title) {\n      const elementContent = {\n        type: \"element\",\n        tagName: caption ? \"div\" : \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-title\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: title }]\n      };\n      onVisitTitle?.(elementContent);\n      fragments.push(elementContent);\n    }\n    fragments.push(pre);\n    if (caption) {\n      const elementContent = {\n        type: \"element\",\n        tagName: \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-caption\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: caption }]\n      };\n      onVisitCaption?.(elementContent);\n      fragments.push(elementContent);\n    }\n    return fragments;\n  });\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_2__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { fragment: true });\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n  const {\n    grid = true,\n    theme = \"github-dark-dimmed\",\n    keepBackground = true,\n    bypassInlineCode = false,\n    defaultLang = \"\",\n    tokensMap = {},\n    filterMetaString = (v) => v,\n    getHighlighter = shiki__WEBPACK_IMPORTED_MODULE_4__.getSingletonHighlighter,\n    transformers,\n    onVisitLine,\n    onVisitHighlightedLine,\n    onVisitHighlightedChars,\n    onVisitTitle,\n    onVisitCaption\n  } = options;\n  const key = JSON.stringify(theme);\n  let cachedHighlighter = globalHighlighterCache.get(key);\n  if (!cachedHighlighter) {\n    cachedHighlighter = getHighlighter({\n      themes: isJSONTheme(theme) || typeof theme === \"string\" ? [theme] : Object.values(theme),\n      langs: [\"plaintext\"]\n    });\n    globalHighlighterCache.set(key, cachedHighlighter);\n  }\n  const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n  const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n  function getOptions(lang, meta) {\n    const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n    const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n    return {\n      lang,\n      meta: { __raw: meta },\n      transformers,\n      defaultColor: typeof theme === \"string\" ? theme : false,\n      ...multipleThemes ? { themes: multipleThemes } : { theme: singleTheme }\n    };\n  }\n  return async (tree) => {\n    const langsToLoad = /* @__PURE__ */ new Set();\n    const highlighter = await cachedHighlighter;\n    if (!highlighter) return;\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent, bypassInlineCode)) {\n        const textElement = element.children[0];\n        if (!isText(textElement)) return;\n        const value = textElement.value;\n        if (!value) return;\n        const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n        if (lang && lang[0] !== \".\") {\n          langsToLoad.add(lang);\n        }\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement)) return;\n        const { lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (lang) {\n          langsToLoad.add(lang);\n        }\n      }\n    });\n    try {\n      await Promise.allSettled(\n        Array.from(langsToLoad).map((lang) => {\n          try {\n            return highlighter.loadLanguage(\n              lang\n            );\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        })\n      );\n    } catch (e) {\n      console.error(e);\n    }\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent, bypassInlineCode)) {\n        const textElement = element.children[0];\n        if (!isText(textElement)) return;\n        const value = textElement.value;\n        if (!value) return;\n        const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n        const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n        textElement.value = strippedValue;\n        const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n        const isLang = lang[0] !== \".\";\n        if (!lang) return;\n        let codeTree;\n        if (isLang) {\n          try {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(lang))\n            );\n          } catch {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\"))\n            );\n          }\n        } else {\n          const themeNames = getThemeNames(theme);\n          const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n          const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n          const colorsByTheme = themeNames.map(\n            (name) => name ? highlighter.getTheme(name).settings.find(\n              ({ scope }) => scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1))\n            )?.settings.foreground ?? \"inherit\" : \"inherit\"\n          );\n          if (isMultiTheme && themeKeys) {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"${themeKeys.map((key2, i) => `--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`\n            );\n          } else {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`\n            );\n          }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n        apply(element, {\n          tree: codeTree,\n          lang: isLang ? lang : \".token\",\n          inline: true,\n          keepBackground,\n          theme\n        });\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement)) return;\n        const textElement = codeElement.children[0];\n        const { title, caption, meta, lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (!lang || lang === \"math\") return;\n        const lineNumbers = [];\n        if (meta) {\n          const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n          for (const match of matches) {\n            if (match[1]) {\n              lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__(match[1]));\n            }\n          }\n        }\n        let lineNumbersMaxDigits = 0;\n        const lineIdMap = /* @__PURE__ */ new Map();\n        const charsList = [];\n        const charsListNumbers = [];\n        const charsListIdMap = /* @__PURE__ */ new Map();\n        const charsMatches = meta ? [\n          ...meta.matchAll(\n            /(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g\n          )\n        ] : void 0;\n        lineNumbers.forEach((lineNumber) => {\n          const id = getLineId(lineNumber, meta);\n          id && lineIdMap.set(lineNumber, id);\n        });\n        if (Array.isArray(charsMatches)) {\n          charsMatches.forEach((name) => {\n            const { chars, charsIdAndOrRange } = name.groups;\n            charsList.push(chars);\n            if (charsIdAndOrRange === \"\") {\n              charsListNumbers.push([]);\n            } else {\n              const [range, id] = charsIdAndOrRange.split(\"#\");\n              range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__(range));\n              id && charsListIdMap.set(chars, id);\n            }\n          });\n        }\n        if (!isText(textElement)) return;\n        const strippedValue = textElement.value.replace(/\\n$/, \"\");\n        let codeTree;\n        try {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(strippedValue, getOptions(lang, meta))\n          );\n        } catch {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(\n              strippedValue,\n              getOptions(\"plaintext\", meta)\n            )\n          );\n        }\n        let lineCounter = 0;\n        const charsHighlighterOptions = {\n          ranges: charsListNumbers,\n          idsMap: charsListIdMap,\n          counterMap: /* @__PURE__ */ new Map()\n        };\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2) => {\n          if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n            if (element2.properties) {\n              element2.properties[\"data-line-numbers\"] = \"\";\n            }\n            const lineNumbersStartAtMatch = reverseString(meta).match(\n              /(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/\n            );\n            const startNumberString = lineNumbersStartAtMatch?.[1];\n            if (startNumberString) {\n              const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n              lineNumbersMaxDigits = startAt;\n              if (element2.properties) {\n                element2.properties.style = `counter-set: line ${startAt};`;\n              }\n            }\n          }\n          if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n            if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(element2) === \"\") {\n              element2.children = [{ type: \"text\", value: \" \" }];\n            }\n            replaceLineClass(element2);\n            onVisitLine?.(element2);\n            lineCounter++;\n            if (lineNumbers.includes(lineCounter)) {\n              element2.properties[\"data-highlighted-line\"] = \"\";\n              const lineId = lineIdMap.get(lineCounter);\n              if (lineId) {\n                element2.properties[\"data-highlighted-line-id\"] = lineId;\n              }\n              onVisitHighlightedLine?.(element2, lineId);\n            }\n            charsHighlighter(\n              element2,\n              charsList,\n              charsHighlighterOptions,\n              onVisitHighlightedChars\n            );\n            lineNumbersMaxDigits++;\n          }\n        });\n        apply(element, {\n          tree: codeTree,\n          lang,\n          title,\n          caption,\n          keepBackground,\n          grid,\n          lineNumbersMaxDigits,\n          theme,\n          onVisitTitle,\n          onVisitCaption\n        });\n      }\n    });\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlaHlwZS1wcmV0dHktY29kZUAwLjE0LjFfc2hpa2lAMi41LjAvbm9kZV9tb2R1bGVzL3JlaHlwZS1wcmV0dHktY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ1A7QUFDTTtBQUNBO0FBQ2I7QUFDSzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4Qyw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQSxtQkFBbUIsZ0RBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRCxtQkFBbUIsOEJBQThCO0FBQ2pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRCxtQkFBbUIsK0JBQStCO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkRBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pELHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLHNCQUFzQiw2REFBUTtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCLDZEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLEdBQUcsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFRO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsUUFBUTtBQUNSLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQU8sT0FBTyxvREFBVyxJQUFJLGdCQUFnQjtBQUM5RDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUIsMERBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1REFBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJLHVEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDLGdFQUFnRSxhQUFhLDZCQUE2QixhQUFhO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQ0FBc0MsS0FBSyxHQUFHLGlCQUFpQixVQUFVLEdBQUcsSUFBSSxjQUFjO0FBQ3ZJO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsK0NBQStDLGlCQUFpQixJQUFJLGNBQWM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNkNBQTZDLGdEQUFZO0FBQ3pEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQVE7QUFDaEMscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFb0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL3JlaHlwZS1wcmV0dHktY29kZUAwLjE0LjFfc2hpa2lAMi41LjAvbm9kZV9tb2R1bGVzL3JlaHlwZS1wcmV0dHktY29kZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyIH0gZnJvbSAnc2hpa2knO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0JztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnaGFzdC11dGlsLXRvLXN0cmluZyc7XG5pbXBvcnQgcmFuZ2VQYXJzZXIyIGZyb20gJ3BhcnNlLW51bWVyaWMtcmFuZ2UnO1xuaW1wb3J0IHsgdW5pZmllZCB9IGZyb20gJ3VuaWZpZWQnO1xuaW1wb3J0IHJlaHlwZVBhcnNlIGZyb20gJ3JlaHlwZS1wYXJzZSc7XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gaXNKU09OVGhlbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ0b2tlbkNvbG9yc1wiKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09IFwiZWxlbWVudFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUudHlwZSA9PT0gXCJ0ZXh0XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQsIGJ5cGFzcyA9IGZhbHNlKSB7XG4gIGlmIChieXBhc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJjb2RlXCIgJiYgaXNFbGVtZW50KHBhcmVudCkgJiYgcGFyZW50LnRhZ05hbWUgIT09IFwicHJlXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcImlubGluZUNvZGVcIjtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tDb2RlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJwcmVcIiAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQuY2hpbGRyZW4pICYmIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGlzRWxlbWVudChlbGVtZW50LmNoaWxkcmVuWzBdKSAmJiBlbGVtZW50LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09IFwiY29kZVwiO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lQ29kZUxhbmcobWV0YSwgZGVmYXVsdEZhbGxiYWNrTGFuZykge1xuICBjb25zdCBwbGFjZWhvbGRlciA9IFwiXFwwXCI7XG4gIGxldCB0ZW1wID0gbWV0YS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBwbGFjZWhvbGRlcik7XG4gIHRlbXAgPSB0ZW1wLnJlcGxhY2UoL1xcXFwoezpbYS16QS1aLi1dK30pJC8sIFwiJDFcIik7XG4gIGNvbnN0IGxhbmcgPSB0ZW1wLm1hdGNoKC97OihbYS16QS1aLi1dKyl9JC8pPy5bMV07XG4gIHJldHVybiBsYW5nPy5yZXBsYWNlKG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsIFwiZ1wiKSwgXCJcXFxcXCIpIHx8IGRlZmF1bHRGYWxsYmFja0xhbmc7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrTWV0YVN0cmluZyhlbGVtZW50LCBmaWx0ZXIsIGRlZmF1bHRGYWxsYmFjaykge1xuICBsZXQgbWV0YSA9IGZpbHRlcihcbiAgICBlbGVtZW50LmRhdGE/Lm1ldGEgPz8gZWxlbWVudC5wcm9wZXJ0aWVzPy5tZXRhc3RyaW5nID8/IFwiXCJcbiAgKTtcbiAgY29uc3QgdGl0bGVNYXRjaCA9IG1ldGEubWF0Y2goL3RpdGxlPVwiKFteXCJdKilcIi8pO1xuICBjb25zdCB0aXRsZSA9IHRpdGxlTWF0Y2g/LlsxXSA/PyBudWxsO1xuICBtZXRhID0gbWV0YS5yZXBsYWNlKHRpdGxlTWF0Y2g/LlswXSA/PyBcIlwiLCBcIlwiKTtcbiAgY29uc3QgY2FwdGlvbk1hdGNoID0gbWV0YS5tYXRjaCgvY2FwdGlvbj1cIihbXlwiXSopXCIvKTtcbiAgY29uc3QgY2FwdGlvbiA9IGNhcHRpb25NYXRjaD8uWzFdID8/IG51bGw7XG4gIG1ldGEgPSBtZXRhLnJlcGxhY2UoY2FwdGlvbk1hdGNoPy5bMF0gPz8gXCJcIiwgXCJcIik7XG4gIGxldCBsYW5nID0gZGVmYXVsdEZhbGxiYWNrO1xuICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkoZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgJiYgdHlwZW9mIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0gPT09IFwic3RyaW5nXCIgJiYgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXS5zdGFydHNXaXRoKFwibGFuZ3VhZ2UtXCIpKSB7XG4gICAgbGFuZyA9IGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0ucmVwbGFjZShcImxhbmd1YWdlLVwiLCBcIlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRpdGxlLFxuICAgIGNhcHRpb24sXG4gICAgbGFuZyxcbiAgICBtZXRhXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaGVtZU5hbWVzKHRoZW1lKSB7XG4gIGlmIChpc0pTT05UaGVtZSh0aGVtZSkpIHtcbiAgICByZXR1cm4gW3RoZW1lLm5hbWVdO1xuICB9XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3RoZW1lXTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGVtZSkubWFwKFxuICAgICh0aGVtZTIpID0+IHR5cGVvZiB0aGVtZTIgPT09IFwic3RyaW5nXCIgPyB0aGVtZTIgOiB0aGVtZTIubmFtZVxuICApO1xufVxuZnVuY3Rpb24gcmVwbGFjZUxpbmVDbGFzcyhlbGVtZW50KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQucHJvcGVydGllcz8uY2xhc3NOYW1lKSAmJiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKFwibGluZVwiKSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUuZmlsdGVyKChjKSA9PiBjICE9PSBcImxpbmVcIik7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS5sZW5ndGggPiAwID8gY2xhc3NOYW1lIDogdm9pZCAwO1xuICAgIGVsZW1lbnQucHJvcGVydGllc1tcImRhdGEtbGluZVwiXSA9IFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExpbmVJZChsaW5lTnVtYmVyLCBtZXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbWV0YS5tYXRjaCgvXFx7W159XStcXH0jW2EtekEtWjAtOV0rL2cpO1xuICBpZiAoIXNlZ21lbnRzKSByZXR1cm4gbnVsbDtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgW3JhbmdlLCBpZF0gPSBzZWdtZW50LnNwbGl0KFwiI1wiKTtcbiAgICBpZiAoIShyYW5nZSAmJiBpZCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1hdGNoID0gcmFuZ2UubWF0Y2goL1xceyguKj8pXFx9Lyk7XG4gICAgY29uc3QgY2FwdHVyZSA9IG1hdGNoPy5bMV07XG4gICAgaWYgKGNhcHR1cmUgJiYgcmFuZ2VQYXJzZXIyKGNhcHR1cmUpLmluY2x1ZGVzKGxpbmVOdW1iZXIpKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvY2hhcnMvc3BsaXRFbGVtZW50LnRzXG5mdW5jdGlvbiBzcGxpdEVsZW1lbnQoe1xuICBlbGVtZW50cyxcbiAgZWxlbWVudFRvV3JhcCxcbiAgaW5uZXJTdHJpbmcsXG4gIHJpZ2h0U3RyaW5nLFxuICBsZWZ0U3RyaW5nLFxuICByZXN0LFxuICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgaW5kZXgsXG4gIGlnbm9yZUNoYXJzXG59KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudFRvV3JhcCkgJiYgZWxlbWVudFRvV3JhcC5jaGlsZHJlbj8uWzBdPy50eXBlICE9PSBcInRleHRcIiB8fCBpZ25vcmVDaGFycykge1xuICAgIHJldHVybiBbZWxlbWVudFRvV3JhcCwgaW5kZXhdO1xuICB9XG4gIGxldCBuZXdJbmRleCA9IGluZGV4O1xuICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnRUb1dyYXAuY2hpbGRyZW5bMF07XG4gIGlmIChpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgdGV4dEVsZW1lbnQudmFsdWUgPSBpbm5lclN0cmluZztcbiAgfVxuICBsZXQgcmlnaHRTdHIgPSByaWdodFN0cmluZztcbiAgY29uc3QgbGVmdFN0ciA9IGxlZnRTdHJpbmc7XG4gIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICByaWdodFN0ciArPSByZXN0Lm1hcCgocykgPT4gcyA9PT0gXCJcIiA/IGlubmVyU3RyaW5nIDogaW5uZXJTdHJpbmcgKyBzKS5qb2luKFwiXCIpO1xuICB9XG4gIGlmIChsZWZ0U3RyLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7IC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllcyB9LFxuICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogbGVmdFN0ciB9XVxuICAgIH0pO1xuICB9XG4gIGlmIChyaWdodFN0ci5sZW5ndGggPiAwICYmICFuZXh0RWxlbWVudENvbnRpbnVlcykge1xuICAgIG5ld0luZGV4ID0gbGVmdFN0ci5sZW5ndGggPiAwID8gbmV3SW5kZXggKyAyIDogbmV3SW5kZXggKyAxO1xuICAgIGVsZW1lbnRzLnNwbGljZShuZXdJbmRleCwgMCwge1xuICAgICAgLi4uZWxlbWVudFRvV3JhcCxcbiAgICAgIHByb3BlcnRpZXM6IHsgLi4uZWxlbWVudFRvV3JhcC5wcm9wZXJ0aWVzIH0sXG4gICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiByaWdodFN0ciB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBbZWxlbWVudFRvV3JhcCwgaW5kZXggKyAxXTtcbn1cbmZ1bmN0aW9uIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gIGVsZW1lbnRzLFxuICBuZXh0SW5kZXgsXG4gIHJlbWFpbmluZ1BhcnRcbn0pIHtcbiAgaWYgKHJlbWFpbmluZ1BhcnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbmV4dE5vZGUgPSBlbGVtZW50c1tuZXh0SW5kZXhdO1xuICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudChuZXh0Tm9kZSk7XG4gIGlmICghY29udGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpbmNsdWRlc05leHQgPSBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkgfHwgcmVtYWluaW5nUGFydC5zdGFydHNXaXRoKGNvbnRlbnQpO1xuICBjb25zdCBvdmVybGFwID0gZmluZE92ZXJsYXAoY29udGVudCwgcmVtYWluaW5nUGFydCk7XG4gIGlmIChvdmVybGFwID09PSByZW1haW5pbmdQYXJ0ICYmIGNvbnRlbnQuc3RhcnRzV2l0aChyZW1haW5pbmdQYXJ0KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbmNsdWRlc05leHQpIHtcbiAgICByZXR1cm4gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbmV4dEluZGV4OiBuZXh0SW5kZXggKyAxLFxuICAgICAgcmVtYWluaW5nUGFydDogcmVtYWluaW5nUGFydC5yZXBsYWNlKGNvbnRlbnQsIFwiXCIpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudChub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICByZXR1cm4gdG9TdHJpbmcobm9kZSk7XG59XG5mdW5jdGlvbiBmaW5kT3ZlcmxhcChhLCBiKSB7XG4gIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChhLmVuZHNXaXRoKGIpKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGEuaW5kZXhPZihiKSA+PSAwKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIGZpbmRPdmVybGFwKGEsIGIuc3Vic3RyaW5nKDAsIGIubGVuZ3RoIC0gMSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY2hhcnMvZ2V0RWxlbWVudHNUb0hpZ2hsaWdodC50c1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChlbGVtZW50LCBjaGFycywgc3RhcnRJbmRleCA9IDAsIGlnbm9yZUNoYXJzID0gZmFsc2UpIHtcbiAgY29uc3QgdG9XcmFwID0gW107XG4gIGxldCBjaGFyc1NvRmFyID0gXCJcIjtcbiAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gY2hhcnNTb0ZhciA/IGNoYXJzLnJlcGxhY2UoY2hhcnNTb0ZhciwgXCJcIikgOiBjaGFycztcbiAgICAgIGlmIChyZW1haW5pbmcgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlRWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKCFtYXliZUVsZW1lbnQgfHwgbWF5YmVFbGVtZW50LnR5cGUgIT09IFwiZWxlbWVudFwiIHx8IC8vIGlnbm9yZSBhbnkgcHJldmlvdXNseSBtYXRjaGVkIGNoYXJzIHdpdGhpblxuICAgICAgT2JqZWN0Lmhhc093bihcbiAgICAgICAgbWF5YmVFbGVtZW50LnByb3BlcnRpZXMgPz8ge30sXG4gICAgICAgIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIlxuICAgICAgKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KG1heWJlRWxlbWVudCkgfHwgXCJcIjtcbiAgICAgIGlmIChjb250ZW50ID09PSBjaGFycyB8fCBjaGFyc1NvRmFyICsgY29udGVudCA9PT0gY2hhcnMpIHtcbiAgICAgICAgdG9XcmFwLnB1c2goeyBlbGVtZW50OiBtYXliZUVsZW1lbnQsIGluZGV4OiBpIH0pO1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJzLnN0YXJ0c1dpdGgoY2hhcnNTb0ZhciArIGNvbnRlbnQpKSB7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogcmVtYWluaW5nLnJlcGxhY2UoY29udGVudCwgXCJcIilcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0b1dyYXAucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnRzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgICBjaGFyc1NvRmFyICs9IGNvbnRlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBmaW5kT3ZlcmxhcChjb250ZW50LCByZW1haW5pbmcpO1xuICAgICAgY29uc3QgcGFydGlhbE1hdGNoID0gb3ZlcmxhcCAmJiByZW1haW5pbmcuc3RhcnRzV2l0aChvdmVybGFwKTtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV4dFBhcnQgPSByZW1haW5pbmcucmVwbGFjZShvdmVybGFwLCBcIlwiKTtcbiAgICAgICAgaWYgKG5leHRQYXJ0ICE9PSBcIlwiICYmIGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSAmJiAhbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IG5leHRQYXJ0XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BsaXRQYXJ0cyA9IGNvbnRlbnQuc3BsaXQob3ZlcmxhcCk7XG4gICAgICAgIGNvbnN0IFtsZWZ0UGFydCwgcmlnaHRQYXJ0LCAuLi5yZXN0XSA9IHNwbGl0UGFydHM7XG4gICAgICAgIGlmIChyaWdodFBhcnQgfHwgbGVmdFBhcnQgfHwgcmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgd2l0aE5leHROb2RlID0gY29udGVudCArIChnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgPyBnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgOiBcIlwiKTtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZU92ZXJsYXAgPSBmaW5kT3ZlcmxhcCh3aXRoTmV4dE5vZGUsIHJlbWFpbmluZyk7XG4gICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHdpdGhOZXh0Tm9kZS5pbmRleE9mKG5leHROb2RlT3ZlcmxhcCk7XG4gICAgICAgICAgaWYgKGNoYXJzLmVuZHNXaXRoKG92ZXJsYXApIHx8IGNoYXJzLnN0YXJ0c1dpdGgob3ZlcmxhcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RyaW5nID0gcmlnaHRQYXJ0LnJlcGxhY2Uob3ZlcmxhcCwgXCJcIik7XG4gICAgICAgICAgICBjb25zdCBpbm5lclN0cmluZyA9IG92ZXJsYXA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0U3RyaW5nID0gY29udGVudC5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RWxlbWVudENvbnRpbnVlcyA9IG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbbmV3RWxlbWVudCwgdXBkYXRlZEluZGV4XSA9IHNwbGl0RWxlbWVudCh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBlbGVtZW50VG9XcmFwOiBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgaW5uZXJTdHJpbmcsXG4gICAgICAgICAgICAgIHJpZ2h0U3RyaW5nLFxuICAgICAgICAgICAgICBsZWZ0U3RyaW5nLFxuICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoYXJzU29GYXIgKz0gb3ZlcmxhcDtcbiAgICAgICAgICAgIHRvV3JhcC5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcbiAgICAgICAgICAgICAgaW5kZXg6IHVwZGF0ZWRJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1dyYXA7XG59XG5cbi8vIHNyYy9jaGFycy93cmFwSGlnaGxpZ2h0ZWRDaGFycy50c1xuZnVuY3Rpb24gd3JhcEhpZ2hsaWdodGVkQ2hhcnMocGFyZW50RWxlbWVudCwgZWxlbWVudHNUb1dyYXAsIG9wdGlvbnMsIGlnbm9yZVdvcmQsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGlmICghZWxlbWVudHNUb1dyYXAgfHwgZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt7IGVsZW1lbnQgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgaWYgKGlnbm9yZVdvcmQpIHtcbiAgICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzKSB7XG4gICAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID4gMSkge1xuICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgZWxlbWVudHNUb1dyYXBbMF0uaW5kZXgsXG4gICAgICBlbGVtZW50c1RvV3JhcC5sZW5ndGgsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcIm1hcmtcIixcbiAgICAgICAgcHJvcGVydGllczogeyBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiOiBcIlwiIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50c1RvV3JhcC5tYXAoKHsgZWxlbWVudDogZWxlbWVudDMgfSkgPT4gZWxlbWVudDMpXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBlbGVtZW50MiA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudHNUb1dyYXBbMF0uaW5kZXhdO1xuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3b3JkU3RyID0gZWxlbWVudDIuY2hpbGRyZW4ucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gaXNFbGVtZW50KG5vZGUpID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWNjICsgdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFwiXCIpO1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZHNNYXAuZ2V0KHdvcmRTdHIpO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMgPSBlbGVtZW50Mi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1jaGFycy1pZFwiXSA9IGlkO1xuICAgIGVsZW1lbnQyLnRhZ05hbWUgPSBcIm1hcmtcIjtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3sgZWxlbWVudDogZWxlbWVudDIgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQyLmNoaWxkcmVuWzBdO1xuICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh0ZXh0RWxlbWVudC52YWx1ZSk7XG4gICAgZWxlbWVudDIucHJvcGVydGllcyA9IGVsZW1lbnQyLnByb3BlcnRpZXMgfHwge307XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1jaGFyc1wiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtY2hhcnMtaWRcIl0gPSBpZDtcbiAgICBlbGVtZW50Mi50YWdOYW1lID0gXCJtYXJrXCI7XG4gICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHN0eWxlOiBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50Mi5jaGlsZHJlblxuICAgICAgfVxuICAgIF07XG4gICAgZWxlbWVudDIucHJvcGVydGllcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYXJzSGlnaGxpZ2h0ZXIoZWxlbWVudCwgY2hhcnNMaXN0LCBvcHRpb25zLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBjb25zdCB7IHJhbmdlcyA9IFtdIH0gPSBvcHRpb25zO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRvU3RyaW5nKGVsZW1lbnQpO1xuICBjaGFyc0xpc3QuZm9yRWFjaCgoY2hhcnMsIGluZGV4KSA9PiB7XG4gICAgaWYgKGNoYXJzICYmIHRleHRDb250ZW50Py5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgIGxldCB0ZXh0Q29udGVudDIgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0ZXh0Q29udGVudDIuaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFyc1JhbmdlID0gcmFuZ2VzW2luZGV4XSB8fCBbXTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHtjaGFyc30tJHtpbmRleH1gO1xuICAgICAgICBvcHRpb25zLmNvdW50ZXJNYXAuc2V0KGlkLCAob3B0aW9ucy5jb3VudGVyTWFwLmdldChpZCkgfHwgMCkgKyAxKTtcbiAgICAgICAgY29uc3QgaWdub3JlQ2hhcnMgPSBjdXJyZW50Q2hhcnNSYW5nZS5sZW5ndGggPiAwICYmICFjdXJyZW50Q2hhcnNSYW5nZS5pbmNsdWRlcyhvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSA/PyAtMSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzVG9XcmFwID0gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGNoYXJzLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgaWdub3JlQ2hhcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHdyYXBIaWdobGlnaHRlZENoYXJzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgZWxlbWVudHNUb1dyYXAsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpZ25vcmVDaGFycyxcbiAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFyc1xuICAgICAgICApO1xuICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoXG4gICAgICAgICAgZWxlbWVudHNUb1dyYXBbZWxlbWVudHNUb1dyYXAubGVuZ3RoIC0gMV0uaW5kZXggLSAyLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gZWxlbWVudC5jaGlsZHJlbi5tYXAoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3BzID0gaXNFbGVtZW50KGNoaWxkTm9kZSkgPyBjaGlsZE5vZGUucHJvcGVydGllcyA6IHt9O1xuICAgICAgICAgIGlmIChwcm9wcyAmJiAhT2JqZWN0Lmhhc093bihwcm9wcywgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiKSAmJiAhT2JqZWN0Lmhhc093bihwcm9wcywgXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzLW1hcmtcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZyhjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgIGlmICghaXNFbGVtZW50KGNoaWxkTm9kZSkpIHJldHVybjtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjaGlsZE5vZGUucHJvcGVydGllcywgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiKSkge1xuICAgICAgY2hpbGROb2RlLnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGFwcGx5KGVsZW1lbnQsIHtcbiAgdHJlZSxcbiAgbGFuZyxcbiAgdGl0bGUsXG4gIGNhcHRpb24sXG4gIGlubGluZSA9IGZhbHNlLFxuICBrZWVwQmFja2dyb3VuZCA9IHRydWUsXG4gIGdyaWQgPSB0cnVlLFxuICBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDEsXG4gIHRoZW1lLFxuICBvblZpc2l0VGl0bGUsXG4gIG9uVmlzaXRDYXB0aW9uXG59KSB7XG4gIGVsZW1lbnQudGFnTmFtZSA9IGlubGluZSA/IFwic3BhblwiIDogXCJmaWd1cmVcIjtcbiAgZWxlbWVudC5wcm9wZXJ0aWVzW1wiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtZmlndXJlXCJdID0gXCJcIjtcbiAgY29uc3QgY29kZURhdGEgPSBlbGVtZW50LmNoaWxkcmVuWzBdPy5kYXRhO1xuICBlbGVtZW50LmNoaWxkcmVuID0gW3RyZWVdLmZsYXRNYXAoKHRyZWUyKSA9PiB7XG4gICAgY29uc3QgcHJlID0gdHJlZTIuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgdGhlbWVOYW1lcyA9IGdldFRoZW1lTmFtZXModGhlbWUpO1xuICAgIGNvbnN0IHRoZW1lTmFtZXNTdHJpbmcgPSB0aGVtZU5hbWVzLmpvaW4oXCIgXCIpO1xuICAgIGlmICghKGlzRWxlbWVudChwcmUpICYmIHByZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gcHJlLmNoaWxkcmVuWzBdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgJiYgcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKFwic2hpa2lcIikpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5maWx0ZXIoXG4gICAgICAgIChjKSA9PiBjICE9PSBcInNoaWtpXCIgJiYgYyAhPT0gXCJzaGlraS10aGVtZXNcIiAmJiAodHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyAhdGhlbWVOYW1lcy5pbmNsdWRlcyhjKSA6IHRydWUpXG4gICAgICApO1xuICAgICAgcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICgha2VlcEJhY2tncm91bmQpIHtcbiAgICAgIHByZS5wcm9wZXJ0aWVzLnN0eWxlID0gdm9pZCAwO1xuICAgIH1cbiAgICBwcmUucHJvcGVydGllc1tcImRhdGEtbGFuZ3VhZ2VcIl0gPSBsYW5nO1xuICAgIHByZS5wcm9wZXJ0aWVzW1wiZGF0YS10aGVtZVwiXSA9IHRoZW1lTmFtZXNTdHJpbmc7XG4gICAgaWYgKCEoaXNFbGVtZW50KGNvZGUpICYmIGNvZGUucHJvcGVydGllcykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS1sYW5ndWFnZVwiXSA9IGxhbmc7XG4gICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS10aGVtZVwiXSA9IHRoZW1lTmFtZXNTdHJpbmc7XG4gICAgY29kZS5kYXRhID0gY29kZURhdGE7XG4gICAgaWYgKGlubGluZSkge1xuICAgICAgaWYgKGtlZXBCYWNrZ3JvdW5kKSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSA9IHByZS5wcm9wZXJ0aWVzLnN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIGlmIChncmlkKSB7XG4gICAgICBpZiAoY29kZS5wcm9wZXJ0aWVzLnN0eWxlKSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSArPSBcImRpc3BsYXk6IGdyaWQ7XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgPSBcImRpc3BsYXk6IGdyaWQ7XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QuaGFzT3duKGNvZGUucHJvcGVydGllcywgXCJkYXRhLWxpbmUtbnVtYmVyc1wiKSkge1xuICAgICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lLW51bWJlcnMtbWF4LWRpZ2l0c1wiXSA9IGxpbmVOdW1iZXJzTWF4RGlnaXRzLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudHMgPSBbXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogY2FwdGlvbiA/IFwiZGl2XCIgOiBcImZpZ2NhcHRpb25cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIFwiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtdGl0bGVcIjogXCJcIixcbiAgICAgICAgICBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZyxcbiAgICAgICAgICBcImRhdGEtdGhlbWVcIjogdGhlbWVOYW1lc1N0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiB0aXRsZSB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRUaXRsZT8uKGVsZW1lbnRDb250ZW50KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGVsZW1lbnRDb250ZW50KTtcbiAgICB9XG4gICAgZnJhZ21lbnRzLnB1c2gocHJlKTtcbiAgICBpZiAoY2FwdGlvbikge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcImZpZ2NhcHRpb25cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIFwiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtY2FwdGlvblwiOiBcIlwiLFxuICAgICAgICAgIFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLFxuICAgICAgICAgIFwiZGF0YS10aGVtZVwiOiB0aGVtZU5hbWVzU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGNhcHRpb24gfV1cbiAgICAgIH07XG4gICAgICBvblZpc2l0Q2FwdGlvbj8uKGVsZW1lbnRDb250ZW50KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGVsZW1lbnRDb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50cztcbiAgfSk7XG59XG52YXIgZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgaGFzdFBhcnNlciA9IHVuaWZpZWQoKS51c2UocmVoeXBlUGFyc2UsIHsgZnJhZ21lbnQ6IHRydWUgfSk7XG52YXIgc3JjX2RlZmF1bHQgPSByZWh5cGVQcmV0dHlDb2RlO1xuZnVuY3Rpb24gcmVoeXBlUHJldHR5Q29kZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGdyaWQgPSB0cnVlLFxuICAgIHRoZW1lID0gXCJnaXRodWItZGFyay1kaW1tZWRcIixcbiAgICBrZWVwQmFja2dyb3VuZCA9IHRydWUsXG4gICAgYnlwYXNzSW5saW5lQ29kZSA9IGZhbHNlLFxuICAgIGRlZmF1bHRMYW5nID0gXCJcIixcbiAgICB0b2tlbnNNYXAgPSB7fSxcbiAgICBmaWx0ZXJNZXRhU3RyaW5nID0gKHYpID0+IHYsXG4gICAgZ2V0SGlnaGxpZ2h0ZXIgPSBnZXRTaW5nbGV0b25IaWdobGlnaHRlcixcbiAgICB0cmFuc2Zvcm1lcnMsXG4gICAgb25WaXNpdExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkTGluZSxcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycyxcbiAgICBvblZpc2l0VGl0bGUsXG4gICAgb25WaXNpdENhcHRpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHRoZW1lKTtcbiAgbGV0IGNhY2hlZEhpZ2hsaWdodGVyID0gZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKCFjYWNoZWRIaWdobGlnaHRlcikge1xuICAgIGNhY2hlZEhpZ2hsaWdodGVyID0gZ2V0SGlnaGxpZ2h0ZXIoe1xuICAgICAgdGhlbWVzOiBpc0pTT05UaGVtZSh0aGVtZSkgfHwgdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gW3RoZW1lXSA6IE9iamVjdC52YWx1ZXModGhlbWUpLFxuICAgICAgbGFuZ3M6IFtcInBsYWludGV4dFwiXVxuICAgIH0pO1xuICAgIGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuc2V0KGtleSwgY2FjaGVkSGlnaGxpZ2h0ZXIpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRDb2RlQmxvY2tMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSBcInN0cmluZ1wiID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5ibG9jayB8fCBcIlwiO1xuICBjb25zdCBkZWZhdWx0SW5saW5lQ29kZUxhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0TGFuZyA6IGRlZmF1bHRMYW5nLmlubGluZSB8fCBcIlwiO1xuICBmdW5jdGlvbiBnZXRPcHRpb25zKGxhbmcsIG1ldGEpIHtcbiAgICBjb25zdCBtdWx0aXBsZVRoZW1lcyA9ICFpc0pTT05UaGVtZSh0aGVtZSkgJiYgdHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiID8gdGhlbWUgOiBudWxsO1xuICAgIGNvbnN0IHNpbmdsZVRoZW1lID0gaXNKU09OVGhlbWUodGhlbWUpIHx8IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZyxcbiAgICAgIG1ldGE6IHsgX19yYXc6IG1ldGEgfSxcbiAgICAgIHRyYW5zZm9ybWVycyxcbiAgICAgIGRlZmF1bHRDb2xvcjogdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBmYWxzZSxcbiAgICAgIC4uLm11bHRpcGxlVGhlbWVzID8geyB0aGVtZXM6IG11bHRpcGxlVGhlbWVzIH0gOiB7IHRoZW1lOiBzaW5nbGVUaGVtZSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXN5bmMgKHRyZWUpID0+IHtcbiAgICBjb25zdCBsYW5nc1RvTG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZXIgPSBhd2FpdCBjYWNoZWRIaWdobGlnaHRlcjtcbiAgICBpZiAoIWhpZ2hsaWdodGVyKSByZXR1cm47XG4gICAgdmlzaXQodHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50LCBfLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50LCBieXBhc3NJbmxpbmVDb2RlKSkge1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhbmcgPSBnZXRJbmxpbmVDb2RlTGFuZyh2YWx1ZSwgZGVmYXVsdElubGluZUNvZGVMYW5nKTtcbiAgICAgICAgaWYgKGxhbmcgJiYgbGFuZ1swXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgICBsYW5nc1RvTG9hZC5hZGQobGFuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrQ29kZShlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNFbGVtZW50KGNvZGVFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhbmcgfSA9IHBhcnNlQmxvY2tNZXRhU3RyaW5nKFxuICAgICAgICAgIGNvZGVFbGVtZW50LFxuICAgICAgICAgIGZpbHRlck1ldGFTdHJpbmcsXG4gICAgICAgICAgZGVmYXVsdENvZGVCbG9ja0xhbmdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxhbmcpIHtcbiAgICAgICAgICBsYW5nc1RvTG9hZC5hZGQobGFuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICBBcnJheS5mcm9tKGxhbmdzVG9Mb2FkKS5tYXAoKGxhbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVyLmxvYWRMYW5ndWFnZShcbiAgICAgICAgICAgICAgbGFuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICB2aXNpdCh0cmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQsIF8sIHBhcmVudCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQsIGJ5cGFzc0lubGluZUNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgY29uc3Qga2VlcExhbmdQYXJ0ID0gL1xcXFx7OlthLXpBLVouLV0rfSQvLnRlc3QodmFsdWUpO1xuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0ga2VlcExhbmdQYXJ0ID8gdmFsdWUucmVwbGFjZSgvXFxcXCh7OlthLXpBLVouLV0rfSkkLywgXCIkMVwiKSA6IHZhbHVlLnJlcGxhY2UoL3s6W2EtekEtWi4tXSt9JC8sIFwiXCIpO1xuICAgICAgICB0ZXh0RWxlbWVudC52YWx1ZSA9IHN0cmlwcGVkVmFsdWU7XG4gICAgICAgIGNvbnN0IGxhbmcgPSBrZWVwTGFuZ1BhcnQgPyBcIlwiIDogZ2V0SW5saW5lQ29kZUxhbmcodmFsdWUsIGRlZmF1bHRJbmxpbmVDb2RlTGFuZyk7XG4gICAgICAgIGNvbnN0IGlzTGFuZyA9IGxhbmdbMF0gIT09IFwiLlwiO1xuICAgICAgICBpZiAoIWxhbmcpIHJldHVybjtcbiAgICAgICAgbGV0IGNvZGVUcmVlO1xuICAgICAgICBpZiAoaXNMYW5nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKGxhbmcpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKFwicGxhaW50ZXh0XCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGhlbWVOYW1lcyA9IGdldFRoZW1lTmFtZXModGhlbWUpO1xuICAgICAgICAgIGNvbnN0IGlzTXVsdGlUaGVtZSA9IHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiAmJiAhaXNKU09OVGhlbWUodGhlbWUpO1xuICAgICAgICAgIGNvbnN0IHRoZW1lS2V5cyA9IGlzTXVsdGlUaGVtZSA/IE9iamVjdC5rZXlzKHRoZW1lKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgY29sb3JzQnlUaGVtZSA9IHRoZW1lTmFtZXMubWFwKFxuICAgICAgICAgICAgKG5hbWUpID0+IG5hbWUgPyBoaWdobGlnaHRlci5nZXRUaGVtZShuYW1lKS5zZXR0aW5ncy5maW5kKFxuICAgICAgICAgICAgICAoeyBzY29wZSB9KSA9PiBzY29wZT8uaW5jbHVkZXModG9rZW5zTWFwW2xhbmcuc2xpY2UoMSldID8/IGxhbmcuc2xpY2UoMSkpXG4gICAgICAgICAgICApPy5zZXR0aW5ncy5mb3JlZ3JvdW5kID8/IFwiaW5oZXJpdFwiIDogXCJpbmhlcml0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc011bHRpVGhlbWUgJiYgdGhlbWVLZXlzKSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGA8cHJlPjxjb2RlPjxzcGFuIHN0eWxlPVwiJHt0aGVtZUtleXMubWFwKChrZXkyLCBpKSA9PiBgLS1zaGlraS0ke2tleTJ9OiR7Y29sb3JzQnlUaGVtZVtpXX1gKS5qb2luKFwiO1wiKX1cIj4ke3N0cmlwcGVkVmFsdWV9PC9zcGFuPjwvY29kZT48L3ByZT5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGA8cHJlPjxjb2RlPjxzcGFuIHN0eWxlPVwiY29sb3I6JHtjb2xvcnNCeVRoZW1lWzBdfVwiPiR7c3RyaXBwZWRWYWx1ZX08L3NwYW4+PC9jb2RlPjwvcHJlPmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0KGNvZGVUcmVlLCBcImVsZW1lbnRcIiwgcmVwbGFjZUxpbmVDbGFzcyk7XG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmVlOiBjb2RlVHJlZSxcbiAgICAgICAgICBsYW5nOiBpc0xhbmcgPyBsYW5nIDogXCIudG9rZW5cIixcbiAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAga2VlcEJhY2tncm91bmQsXG4gICAgICAgICAgdGhlbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0NvZGUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgY29kZUVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzRWxlbWVudChjb2RlRWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBjb2RlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgY2FwdGlvbiwgbWV0YSwgbGFuZyB9ID0gcGFyc2VCbG9ja01ldGFTdHJpbmcoXG4gICAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgICAgZmlsdGVyTWV0YVN0cmluZyxcbiAgICAgICAgICBkZWZhdWx0Q29kZUJsb2NrTGFuZ1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWxhbmcgfHwgbGFuZyA9PT0gXCJtYXRoXCIpIHJldHVybjtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVzID0gbWV0YS5tYXRjaEFsbCgvXFxCXFx7KC4qPylcXH1cXEIvZyk7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnMucHVzaCguLi5yYW5nZVBhcnNlcjIobWF0Y2hbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gMDtcbiAgICAgICAgY29uc3QgbGluZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdE51bWJlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0SWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjaGFyc01hdGNoZXMgPSBtZXRhID8gW1xuICAgICAgICAgIC4uLm1ldGEubWF0Y2hBbGwoXG4gICAgICAgICAgICAvKD88ZGVsaW1pdGVyPltcIi9dKSg/PGNoYXJzPi4qPylcXGs8ZGVsaW1pdGVyPig/PGNoYXJzSWRBbmRPclJhbmdlPlxcUyopL2dcbiAgICAgICAgICApXG4gICAgICAgIF0gOiB2b2lkIDA7XG4gICAgICAgIGxpbmVOdW1iZXJzLmZvckVhY2goKGxpbmVOdW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGdldExpbmVJZChsaW5lTnVtYmVyLCBtZXRhKTtcbiAgICAgICAgICBpZCAmJiBsaW5lSWRNYXAuc2V0KGxpbmVOdW1iZXIsIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYXJzTWF0Y2hlcykpIHtcbiAgICAgICAgICBjaGFyc01hdGNoZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFycywgY2hhcnNJZEFuZE9yUmFuZ2UgfSA9IG5hbWUuZ3JvdXBzO1xuICAgICAgICAgICAgY2hhcnNMaXN0LnB1c2goY2hhcnMpO1xuICAgICAgICAgICAgaWYgKGNoYXJzSWRBbmRPclJhbmdlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGNoYXJzTGlzdE51bWJlcnMucHVzaChbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBbcmFuZ2UsIGlkXSA9IGNoYXJzSWRBbmRPclJhbmdlLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgcmFuZ2UgJiYgY2hhcnNMaXN0TnVtYmVycy5wdXNoKHJhbmdlUGFyc2VyMihyYW5nZSkpO1xuICAgICAgICAgICAgICBpZCAmJiBjaGFyc0xpc3RJZE1hcC5zZXQoY2hhcnMsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgICAgICAgbGV0IGNvZGVUcmVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhsYW5nLCBtZXRhKSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKFxuICAgICAgICAgICAgICBzdHJpcHBlZFZhbHVlLFxuICAgICAgICAgICAgICBnZXRPcHRpb25zKFwicGxhaW50ZXh0XCIsIG1ldGEpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZUNvdW50ZXIgPSAwO1xuICAgICAgICBjb25zdCBjaGFyc0hpZ2hsaWdodGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICByYW5nZXM6IGNoYXJzTGlzdE51bWJlcnMsXG4gICAgICAgICAgaWRzTWFwOiBjaGFyc0xpc3RJZE1hcCxcbiAgICAgICAgICBjb3VudGVyTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0KGNvZGVUcmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQyKSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQyLnRhZ05hbWUgPT09IFwiY29kZVwiICYmIC9zcmVibXVOZW5pTHdvaHMoPyEoLiopKFxcLykpLy50ZXN0KHJldmVyc2VTdHJpbmcobWV0YSkpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudDIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lLW51bWJlcnNcIl0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlcnNTdGFydEF0TWF0Y2ggPSByZXZlcnNlU3RyaW5nKG1ldGEpLm1hdGNoKFxuICAgICAgICAgICAgICAvKD86XFx9KFxcZCspeyk/c3JlYm11TmVuaUx3b2hzKD8hKC4qKShcXC8pKS9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFydE51bWJlclN0cmluZyA9IGxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoPy5bMV07XG4gICAgICAgICAgICBpZiAoc3RhcnROdW1iZXJTdHJpbmcpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHN0YXJ0TnVtYmVyU3RyaW5nID8gTnVtYmVyKHJldmVyc2VTdHJpbmcoc3RhcnROdW1iZXJTdHJpbmcpKSAtIDEgOiAwO1xuICAgICAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cyA9IHN0YXJ0QXQ7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Mi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllcy5zdHlsZSA9IGBjb3VudGVyLXNldDogbGluZSAke3N0YXJ0QXR9O2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudDIucHJvcGVydGllcz8uY2xhc3NOYW1lKSAmJiBlbGVtZW50Mi5wcm9wZXJ0aWVzPy5jbGFzc05hbWU/LlswXSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgICAgICAgIGlmIChncmlkICYmIHRvU3RyaW5nKGVsZW1lbnQyKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5jaGlsZHJlbiA9IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCIgXCIgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlTGluZUNsYXNzKGVsZW1lbnQyKTtcbiAgICAgICAgICAgIG9uVmlzaXRMaW5lPy4oZWxlbWVudDIpO1xuICAgICAgICAgICAgbGluZUNvdW50ZXIrKztcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVycy5pbmNsdWRlcyhsaW5lQ291bnRlcikpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtbGluZVwiXSA9IFwiXCI7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVJZCA9IGxpbmVJZE1hcC5nZXQobGluZUNvdW50ZXIpO1xuICAgICAgICAgICAgICBpZiAobGluZUlkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtbGluZS1pZFwiXSA9IGxpbmVJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lPy4oZWxlbWVudDIsIGxpbmVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFyc0hpZ2hsaWdodGVyKFxuICAgICAgICAgICAgICBlbGVtZW50MixcbiAgICAgICAgICAgICAgY2hhcnNMaXN0LFxuICAgICAgICAgICAgICBjaGFyc0hpZ2hsaWdodGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmVlOiBjb2RlVHJlZSxcbiAgICAgICAgICBsYW5nLFxuICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgIGNhcHRpb24sXG4gICAgICAgICAga2VlcEJhY2tncm91bmQsXG4gICAgICAgICAgZ3JpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cyxcbiAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICBvblZpc2l0VGl0bGUsXG4gICAgICAgICAgb25WaXNpdENhcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHNyY19kZWZhdWx0IGFzIGRlZmF1bHQsIHJlaHlwZVByZXR0eUNvZGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/rehype-pretty-code@0.14.1_shiki@2.5.0/node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;