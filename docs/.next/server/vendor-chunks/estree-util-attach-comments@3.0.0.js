"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-attach-comments@3.0.0";
exports.ids = ["vendor-chunks/estree-util-attach-comments@3.0.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attachComments: () => (/* binding */ attachComments)\n/* harmony export */ });\n/**\n * @typedef {import('estree').Comment} Comment\n * @typedef {import('estree').Node} Nodes\n */\n\n/**\n * @typedef Fields\n *   Fields.\n * @property {boolean} leading\n *   Whether it’s leading.\n * @property {boolean} trailing\n *   Whether it’s trailing.\n *\n * @typedef State\n *   Info passed around.\n * @property {Array<Comment>} comments\n *   Comments.\n * @property {number} index\n *   Index of comment.\n */\n\nconst own = {}.hasOwnProperty\n\n/** @type {Array<Comment>} */\nconst emptyComments = []\n\n/**\n * Attach semistandard estree comment nodes to the tree.\n *\n * This mutates the given `tree`.\n * It takes `comments`, walks the tree, and adds comments as close as possible\n * to where they originated.\n *\n * Comment nodes are given two boolean fields: `leading` (`true` for\n * `/* a *\\/ b`) and `trailing` (`true` for `a /* b *\\/`).\n * Both fields are `false` for dangling comments: `[/* a *\\/]`.\n * This is what `recast` uses too, and is somewhat similar to Babel, which is\n * not estree but instead uses `leadingComments`, `trailingComments`, and\n * `innerComments` arrays on nodes.\n *\n * The algorithm checks any node: even recent (or future) proposals or\n * nonstandard syntax such as JSX, because it ducktypes to find nodes instead\n * of having a list of visitor keys.\n *\n * The algorithm supports `loc` fields (line/column), `range` fields (offsets),\n * and direct `start` / `end` fields.\n *\n * @template {Nodes} Tree\n *   Node type.\n * @param {Tree} tree\n *   Tree to attach to.\n * @param {Array<Comment> | null | undefined} [comments]\n *   List of comments (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction attachComments(tree, comments) {\n  const list = comments ? [...comments].sort(compare) : emptyComments\n  if (list.length > 0) walk(tree, {comments: list, index: 0})\n}\n\n/**\n * Attach semistandard estree comment nodes to the tree.\n *\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {undefined}\n *   Nothing.\n */\nfunction walk(node, state) {\n  // Done, we can quit.\n  if (state.index === state.comments.length) {\n    return\n  }\n\n  /** @type {Array<Nodes>} */\n  const children = []\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {string} */\n  let key\n\n  // Find all children of `node`\n  for (key in node) {\n    if (own.call(node, key)) {\n      /** @type {Array<Nodes> | Nodes} */\n      // @ts-expect-error: indexable.\n      const value = node[key]\n\n      // Ignore comments.\n      if (value && typeof value === 'object' && key !== 'comments') {\n        if (Array.isArray(value)) {\n          let index = -1\n\n          while (++index < value.length) {\n            if (value[index] && typeof value[index].type === 'string') {\n              children.push(value[index])\n            }\n          }\n        } else if (typeof value.type === 'string') {\n          children.push(value)\n        }\n      }\n    }\n  }\n\n  // Sort the children.\n  children.sort(compare)\n\n  // Initial comments.\n  comments.push(...slice(state, node, false, {leading: true, trailing: false}))\n\n  let index = -1\n\n  while (++index < children.length) {\n    walk(children[index], state)\n  }\n\n  // Dangling or trailing comments.\n  comments.push(\n    ...slice(state, node, true, {\n      leading: false,\n      trailing: children.length > 0\n    })\n  )\n\n  if (comments.length > 0) {\n    // @ts-expect-error, yes, because they’re nonstandard.\n    node.comments = comments\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @param {boolean} compareEnd\n *   Whether to compare on the end (default is on start).\n * @param {Fields} fields\n *   Fields.\n * @returns {Array<Comment>}\n *   Slice from `state.comments`.\n */\nfunction slice(state, node, compareEnd, fields) {\n  /** @type {Array<Comment>} */\n  const result = []\n\n  while (\n    state.comments[state.index] &&\n    compare(state.comments[state.index], node, compareEnd) < 1\n  ) {\n    result.push(Object.assign({}, state.comments[state.index++], fields))\n  }\n\n  return result\n}\n\n/**\n * Sort two nodes (or comments).\n *\n * @param {Comment | Nodes} left\n *   A node.\n * @param {Comment | Nodes} right\n *   The other node.\n * @param {boolean | undefined} [compareEnd=false]\n *   Compare on `end` of `right`, default is to compare on `start` (default:\n *   `false`).\n * @returns {number}\n *   Sorting.\n */\nfunction compare(left, right, compareEnd) {\n  const field = compareEnd ? 'end' : 'start'\n\n  // Offsets.\n  if (left.range && right.range) {\n    return left.range[0] - right.range[compareEnd ? 1 : 0]\n  }\n\n  // Points.\n  if (left.loc && left.loc.start && right.loc && right.loc[field]) {\n    return (\n      left.loc.start.line - right.loc[field].line ||\n      left.loc.start.column - right.loc[field].column\n    )\n  }\n\n  // Just `start` (and `end`) on nodes.\n  // Default in most parsers.\n  if ('start' in left && field in right) {\n    // @ts-expect-error Added by Acorn\n    return left.start - right[field]\n  }\n\n  return Number.NaN\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWF0dGFjaC1jb21tZW50c0AzLjAuMC9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYXR0YWNoLWNvbW1lbnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLHVCQUF1QjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBLGNBQWM7O0FBRWQsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCOztBQUU3RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWF0dGFjaC1jb21tZW50c0AzLjAuMC9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYXR0YWNoLWNvbW1lbnRzL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZScpLkNvbW1lbnR9IENvbW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZScpLk5vZGV9IE5vZGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBGaWVsZHNcbiAqICAgRmllbGRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBsZWFkaW5nXG4gKiAgIFdoZXRoZXIgaXTigJlzIGxlYWRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiAgIFdoZXRoZXIgaXTigJlzIHRyYWlsaW5nLlxuICpcbiAqIEB0eXBlZGVmIFN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Q29tbWVudD59IGNvbW1lbnRzXG4gKiAgIENvbW1lbnRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XG4gKiAgIEluZGV4IG9mIGNvbW1lbnQuXG4gKi9cblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqIEB0eXBlIHtBcnJheTxDb21tZW50Pn0gKi9cbmNvbnN0IGVtcHR5Q29tbWVudHMgPSBbXVxuXG4vKipcbiAqIEF0dGFjaCBzZW1pc3RhbmRhcmQgZXN0cmVlIGNvbW1lbnQgbm9kZXMgdG8gdGhlIHRyZWUuXG4gKlxuICogVGhpcyBtdXRhdGVzIHRoZSBnaXZlbiBgdHJlZWAuXG4gKiBJdCB0YWtlcyBgY29tbWVudHNgLCB3YWxrcyB0aGUgdHJlZSwgYW5kIGFkZHMgY29tbWVudHMgYXMgY2xvc2UgYXMgcG9zc2libGVcbiAqIHRvIHdoZXJlIHRoZXkgb3JpZ2luYXRlZC5cbiAqXG4gKiBDb21tZW50IG5vZGVzIGFyZSBnaXZlbiB0d28gYm9vbGVhbiBmaWVsZHM6IGBsZWFkaW5nYCAoYHRydWVgIGZvclxuICogYC8qIGEgKlxcLyBiYCkgYW5kIGB0cmFpbGluZ2AgKGB0cnVlYCBmb3IgYGEgLyogYiAqXFwvYCkuXG4gKiBCb3RoIGZpZWxkcyBhcmUgYGZhbHNlYCBmb3IgZGFuZ2xpbmcgY29tbWVudHM6IGBbLyogYSAqXFwvXWAuXG4gKiBUaGlzIGlzIHdoYXQgYHJlY2FzdGAgdXNlcyB0b28sIGFuZCBpcyBzb21ld2hhdCBzaW1pbGFyIHRvIEJhYmVsLCB3aGljaCBpc1xuICogbm90IGVzdHJlZSBidXQgaW5zdGVhZCB1c2VzIGBsZWFkaW5nQ29tbWVudHNgLCBgdHJhaWxpbmdDb21tZW50c2AsIGFuZFxuICogYGlubmVyQ29tbWVudHNgIGFycmF5cyBvbiBub2Rlcy5cbiAqXG4gKiBUaGUgYWxnb3JpdGhtIGNoZWNrcyBhbnkgbm9kZTogZXZlbiByZWNlbnQgKG9yIGZ1dHVyZSkgcHJvcG9zYWxzIG9yXG4gKiBub25zdGFuZGFyZCBzeW50YXggc3VjaCBhcyBKU1gsIGJlY2F1c2UgaXQgZHVja3R5cGVzIHRvIGZpbmQgbm9kZXMgaW5zdGVhZFxuICogb2YgaGF2aW5nIGEgbGlzdCBvZiB2aXNpdG9yIGtleXMuXG4gKlxuICogVGhlIGFsZ29yaXRobSBzdXBwb3J0cyBgbG9jYCBmaWVsZHMgKGxpbmUvY29sdW1uKSwgYHJhbmdlYCBmaWVsZHMgKG9mZnNldHMpLFxuICogYW5kIGRpcmVjdCBgc3RhcnRgIC8gYGVuZGAgZmllbGRzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7Tm9kZXN9IFRyZWVcbiAqICAgTm9kZSB0eXBlLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlXG4gKiAgIFRyZWUgdG8gYXR0YWNoIHRvLlxuICogQHBhcmFtIHtBcnJheTxDb21tZW50PiB8IG51bGwgfCB1bmRlZmluZWR9IFtjb21tZW50c11cbiAqICAgTGlzdCBvZiBjb21tZW50cyAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaENvbW1lbnRzKHRyZWUsIGNvbW1lbnRzKSB7XG4gIGNvbnN0IGxpc3QgPSBjb21tZW50cyA/IFsuLi5jb21tZW50c10uc29ydChjb21wYXJlKSA6IGVtcHR5Q29tbWVudHNcbiAgaWYgKGxpc3QubGVuZ3RoID4gMCkgd2Fsayh0cmVlLCB7Y29tbWVudHM6IGxpc3QsIGluZGV4OiAwfSlcbn1cblxuLyoqXG4gKiBBdHRhY2ggc2VtaXN0YW5kYXJkIGVzdHJlZSBjb21tZW50IG5vZGVzIHRvIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIHdhbGsobm9kZSwgc3RhdGUpIHtcbiAgLy8gRG9uZSwgd2UgY2FuIHF1aXQuXG4gIGlmIChzdGF0ZS5pbmRleCA9PT0gc3RhdGUuY29tbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiogQHR5cGUge0FycmF5PE5vZGVzPn0gKi9cbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAvKiogQHR5cGUge0FycmF5PENvbW1lbnQ+fSAqL1xuICBjb25zdCBjb21tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQga2V5XG5cbiAgLy8gRmluZCBhbGwgY2hpbGRyZW4gb2YgYG5vZGVgXG4gIGZvciAoa2V5IGluIG5vZGUpIHtcbiAgICBpZiAob3duLmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz4gfCBOb2Rlc30gKi9cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluZGV4YWJsZS5cbiAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldXG5cbiAgICAgIC8vIElnbm9yZSBjb21tZW50cy5cbiAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIGtleSAhPT0gJ2NvbW1lbnRzJykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtpbmRleF0gJiYgdHlwZW9mIHZhbHVlW2luZGV4XS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHZhbHVlW2luZGV4XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvcnQgdGhlIGNoaWxkcmVuLlxuICBjaGlsZHJlbi5zb3J0KGNvbXBhcmUpXG5cbiAgLy8gSW5pdGlhbCBjb21tZW50cy5cbiAgY29tbWVudHMucHVzaCguLi5zbGljZShzdGF0ZSwgbm9kZSwgZmFsc2UsIHtsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogZmFsc2V9KSlcblxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgd2FsayhjaGlsZHJlbltpbmRleF0sIHN0YXRlKVxuICB9XG5cbiAgLy8gRGFuZ2xpbmcgb3IgdHJhaWxpbmcgY29tbWVudHMuXG4gIGNvbW1lbnRzLnB1c2goXG4gICAgLi4uc2xpY2Uoc3RhdGUsIG5vZGUsIHRydWUsIHtcbiAgICAgIGxlYWRpbmc6IGZhbHNlLFxuICAgICAgdHJhaWxpbmc6IGNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICB9KVxuICApXG5cbiAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yLCB5ZXMsIGJlY2F1c2UgdGhleeKAmXJlIG5vbnN0YW5kYXJkLlxuICAgIG5vZGUuY29tbWVudHMgPSBjb21tZW50c1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICogICBOb2RlLlxuICogQHBhcmFtIHtib29sZWFufSBjb21wYXJlRW5kXG4gKiAgIFdoZXRoZXIgdG8gY29tcGFyZSBvbiB0aGUgZW5kIChkZWZhdWx0IGlzIG9uIHN0YXJ0KS5cbiAqIEBwYXJhbSB7RmllbGRzfSBmaWVsZHNcbiAqICAgRmllbGRzLlxuICogQHJldHVybnMge0FycmF5PENvbW1lbnQ+fVxuICogICBTbGljZSBmcm9tIGBzdGF0ZS5jb21tZW50c2AuXG4gKi9cbmZ1bmN0aW9uIHNsaWNlKHN0YXRlLCBub2RlLCBjb21wYXJlRW5kLCBmaWVsZHMpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxDb21tZW50Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICB3aGlsZSAoXG4gICAgc3RhdGUuY29tbWVudHNbc3RhdGUuaW5kZXhdICYmXG4gICAgY29tcGFyZShzdGF0ZS5jb21tZW50c1tzdGF0ZS5pbmRleF0sIG5vZGUsIGNvbXBhcmVFbmQpIDwgMVxuICApIHtcbiAgICByZXN1bHQucHVzaChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5jb21tZW50c1tzdGF0ZS5pbmRleCsrXSwgZmllbGRzKSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBTb3J0IHR3byBub2RlcyAob3IgY29tbWVudHMpLlxuICpcbiAqIEBwYXJhbSB7Q29tbWVudCB8IE5vZGVzfSBsZWZ0XG4gKiAgIEEgbm9kZS5cbiAqIEBwYXJhbSB7Q29tbWVudCB8IE5vZGVzfSByaWdodFxuICogICBUaGUgb3RoZXIgbm9kZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2NvbXBhcmVFbmQ9ZmFsc2VdXG4gKiAgIENvbXBhcmUgb24gYGVuZGAgb2YgYHJpZ2h0YCwgZGVmYXVsdCBpcyB0byBjb21wYXJlIG9uIGBzdGFydGAgKGRlZmF1bHQ6XG4gKiAgIGBmYWxzZWApLlxuICogQHJldHVybnMge251bWJlcn1cbiAqICAgU29ydGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZShsZWZ0LCByaWdodCwgY29tcGFyZUVuZCkge1xuICBjb25zdCBmaWVsZCA9IGNvbXBhcmVFbmQgPyAnZW5kJyA6ICdzdGFydCdcblxuICAvLyBPZmZzZXRzLlxuICBpZiAobGVmdC5yYW5nZSAmJiByaWdodC5yYW5nZSkge1xuICAgIHJldHVybiBsZWZ0LnJhbmdlWzBdIC0gcmlnaHQucmFuZ2VbY29tcGFyZUVuZCA/IDEgOiAwXVxuICB9XG5cbiAgLy8gUG9pbnRzLlxuICBpZiAobGVmdC5sb2MgJiYgbGVmdC5sb2Muc3RhcnQgJiYgcmlnaHQubG9jICYmIHJpZ2h0LmxvY1tmaWVsZF0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgbGVmdC5sb2Muc3RhcnQubGluZSAtIHJpZ2h0LmxvY1tmaWVsZF0ubGluZSB8fFxuICAgICAgbGVmdC5sb2Muc3RhcnQuY29sdW1uIC0gcmlnaHQubG9jW2ZpZWxkXS5jb2x1bW5cbiAgICApXG4gIH1cblxuICAvLyBKdXN0IGBzdGFydGAgKGFuZCBgZW5kYCkgb24gbm9kZXMuXG4gIC8vIERlZmF1bHQgaW4gbW9zdCBwYXJzZXJzLlxuICBpZiAoJ3N0YXJ0JyBpbiBsZWZ0ICYmIGZpZWxkIGluIHJpZ2h0KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBBZGRlZCBieSBBY29yblxuICAgIHJldHVybiBsZWZ0LnN0YXJ0IC0gcmlnaHRbZmllbGRdXG4gIH1cblxuICByZXR1cm4gTnVtYmVyLk5hTlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js\n");

/***/ })

};
;