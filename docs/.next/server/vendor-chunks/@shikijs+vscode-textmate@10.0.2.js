"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+vscode-textmate@10.0.2";
exports.ids = ["vendor-chunks/@shikijs+vscode-textmate@10.0.2"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncodedTokenMetadata: () => (/* binding */ EncodedTokenMetadata),\n/* harmony export */   FindOption: () => (/* binding */ FindOption),\n/* harmony export */   FontStyle: () => (/* binding */ FontStyle),\n/* harmony export */   INITIAL: () => (/* binding */ INITIAL),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Theme: () => (/* binding */ Theme),\n/* harmony export */   disposeOnigString: () => (/* binding */ disposeOnigString)\n/* harmony export */ });\n// src/utils.ts\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (something instanceof RegExp) {\n    return something;\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nvar RegexSource = class {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n};\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nvar CachedFn = class {\n  constructor(fn) {\n    this.fn = fn;\n  }\n  cache = /* @__PURE__ */ new Map();\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n};\n\n// src/theme.ts\nvar Theme = class {\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn(\n    (scopeName) => this._root.match(scopeName)\n  );\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find(\n      (v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes)\n    );\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(\n      effectiveRule.fontStyle,\n      effectiveRule.foreground,\n      effectiveRule.background\n    );\n  }\n};\nvar ScopeStack = class _ScopeStack {\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new _ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new _ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  push(scopeName) {\n    return new _ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n};\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes.length === 0) {\n    return true;\n  }\n  for (let index = 0; index < parentScopes.length; index++) {\n    let scopePattern = parentScopes[index];\n    let scopeMustMatch = false;\n    if (scopePattern === \">\") {\n      if (index === parentScopes.length - 1) {\n        return false;\n      }\n      scopePattern = parentScopes[++index];\n      scopeMustMatch = true;\n    }\n    while (scopePath) {\n      if (_matchesScope(scopePath.scopeName, scopePattern)) {\n        break;\n      }\n      if (scopeMustMatch) {\n        return false;\n      }\n      scopePath = scopePath.parent;\n    }\n    if (!scopePath) {\n      return false;\n    }\n    scopePath = scopePath.parent;\n  }\n  return true;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nvar StyleAttributes = class {\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n};\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0 /* None */;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8 /* Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(\n        scope,\n        parentScopes,\n        i,\n        fontStyle,\n        foreground,\n        background\n      );\n    }\n  }\n  return result;\n}\nvar ParsedThemeRule = class {\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n};\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[FontStyle2[\"NotSet\"] = -1] = \"NotSet\";\n  FontStyle2[FontStyle2[\"None\"] = 0] = \"None\";\n  FontStyle2[FontStyle2[\"Italic\"] = 1] = \"Italic\";\n  FontStyle2[FontStyle2[\"Bold\"] = 2] = \"Bold\";\n  FontStyle2[FontStyle2[\"Underline\"] = 4] = \"Underline\";\n  FontStyle2[FontStyle2[\"Strikethrough\"] = 8] = \"Strikethrough\";\n  return FontStyle2;\n})(FontStyle || {});\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = class {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n};\nvar emptyParentScopes = Object.freeze([]);\nvar ThemeTrieElementRule = class _ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes || emptyParentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n};\nvar ThemeTrieElement = class _ThemeTrieElement {\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  _rulesWithParentScopes;\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth !== b.scopeDepth) {\n      return b.scopeDepth - a.scopeDepth;\n    }\n    let aParentIndex = 0;\n    let bParentIndex = 0;\n    while (true) {\n      if (a.parentScopes[aParentIndex] === \">\") {\n        aParentIndex++;\n      }\n      if (b.parentScopes[bParentIndex] === \">\") {\n        bParentIndex++;\n      }\n      if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {\n        break;\n      }\n      const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;\n      if (parentScopeLengthDiff !== 0) {\n        return parentScopeLengthDiff;\n      }\n      aParentIndex++;\n      bParentIndex++;\n    }\n    return b.parentScopes.length - a.parentScopes.length;\n  }\n  match(scope) {\n    if (scope !== \"\") {\n      let dotIndex = scope.indexOf(\".\");\n      let head;\n      let tail;\n      if (dotIndex === -1) {\n        head = scope;\n        tail = \"\";\n      } else {\n        head = scope.substring(0, dotIndex);\n        tail = scope.substring(dotIndex + 1);\n      }\n      if (this._children.hasOwnProperty(head)) {\n        return this._children[head].match(tail);\n      }\n    }\n    const rules = this._rulesWithParentScopes.concat(this._mainRule);\n    rules.sort(_ThemeTrieElement._cmpBySpecificity);\n    return rules;\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1 /* NotSet */) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n};\n\n// src/encodedTokenAttributes.ts\nvar EncodedTokenMetadata = class _EncodedTokenMetadata {\n  static toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  static print(encodedTokenAttributes) {\n    const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  static getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n  }\n  static getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n  }\n  static containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n  }\n  static getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n  }\n  static getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>> 15 /* FOREGROUND_OFFSET */;\n  }\n  static getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>> 24 /* BACKGROUND_OFFSET */;\n  }\n  /**\n   * Updates the fields in `metadata`.\n   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n   */\n  static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n    let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8 /* NotSet */) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 /* LANGUAGEID_OFFSET */ | _tokenType << 8 /* TOKEN_TYPE_OFFSET */ | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */ | _fontStyle << 11 /* FONT_STYLE_OFFSET */ | _foreground << 15 /* FOREGROUND_OFFSET */ | _background << 24 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n};\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\n\n// src/matcher.ts\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\n\n// src/onigLib.ts\nvar FindOption = /* @__PURE__ */ ((FindOption2) => {\n  FindOption2[FindOption2[\"None\"] = 0] = \"None\";\n  FindOption2[FindOption2[\"NotBeginString\"] = 1] = \"NotBeginString\";\n  FindOption2[FindOption2[\"NotEndString\"] = 2] = \"NotEndString\";\n  FindOption2[FindOption2[\"NotBeginPosition\"] = 4] = \"NotBeginPosition\";\n  FindOption2[FindOption2[\"DebugCall\"] = 8] = \"DebugCall\";\n  return FindOption2;\n})(FindOption || {});\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\n\n// src/grammar/grammarDependencies.ts\nvar TopLevelRuleReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n};\nvar TopLevelRepositoryRuleReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n};\nvar ExternalReferenceCollector = class {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n};\nvar ScopeDependencyProcessor = class {\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n};\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(\n      reference.ruleName,\n      { baseGrammar, selfGrammar, repository: selfGrammar.repository },\n      result\n    );\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(\n      context.selfGrammar.patterns,\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(\n      Object.values(context.selfGrammar.injections),\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0 /* Base */:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1 /* Self */:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2 /* RelativeReference */:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3 /* TopLevelReference */:\n      case 4 /* TopLevelRepositoryReference */:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nvar BaseReference = class {\n  kind = 0 /* Base */;\n};\nvar SelfReference = class {\n  kind = 1 /* Self */;\n};\nvar RelativeReference = class {\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n  kind = 2 /* RelativeReference */;\n};\nvar TopLevelReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  kind = 3 /* TopLevelReference */;\n};\nvar TopLevelRepositoryReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  kind = 4 /* TopLevelRepositoryReference */;\n};\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\n\n// src/rule.ts\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar ruleIdSymbol = Symbol(\"RuleId\");\nvar endRuleId = -1;\nvar whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nvar Rule = class {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n};\nvar CaptureRule = class extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n};\nvar MatchRule = class extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar IncludeOnlyRule = class extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginEndRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"\\uFFFF\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginWhileRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"\\uFFFF\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n};\nvar RuleFactory = class _RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.match,\n            _RuleFactory._compileCaptures(desc.captures, helper, repository)\n          );\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            _RuleFactory._compilePatterns(patterns, helper, repository)\n          );\n        }\n        if (desc.while) {\n          return new BeginWhileRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            desc.begin,\n            _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n            desc.while,\n            _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n            _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n          );\n        }\n        return new BeginEndRule(\n          desc.$vscodeTextmateLocation,\n          desc.id,\n          desc.name,\n          desc.contentName,\n          desc.begin,\n          _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n          desc.end,\n          _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n          desc.applyEndPatternLast,\n          _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n        );\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0 /* Base */:\n            case 1 /* Self */:\n              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2 /* RelativeReference */:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              } else {\n              }\n              break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */ ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  } else {\n                  }\n                } else {\n                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              } else {\n              }\n              break;\n          }\n        } else {\n          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n};\nvar RegExpSource = class _RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource && typeof regExpSource === \"string\") {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    if (typeof this.source === \"string\") {\n      this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n    } else {\n      this.hasBackReferences = false;\n    }\n  }\n  clone() {\n    return new _RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"\\uFFFF\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"\\uFFFF\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache || typeof this.source !== \"string\") {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n};\nvar RegExpSourceList = class {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n};\nvar CompiledRule = class {\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  scanner;\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n};\n\n// src/grammar/basicScopesAttributeProvider.ts\nvar BasicScopeAttributes = class {\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n};\nvar BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8 /* NotSet */;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1 /* Comment */;\n      case \"string\":\n        return 2 /* String */;\n      case \"regex\":\n        return 3 /* RegEx */;\n      case \"meta.embedded\":\n        return 0 /* Other */;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n};\nvar ScopeMatcher = class {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(\n        ([scopeName, value]) => escapeRegExpCharacters(scopeName)\n      );\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(\n        `^((${escapedScopes.join(\")|(\")}))($|\\\\.)`,\n        \"\"\n      );\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n};\n\n// src/debug.ts\nvar DebugFlags = {\n  InDebugMode: typeof process !== \"undefined\" && !!process.env[\"VSCODE_TEXTMATE_DEBUG\"]\n};\nvar UseOnigurumaFindOptions = false;\n\n// src/grammar/tokenizeString.ts\nvar TokenizeStringResult = class {\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n};\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      lineTokens\n    );\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    if (false) {}\n    const r = matchRuleOrInjections(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      anchorPosition\n    );\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      if (false) {}\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(\n        grammar,\n        lineText,\n        isFirstLine,\n        stack,\n        lineTokens,\n        poppedRule.endCaptures,\n        captureIndices\n      );\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        if (false) {}\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(\n        scopeName,\n        grammar\n      );\n      stack = stack.push(\n        matchedRuleId,\n        linePos,\n        anchorPosition,\n        captureIndices[0].end === lineLength,\n        null,\n        nameScopesList,\n        nameScopesList\n      );\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getEndWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getWhileWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          matchingRule.captures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          if (false) {}\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (false) {}\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      if (false) {}\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    if (false) {}\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compileWhile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n  let options = 0 /* None */;\n  if (!allowA) {\n    options |= 1 /* NotBeginString */;\n  }\n  if (!allowG) {\n    options |= 4 /* NotBeginPosition */;\n  }\n  return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nvar LocalStackElement = class {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n};\n\n// src/grammar/grammar.ts\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(\n    scopeName,\n    grammar,\n    initialLanguage,\n    embeddedLanguages,\n    tokenTypes,\n    balancedBracketSelectors,\n    grammarRepository,\n    onigLib\n  );\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nvar Grammar = class {\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(\n      initialLanguage,\n      embeddedLanguages\n    );\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(\n            result,\n            expression,\n            rawInjections[expression],\n            this,\n            grammar\n          );\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(\n                result,\n                selector,\n                injectionGrammar,\n                this,\n                injectionGrammar\n              );\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(\n          rawIncludedGrammar,\n          repository && repository.$base\n        );\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(\n        this._grammar.repository.$self,\n        this,\n        this._grammar.repository\n      );\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenMetadata.set(\n        0,\n        rawDefaultMetadata.languageId,\n        rawDefaultMetadata.tokenType,\n        null,\n        defaultStyle.fontStyle,\n        defaultStyle.foregroundId,\n        defaultStyle.backgroundId\n      );\n      const rootScopeName = this.getRule(this._rootId).getName(\n        null,\n        null\n      );\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(\n          rootScopeName,\n          defaultMetadata,\n          this\n        );\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\n          \"unknown\",\n          defaultMetadata\n        );\n      }\n      prevState = new StateStackImpl(\n        null,\n        this._rootId,\n        -1,\n        -1,\n        false,\n        null,\n        scopeList,\n        scopeList\n      );\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(\n      emitBinaryTokens,\n      lineText,\n      this._tokenTypeMatchers,\n      this.balancedBracketSelectors\n    );\n    const r = _tokenizeString(\n      this,\n      onigLineText,\n      isFirstLine,\n      0,\n      prevState,\n      lineTokens,\n      true,\n      timeLimit\n    );\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n};\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nvar AttributedScopeStack = class _AttributedScopeStack {\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(\n      tokenAttributes,\n      rawRootMetadata,\n      rootStyle\n    );\n    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return _AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1 /* NotSet */;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenMetadata.set(\n      existingTokenAttributes,\n      basicScopeAttributes.languageId,\n      basicScopeAttributes.tokenType,\n      null,\n      fontStyle,\n      foreground,\n      background\n    );\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = _AttributedScopeStack.mergeAttributes(\n      target.tokenAttributes,\n      rawMetadata,\n      scopeThemeMatchResult\n    );\n    return new _AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n};\nvar StateStackImpl = class _StateStackImpl {\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new _StateStackImpl(\n    null,\n    0,\n    0,\n    0,\n    false,\n    null,\n    null,\n    null\n  );\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return _StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    _StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new _StateStackImpl(\n      this,\n      ruleId,\n      enterPos,\n      anchorPos,\n      beginRuleCapturedEOL,\n      endRule,\n      nameScopesList,\n      contentNameScopesList\n    );\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      this.endRule,\n      this.nameScopesList,\n      contentNameScopeStack\n    );\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new _StateStackImpl(\n      this.parent,\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      endRule,\n      this.nameScopesList,\n      this.contentNameScopesList\n    );\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new _StateStackImpl(\n      self,\n      ruleIdFromNumber(frame.ruleId),\n      frame.enterPos ?? -1,\n      frame.anchorPos ?? -1,\n      frame.beginRuleCapturedEOL,\n      frame.endRule,\n      namesScopeList,\n      AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList)\n    );\n  }\n};\nvar BalancedBracketSelectors = class {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap(\n      (selector) => {\n        if (selector === \"*\") {\n          this.allowAny = true;\n          return [];\n        }\n        return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n      }\n    );\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(\n      (selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher)\n    );\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n};\nvar LineTokens = class {\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    if (false) {} else {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenMetadata.set(\n              metadata,\n              0,\n              toOptionalTokenType(tokenType.type),\n              null,\n              -1 /* NotSet */,\n              0,\n              0\n            );\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenMetadata.set(\n          metadata,\n          0,\n          8 /* NotSet */,\n          containsBalancedBrackets,\n          -1 /* NotSet */,\n          0,\n          0\n        );\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n};\n\n// src/registry.ts\nvar SyncRegistry = class {\n  constructor(theme, _onigLib) {\n    this._onigLib = _onigLib;\n    this._theme = theme;\n  }\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(\n        scopeName,\n        rawGrammar,\n        initialLanguage,\n        embeddedLanguages,\n        tokenTypes,\n        balancedBracketSelectors,\n        this,\n        this._onigLib\n      ));\n    }\n    return this._grammars.get(scopeName);\n  }\n};\n\n// src/index.ts\nvar Registry = class {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(\n      Theme.createFromRawTheme(options.theme, options.colorMap),\n      options.onigLib\n    );\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(\n      initialScopeName,\n      initialLanguage,\n      configuration.embeddedLanguages,\n      configuration.tokenTypes,\n      new BalancedBracketSelectors(\n        configuration.balancedBracketSelectors || [],\n        configuration.unbalancedBracketSelectors || []\n      )\n    );\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(\n      initialScopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n  _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._doLoadSingleGrammar(scopeName);\n      this._ensureGrammarCache.set(scopeName, true);\n    }\n  }\n  _doLoadSingleGrammar(scopeName) {\n    const grammar = this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(\n      scopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n};\nvar INITIAL = StateStackImpl.NULL;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK3ZzY29kZS10ZXh0bWF0ZUAxMC4wLjIvbm9kZV9tb2R1bGVzL0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsR0FBRyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEUsSUFBSTtBQUNKO0FBQ0E7QUFDQSxRQUFRLDhEQUE4RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBd0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBd0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOENBQThDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsMkNBQTJDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDLEdBQUcsb0JBQW9CO0FBQ2xHLGNBQWMsc0JBQXNCLEdBQUcsU0FBUyxJQUFJLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBS1Y7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUssRUFBRSxFQUlWO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUlWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxFQUFFLEVBSVY7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsRUFJVjtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUVWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFLLEVBQUUsRUFJVjtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsS0FBSyxFQUFFLEVBRVY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZLElBQUksZ0NBQWdDLElBQUksdUNBQXVDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBRVYsQ0FBQztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsbUJBQW1CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrdnNjb2RlLXRleHRtYXRlQDEwLjAuMi9ub2RlX21vZHVsZXMvQHNoaWtpanMvdnNjb2RlLXRleHRtYXRlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiBjbG9uZShzb21ldGhpbmcpIHtcbiAgcmV0dXJuIGRvQ2xvbmUoc29tZXRoaW5nKTtcbn1cbmZ1bmN0aW9uIGRvQ2xvbmUoc29tZXRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gY2xvbmVBcnJheShzb21ldGhpbmcpO1xuICB9XG4gIGlmIChzb21ldGhpbmcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gc29tZXRoaW5nO1xuICB9XG4gIGlmICh0eXBlb2Ygc29tZXRoaW5nID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGNsb25lT2JqKHNvbWV0aGluZyk7XG4gIH1cbiAgcmV0dXJuIHNvbWV0aGluZztcbn1cbmZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyKSB7XG4gIGxldCByID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByW2ldID0gZG9DbG9uZShhcnJbaV0pO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gY2xvbmVPYmoob2JqKSB7XG4gIGxldCByID0ge307XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICByW2tleV0gPSBkb0Nsb25lKG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGNvbnN0IGlkeCA9IH5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSB8fCB+cGF0aC5sYXN0SW5kZXhPZihcIlxcXFxcIik7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSBlbHNlIGlmICh+aWR4ID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUocGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGguc3Vic3RyKH5pZHggKyAxKTtcbiAgfVxufVxudmFyIENBUFRVUklOR19SRUdFWF9TT1VSQ0UgPSAvXFwkKFxcZCspfFxcJHsoXFxkKyk6XFwvKGRvd25jYXNlfHVwY2FzZSl9L2c7XG52YXIgUmVnZXhTb3VyY2UgPSBjbGFzcyB7XG4gIHN0YXRpYyBoYXNDYXB0dXJlcyhyZWdleFNvdXJjZSkge1xuICAgIGlmIChyZWdleFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDQVBUVVJJTkdfUkVHRVhfU09VUkNFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIENBUFRVUklOR19SRUdFWF9TT1VSQ0UudGVzdChyZWdleFNvdXJjZSk7XG4gIH1cbiAgc3RhdGljIHJlcGxhY2VDYXB0dXJlcyhyZWdleFNvdXJjZSwgY2FwdHVyZVNvdXJjZSwgY2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4gcmVnZXhTb3VyY2UucmVwbGFjZShDQVBUVVJJTkdfUkVHRVhfU09VUkNFLCAobWF0Y2gsIGluZGV4LCBjb21tYW5kSW5kZXgsIGNvbW1hbmQpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlID0gY2FwdHVyZUluZGljZXNbcGFyc2VJbnQoaW5kZXggfHwgY29tbWFuZEluZGV4LCAxMCldO1xuICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGNhcHR1cmVTb3VyY2Uuc3Vic3RyaW5nKGNhcHR1cmUuc3RhcnQsIGNhcHR1cmUuZW5kKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFswXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgIGNhc2UgXCJkb3duY2FzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGNhc2UgXCJ1cGNhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc3RyY21wKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3RyQXJyQ21wKGEsIGIpIHtcbiAgaWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICghYSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoIWIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgbGVuMSA9IGEubGVuZ3RoO1xuICBsZXQgbGVuMiA9IGIubGVuZ3RoO1xuICBpZiAobGVuMSA9PT0gbGVuMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgICBsZXQgcmVzID0gc3RyY21wKGFbaV0sIGJbaV0pO1xuICAgICAgaWYgKHJlcyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gbGVuMSAtIGxlbjI7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSGV4Q29sb3IoaGV4KSB7XG4gIGlmICgvXiNbMC05YS1mXXs2fSQvaS50ZXN0KGhleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoL14jWzAtOWEtZl17OH0kL2kudGVzdChoZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKC9eI1swLTlhLWZdezN9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgvXiNbMC05YS1mXXs0fSQvaS50ZXN0KGhleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxcXFxce1xcfVxcKlxcK1xcP1xcfFxcXlxcJFxcLlxcLFxcW1xcXVxcKFxcKVxcI1xcc10vZywgXCJcXFxcJCZcIik7XG59XG52YXIgQ2FjaGVkRm4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICB9XG4gIGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZ2V0KGtleSkge1xuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmZuKGtleSk7XG4gICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvdGhlbWUudHNcbnZhciBUaGVtZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2NvbG9yTWFwLCBfZGVmYXVsdHMsIF9yb290KSB7XG4gICAgdGhpcy5fY29sb3JNYXAgPSBfY29sb3JNYXA7XG4gICAgdGhpcy5fZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4gICAgdGhpcy5fcm9vdCA9IF9yb290O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVGcm9tUmF3VGhlbWUoc291cmNlLCBjb2xvck1hcCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUZyb21QYXJzZWRUaGVtZShwYXJzZVRoZW1lKHNvdXJjZSksIGNvbG9yTWFwKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlRnJvbVBhcnNlZFRoZW1lKHNvdXJjZSwgY29sb3JNYXApIHtcbiAgICByZXR1cm4gcmVzb2x2ZVBhcnNlZFRoZW1lUnVsZXMoc291cmNlLCBjb2xvck1hcCk7XG4gIH1cbiAgX2NhY2hlZE1hdGNoUm9vdCA9IG5ldyBDYWNoZWRGbihcbiAgICAoc2NvcGVOYW1lKSA9PiB0aGlzLl9yb290Lm1hdGNoKHNjb3BlTmFtZSlcbiAgKTtcbiAgZ2V0Q29sb3JNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwLmdldENvbG9yTWFwKCk7XG4gIH1cbiAgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzO1xuICB9XG4gIG1hdGNoKHNjb3BlUGF0aCkge1xuICAgIGlmIChzY29wZVBhdGggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cztcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVOYW1lID0gc2NvcGVQYXRoLnNjb3BlTmFtZTtcbiAgICBjb25zdCBtYXRjaGluZ1RyaWVFbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1hdGNoUm9vdC5nZXQoc2NvcGVOYW1lKTtcbiAgICBjb25zdCBlZmZlY3RpdmVSdWxlID0gbWF0Y2hpbmdUcmllRWxlbWVudHMuZmluZChcbiAgICAgICh2KSA9PiBfc2NvcGVQYXRoTWF0Y2hlc1BhcmVudFNjb3BlcyhzY29wZVBhdGgucGFyZW50LCB2LnBhcmVudFNjb3BlcylcbiAgICApO1xuICAgIGlmICghZWZmZWN0aXZlUnVsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3R5bGVBdHRyaWJ1dGVzKFxuICAgICAgZWZmZWN0aXZlUnVsZS5mb250U3R5bGUsXG4gICAgICBlZmZlY3RpdmVSdWxlLmZvcmVncm91bmQsXG4gICAgICBlZmZlY3RpdmVSdWxlLmJhY2tncm91bmRcbiAgICApO1xuICB9XG59O1xudmFyIFNjb3BlU3RhY2sgPSBjbGFzcyBfU2NvcGVTdGFjayB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgc2NvcGVOYW1lKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gIH1cbiAgc3RhdGljIHB1c2gocGF0aCwgc2NvcGVOYW1lcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzY29wZU5hbWVzKSB7XG4gICAgICBwYXRoID0gbmV3IF9TY29wZVN0YWNrKHBhdGgsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBzdGF0aWMgZnJvbSguLi5zZWdtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBfU2NvcGVTdGFjayhyZXN1bHQsIHNlZ21lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwdXNoKHNjb3BlTmFtZSkge1xuICAgIHJldHVybiBuZXcgX1Njb3BlU3RhY2sodGhpcywgc2NvcGVOYW1lKTtcbiAgfVxuICBnZXRTZWdtZW50cygpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0uc2NvcGVOYW1lKTtcbiAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcbiAgICB9XG4gICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNlZ21lbnRzKCkuam9pbihcIiBcIik7XG4gIH1cbiAgZXh0ZW5kcyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZXh0ZW5kcyhvdGhlcik7XG4gIH1cbiAgZ2V0RXh0ZW5zaW9uSWZEZWZpbmVkKGJhc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaXRlbSA9IHRoaXM7XG4gICAgd2hpbGUgKGl0ZW0gJiYgaXRlbSAhPT0gYmFzZSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbS5zY29wZU5hbWUpO1xuICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbSA9PT0gYmFzZSA/IHJlc3VsdC5yZXZlcnNlKCkgOiB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBfc2NvcGVQYXRoTWF0Y2hlc1BhcmVudFNjb3BlcyhzY29wZVBhdGgsIHBhcmVudFNjb3Blcykge1xuICBpZiAocGFyZW50U2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXJlbnRTY29wZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHNjb3BlUGF0dGVybiA9IHBhcmVudFNjb3Blc1tpbmRleF07XG4gICAgbGV0IHNjb3BlTXVzdE1hdGNoID0gZmFsc2U7XG4gICAgaWYgKHNjb3BlUGF0dGVybiA9PT0gXCI+XCIpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gcGFyZW50U2NvcGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc2NvcGVQYXR0ZXJuID0gcGFyZW50U2NvcGVzWysraW5kZXhdO1xuICAgICAgc2NvcGVNdXN0TWF0Y2ggPSB0cnVlO1xuICAgIH1cbiAgICB3aGlsZSAoc2NvcGVQYXRoKSB7XG4gICAgICBpZiAoX21hdGNoZXNTY29wZShzY29wZVBhdGguc2NvcGVOYW1lLCBzY29wZVBhdHRlcm4pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlTXVzdE1hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNjb3BlUGF0aCA9IHNjb3BlUGF0aC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICghc2NvcGVQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNjb3BlUGF0aCA9IHNjb3BlUGF0aC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBfbWF0Y2hlc1Njb3BlKHNjb3BlTmFtZSwgc2NvcGVQYXR0ZXJuKSB7XG4gIHJldHVybiBzY29wZVBhdHRlcm4gPT09IHNjb3BlTmFtZSB8fCBzY29wZU5hbWUuc3RhcnRzV2l0aChzY29wZVBhdHRlcm4pICYmIHNjb3BlTmFtZVtzY29wZVBhdHRlcm4ubGVuZ3RoXSA9PT0gXCIuXCI7XG59XG52YXIgU3R5bGVBdHRyaWJ1dGVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihmb250U3R5bGUsIGZvcmVncm91bmRJZCwgYmFja2dyb3VuZElkKSB7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgdGhpcy5mb3JlZ3JvdW5kSWQgPSBmb3JlZ3JvdW5kSWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kSWQgPSBiYWNrZ3JvdW5kSWQ7XG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZVRoZW1lKHNvdXJjZSkge1xuICBpZiAoIXNvdXJjZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIXNvdXJjZS5zZXR0aW5ncyB8fCAhQXJyYXkuaXNBcnJheShzb3VyY2Uuc2V0dGluZ3MpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCBzZXR0aW5ncyA9IHNvdXJjZS5zZXR0aW5ncztcbiAgbGV0IHJlc3VsdCA9IFtdLCByZXN1bHRMZW4gPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2V0dGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgZW50cnkgPSBzZXR0aW5nc1tpXTtcbiAgICBpZiAoIWVudHJ5LnNldHRpbmdzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHNjb3BlcztcbiAgICBpZiAodHlwZW9mIGVudHJ5LnNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsZXQgX3Njb3BlID0gZW50cnkuc2NvcGU7XG4gICAgICBfc2NvcGUgPSBfc2NvcGUucmVwbGFjZSgvXlssXSsvLCBcIlwiKTtcbiAgICAgIF9zY29wZSA9IF9zY29wZS5yZXBsYWNlKC9bLF0rJC8sIFwiXCIpO1xuICAgICAgc2NvcGVzID0gX3Njb3BlLnNwbGl0KFwiLFwiKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkuc2NvcGUpKSB7XG4gICAgICBzY29wZXMgPSBlbnRyeS5zY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcGVzID0gW1wiXCJdO1xuICAgIH1cbiAgICBsZXQgZm9udFN0eWxlID0gLTEgLyogTm90U2V0ICovO1xuICAgIGlmICh0eXBlb2YgZW50cnkuc2V0dGluZ3MuZm9udFN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb250U3R5bGUgPSAwIC8qIE5vbmUgKi87XG4gICAgICBsZXQgc2VnbWVudHMgPSBlbnRyeS5zZXR0aW5ncy5mb250U3R5bGUuc3BsaXQoXCIgXCIpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbkogPSBzZWdtZW50cy5sZW5ndGg7IGogPCBsZW5KOyBqKyspIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50c1tqXTtcbiAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XG4gICAgICAgICAgY2FzZSBcIml0YWxpY1wiOlxuICAgICAgICAgICAgZm9udFN0eWxlID0gZm9udFN0eWxlIHwgMSAvKiBJdGFsaWMgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYm9sZFwiOlxuICAgICAgICAgICAgZm9udFN0eWxlID0gZm9udFN0eWxlIHwgMiAvKiBCb2xkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInVuZGVybGluZVwiOlxuICAgICAgICAgICAgZm9udFN0eWxlID0gZm9udFN0eWxlIHwgNCAvKiBVbmRlcmxpbmUgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaWtldGhyb3VnaFwiOlxuICAgICAgICAgICAgZm9udFN0eWxlID0gZm9udFN0eWxlIHwgOCAvKiBTdHJpa2V0aHJvdWdoICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZvcmVncm91bmQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZW50cnkuc2V0dGluZ3MuZm9yZWdyb3VuZCA9PT0gXCJzdHJpbmdcIiAmJiBpc1ZhbGlkSGV4Q29sb3IoZW50cnkuc2V0dGluZ3MuZm9yZWdyb3VuZCkpIHtcbiAgICAgIGZvcmVncm91bmQgPSBlbnRyeS5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBsZXQgYmFja2dyb3VuZCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zZXR0aW5ncy5iYWNrZ3JvdW5kID09PSBcInN0cmluZ1wiICYmIGlzVmFsaWRIZXhDb2xvcihlbnRyeS5zZXR0aW5ncy5iYWNrZ3JvdW5kKSkge1xuICAgICAgYmFja2dyb3VuZCA9IGVudHJ5LnNldHRpbmdzLmJhY2tncm91bmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwLCBsZW5KID0gc2NvcGVzLmxlbmd0aDsgaiA8IGxlbko7IGorKykge1xuICAgICAgbGV0IF9zY29wZSA9IHNjb3Blc1tqXS50cmltKCk7XG4gICAgICBsZXQgc2VnbWVudHMgPSBfc2NvcGUuc3BsaXQoXCIgXCIpO1xuICAgICAgbGV0IHNjb3BlID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgcGFyZW50U2NvcGVzID0gbnVsbDtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcmVudFNjb3BlcyA9IHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICBwYXJlbnRTY29wZXMucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBQYXJzZWRUaGVtZVJ1bGUoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBwYXJlbnRTY29wZXMsXG4gICAgICAgIGksXG4gICAgICAgIGZvbnRTdHlsZSxcbiAgICAgICAgZm9yZWdyb3VuZCxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBQYXJzZWRUaGVtZVJ1bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlLCBwYXJlbnRTY29wZXMsIGluZGV4LCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5wYXJlbnRTY29wZXMgPSBwYXJlbnRTY29wZXM7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgfVxufTtcbnZhciBGb250U3R5bGUgPSAvKiBAX19QVVJFX18gKi8gKChGb250U3R5bGUyKSA9PiB7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIk5vdFNldFwiXSA9IC0xXSA9IFwiTm90U2V0XCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJJdGFsaWNcIl0gPSAxXSA9IFwiSXRhbGljXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIkJvbGRcIl0gPSAyXSA9IFwiQm9sZFwiO1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJVbmRlcmxpbmVcIl0gPSA0XSA9IFwiVW5kZXJsaW5lXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIlN0cmlrZXRocm91Z2hcIl0gPSA4XSA9IFwiU3RyaWtldGhyb3VnaFwiO1xuICByZXR1cm4gRm9udFN0eWxlMjtcbn0pKEZvbnRTdHlsZSB8fCB7fSk7XG5mdW5jdGlvbiByZXNvbHZlUGFyc2VkVGhlbWVSdWxlcyhwYXJzZWRUaGVtZVJ1bGVzLCBfY29sb3JNYXApIHtcbiAgcGFyc2VkVGhlbWVSdWxlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgbGV0IHIgPSBzdHJjbXAoYS5zY29wZSwgYi5zY29wZSk7XG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICByID0gc3RyQXJyQ21wKGEucGFyZW50U2NvcGVzLCBiLnBhcmVudFNjb3Blcyk7XG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gIH0pO1xuICBsZXQgZGVmYXVsdEZvbnRTdHlsZSA9IDAgLyogTm9uZSAqLztcbiAgbGV0IGRlZmF1bHRGb3JlZ3JvdW5kID0gXCIjMDAwMDAwXCI7XG4gIGxldCBkZWZhdWx0QmFja2dyb3VuZCA9IFwiI2ZmZmZmZlwiO1xuICB3aGlsZSAocGFyc2VkVGhlbWVSdWxlcy5sZW5ndGggPj0gMSAmJiBwYXJzZWRUaGVtZVJ1bGVzWzBdLnNjb3BlID09PSBcIlwiKSB7XG4gICAgbGV0IGluY29taW5nRGVmYXVsdHMgPSBwYXJzZWRUaGVtZVJ1bGVzLnNoaWZ0KCk7XG4gICAgaWYgKGluY29taW5nRGVmYXVsdHMuZm9udFN0eWxlICE9PSAtMSAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIGRlZmF1bHRGb250U3R5bGUgPSBpbmNvbWluZ0RlZmF1bHRzLmZvbnRTdHlsZTtcbiAgICB9XG4gICAgaWYgKGluY29taW5nRGVmYXVsdHMuZm9yZWdyb3VuZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdEZvcmVncm91bmQgPSBpbmNvbWluZ0RlZmF1bHRzLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGlmIChpbmNvbWluZ0RlZmF1bHRzLmJhY2tncm91bmQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRCYWNrZ3JvdW5kID0gaW5jb21pbmdEZWZhdWx0cy5iYWNrZ3JvdW5kO1xuICAgIH1cbiAgfVxuICBsZXQgY29sb3JNYXAgPSBuZXcgQ29sb3JNYXAoX2NvbG9yTWFwKTtcbiAgbGV0IGRlZmF1bHRzID0gbmV3IFN0eWxlQXR0cmlidXRlcyhkZWZhdWx0Rm9udFN0eWxlLCBjb2xvck1hcC5nZXRJZChkZWZhdWx0Rm9yZWdyb3VuZCksIGNvbG9yTWFwLmdldElkKGRlZmF1bHRCYWNrZ3JvdW5kKSk7XG4gIGxldCByb290ID0gbmV3IFRoZW1lVHJpZUVsZW1lbnQobmV3IFRoZW1lVHJpZUVsZW1lbnRSdWxlKDAsIG51bGwsIC0xIC8qIE5vdFNldCAqLywgMCwgMCksIFtdKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnNlZFRoZW1lUnVsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgcnVsZSA9IHBhcnNlZFRoZW1lUnVsZXNbaV07XG4gICAgcm9vdC5pbnNlcnQoMCwgcnVsZS5zY29wZSwgcnVsZS5wYXJlbnRTY29wZXMsIHJ1bGUuZm9udFN0eWxlLCBjb2xvck1hcC5nZXRJZChydWxlLmZvcmVncm91bmQpLCBjb2xvck1hcC5nZXRJZChydWxlLmJhY2tncm91bmQpKTtcbiAgfVxuICByZXR1cm4gbmV3IFRoZW1lKGNvbG9yTWFwLCBkZWZhdWx0cywgcm9vdCk7XG59XG52YXIgQ29sb3JNYXAgPSBjbGFzcyB7XG4gIF9pc0Zyb3plbjtcbiAgX2xhc3RDb2xvcklkO1xuICBfaWQyY29sb3I7XG4gIF9jb2xvcjJpZDtcbiAgY29uc3RydWN0b3IoX2NvbG9yTWFwKSB7XG4gICAgdGhpcy5fbGFzdENvbG9ySWQgPSAwO1xuICAgIHRoaXMuX2lkMmNvbG9yID0gW107XG4gICAgdGhpcy5fY29sb3IyaWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfY29sb3JNYXApKSB7XG4gICAgICB0aGlzLl9pc0Zyb3plbiA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gX2NvbG9yTWFwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yMmlkW19jb2xvck1hcFtpXV0gPSBpO1xuICAgICAgICB0aGlzLl9pZDJjb2xvcltpXSA9IF9jb2xvck1hcFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNGcm96ZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0SWQoY29sb3IpIHtcbiAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb2xvciA9IGNvbG9yLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5fY29sb3IyaWRbY29sb3JdO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNGcm96ZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBjb2xvciBpbiBjb2xvciBtYXAgLSAke2NvbG9yfWApO1xuICAgIH1cbiAgICB2YWx1ZSA9ICsrdGhpcy5fbGFzdENvbG9ySWQ7XG4gICAgdGhpcy5fY29sb3IyaWRbY29sb3JdID0gdmFsdWU7XG4gICAgdGhpcy5faWQyY29sb3JbdmFsdWVdID0gY29sb3I7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldENvbG9yTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDJjb2xvci5zbGljZSgwKTtcbiAgfVxufTtcbnZhciBlbXB0eVBhcmVudFNjb3BlcyA9IE9iamVjdC5mcmVlemUoW10pO1xudmFyIFRoZW1lVHJpZUVsZW1lbnRSdWxlID0gY2xhc3MgX1RoZW1lVHJpZUVsZW1lbnRSdWxlIHtcbiAgc2NvcGVEZXB0aDtcbiAgcGFyZW50U2NvcGVzO1xuICBmb250U3R5bGU7XG4gIGZvcmVncm91bmQ7XG4gIGJhY2tncm91bmQ7XG4gIGNvbnN0cnVjdG9yKHNjb3BlRGVwdGgsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgdGhpcy5zY29wZURlcHRoID0gc2NvcGVEZXB0aDtcbiAgICB0aGlzLnBhcmVudFNjb3BlcyA9IHBhcmVudFNjb3BlcyB8fCBlbXB0eVBhcmVudFNjb3BlcztcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGhlbWVUcmllRWxlbWVudFJ1bGUodGhpcy5zY29wZURlcHRoLCB0aGlzLnBhcmVudFNjb3BlcywgdGhpcy5mb250U3R5bGUsIHRoaXMuZm9yZWdyb3VuZCwgdGhpcy5iYWNrZ3JvdW5kKTtcbiAgfVxuICBzdGF0aWMgY2xvbmVBcnIoYXJyKSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByW2ldID0gYXJyW2ldLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGFjY2VwdE92ZXJ3cml0ZShzY29wZURlcHRoLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICBpZiAodGhpcy5zY29wZURlcHRoID4gc2NvcGVEZXB0aCkge1xuICAgICAgY29uc29sZS5sb2coXCJob3cgZGlkIHRoaXMgaGFwcGVuP1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZURlcHRoID0gc2NvcGVEZXB0aDtcbiAgICB9XG4gICAgaWYgKGZvbnRTdHlsZSAhPT0gLTEgLyogTm90U2V0ICovKSB7XG4gICAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB9XG4gICAgaWYgKGZvcmVncm91bmQgIT09IDApIHtcbiAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG4gICAgfVxuICAgIGlmIChiYWNrZ3JvdW5kICE9PSAwKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH1cbiAgfVxufTtcbnZhciBUaGVtZVRyaWVFbGVtZW50ID0gY2xhc3MgX1RoZW1lVHJpZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihfbWFpblJ1bGUsIHJ1bGVzV2l0aFBhcmVudFNjb3BlcyA9IFtdLCBfY2hpbGRyZW4gPSB7fSkge1xuICAgIHRoaXMuX21haW5SdWxlID0gX21haW5SdWxlO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gX2NoaWxkcmVuO1xuICAgIHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3BlcyA9IHJ1bGVzV2l0aFBhcmVudFNjb3BlcztcbiAgfVxuICBfcnVsZXNXaXRoUGFyZW50U2NvcGVzO1xuICBzdGF0aWMgX2NtcEJ5U3BlY2lmaWNpdHkoYSwgYikge1xuICAgIGlmIChhLnNjb3BlRGVwdGggIT09IGIuc2NvcGVEZXB0aCkge1xuICAgICAgcmV0dXJuIGIuc2NvcGVEZXB0aCAtIGEuc2NvcGVEZXB0aDtcbiAgICB9XG4gICAgbGV0IGFQYXJlbnRJbmRleCA9IDA7XG4gICAgbGV0IGJQYXJlbnRJbmRleCA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChhLnBhcmVudFNjb3Blc1thUGFyZW50SW5kZXhdID09PSBcIj5cIikge1xuICAgICAgICBhUGFyZW50SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChiLnBhcmVudFNjb3Blc1tiUGFyZW50SW5kZXhdID09PSBcIj5cIikge1xuICAgICAgICBiUGFyZW50SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChhUGFyZW50SW5kZXggPj0gYS5wYXJlbnRTY29wZXMubGVuZ3RoIHx8IGJQYXJlbnRJbmRleCA+PSBiLnBhcmVudFNjb3Blcy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnRTY29wZUxlbmd0aERpZmYgPSBiLnBhcmVudFNjb3Blc1tiUGFyZW50SW5kZXhdLmxlbmd0aCAtIGEucGFyZW50U2NvcGVzW2FQYXJlbnRJbmRleF0ubGVuZ3RoO1xuICAgICAgaWYgKHBhcmVudFNjb3BlTGVuZ3RoRGlmZiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyZW50U2NvcGVMZW5ndGhEaWZmO1xuICAgICAgfVxuICAgICAgYVBhcmVudEluZGV4Kys7XG4gICAgICBiUGFyZW50SW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGIucGFyZW50U2NvcGVzLmxlbmd0aCAtIGEucGFyZW50U2NvcGVzLmxlbmd0aDtcbiAgfVxuICBtYXRjaChzY29wZSkge1xuICAgIGlmIChzY29wZSAhPT0gXCJcIikge1xuICAgICAgbGV0IGRvdEluZGV4ID0gc2NvcGUuaW5kZXhPZihcIi5cIik7XG4gICAgICBsZXQgaGVhZDtcbiAgICAgIGxldCB0YWlsO1xuICAgICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgICBoZWFkID0gc2NvcGU7XG4gICAgICAgIHRhaWwgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZCA9IHNjb3BlLnN1YnN0cmluZygwLCBkb3RJbmRleCk7XG4gICAgICAgIHRhaWwgPSBzY29wZS5zdWJzdHJpbmcoZG90SW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShoZWFkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baGVhZF0ubWF0Y2godGFpbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzLmNvbmNhdCh0aGlzLl9tYWluUnVsZSk7XG4gICAgcnVsZXMuc29ydChfVGhlbWVUcmllRWxlbWVudC5fY21wQnlTcGVjaWZpY2l0eSk7XG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG4gIGluc2VydChzY29wZURlcHRoLCBzY29wZSwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICBpZiAoc2NvcGUgPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX2RvSW5zZXJ0SGVyZShzY29wZURlcHRoLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb3RJbmRleCA9IHNjb3BlLmluZGV4T2YoXCIuXCIpO1xuICAgIGxldCBoZWFkO1xuICAgIGxldCB0YWlsO1xuICAgIGlmIChkb3RJbmRleCA9PT0gLTEpIHtcbiAgICAgIGhlYWQgPSBzY29wZTtcbiAgICAgIHRhaWwgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gc2NvcGUuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICAgIHRhaWwgPSBzY29wZS5zdWJzdHJpbmcoZG90SW5kZXggKyAxKTtcbiAgICB9XG4gICAgbGV0IGNoaWxkO1xuICAgIGlmICh0aGlzLl9jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShoZWFkKSkge1xuICAgICAgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltoZWFkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBuZXcgX1RoZW1lVHJpZUVsZW1lbnQodGhpcy5fbWFpblJ1bGUuY2xvbmUoKSwgVGhlbWVUcmllRWxlbWVudFJ1bGUuY2xvbmVBcnIodGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzKSk7XG4gICAgICB0aGlzLl9jaGlsZHJlbltoZWFkXSA9IGNoaWxkO1xuICAgIH1cbiAgICBjaGlsZC5pbnNlcnQoc2NvcGVEZXB0aCArIDEsIHRhaWwsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgfVxuICBfZG9JbnNlcnRIZXJlKHNjb3BlRGVwdGgsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgaWYgKHBhcmVudFNjb3BlcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fbWFpblJ1bGUuYWNjZXB0T3ZlcndyaXRlKHNjb3BlRGVwdGgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBydWxlID0gdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzW2ldO1xuICAgICAgaWYgKHN0ckFyckNtcChydWxlLnBhcmVudFNjb3BlcywgcGFyZW50U2NvcGVzKSA9PT0gMCkge1xuICAgICAgICBydWxlLmFjY2VwdE92ZXJ3cml0ZShzY29wZURlcHRoLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb250U3R5bGUgPT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgZm9udFN0eWxlID0gdGhpcy5fbWFpblJ1bGUuZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoZm9yZWdyb3VuZCA9PT0gMCkge1xuICAgICAgZm9yZWdyb3VuZCA9IHRoaXMuX21haW5SdWxlLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGlmIChiYWNrZ3JvdW5kID09PSAwKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gdGhpcy5fbWFpblJ1bGUuYmFja2dyb3VuZDtcbiAgICB9XG4gICAgdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzLnB1c2gobmV3IFRoZW1lVHJpZUVsZW1lbnRSdWxlKHNjb3BlRGVwdGgsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLnRzXG52YXIgRW5jb2RlZFRva2VuTWV0YWRhdGEgPSBjbGFzcyBfRW5jb2RlZFRva2VuTWV0YWRhdGEge1xuICBzdGF0aWMgdG9CaW5hcnlTdHIoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiBlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDMyLCBcIjBcIik7XG4gIH1cbiAgc3RhdGljIHByaW50KGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBsYW5ndWFnZUlkID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldExhbmd1YWdlSWQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldFRva2VuVHlwZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBmb250U3R5bGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9udFN0eWxlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGZvcmVncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEJhY2tncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc29sZS5sb2coe1xuICAgICAgbGFuZ3VhZ2VJZCxcbiAgICAgIHRva2VuVHlwZSxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvcmVncm91bmQsXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldExhbmd1YWdlSWQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDI1NSAvKiBMQU5HVUFHRUlEX01BU0sgKi8pID4+PiAwIC8qIExBTkdVQUdFSURfT0ZGU0VUICovO1xuICB9XG4gIHN0YXRpYyBnZXRUb2tlblR5cGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDc2OCAvKiBUT0tFTl9UWVBFX01BU0sgKi8pID4+PiA4IC8qIFRPS0VOX1RZUEVfT0ZGU0VUICovO1xuICB9XG4gIHN0YXRpYyBjb250YWluc0JhbGFuY2VkQnJhY2tldHMoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDEwMjQgLyogQkFMQU5DRURfQlJBQ0tFVFNfTUFTSyAqLykgIT09IDA7XG4gIH1cbiAgc3RhdGljIGdldEZvbnRTdHlsZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMzA3MjAgLyogRk9OVF9TVFlMRV9NQVNLICovKSA+Pj4gMTEgLyogRk9OVF9TVFlMRV9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGdldEZvcmVncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDE2NzQ0NDQ4IC8qIEZPUkVHUk9VTkRfTUFTSyAqLykgPj4+IDE1IC8qIEZPUkVHUk9VTkRfT0ZGU0VUICovO1xuICB9XG4gIHN0YXRpYyBnZXRCYWNrZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiA0Mjc4MTkwMDgwIC8qIEJBQ0tHUk9VTkRfTUFTSyAqLykgPj4+IDI0IC8qIEJBQ0tHUk9VTkRfT0ZGU0VUICovO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmaWVsZHMgaW4gYG1ldGFkYXRhYC5cbiAgICogQSB2YWx1ZSBvZiBgMGAsIGBOb3RTZXRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZCBzaG91bGQgYmUgbGVmdCBhcyBpcy5cbiAgICovXG4gIHN0YXRpYyBzZXQoZW5jb2RlZFRva2VuQXR0cmlidXRlcywgbGFuZ3VhZ2VJZCwgdG9rZW5UeXBlLCBjb250YWluc0JhbGFuY2VkQnJhY2tldHMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGxldCBfbGFuZ3VhZ2VJZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRMYW5ndWFnZUlkKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGxldCBfdG9rZW5UeXBlID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldFRva2VuVHlwZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX2NvbnRhaW5zQmFsYW5jZWRCcmFja2V0c0JpdCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5jb250YWluc0JhbGFuY2VkQnJhY2tldHMoZW5jb2RlZFRva2VuQXR0cmlidXRlcykgPyAxIDogMDtcbiAgICBsZXQgX2ZvbnRTdHlsZSA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgbGV0IF9mb3JlZ3JvdW5kID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvcmVncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgbGV0IF9iYWNrZ3JvdW5kID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEJhY2tncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgaWYgKGxhbmd1YWdlSWQgIT09IDApIHtcbiAgICAgIF9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICB9XG4gICAgaWYgKHRva2VuVHlwZSAhPT0gOCAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIF90b2tlblR5cGUgPSBmcm9tT3B0aW9uYWxUb2tlblR5cGUodG9rZW5UeXBlKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyAhPT0gbnVsbCkge1xuICAgICAgX2NvbnRhaW5zQmFsYW5jZWRCcmFja2V0c0JpdCA9IGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyA/IDEgOiAwO1xuICAgIH1cbiAgICBpZiAoZm9udFN0eWxlICE9PSAtMSAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIF9mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgfVxuICAgIGlmIChmb3JlZ3JvdW5kICE9PSAwKSB7XG4gICAgICBfZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG4gICAgfVxuICAgIGlmIChiYWNrZ3JvdW5kICE9PSAwKSB7XG4gICAgICBfYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfVxuICAgIHJldHVybiAoX2xhbmd1YWdlSWQgPDwgMCAvKiBMQU5HVUFHRUlEX09GRlNFVCAqLyB8IF90b2tlblR5cGUgPDwgOCAvKiBUT0tFTl9UWVBFX09GRlNFVCAqLyB8IF9jb250YWluc0JhbGFuY2VkQnJhY2tldHNCaXQgPDwgMTAgLyogQkFMQU5DRURfQlJBQ0tFVFNfT0ZGU0VUICovIHwgX2ZvbnRTdHlsZSA8PCAxMSAvKiBGT05UX1NUWUxFX09GRlNFVCAqLyB8IF9mb3JlZ3JvdW5kIDw8IDE1IC8qIEZPUkVHUk9VTkRfT0ZGU0VUICovIHwgX2JhY2tncm91bmQgPDwgMjQgLyogQkFDS0dST1VORF9PRkZTRVQgKi8pID4+PiAwO1xuICB9XG59O1xuZnVuY3Rpb24gdG9PcHRpb25hbFRva2VuVHlwZShzdGFuZGFyZFR5cGUpIHtcbiAgcmV0dXJuIHN0YW5kYXJkVHlwZTtcbn1cbmZ1bmN0aW9uIGZyb21PcHRpb25hbFRva2VuVHlwZShzdGFuZGFyZFR5cGUpIHtcbiAgcmV0dXJuIHN0YW5kYXJkVHlwZTtcbn1cblxuLy8gc3JjL21hdGNoZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBtYXRjaGVzTmFtZSkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IHRva2VuaXplciA9IG5ld1Rva2VuaXplcihzZWxlY3Rvcik7XG4gIGxldCB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gIHdoaWxlICh0b2tlbiAhPT0gbnVsbCkge1xuICAgIGxldCBwcmlvcml0eSA9IDA7XG4gICAgaWYgKHRva2VuLmxlbmd0aCA9PT0gMiAmJiB0b2tlbi5jaGFyQXQoMSkgPT09IFwiOlwiKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgIHByaW9yaXR5ID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICBwcmlvcml0eSA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUubG9nKGBVbmtub3duIHByaW9yaXR5ICR7dG9rZW59IGluIHNjb3BlIHNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgfVxuICAgIGxldCBtYXRjaGVyID0gcGFyc2VDb25qdW5jdGlvbigpO1xuICAgIHJlc3VsdHMucHVzaCh7IG1hdGNoZXIsIHByaW9yaXR5IH0pO1xuICAgIGlmICh0b2tlbiAhPT0gXCIsXCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG4gIGZ1bmN0aW9uIHBhcnNlT3BlcmFuZCgpIHtcbiAgICBpZiAodG9rZW4gPT09IFwiLVwiKSB7XG4gICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICBjb25zdCBleHByZXNzaW9uVG9OZWdhdGUgPSBwYXJzZU9wZXJhbmQoKTtcbiAgICAgIHJldHVybiAobWF0Y2hlcklucHV0KSA9PiAhIWV4cHJlc3Npb25Ub05lZ2F0ZSAmJiAhZXhwcmVzc2lvblRvTmVnYXRlKG1hdGNoZXJJbnB1dCk7XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25JblBhcmVudHMgPSBwYXJzZUlubmVyRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHRva2VuID09PSBcIilcIikge1xuICAgICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbkluUGFyZW50cztcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllcih0b2tlbikpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgICBkbyB7XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICB9IHdoaWxlIChpc0lkZW50aWZpZXIodG9rZW4pKTtcbiAgICAgIHJldHVybiAobWF0Y2hlcklucHV0KSA9PiBtYXRjaGVzTmFtZShpZGVudGlmaWVycywgbWF0Y2hlcklucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VDb25qdW5jdGlvbigpIHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGxldCBtYXRjaGVyID0gcGFyc2VPcGVyYW5kKCk7XG4gICAgd2hpbGUgKG1hdGNoZXIpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICBtYXRjaGVyID0gcGFyc2VPcGVyYW5kKCk7XG4gICAgfVxuICAgIHJldHVybiAobWF0Y2hlcklucHV0KSA9PiBtYXRjaGVycy5ldmVyeSgobWF0Y2hlcjIpID0+IG1hdGNoZXIyKG1hdGNoZXJJbnB1dCkpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSW5uZXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gW107XG4gICAgbGV0IG1hdGNoZXIgPSBwYXJzZUNvbmp1bmN0aW9uKCk7XG4gICAgd2hpbGUgKG1hdGNoZXIpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICBpZiAodG9rZW4gPT09IFwifFwiIHx8IHRva2VuID09PSBcIixcIikge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgICB9IHdoaWxlICh0b2tlbiA9PT0gXCJ8XCIgfHwgdG9rZW4gPT09IFwiLFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF0Y2hlciA9IHBhcnNlQ29uanVuY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+IG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIyKSA9PiBtYXRjaGVyMihtYXRjaGVySW5wdXQpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHRva2VuKSB7XG4gIHJldHVybiAhIXRva2VuICYmICEhdG9rZW4ubWF0Y2goL1tcXHdcXC46XSsvKTtcbn1cbmZ1bmN0aW9uIG5ld1Rva2VuaXplcihpbnB1dCkge1xuICBsZXQgcmVnZXggPSAvKFtMUl06fFtcXHdcXC46XVtcXHdcXC46XFwtXSp8W1xcLFxcfFxcLVxcKFxcKV0pL2c7XG4gIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoaW5wdXQpO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICgpID0+IHtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSBtYXRjaFswXTtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL29uaWdMaWIudHNcbnZhciBGaW5kT3B0aW9uID0gLyogQF9fUFVSRV9fICovICgoRmluZE9wdGlvbjIpID0+IHtcbiAgRmluZE9wdGlvbjJbRmluZE9wdGlvbjJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgRmluZE9wdGlvbjJbRmluZE9wdGlvbjJbXCJOb3RCZWdpblN0cmluZ1wiXSA9IDFdID0gXCJOb3RCZWdpblN0cmluZ1wiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vdEVuZFN0cmluZ1wiXSA9IDJdID0gXCJOb3RFbmRTdHJpbmdcIjtcbiAgRmluZE9wdGlvbjJbRmluZE9wdGlvbjJbXCJOb3RCZWdpblBvc2l0aW9uXCJdID0gNF0gPSBcIk5vdEJlZ2luUG9zaXRpb25cIjtcbiAgRmluZE9wdGlvbjJbRmluZE9wdGlvbjJbXCJEZWJ1Z0NhbGxcIl0gPSA4XSA9IFwiRGVidWdDYWxsXCI7XG4gIHJldHVybiBGaW5kT3B0aW9uMjtcbn0pKEZpbmRPcHRpb24gfHwge30pO1xuZnVuY3Rpb24gZGlzcG9zZU9uaWdTdHJpbmcoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyLmRpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0ci5kaXNwb3NlKCk7XG4gIH1cbn1cblxuLy8gc3JjL2dyYW1tYXIvZ3JhbW1hckRlcGVuZGVuY2llcy50c1xudmFyIFRvcExldmVsUnVsZVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGVOYW1lKSB7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gIH1cbiAgdG9LZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVOYW1lO1xuICB9XG59O1xudmFyIFRvcExldmVsUmVwb3NpdG9yeVJ1bGVSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSwgcnVsZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cbiAgdG9LZXkoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuc2NvcGVOYW1lfSMke3RoaXMucnVsZU5hbWV9YDtcbiAgfVxufTtcbnZhciBFeHRlcm5hbFJlZmVyZW5jZUNvbGxlY3RvciA9IGNsYXNzIHtcbiAgX3JlZmVyZW5jZXMgPSBbXTtcbiAgX3NlZW5SZWZlcmVuY2VLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZ2V0IHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZXM7XG4gIH1cbiAgdmlzaXRlZFJ1bGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBhZGQocmVmZXJlbmNlKSB7XG4gICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlLnRvS2V5KCk7XG4gICAgaWYgKHRoaXMuX3NlZW5SZWZlcmVuY2VLZXlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NlZW5SZWZlcmVuY2VLZXlzLmFkZChrZXkpO1xuICAgIHRoaXMuX3JlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICB9XG59O1xudmFyIFNjb3BlRGVwZW5kZW5jeVByb2Nlc3NvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVwbywgaW5pdGlhbFNjb3BlTmFtZSkge1xuICAgIHRoaXMucmVwbyA9IHJlcG87XG4gICAgdGhpcy5pbml0aWFsU2NvcGVOYW1lID0gaW5pdGlhbFNjb3BlTmFtZTtcbiAgICB0aGlzLnNlZW5GdWxsU2NvcGVSZXF1ZXN0cy5hZGQodGhpcy5pbml0aWFsU2NvcGVOYW1lKTtcbiAgICB0aGlzLlEgPSBbbmV3IFRvcExldmVsUnVsZVJlZmVyZW5jZSh0aGlzLmluaXRpYWxTY29wZU5hbWUpXTtcbiAgfVxuICBzZWVuRnVsbFNjb3BlUmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBzZWVuUGFydGlhbFNjb3BlUmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBRO1xuICBwcm9jZXNzUXVldWUoKSB7XG4gICAgY29uc3QgcSA9IHRoaXMuUTtcbiAgICB0aGlzLlEgPSBbXTtcbiAgICBjb25zdCBkZXBzID0gbmV3IEV4dGVybmFsUmVmZXJlbmNlQ29sbGVjdG9yKCk7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgcSkge1xuICAgICAgY29sbGVjdFJlZmVyZW5jZXNPZlJlZmVyZW5jZShkZXAsIHRoaXMuaW5pdGlhbFNjb3BlTmFtZSwgdGhpcy5yZXBvLCBkZXBzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcy5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAoZGVwIGluc3RhbmNlb2YgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZW5GdWxsU2NvcGVSZXF1ZXN0cy5oYXMoZGVwLnNjb3BlTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZW5GdWxsU2NvcGVSZXF1ZXN0cy5hZGQoZGVwLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMuUS5wdXNoKGRlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zZWVuRnVsbFNjb3BlUmVxdWVzdHMuaGFzKGRlcC5zY29wZU5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VlblBhcnRpYWxTY29wZVJlcXVlc3RzLmhhcyhkZXAudG9LZXkoKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZW5QYXJ0aWFsU2NvcGVSZXF1ZXN0cy5hZGQoZGVwLnRvS2V5KCkpO1xuICAgICAgICB0aGlzLlEucHVzaChkZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNvbGxlY3RSZWZlcmVuY2VzT2ZSZWZlcmVuY2UocmVmZXJlbmNlLCBiYXNlR3JhbW1hclNjb3BlTmFtZSwgcmVwbywgcmVzdWx0KSB7XG4gIGNvbnN0IHNlbGZHcmFtbWFyID0gcmVwby5sb29rdXAocmVmZXJlbmNlLnNjb3BlTmFtZSk7XG4gIGlmICghc2VsZkdyYW1tYXIpIHtcbiAgICBpZiAocmVmZXJlbmNlLnNjb3BlTmFtZSA9PT0gYmFzZUdyYW1tYXJTY29wZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZ3JhbW1hciBwcm92aWRlZCBmb3IgPCR7YmFzZUdyYW1tYXJTY29wZU5hbWV9PmApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYmFzZUdyYW1tYXIgPSByZXBvLmxvb2t1cChiYXNlR3JhbW1hclNjb3BlTmFtZSk7XG4gIGlmIChyZWZlcmVuY2UgaW5zdGFuY2VvZiBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UpIHtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoeyBiYXNlR3JhbW1hciwgc2VsZkdyYW1tYXIgfSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJlcG9zaXRvcnlSdWxlKFxuICAgICAgcmVmZXJlbmNlLnJ1bGVOYW1lLFxuICAgICAgeyBiYXNlR3JhbW1hciwgc2VsZkdyYW1tYXIsIHJlcG9zaXRvcnk6IHNlbGZHcmFtbWFyLnJlcG9zaXRvcnkgfSxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cbiAgY29uc3QgaW5qZWN0aW9ucyA9IHJlcG8uaW5qZWN0aW9ucyhyZWZlcmVuY2Uuc2NvcGVOYW1lKTtcbiAgaWYgKGluamVjdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGluamVjdGlvbiBvZiBpbmplY3Rpb25zKSB7XG4gICAgICByZXN1bHQuYWRkKG5ldyBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UoaW5qZWN0aW9uKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJlcG9zaXRvcnlSdWxlKHJ1bGVOYW1lLCBjb250ZXh0LCByZXN1bHQpIHtcbiAgaWYgKGNvbnRleHQucmVwb3NpdG9yeSAmJiBjb250ZXh0LnJlcG9zaXRvcnlbcnVsZU5hbWVdKSB7XG4gICAgY29uc3QgcnVsZSA9IGNvbnRleHQucmVwb3NpdG9yeVtydWxlTmFtZV07XG4gICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luUnVsZXMoW3J1bGVdLCBjb250ZXh0LCByZXN1bHQpO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoY29udGV4dCwgcmVzdWx0KSB7XG4gIGlmIChjb250ZXh0LnNlbGZHcmFtbWFyLnBhdHRlcm5zICYmIEFycmF5LmlzQXJyYXkoY29udGV4dC5zZWxmR3JhbW1hci5wYXR0ZXJucykpIHtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhcbiAgICAgIGNvbnRleHQuc2VsZkdyYW1tYXIucGF0dGVybnMsXG4gICAgICB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IGNvbnRleHQuc2VsZkdyYW1tYXIucmVwb3NpdG9yeSB9LFxuICAgICAgcmVzdWx0XG4gICAgKTtcbiAgfVxuICBpZiAoY29udGV4dC5zZWxmR3JhbW1hci5pbmplY3Rpb25zKSB7XG4gICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luUnVsZXMoXG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuc2VsZkdyYW1tYXIuaW5qZWN0aW9ucyksXG4gICAgICB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IGNvbnRleHQuc2VsZkdyYW1tYXIucmVwb3NpdG9yeSB9LFxuICAgICAgcmVzdWx0XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luUnVsZXMocnVsZXMsIGNvbnRleHQsIHJlc3VsdCkge1xuICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICBpZiAocmVzdWx0LnZpc2l0ZWRSdWxlLmhhcyhydWxlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC52aXNpdGVkUnVsZS5hZGQocnVsZSk7XG4gICAgY29uc3QgcGF0dGVyblJlcG9zaXRvcnkgPSBydWxlLnJlcG9zaXRvcnkgPyBtZXJnZU9iamVjdHMoe30sIGNvbnRleHQucmVwb3NpdG9yeSwgcnVsZS5yZXBvc2l0b3J5KSA6IGNvbnRleHQucmVwb3NpdG9yeTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlLnBhdHRlcm5zKSkge1xuICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luUnVsZXMocnVsZS5wYXR0ZXJucywgeyAuLi5jb250ZXh0LCByZXBvc2l0b3J5OiBwYXR0ZXJuUmVwb3NpdG9yeSB9LCByZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlID0gcnVsZS5pbmNsdWRlO1xuICAgIGlmICghaW5jbHVkZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHJlZmVyZW5jZSA9IHBhcnNlSW5jbHVkZShpbmNsdWRlKTtcbiAgICBzd2l0Y2ggKHJlZmVyZW5jZS5raW5kKSB7XG4gICAgICBjYXNlIDAgLyogQmFzZSAqLzpcbiAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKHsgLi4uY29udGV4dCwgc2VsZkdyYW1tYXI6IGNvbnRleHQuYmFzZUdyYW1tYXIgfSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogU2VsZiAqLzpcbiAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIFJlbGF0aXZlUmVmZXJlbmNlICovOlxuICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJlcG9zaXRvcnlSdWxlKHJlZmVyZW5jZS5ydWxlTmFtZSwgeyAuLi5jb250ZXh0LCByZXBvc2l0b3J5OiBwYXR0ZXJuUmVwb3NpdG9yeSB9LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBUb3BMZXZlbFJlZmVyZW5jZSAqLzpcbiAgICAgIGNhc2UgNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi86XG4gICAgICAgIGNvbnN0IHNlbGZHcmFtbWFyID0gcmVmZXJlbmNlLnNjb3BlTmFtZSA9PT0gY29udGV4dC5zZWxmR3JhbW1hci5zY29wZU5hbWUgPyBjb250ZXh0LnNlbGZHcmFtbWFyIDogcmVmZXJlbmNlLnNjb3BlTmFtZSA9PT0gY29udGV4dC5iYXNlR3JhbW1hci5zY29wZU5hbWUgPyBjb250ZXh0LmJhc2VHcmFtbWFyIDogdm9pZCAwO1xuICAgICAgICBpZiAoc2VsZkdyYW1tYXIpIHtcbiAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0geyBiYXNlR3JhbW1hcjogY29udGV4dC5iYXNlR3JhbW1hciwgc2VsZkdyYW1tYXIsIHJlcG9zaXRvcnk6IHBhdHRlcm5SZXBvc2l0b3J5IH07XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZS5raW5kID09PSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLykge1xuICAgICAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZShyZWZlcmVuY2UucnVsZU5hbWUsIG5ld0NvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZShuZXdDb250ZXh0LCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlLmtpbmQgPT09IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKG5ldyBUb3BMZXZlbFJlcG9zaXRvcnlSdWxlUmVmZXJlbmNlKHJlZmVyZW5jZS5zY29wZU5hbWUsIHJlZmVyZW5jZS5ydWxlTmFtZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKG5ldyBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UocmVmZXJlbmNlLnNjb3BlTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbnZhciBCYXNlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBraW5kID0gMCAvKiBCYXNlICovO1xufTtcbnZhciBTZWxmUmVmZXJlbmNlID0gY2xhc3Mge1xuICBraW5kID0gMSAvKiBTZWxmICovO1xufTtcbnZhciBSZWxhdGl2ZVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWUpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cbiAga2luZCA9IDIgLyogUmVsYXRpdmVSZWZlcmVuY2UgKi87XG59O1xudmFyIFRvcExldmVsUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgfVxuICBraW5kID0gMyAvKiBUb3BMZXZlbFJlZmVyZW5jZSAqLztcbn07XG52YXIgVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZU5hbWUsIHJ1bGVOYW1lKSB7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIGtpbmQgPSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLztcbn07XG5mdW5jdGlvbiBwYXJzZUluY2x1ZGUoaW5jbHVkZSkge1xuICBpZiAoaW5jbHVkZSA9PT0gXCIkYmFzZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNlUmVmZXJlbmNlKCk7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZSA9PT0gXCIkc2VsZlwiKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxmUmVmZXJlbmNlKCk7XG4gIH1cbiAgY29uc3QgaW5kZXhPZlNoYXJwID0gaW5jbHVkZS5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGluZGV4T2ZTaGFycCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbmV3IFRvcExldmVsUmVmZXJlbmNlKGluY2x1ZGUpO1xuICB9IGVsc2UgaWYgKGluZGV4T2ZTaGFycCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVSZWZlcmVuY2UoaW5jbHVkZS5zdWJzdHJpbmcoMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNjb3BlTmFtZSA9IGluY2x1ZGUuc3Vic3RyaW5nKDAsIGluZGV4T2ZTaGFycCk7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBpbmNsdWRlLnN1YnN0cmluZyhpbmRleE9mU2hhcnAgKyAxKTtcbiAgICByZXR1cm4gbmV3IFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZShzY29wZU5hbWUsIHJ1bGVOYW1lKTtcbiAgfVxufVxuXG4vLyBzcmMvcnVsZS50c1xudmFyIEhBU19CQUNLX1JFRkVSRU5DRVMgPSAvXFxcXChcXGQrKS87XG52YXIgQkFDS19SRUZFUkVOQ0lOR19FTkQgPSAvXFxcXChcXGQrKS9nO1xudmFyIHJ1bGVJZFN5bWJvbCA9IFN5bWJvbChcIlJ1bGVJZFwiKTtcbnZhciBlbmRSdWxlSWQgPSAtMTtcbnZhciB3aGlsZVJ1bGVJZCA9IC0yO1xuZnVuY3Rpb24gcnVsZUlkRnJvbU51bWJlcihpZCkge1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBydWxlSWRUb051bWJlcihpZCkge1xuICByZXR1cm4gaWQ7XG59XG52YXIgUnVsZSA9IGNsYXNzIHtcbiAgJGxvY2F0aW9uO1xuICBpZDtcbiAgX25hbWVJc0NhcHR1cmluZztcbiAgX25hbWU7XG4gIF9jb250ZW50TmFtZUlzQ2FwdHVyaW5nO1xuICBfY29udGVudE5hbWU7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKSB7XG4gICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IG51bGw7XG4gICAgdGhpcy5fbmFtZUlzQ2FwdHVyaW5nID0gUmVnZXhTb3VyY2UuaGFzQ2FwdHVyZXModGhpcy5fbmFtZSk7XG4gICAgdGhpcy5fY29udGVudE5hbWUgPSBjb250ZW50TmFtZSB8fCBudWxsO1xuICAgIHRoaXMuX2NvbnRlbnROYW1lSXNDYXB0dXJpbmcgPSBSZWdleFNvdXJjZS5oYXNDYXB0dXJlcyh0aGlzLl9jb250ZW50TmFtZSk7XG4gIH1cbiAgZ2V0IGRlYnVnTmFtZSgpIHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuJGxvY2F0aW9uID8gYCR7YmFzZW5hbWUodGhpcy4kbG9jYXRpb24uZmlsZW5hbWUpfToke3RoaXMuJGxvY2F0aW9uLmxpbmV9YCA6IFwidW5rbm93blwiO1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IyR7dGhpcy5pZH0gQCAke2xvY2F0aW9ufWA7XG4gIH1cbiAgZ2V0TmFtZShsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICBpZiAoIXRoaXMuX25hbWVJc0NhcHR1cmluZyB8fCB0aGlzLl9uYW1lID09PSBudWxsIHx8IGxpbmVUZXh0ID09PSBudWxsIHx8IGNhcHR1cmVJbmRpY2VzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZ2V4U291cmNlLnJlcGxhY2VDYXB0dXJlcyh0aGlzLl9uYW1lLCBsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpO1xuICB9XG4gIGdldENvbnRlbnROYW1lKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIGlmICghdGhpcy5fY29udGVudE5hbWVJc0NhcHR1cmluZyB8fCB0aGlzLl9jb250ZW50TmFtZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gUmVnZXhTb3VyY2UucmVwbGFjZUNhcHR1cmVzKHRoaXMuX2NvbnRlbnROYW1lLCBsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpO1xuICB9XG59O1xudmFyIENhcHR1cmVSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZDtcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSk7XG4gICAgdGhpcy5yZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkID0gcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbiAgY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG59O1xudmFyIE1hdGNoUnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIF9tYXRjaDtcbiAgY2FwdHVyZXM7XG4gIF9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBtYXRjaCwgY2FwdHVyZXMpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBudWxsKTtcbiAgICB0aGlzLl9tYXRjaCA9IG5ldyBSZWdFeHBTb3VyY2UobWF0Y2gsIHRoaXMuaWQpO1xuICAgIHRoaXMuY2FwdHVyZXMgPSBjYXB0dXJlcztcbiAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXQgZGVidWdNYXRjaFJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fbWF0Y2guc291cmNlfWA7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIG91dC5wdXNoKHRoaXMuX21hdGNoKTtcbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIHRoaXMuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgfVxufTtcbnZhciBJbmNsdWRlT25seVJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICBoYXNNaXNzaW5nUGF0dGVybnM7XG4gIHBhdHRlcm5zO1xuICBfY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIHBhdHRlcm5zKSB7XG4gICAgc3VwZXIoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpO1xuICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucy5wYXR0ZXJucztcbiAgICB0aGlzLmhhc01pc3NpbmdQYXR0ZXJucyA9IHBhdHRlcm5zLmhhc01pc3NpbmdQYXR0ZXJucztcbiAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucGF0dGVybnMpIHtcbiAgICAgIGNvbnN0IHJ1bGUgPSBncmFtbWFyLmdldFJ1bGUocGF0dGVybik7XG4gICAgICBydWxlLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpO1xuICAgIH1cbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIHRoaXMuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgfVxufTtcbnZhciBCZWdpbkVuZFJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICBfYmVnaW47XG4gIGJlZ2luQ2FwdHVyZXM7XG4gIF9lbmQ7XG4gIGVuZEhhc0JhY2tSZWZlcmVuY2VzO1xuICBlbmRDYXB0dXJlcztcbiAgYXBwbHlFbmRQYXR0ZXJuTGFzdDtcbiAgaGFzTWlzc2luZ1BhdHRlcm5zO1xuICBwYXR0ZXJucztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCBiZWdpbiwgYmVnaW5DYXB0dXJlcywgZW5kLCBlbmRDYXB0dXJlcywgYXBwbHlFbmRQYXR0ZXJuTGFzdCwgcGF0dGVybnMpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSk7XG4gICAgdGhpcy5fYmVnaW4gPSBuZXcgUmVnRXhwU291cmNlKGJlZ2luLCB0aGlzLmlkKTtcbiAgICB0aGlzLmJlZ2luQ2FwdHVyZXMgPSBiZWdpbkNhcHR1cmVzO1xuICAgIHRoaXMuX2VuZCA9IG5ldyBSZWdFeHBTb3VyY2UoZW5kID8gZW5kIDogXCJcXHVGRkZGXCIsIC0xKTtcbiAgICB0aGlzLmVuZEhhc0JhY2tSZWZlcmVuY2VzID0gdGhpcy5fZW5kLmhhc0JhY2tSZWZlcmVuY2VzO1xuICAgIHRoaXMuZW5kQ2FwdHVyZXMgPSBlbmRDYXB0dXJlcztcbiAgICB0aGlzLmFwcGx5RW5kUGF0dGVybkxhc3QgPSBhcHBseUVuZFBhdHRlcm5MYXN0IHx8IGZhbHNlO1xuICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucy5wYXR0ZXJucztcbiAgICB0aGlzLmhhc01pc3NpbmdQYXR0ZXJucyA9IHBhdHRlcm5zLmhhc01pc3NpbmdQYXR0ZXJucztcbiAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXQgZGVidWdCZWdpblJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fYmVnaW4uc291cmNlfWA7XG4gIH1cbiAgZ2V0IGRlYnVnRW5kUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9lbmQuc291cmNlfWA7XG4gIH1cbiAgZ2V0RW5kV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZC5yZXNvbHZlQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgb3V0LnB1c2godGhpcy5fYmVnaW4pO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShwYXR0ZXJuKTtcbiAgICAgICAgcnVsZS5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcHBseUVuZFBhdHRlcm5MYXN0KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMucHVzaCh0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXMgPyB0aGlzLl9lbmQuY2xvbmUoKSA6IHRoaXMuX2VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLnVuc2hpZnQodGhpcy5fZW5kLmhhc0JhY2tSZWZlcmVuY2VzID8gdGhpcy5fZW5kLmNsb25lKCkgOiB0aGlzLl9lbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZW5kLmhhc0JhY2tSZWZlcmVuY2VzKSB7XG4gICAgICBpZiAodGhpcy5hcHBseUVuZFBhdHRlcm5MYXN0KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuc2V0U291cmNlKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMubGVuZ3RoKCkgLSAxLCBlbmRSZWdleFNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLnNldFNvdXJjZSgwLCBlbmRSZWdleFNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG59O1xudmFyIEJlZ2luV2hpbGVSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgX2JlZ2luO1xuICBiZWdpbkNhcHR1cmVzO1xuICB3aGlsZUNhcHR1cmVzO1xuICBfd2hpbGU7XG4gIHdoaWxlSGFzQmFja1JlZmVyZW5jZXM7XG4gIGhhc01pc3NpbmdQYXR0ZXJucztcbiAgcGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICBfY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgYmVnaW4sIGJlZ2luQ2FwdHVyZXMsIF93aGlsZSwgd2hpbGVDYXB0dXJlcywgcGF0dGVybnMpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSk7XG4gICAgdGhpcy5fYmVnaW4gPSBuZXcgUmVnRXhwU291cmNlKGJlZ2luLCB0aGlzLmlkKTtcbiAgICB0aGlzLmJlZ2luQ2FwdHVyZXMgPSBiZWdpbkNhcHR1cmVzO1xuICAgIHRoaXMud2hpbGVDYXB0dXJlcyA9IHdoaWxlQ2FwdHVyZXM7XG4gICAgdGhpcy5fd2hpbGUgPSBuZXcgUmVnRXhwU291cmNlKF93aGlsZSwgd2hpbGVSdWxlSWQpO1xuICAgIHRoaXMud2hpbGVIYXNCYWNrUmVmZXJlbmNlcyA9IHRoaXMuX3doaWxlLmhhc0JhY2tSZWZlcmVuY2VzO1xuICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucy5wYXR0ZXJucztcbiAgICB0aGlzLmhhc01pc3NpbmdQYXR0ZXJucyA9IHBhdHRlcm5zLmhhc01pc3NpbmdQYXR0ZXJucztcbiAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXQgZGVidWdCZWdpblJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fYmVnaW4uc291cmNlfWA7XG4gIH1cbiAgZ2V0IGRlYnVnV2hpbGVSZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3doaWxlLnNvdXJjZX1gO1xuICB9XG4gIGdldFdoaWxlV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3doaWxlLnJlc29sdmVCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpO1xuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBvdXQucHVzaCh0aGlzLl9iZWdpbik7XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGUoZ3JhbW1hcik7XG4gIH1cbiAgY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wYXR0ZXJucykge1xuICAgICAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKHBhdHRlcm4pO1xuICAgICAgICBydWxlLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIH1cbiAgY29tcGlsZVdoaWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlV2hpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucy5wdXNoKHRoaXMuX3doaWxlLmhhc0JhY2tSZWZlcmVuY2VzID8gdGhpcy5fd2hpbGUuY2xvbmUoKSA6IHRoaXMuX3doaWxlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3doaWxlLmhhc0JhY2tSZWZlcmVuY2VzKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMuc2V0U291cmNlKDAsIGVuZFJlZ2V4U291cmNlID8gZW5kUmVnZXhTb3VyY2UgOiBcIlxcdUZGRkZcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnM7XG4gIH1cbn07XG52YXIgUnVsZUZhY3RvcnkgPSBjbGFzcyBfUnVsZUZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlQ2FwdHVyZVJ1bGUoaGVscGVyLCAkbG9jYXRpb24sIG5hbWUsIGNvbnRlbnROYW1lLCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKSB7XG4gICAgcmV0dXJuIGhlbHBlci5yZWdpc3RlclJ1bGUoKGlkKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IENhcHR1cmVSdWxlKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0Q29tcGlsZWRSdWxlSWQoZGVzYywgaGVscGVyLCByZXBvc2l0b3J5KSB7XG4gICAgaWYgKCFkZXNjLmlkKSB7XG4gICAgICBoZWxwZXIucmVnaXN0ZXJSdWxlKChpZCkgPT4ge1xuICAgICAgICBkZXNjLmlkID0gaWQ7XG4gICAgICAgIGlmIChkZXNjLm1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNYXRjaFJ1bGUoXG4gICAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgICAgZGVzYy5pZCxcbiAgICAgICAgICAgIGRlc2MubmFtZSxcbiAgICAgICAgICAgIGRlc2MubWF0Y2gsXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlc2MuYmVnaW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoZGVzYy5yZXBvc2l0b3J5KSB7XG4gICAgICAgICAgICByZXBvc2l0b3J5ID0gbWVyZ2VPYmplY3RzKHt9LCByZXBvc2l0b3J5LCBkZXNjLnJlcG9zaXRvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcGF0dGVybnMgPSBkZXNjLnBhdHRlcm5zO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybnMgPT09IFwidW5kZWZpbmVkXCIgJiYgZGVzYy5pbmNsdWRlKSB7XG4gICAgICAgICAgICBwYXR0ZXJucyA9IFt7IGluY2x1ZGU6IGRlc2MuaW5jbHVkZSB9XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbmNsdWRlT25seVJ1bGUoXG4gICAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgICAgZGVzYy5pZCxcbiAgICAgICAgICAgIGRlc2MubmFtZSxcbiAgICAgICAgICAgIGRlc2MuY29udGVudE5hbWUsXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVQYXR0ZXJucyhwYXR0ZXJucywgaGVscGVyLCByZXBvc2l0b3J5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2Mud2hpbGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJlZ2luV2hpbGVSdWxlKFxuICAgICAgICAgICAgZGVzYy4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICAgICAgICAgIGRlc2MuaWQsXG4gICAgICAgICAgICBkZXNjLm5hbWUsXG4gICAgICAgICAgICBkZXNjLmNvbnRlbnROYW1lLFxuICAgICAgICAgICAgZGVzYy5iZWdpbixcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2MuYmVnaW5DYXB0dXJlcyB8fCBkZXNjLmNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpLFxuICAgICAgICAgICAgZGVzYy53aGlsZSxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2Mud2hpbGVDYXB0dXJlcyB8fCBkZXNjLmNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlUGF0dGVybnMoZGVzYy5wYXR0ZXJucywgaGVscGVyLCByZXBvc2l0b3J5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCZWdpbkVuZFJ1bGUoXG4gICAgICAgICAgZGVzYy4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgIGRlc2MubmFtZSxcbiAgICAgICAgICBkZXNjLmNvbnRlbnROYW1lLFxuICAgICAgICAgIGRlc2MuYmVnaW4sXG4gICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy5iZWdpbkNhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgZGVzYy5lbmQsXG4gICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy5lbmRDYXB0dXJlcyB8fCBkZXNjLmNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpLFxuICAgICAgICAgIGRlc2MuYXBwbHlFbmRQYXR0ZXJuTGFzdCxcbiAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVQYXR0ZXJucyhkZXNjLnBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2MuaWQ7XG4gIH1cbiAgc3RhdGljIF9jb21waWxlQ2FwdHVyZXMoY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICBsZXQgbWF4aW11bUNhcHR1cmVJZCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNhcHR1cmVJZCBpbiBjYXB0dXJlcykge1xuICAgICAgICBpZiAoY2FwdHVyZUlkID09PSBcIiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1lcmljQ2FwdHVyZUlkID0gcGFyc2VJbnQoY2FwdHVyZUlkLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljQ2FwdHVyZUlkID4gbWF4aW11bUNhcHR1cmVJZCkge1xuICAgICAgICAgIG1heGltdW1DYXB0dXJlSWQgPSBudW1lcmljQ2FwdHVyZUlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhpbXVtQ2FwdHVyZUlkOyBpKyspIHtcbiAgICAgICAgcltpXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNhcHR1cmVJZCBpbiBjYXB0dXJlcykge1xuICAgICAgICBpZiAoY2FwdHVyZUlkID09PSBcIiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1lcmljQ2FwdHVyZUlkID0gcGFyc2VJbnQoY2FwdHVyZUlkLCAxMCk7XG4gICAgICAgIGxldCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkID0gMDtcbiAgICAgICAgaWYgKGNhcHR1cmVzW2NhcHR1cmVJZF0ucGF0dGVybnMpIHtcbiAgICAgICAgICByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKGNhcHR1cmVzW2NhcHR1cmVJZF0sIGhlbHBlciwgcmVwb3NpdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcltudW1lcmljQ2FwdHVyZUlkXSA9IF9SdWxlRmFjdG9yeS5jcmVhdGVDYXB0dXJlUnVsZShoZWxwZXIsIGNhcHR1cmVzW2NhcHR1cmVJZF0uJHZzY29kZVRleHRtYXRlTG9jYXRpb24sIGNhcHR1cmVzW2NhcHR1cmVJZF0ubmFtZSwgY2FwdHVyZXNbY2FwdHVyZUlkXS5jb250ZW50TmFtZSwgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBfY29tcGlsZVBhdHRlcm5zKHBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmIChwYXR0ZXJucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICAgICAgbGV0IHJ1bGVJZCA9IC0xO1xuICAgICAgICBpZiAocGF0dGVybi5pbmNsdWRlKSB7XG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gcGFyc2VJbmNsdWRlKHBhdHRlcm4uaW5jbHVkZSk7XG4gICAgICAgICAgc3dpdGNoIChyZWZlcmVuY2Uua2luZCkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEJhc2UgKi86XG4gICAgICAgICAgICBjYXNlIDEgLyogU2VsZiAqLzpcbiAgICAgICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKHJlcG9zaXRvcnlbcGF0dGVybi5pbmNsdWRlXSwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogUmVsYXRpdmVSZWZlcmVuY2UgKi86XG4gICAgICAgICAgICAgIGxldCBsb2NhbEluY2x1ZGVkUnVsZSA9IHJlcG9zaXRvcnlbcmVmZXJlbmNlLnJ1bGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsSW5jbHVkZWRSdWxlKSB7XG4gICAgICAgICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKGxvY2FsSW5jbHVkZWRSdWxlLCBoZWxwZXIsIHJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFRvcExldmVsUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgY2FzZSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLzpcbiAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxHcmFtbWFyTmFtZSA9IHJlZmVyZW5jZS5zY29wZU5hbWU7XG4gICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsR3JhbW1hckluY2x1ZGUgPSByZWZlcmVuY2Uua2luZCA9PT0gNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi8gPyByZWZlcmVuY2UucnVsZU5hbWUgOiBudWxsO1xuICAgICAgICAgICAgICBjb25zdCBleHRlcm5hbEdyYW1tYXIgPSBoZWxwZXIuZ2V0RXh0ZXJuYWxHcmFtbWFyKGV4dGVybmFsR3JhbW1hck5hbWUsIHJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxHcmFtbWFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsR3JhbW1hckluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBleHRlcm5hbEluY2x1ZGVkUnVsZSA9IGV4dGVybmFsR3JhbW1hci5yZXBvc2l0b3J5W2V4dGVybmFsR3JhbW1hckluY2x1ZGVdO1xuICAgICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsSW5jbHVkZWRSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChleHRlcm5hbEluY2x1ZGVkUnVsZSwgaGVscGVyLCBleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoZXh0ZXJuYWxHcmFtbWFyLnJlcG9zaXRvcnkuJHNlbGYsIGhlbHBlciwgZXh0ZXJuYWxHcmFtbWFyLnJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKHBhdHRlcm4sIGhlbHBlciwgcmVwb3NpdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCBydWxlID0gaGVscGVyLmdldFJ1bGUocnVsZUlkKTtcbiAgICAgICAgICBsZXQgc2tpcFJ1bGUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIEluY2x1ZGVPbmx5UnVsZSB8fCBydWxlIGluc3RhbmNlb2YgQmVnaW5FbmRSdWxlIHx8IHJ1bGUgaW5zdGFuY2VvZiBCZWdpbldoaWxlUnVsZSkge1xuICAgICAgICAgICAgaWYgKHJ1bGUuaGFzTWlzc2luZ1BhdHRlcm5zICYmIHJ1bGUucGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHNraXBSdWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNraXBSdWxlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5wdXNoKHJ1bGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdHRlcm5zOiByLFxuICAgICAgaGFzTWlzc2luZ1BhdHRlcm5zOiAocGF0dGVybnMgPyBwYXR0ZXJucy5sZW5ndGggOiAwKSAhPT0gci5sZW5ndGhcbiAgICB9O1xuICB9XG59O1xudmFyIFJlZ0V4cFNvdXJjZSA9IGNsYXNzIF9SZWdFeHBTb3VyY2Uge1xuICBzb3VyY2U7XG4gIHJ1bGVJZDtcbiAgaGFzQW5jaG9yO1xuICBoYXNCYWNrUmVmZXJlbmNlcztcbiAgX2FuY2hvckNhY2hlO1xuICBjb25zdHJ1Y3RvcihyZWdFeHBTb3VyY2UsIHJ1bGVJZCkge1xuICAgIGlmIChyZWdFeHBTb3VyY2UgJiYgdHlwZW9mIHJlZ0V4cFNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgbGVuID0gcmVnRXhwU291cmNlLmxlbmd0aDtcbiAgICAgIGxldCBsYXN0UHVzaGVkUG9zID0gMDtcbiAgICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICAgIGxldCBoYXNBbmNob3IgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICAgICAgY29uc3QgY2ggPSByZWdFeHBTb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBpZiAocG9zICsgMSA8IGxlbikge1xuICAgICAgICAgICAgY29uc3QgbmV4dENoID0gcmVnRXhwU291cmNlLmNoYXJBdChwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2ggPT09IFwielwiKSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJlZ0V4cFNvdXJjZS5zdWJzdHJpbmcobGFzdFB1c2hlZFBvcywgcG9zKSk7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKFwiJCg/IVxcXFxuKSg/PCFcXFxcbilcIik7XG4gICAgICAgICAgICAgIGxhc3RQdXNoZWRQb3MgPSBwb3MgKyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2ggPT09IFwiQVwiIHx8IG5leHRDaCA9PT0gXCJHXCIpIHtcbiAgICAgICAgICAgICAgaGFzQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5oYXNBbmNob3IgPSBoYXNBbmNob3I7XG4gICAgICBpZiAobGFzdFB1c2hlZFBvcyA9PT0gMCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHJlZ0V4cFNvdXJjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHJlZ0V4cFNvdXJjZS5zdWJzdHJpbmcobGFzdFB1c2hlZFBvcywgbGVuKSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gb3V0cHV0LmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQW5jaG9yID0gZmFsc2U7XG4gICAgICB0aGlzLnNvdXJjZSA9IHJlZ0V4cFNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQW5jaG9yKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZSA9IHRoaXMuX2J1aWxkQW5jaG9yQ2FjaGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVJZCA9IHJ1bGVJZDtcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmhhc0JhY2tSZWZlcmVuY2VzID0gSEFTX0JBQ0tfUkVGRVJFTkNFUy50ZXN0KHRoaXMuc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNCYWNrUmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9SZWdFeHBTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMucnVsZUlkKTtcbiAgfVxuICBzZXRTb3VyY2UobmV3U291cmNlKSB7XG4gICAgaWYgKHRoaXMuc291cmNlID09PSBuZXdTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSBuZXdTb3VyY2U7XG4gICAgaWYgKHRoaXMuaGFzQW5jaG9yKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZSA9IHRoaXMuX2J1aWxkQW5jaG9yQ2FjaGUoKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgc291cmNlIGlzIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBsZXQgY2FwdHVyZWRWYWx1ZXMgPSBjYXB0dXJlSW5kaWNlcy5tYXAoKGNhcHR1cmUpID0+IHtcbiAgICAgIHJldHVybiBsaW5lVGV4dC5zdWJzdHJpbmcoY2FwdHVyZS5zdGFydCwgY2FwdHVyZS5lbmQpO1xuICAgIH0pO1xuICAgIEJBQ0tfUkVGRVJFTkNJTkdfRU5ELmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnJlcGxhY2UoQkFDS19SRUZFUkVOQ0lOR19FTkQsIChtYXRjaCwgZzEpID0+IHtcbiAgICAgIHJldHVybiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKGNhcHR1cmVkVmFsdWVzW3BhcnNlSW50KGcxLCAxMCldIHx8IFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIF9idWlsZEFuY2hvckNhY2hlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgc291cmNlIGlzIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBsZXQgQTBfRzBfcmVzdWx0ID0gW107XG4gICAgbGV0IEEwX0cxX3Jlc3VsdCA9IFtdO1xuICAgIGxldCBBMV9HMF9yZXN1bHQgPSBbXTtcbiAgICBsZXQgQTFfRzFfcmVzdWx0ID0gW107XG4gICAgbGV0IHBvcywgbGVuLCBjaCwgbmV4dENoO1xuICAgIGZvciAocG9zID0gMCwgbGVuID0gdGhpcy5zb3VyY2UubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJBdChwb3MpO1xuICAgICAgQTBfRzBfcmVzdWx0W3Bvc10gPSBjaDtcbiAgICAgIEEwX0cxX3Jlc3VsdFtwb3NdID0gY2g7XG4gICAgICBBMV9HMF9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgQTFfRzFfcmVzdWx0W3Bvc10gPSBjaDtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgaWYgKHBvcyArIDEgPCBsZW4pIHtcbiAgICAgICAgICBuZXh0Q2ggPSB0aGlzLnNvdXJjZS5jaGFyQXQocG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHRDaCA9PT0gXCJBXCIpIHtcbiAgICAgICAgICAgIEEwX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IFwiXFx1RkZGRlwiO1xuICAgICAgICAgICAgQTBfRzFfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMV9HMF9yZXN1bHRbcG9zICsgMV0gPSBcIkFcIjtcbiAgICAgICAgICAgIEExX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IFwiQVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoID09PSBcIkdcIikge1xuICAgICAgICAgICAgQTBfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMF9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIkdcIjtcbiAgICAgICAgICAgIEExX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IFwiXFx1RkZGRlwiO1xuICAgICAgICAgICAgQTFfRzFfcmVzdWx0W3BvcyArIDFdID0gXCJHXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEEwX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IG5leHRDaDtcbiAgICAgICAgICAgIEEwX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IG5leHRDaDtcbiAgICAgICAgICAgIEExX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IG5leHRDaDtcbiAgICAgICAgICAgIEExX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IG5leHRDaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIEEwX0cwOiBBMF9HMF9yZXN1bHQuam9pbihcIlwiKSxcbiAgICAgIEEwX0cxOiBBMF9HMV9yZXN1bHQuam9pbihcIlwiKSxcbiAgICAgIEExX0cwOiBBMV9HMF9yZXN1bHQuam9pbihcIlwiKSxcbiAgICAgIEExX0cxOiBBMV9HMV9yZXN1bHQuam9pbihcIlwiKVxuICAgIH07XG4gIH1cbiAgcmVzb2x2ZUFuY2hvcnMoYWxsb3dBLCBhbGxvd0cpIHtcbiAgICBpZiAoIXRoaXMuaGFzQW5jaG9yIHx8ICF0aGlzLl9hbmNob3JDYWNoZSB8fCB0eXBlb2YgdGhpcy5zb3VyY2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGFsbG93QSkge1xuICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd0cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBSZWdFeHBTb3VyY2VMaXN0ID0gY2xhc3Mge1xuICBfaXRlbXM7XG4gIF9oYXNBbmNob3JzO1xuICBfY2FjaGVkO1xuICBfYW5jaG9yQ2FjaGU7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faGFzQW5jaG9ycyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yQ2FjaGUgPSB7XG4gICAgICBBMF9HMDogbnVsbCxcbiAgICAgIEEwX0cxOiBudWxsLFxuICAgICAgQTFfRzA6IG51bGwsXG4gICAgICBBMV9HMTogbnVsbFxuICAgIH07XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9kaXNwb3NlQ2FjaGVzKCk7XG4gIH1cbiAgX2Rpc3Bvc2VDYWNoZXMoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCkge1xuICAgICAgdGhpcy5fY2FjaGVkLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCkge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzAuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzAgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkExX0cwKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hbmNob3JDYWNoZS5BMV9HMSkge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwdXNoKGl0ZW0pIHtcbiAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuX2hhc0FuY2hvcnMgPSB0aGlzLl9oYXNBbmNob3JzIHx8IGl0ZW0uaGFzQW5jaG9yO1xuICB9XG4gIHVuc2hpZnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnVuc2hpZnQoaXRlbSk7XG4gICAgdGhpcy5faGFzQW5jaG9ycyA9IHRoaXMuX2hhc0FuY2hvcnMgfHwgaXRlbS5oYXNBbmNob3I7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cbiAgc2V0U291cmNlKGluZGV4LCBuZXdTb3VyY2UpIHtcbiAgICBpZiAodGhpcy5faXRlbXNbaW5kZXhdLnNvdXJjZSAhPT0gbmV3U291cmNlKSB7XG4gICAgICB0aGlzLl9kaXNwb3NlQ2FjaGVzKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleF0uc2V0U291cmNlKG5ld1NvdXJjZSk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGUob25pZ0xpYikge1xuICAgIGlmICghdGhpcy5fY2FjaGVkKSB7XG4gICAgICBsZXQgcmVnRXhwcyA9IHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5zb3VyY2UpO1xuICAgICAgdGhpcy5fY2FjaGVkID0gbmV3IENvbXBpbGVkUnVsZShvbmlnTGliLCByZWdFeHBzLCB0aGlzLl9pdGVtcy5tYXAoKGUpID0+IGUucnVsZUlkKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gIH1cbiAgY29tcGlsZUFHKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNBbmNob3JzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKG9uaWdMaWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWxsb3dBKSB7XG4gICAgICAgIGlmIChhbGxvd0cpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2FuY2hvckNhY2hlLkExX0cxKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMSA9IHRoaXMuX3Jlc29sdmVBbmNob3JzKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzApIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxvd0cpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2FuY2hvckNhY2hlLkEwX0cxKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMSA9IHRoaXMuX3Jlc29sdmVBbmNob3JzKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzApIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jlc29sdmVBbmNob3JzKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgbGV0IHJlZ0V4cHMgPSB0aGlzLl9pdGVtcy5tYXAoKGUpID0+IGUucmVzb2x2ZUFuY2hvcnMoYWxsb3dBLCBhbGxvd0cpKTtcbiAgICByZXR1cm4gbmV3IENvbXBpbGVkUnVsZShvbmlnTGliLCByZWdFeHBzLCB0aGlzLl9pdGVtcy5tYXAoKGUpID0+IGUucnVsZUlkKSk7XG4gIH1cbn07XG52YXIgQ29tcGlsZWRSdWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvbmlnTGliLCByZWdFeHBzLCBydWxlcykge1xuICAgIHRoaXMucmVnRXhwcyA9IHJlZ0V4cHM7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuc2Nhbm5lciA9IG9uaWdMaWIuY3JlYXRlT25pZ1NjYW5uZXIocmVnRXhwcyk7XG4gIH1cbiAgc2Nhbm5lcjtcbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2Nhbm5lci5kaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuc2Nhbm5lci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5ydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgci5wdXNoKFwiICAgLSBcIiArIHRoaXMucnVsZXNbaV0gKyBcIjogXCIgKyB0aGlzLnJlZ0V4cHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gci5qb2luKFwiXFxuXCIpO1xuICB9XG4gIGZpbmROZXh0TWF0Y2hTeW5jKHN0cmluZywgc3RhcnRQb3NpdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2Nhbm5lci5maW5kTmV4dE1hdGNoU3luYyhzdHJpbmcsIHN0YXJ0UG9zaXRpb24sIG9wdGlvbnMpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVJZDogdGhpcy5ydWxlc1tyZXN1bHQuaW5kZXhdLFxuICAgICAgY2FwdHVyZUluZGljZXM6IHJlc3VsdC5jYXB0dXJlSW5kaWNlc1xuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9ncmFtbWFyL2Jhc2ljU2NvcGVzQXR0cmlidXRlUHJvdmlkZXIudHNcbnZhciBCYXNpY1Njb3BlQXR0cmlidXRlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGFuZ3VhZ2VJZCwgdG9rZW5UeXBlKSB7XG4gICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgfVxufTtcbnZhciBCYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyID0gY2xhc3MgX0Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIge1xuICBfZGVmYXVsdEF0dHJpYnV0ZXM7XG4gIF9lbWJlZGRlZExhbmd1YWdlc01hdGNoZXI7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxMYW5ndWFnZUlkLCBlbWJlZGRlZExhbmd1YWdlcykge1xuICAgIHRoaXMuX2RlZmF1bHRBdHRyaWJ1dGVzID0gbmV3IEJhc2ljU2NvcGVBdHRyaWJ1dGVzKGluaXRpYWxMYW5ndWFnZUlkLCA4IC8qIE5vdFNldCAqLyk7XG4gICAgdGhpcy5fZW1iZWRkZWRMYW5ndWFnZXNNYXRjaGVyID0gbmV3IFNjb3BlTWF0Y2hlcihPYmplY3QuZW50cmllcyhlbWJlZGRlZExhbmd1YWdlcyB8fCB7fSkpO1xuICB9XG4gIGdldERlZmF1bHRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0QXR0cmlidXRlcztcbiAgfVxuICBnZXRCYXNpY1Njb3BlQXR0cmlidXRlcyhzY29wZU5hbWUpIHtcbiAgICBpZiAoc2NvcGVOYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gX0Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIuX05VTExfU0NPUEVfTUVUQURBVEE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRCYXNpY1Njb3BlQXR0cmlidXRlcy5nZXQoc2NvcGVOYW1lKTtcbiAgfVxuICBzdGF0aWMgX05VTExfU0NPUEVfTUVUQURBVEEgPSBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXMoMCwgMCk7XG4gIF9nZXRCYXNpY1Njb3BlQXR0cmlidXRlcyA9IG5ldyBDYWNoZWRGbigoc2NvcGVOYW1lKSA9PiB7XG4gICAgY29uc3QgbGFuZ3VhZ2VJZCA9IHRoaXMuX3Njb3BlVG9MYW5ndWFnZShzY29wZU5hbWUpO1xuICAgIGNvbnN0IHN0YW5kYXJkVG9rZW5UeXBlID0gdGhpcy5fdG9TdGFuZGFyZFRva2VuVHlwZShzY29wZU5hbWUpO1xuICAgIHJldHVybiBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXMobGFuZ3VhZ2VJZCwgc3RhbmRhcmRUb2tlblR5cGUpO1xuICB9KTtcbiAgLyoqXG4gICAqIEdpdmVuIGEgcHJvZHVjZWQgVE0gc2NvcGUsIHJldHVybiB0aGUgbGFuZ3VhZ2UgdGhhdCB0b2tlbiBkZXNjcmliZXMgb3IgbnVsbCBpZiB1bmtub3duLlxuICAgKiBlLmcuIHNvdXJjZS5odG1sID0+IGh0bWwsIHNvdXJjZS5jc3MuZW1iZWRkZWQuaHRtbCA9PiBjc3MsIHB1bmN0dWF0aW9uLmRlZmluaXRpb24udGFnLmh0bWwgPT4gbnVsbFxuICAgKi9cbiAgX3Njb3BlVG9MYW5ndWFnZShzY29wZSkge1xuICAgIHJldHVybiB0aGlzLl9lbWJlZGRlZExhbmd1YWdlc01hdGNoZXIubWF0Y2goc2NvcGUpIHx8IDA7XG4gIH1cbiAgX3RvU3RhbmRhcmRUb2tlblR5cGUoc2NvcGVOYW1lKSB7XG4gICAgY29uc3QgbSA9IHNjb3BlTmFtZS5tYXRjaChfQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5TVEFOREFSRF9UT0tFTl9UWVBFX1JFR0VYUCk7XG4gICAgaWYgKCFtKSB7XG4gICAgICByZXR1cm4gOCAvKiBOb3RTZXQgKi87XG4gICAgfVxuICAgIHN3aXRjaCAobVsxXSkge1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIDEgLyogQ29tbWVudCAqLztcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIDIgLyogU3RyaW5nICovO1xuICAgICAgY2FzZSBcInJlZ2V4XCI6XG4gICAgICAgIHJldHVybiAzIC8qIFJlZ0V4ICovO1xuICAgICAgY2FzZSBcIm1ldGEuZW1iZWRkZWRcIjpcbiAgICAgICAgcmV0dXJuIDAgLyogT3RoZXIgKi87XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWF0Y2ggZm9yIHN0YW5kYXJkIHRva2VuIHR5cGUhXCIpO1xuICB9XG4gIHN0YXRpYyBTVEFOREFSRF9UT0tFTl9UWVBFX1JFR0VYUCA9IC9cXGIoY29tbWVudHxzdHJpbmd8cmVnZXh8bWV0YVxcLmVtYmVkZGVkKVxcYi87XG59O1xudmFyIFNjb3BlTWF0Y2hlciA9IGNsYXNzIHtcbiAgdmFsdWVzO1xuICBzY29wZXNSZWdFeHA7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG51bGw7XG4gICAgICB0aGlzLnNjb3Blc1JlZ0V4cCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWVzID0gbmV3IE1hcCh2YWx1ZXMpO1xuICAgICAgY29uc3QgZXNjYXBlZFNjb3BlcyA9IHZhbHVlcy5tYXAoXG4gICAgICAgIChbc2NvcGVOYW1lLCB2YWx1ZV0pID0+IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICAgIGVzY2FwZWRTY29wZXMuc29ydCgpO1xuICAgICAgZXNjYXBlZFNjb3Blcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnNjb3Blc1JlZ0V4cCA9IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeKCgke2VzY2FwZWRTY29wZXMuam9pbihcIil8KFwiKX0pKSgkfFxcXFwuKWAsXG4gICAgICAgIFwiXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG1hdGNoKHNjb3BlKSB7XG4gICAgaWYgKCF0aGlzLnNjb3Blc1JlZ0V4cCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbSA9IHNjb3BlLm1hdGNoKHRoaXMuc2NvcGVzUmVnRXhwKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbHVlcy5nZXQobVsxXSk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZWJ1Zy50c1xudmFyIERlYnVnRmxhZ3MgPSB7XG4gIEluRGVidWdNb2RlOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXByb2Nlc3MuZW52W1wiVlNDT0RFX1RFWFRNQVRFX0RFQlVHXCJdXG59O1xudmFyIFVzZU9uaWd1cnVtYUZpbmRPcHRpb25zID0gZmFsc2U7XG5cbi8vIHNyYy9ncmFtbWFyL3Rva2VuaXplU3RyaW5nLnRzXG52YXIgVG9rZW5pemVTdHJpbmdSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrLCBzdG9wcGVkRWFybHkpIHtcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5zdG9wcGVkRWFybHkgPSBzdG9wcGVkRWFybHk7XG4gIH1cbn07XG5mdW5jdGlvbiBfdG9rZW5pemVTdHJpbmcoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgbGluZVRva2VucywgY2hlY2tXaGlsZUNvbmRpdGlvbnMsIHRpbWVMaW1pdCkge1xuICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZVRleHQuY29udGVudC5sZW5ndGg7XG4gIGxldCBTVE9QID0gZmFsc2U7XG4gIGxldCBhbmNob3JQb3NpdGlvbiA9IC0xO1xuICBpZiAoY2hlY2tXaGlsZUNvbmRpdGlvbnMpIHtcbiAgICBjb25zdCB3aGlsZUNoZWNrUmVzdWx0ID0gX2NoZWNrV2hpbGVDb25kaXRpb25zKFxuICAgICAgZ3JhbW1hcixcbiAgICAgIGxpbmVUZXh0LFxuICAgICAgaXNGaXJzdExpbmUsXG4gICAgICBsaW5lUG9zLFxuICAgICAgc3RhY2ssXG4gICAgICBsaW5lVG9rZW5zXG4gICAgKTtcbiAgICBzdGFjayA9IHdoaWxlQ2hlY2tSZXN1bHQuc3RhY2s7XG4gICAgbGluZVBvcyA9IHdoaWxlQ2hlY2tSZXN1bHQubGluZVBvcztcbiAgICBpc0ZpcnN0TGluZSA9IHdoaWxlQ2hlY2tSZXN1bHQuaXNGaXJzdExpbmU7XG4gICAgYW5jaG9yUG9zaXRpb24gPSB3aGlsZUNoZWNrUmVzdWx0LmFuY2hvclBvc2l0aW9uO1xuICB9XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIHdoaWxlICghU1RPUCkge1xuICAgIGlmICh0aW1lTGltaXQgIT09IDApIHtcbiAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGlmIChlbGFwc2VkVGltZSA+IHRpbWVMaW1pdCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplU3RyaW5nUmVzdWx0KHN0YWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2Nhbk5leHQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuaXplU3RyaW5nUmVzdWx0KHN0YWNrLCBmYWxzZSk7XG4gIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYEBAc2Nhbk5leHQgJHtsaW5lUG9zfTogfCR7bGluZVRleHQuY29udGVudC5zdWJzdHIobGluZVBvcykucmVwbGFjZSgvXFxuJC8sIFwiXFxcXG5cIil9fGBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSBtYXRjaFJ1bGVPckluamVjdGlvbnMoXG4gICAgICBncmFtbWFyLFxuICAgICAgbGluZVRleHQsXG4gICAgICBpc0ZpcnN0TGluZSxcbiAgICAgIGxpbmVQb3MsXG4gICAgICBzdGFjayxcbiAgICAgIGFuY2hvclBvc2l0aW9uXG4gICAgKTtcbiAgICBpZiAoIXIpIHtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FwdHVyZUluZGljZXMgPSByLmNhcHR1cmVJbmRpY2VzO1xuICAgIGNvbnN0IG1hdGNoZWRSdWxlSWQgPSByLm1hdGNoZWRSdWxlSWQ7XG4gICAgY29uc3QgaGFzQWR2YW5jZWQgPSBjYXB0dXJlSW5kaWNlcyAmJiBjYXB0dXJlSW5kaWNlcy5sZW5ndGggPiAwID8gY2FwdHVyZUluZGljZXNbMF0uZW5kID4gbGluZVBvcyA6IGZhbHNlO1xuICAgIGlmIChtYXRjaGVkUnVsZUlkID09PSBlbmRSdWxlSWQpIHtcbiAgICAgIGNvbnN0IHBvcHBlZFJ1bGUgPSBzdGFjay5nZXRSdWxlKGdyYW1tYXIpO1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiICBwb3BwaW5nIFwiICsgcG9wcGVkUnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgcG9wcGVkUnVsZS5kZWJ1Z0VuZFJlZ0V4cFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5zdGFydCk7XG4gICAgICBzdGFjayA9IHN0YWNrLndpdGhDb250ZW50TmFtZVNjb3Blc0xpc3Qoc3RhY2submFtZVNjb3Blc0xpc3QpO1xuICAgICAgaGFuZGxlQ2FwdHVyZXMoXG4gICAgICAgIGdyYW1tYXIsXG4gICAgICAgIGxpbmVUZXh0LFxuICAgICAgICBpc0ZpcnN0TGluZSxcbiAgICAgICAgc3RhY2ssXG4gICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgIHBvcHBlZFJ1bGUuZW5kQ2FwdHVyZXMsXG4gICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICApO1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgY29uc3QgcG9wcGVkID0gc3RhY2s7XG4gICAgICBzdGFjayA9IHN0YWNrLnBhcmVudDtcbiAgICAgIGFuY2hvclBvc2l0aW9uID0gcG9wcGVkLmdldEFuY2hvclBvcygpO1xuICAgICAgaWYgKCFoYXNBZHZhbmNlZCAmJiBwb3BwZWQuZ2V0RW50ZXJQb3MoKSA9PT0gbGluZVBvcykge1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbMV0gLSBHcmFtbWFyIGlzIGluIGFuIGVuZGxlc3MgbG9vcCAtIEdyYW1tYXIgcHVzaGVkICYgcG9wcGVkIGEgcnVsZSB3aXRob3V0IGFkdmFuY2luZ1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFjayA9IHBvcHBlZDtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgU1RPUCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgX3J1bGUgPSBncmFtbWFyLmdldFJ1bGUobWF0Y2hlZFJ1bGVJZCk7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGJlZm9yZVB1c2ggPSBzdGFjaztcbiAgICAgIGNvbnN0IHNjb3BlTmFtZSA9IF9ydWxlLmdldE5hbWUobGluZVRleHQuY29udGVudCwgY2FwdHVyZUluZGljZXMpO1xuICAgICAgY29uc3QgbmFtZVNjb3Blc0xpc3QgPSBzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoXG4gICAgICAgIHNjb3BlTmFtZSxcbiAgICAgICAgZ3JhbW1hclxuICAgICAgKTtcbiAgICAgIHN0YWNrID0gc3RhY2sucHVzaChcbiAgICAgICAgbWF0Y2hlZFJ1bGVJZCxcbiAgICAgICAgbGluZVBvcyxcbiAgICAgICAgYW5jaG9yUG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCA9PT0gbGluZUxlbmd0aCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmFtZVNjb3Blc0xpc3QsXG4gICAgICAgIG5hbWVTY29wZXNMaXN0XG4gICAgICApO1xuICAgICAgaWYgKF9ydWxlIGluc3RhbmNlb2YgQmVnaW5FbmRSdWxlKSB7XG4gICAgICAgIGNvbnN0IHB1c2hlZFJ1bGUgPSBfcnVsZTtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIiAgcHVzaGluZyBcIiArIHB1c2hlZFJ1bGUuZGVidWdOYW1lICsgXCIgLSBcIiArIHB1c2hlZFJ1bGUuZGVidWdCZWdpblJlZ0V4cFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoXG4gICAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgICBsaW5lVGV4dCxcbiAgICAgICAgICBpc0ZpcnN0TGluZSxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICAgIHB1c2hlZFJ1bGUuYmVnaW5DYXB0dXJlcyxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIGFuY2hvclBvc2l0aW9uID0gY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IHB1c2hlZFJ1bGUuZ2V0Q29udGVudE5hbWUoXG4gICAgICAgICAgbGluZVRleHQuY29udGVudCxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZVNjb3Blc0xpc3QgPSBuYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChcbiAgICAgICAgICBjb250ZW50TmFtZSxcbiAgICAgICAgICBncmFtbWFyXG4gICAgICAgICk7XG4gICAgICAgIHN0YWNrID0gc3RhY2sud2l0aENvbnRlbnROYW1lU2NvcGVzTGlzdChjb250ZW50TmFtZVNjb3Blc0xpc3QpO1xuICAgICAgICBpZiAocHVzaGVkUnVsZS5lbmRIYXNCYWNrUmVmZXJlbmNlcykge1xuICAgICAgICAgIHN0YWNrID0gc3RhY2sud2l0aEVuZFJ1bGUoXG4gICAgICAgICAgICBwdXNoZWRSdWxlLmdldEVuZFdpdGhSZXNvbHZlZEJhY2tSZWZlcmVuY2VzKFxuICAgICAgICAgICAgICBsaW5lVGV4dC5jb250ZW50LFxuICAgICAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNBZHZhbmNlZCAmJiBiZWZvcmVQdXNoLmhhc1NhbWVSdWxlQXMoc3RhY2spKSB7XG4gICAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlsyXSAtIEdyYW1tYXIgaXMgaW4gYW4gZW5kbGVzcyBsb29wIC0gR3JhbW1hciBwdXNoZWQgdGhlIHNhbWUgcnVsZSB3aXRob3V0IGFkdmFuY2luZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICAgICAgU1RPUCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9ydWxlIGluc3RhbmNlb2YgQmVnaW5XaGlsZVJ1bGUpIHtcbiAgICAgICAgY29uc3QgcHVzaGVkUnVsZSA9IF9ydWxlO1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgcHVzaGluZyBcIiArIHB1c2hlZFJ1bGUuZGVidWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgICBncmFtbWFyLFxuICAgICAgICAgIGxpbmVUZXh0LFxuICAgICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgICAgcHVzaGVkUnVsZS5iZWdpbkNhcHR1cmVzLFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgICAgYW5jaG9yUG9zaXRpb24gPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gcHVzaGVkUnVsZS5nZXRDb250ZW50TmFtZShcbiAgICAgICAgICBsaW5lVGV4dC5jb250ZW50LFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKFxuICAgICAgICAgIGNvbnRlbnROYW1lLFxuICAgICAgICAgIGdyYW1tYXJcbiAgICAgICAgKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KGNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gICAgICAgIGlmIChwdXNoZWRSdWxlLndoaWxlSGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgICAgICBzdGFjayA9IHN0YWNrLndpdGhFbmRSdWxlKFxuICAgICAgICAgICAgcHVzaGVkUnVsZS5nZXRXaGlsZVdpdGhSZXNvbHZlZEJhY2tSZWZlcmVuY2VzKFxuICAgICAgICAgICAgICBsaW5lVGV4dC5jb250ZW50LFxuICAgICAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNBZHZhbmNlZCAmJiBiZWZvcmVQdXNoLmhhc1NhbWVSdWxlQXMoc3RhY2spKSB7XG4gICAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlszXSAtIEdyYW1tYXIgaXMgaW4gYW4gZW5kbGVzcyBsb29wIC0gR3JhbW1hciBwdXNoZWQgdGhlIHNhbWUgcnVsZSB3aXRob3V0IGFkdmFuY2luZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICAgICAgU1RPUCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGluZ1J1bGUgPSBfcnVsZTtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIiAgbWF0Y2hlZCBcIiArIG1hdGNoaW5nUnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgbWF0Y2hpbmdSdWxlLmRlYnVnTWF0Y2hSZWdFeHBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNhcHR1cmVzKFxuICAgICAgICAgIGdyYW1tYXIsXG4gICAgICAgICAgbGluZVRleHQsXG4gICAgICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgICBtYXRjaGluZ1J1bGUuY2FwdHVyZXMsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgICBzdGFjayA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWhhc0FkdmFuY2VkKSB7XG4gICAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIls0XSAtIEdyYW1tYXIgaXMgaW4gYW4gZW5kbGVzcyBsb29wIC0gR3JhbW1hciBpcyBub3QgYWR2YW5jaW5nLCBub3IgaXMgaXQgcHVzaGluZy9wb3BwaW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrID0gc3RhY2suc2FmZVBvcCgpO1xuICAgICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICAgICAgU1RPUCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYXB0dXJlSW5kaWNlc1swXS5lbmQgPiBsaW5lUG9zKSB7XG4gICAgICBsaW5lUG9zID0gY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICAgICAgaXNGaXJzdExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9jaGVja1doaWxlQ29uZGl0aW9ucyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBsaW5lVG9rZW5zKSB7XG4gIGxldCBhbmNob3JQb3NpdGlvbiA9IHN0YWNrLmJlZ2luUnVsZUNhcHR1cmVkRU9MID8gMCA6IC0xO1xuICBjb25zdCB3aGlsZVJ1bGVzID0gW107XG4gIGZvciAobGV0IG5vZGUgPSBzdGFjazsgbm9kZTsgbm9kZSA9IG5vZGUucG9wKCkpIHtcbiAgICBjb25zdCBub2RlUnVsZSA9IG5vZGUuZ2V0UnVsZShncmFtbWFyKTtcbiAgICBpZiAobm9kZVJ1bGUgaW5zdGFuY2VvZiBCZWdpbldoaWxlUnVsZSkge1xuICAgICAgd2hpbGVSdWxlcy5wdXNoKHtcbiAgICAgICAgcnVsZTogbm9kZVJ1bGUsXG4gICAgICAgIHN0YWNrOiBub2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgd2hpbGVSdWxlID0gd2hpbGVSdWxlcy5wb3AoKTsgd2hpbGVSdWxlOyB3aGlsZVJ1bGUgPSB3aGlsZVJ1bGVzLnBvcCgpKSB7XG4gICAgY29uc3QgeyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnMgfSA9IHByZXBhcmVSdWxlV2hpbGVTZWFyY2god2hpbGVSdWxlLnJ1bGUsIGdyYW1tYXIsIHdoaWxlUnVsZS5zdGFjay5lbmRSdWxlLCBpc0ZpcnN0TGluZSwgbGluZVBvcyA9PT0gYW5jaG9yUG9zaXRpb24pO1xuICAgIGNvbnN0IHIgPSBydWxlU2Nhbm5lci5maW5kTmV4dE1hdGNoU3luYyhsaW5lVGV4dCwgbGluZVBvcywgZmluZE9wdGlvbnMpO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgY29uc29sZS5sb2coXCIgIHNjYW5uaW5nIGZvciB3aGlsZSBydWxlXCIpO1xuICAgICAgY29uc29sZS5sb2cocnVsZVNjYW5uZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICBjb25zdCBtYXRjaGVkUnVsZUlkID0gci5ydWxlSWQ7XG4gICAgICBpZiAobWF0Y2hlZFJ1bGVJZCAhPT0gd2hpbGVSdWxlSWQpIHtcbiAgICAgICAgc3RhY2sgPSB3aGlsZVJ1bGUuc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHIuY2FwdHVyZUluZGljZXMgJiYgci5jYXB0dXJlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHdoaWxlUnVsZS5zdGFjaywgci5jYXB0dXJlSW5kaWNlc1swXS5zdGFydCk7XG4gICAgICAgIGhhbmRsZUNhcHR1cmVzKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgd2hpbGVSdWxlLnN0YWNrLCBsaW5lVG9rZW5zLCB3aGlsZVJ1bGUucnVsZS53aGlsZUNhcHR1cmVzLCByLmNhcHR1cmVJbmRpY2VzKTtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHdoaWxlUnVsZS5zdGFjaywgci5jYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgICBhbmNob3JQb3NpdGlvbiA9IHIuY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICAgICAgICBpZiAoci5jYXB0dXJlSW5kaWNlc1swXS5lbmQgPiBsaW5lUG9zKSB7XG4gICAgICAgICAgbGluZVBvcyA9IHIuY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICAgICAgICAgIGlzRmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiICBwb3BwaW5nIFwiICsgd2hpbGVSdWxlLnJ1bGUuZGVidWdOYW1lICsgXCIgLSBcIiArIHdoaWxlUnVsZS5ydWxlLmRlYnVnV2hpbGVSZWdFeHApO1xuICAgICAgfVxuICAgICAgc3RhY2sgPSB3aGlsZVJ1bGUuc3RhY2sucG9wKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgc3RhY2ssIGxpbmVQb3MsIGFuY2hvclBvc2l0aW9uLCBpc0ZpcnN0TGluZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hSdWxlT3JJbmplY3Rpb25zKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGFuY2hvclBvc2l0aW9uKSB7XG4gIGNvbnN0IG1hdGNoUmVzdWx0ID0gbWF0Y2hSdWxlKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGFuY2hvclBvc2l0aW9uKTtcbiAgY29uc3QgaW5qZWN0aW9ucyA9IGdyYW1tYXIuZ2V0SW5qZWN0aW9ucygpO1xuICBpZiAoaW5qZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbWF0Y2hSZXN1bHQ7XG4gIH1cbiAgY29uc3QgaW5qZWN0aW9uUmVzdWx0ID0gbWF0Y2hJbmplY3Rpb25zKGluamVjdGlvbnMsIGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGFuY2hvclBvc2l0aW9uKTtcbiAgaWYgKCFpbmplY3Rpb25SZXN1bHQpIHtcbiAgICByZXR1cm4gbWF0Y2hSZXN1bHQ7XG4gIH1cbiAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgIHJldHVybiBpbmplY3Rpb25SZXN1bHQ7XG4gIH1cbiAgY29uc3QgbWF0Y2hSZXN1bHRTY29yZSA9IG1hdGNoUmVzdWx0LmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0O1xuICBjb25zdCBpbmplY3Rpb25SZXN1bHRTY29yZSA9IGluamVjdGlvblJlc3VsdC5jYXB0dXJlSW5kaWNlc1swXS5zdGFydDtcbiAgaWYgKGluamVjdGlvblJlc3VsdFNjb3JlIDwgbWF0Y2hSZXN1bHRTY29yZSB8fCBpbmplY3Rpb25SZXN1bHQucHJpb3JpdHlNYXRjaCAmJiBpbmplY3Rpb25SZXN1bHRTY29yZSA9PT0gbWF0Y2hSZXN1bHRTY29yZSkge1xuICAgIHJldHVybiBpbmplY3Rpb25SZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIG1hdGNoUmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hSdWxlKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGFuY2hvclBvc2l0aW9uKSB7XG4gIGNvbnN0IHJ1bGUgPSBzdGFjay5nZXRSdWxlKGdyYW1tYXIpO1xuICBjb25zdCB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9ucyB9ID0gcHJlcGFyZVJ1bGVTZWFyY2gocnVsZSwgZ3JhbW1hciwgc3RhY2suZW5kUnVsZSwgaXNGaXJzdExpbmUsIGxpbmVQb3MgPT09IGFuY2hvclBvc2l0aW9uKTtcbiAgY29uc3QgciA9IHJ1bGVTY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKGxpbmVUZXh0LCBsaW5lUG9zLCBmaW5kT3B0aW9ucyk7XG4gIGlmIChyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmVJbmRpY2VzOiByLmNhcHR1cmVJbmRpY2VzLFxuICAgICAgbWF0Y2hlZFJ1bGVJZDogci5ydWxlSWRcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWF0Y2hJbmplY3Rpb25zKGluamVjdGlvbnMsIGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGFuY2hvclBvc2l0aW9uKSB7XG4gIGxldCBiZXN0TWF0Y2hSYXRpbmcgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICBsZXQgYmVzdE1hdGNoQ2FwdHVyZUluZGljZXMgPSBudWxsO1xuICBsZXQgYmVzdE1hdGNoUnVsZUlkO1xuICBsZXQgYmVzdE1hdGNoUmVzdWx0UHJpb3JpdHkgPSAwO1xuICBjb25zdCBzY29wZXMgPSBzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3QuZ2V0U2NvcGVOYW1lcygpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5qZWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGluamVjdGlvbiA9IGluamVjdGlvbnNbaV07XG4gICAgaWYgKCFpbmplY3Rpb24ubWF0Y2hlcihzY29wZXMpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShpbmplY3Rpb24ucnVsZUlkKTtcbiAgICBjb25zdCB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9ucyB9ID0gcHJlcGFyZVJ1bGVTZWFyY2gocnVsZSwgZ3JhbW1hciwgbnVsbCwgaXNGaXJzdExpbmUsIGxpbmVQb3MgPT09IGFuY2hvclBvc2l0aW9uKTtcbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHJ1bGVTY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKGxpbmVUZXh0LCBsaW5lUG9zLCBmaW5kT3B0aW9ucyk7XG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmYWxzZSkge1xuICAgICAgY29uc29sZS5sb2coYCAgbWF0Y2hlZCBpbmplY3Rpb246ICR7aW5qZWN0aW9uLmRlYnVnU2VsZWN0b3J9YCk7XG4gICAgICBjb25zb2xlLmxvZyhydWxlU2Nhbm5lci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hSYXRpbmcgPSBtYXRjaFJlc3VsdC5jYXB0dXJlSW5kaWNlc1swXS5zdGFydDtcbiAgICBpZiAobWF0Y2hSYXRpbmcgPj0gYmVzdE1hdGNoUmF0aW5nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYmVzdE1hdGNoUmF0aW5nID0gbWF0Y2hSYXRpbmc7XG4gICAgYmVzdE1hdGNoQ2FwdHVyZUluZGljZXMgPSBtYXRjaFJlc3VsdC5jYXB0dXJlSW5kaWNlcztcbiAgICBiZXN0TWF0Y2hSdWxlSWQgPSBtYXRjaFJlc3VsdC5ydWxlSWQ7XG4gICAgYmVzdE1hdGNoUmVzdWx0UHJpb3JpdHkgPSBpbmplY3Rpb24ucHJpb3JpdHk7XG4gICAgaWYgKGJlc3RNYXRjaFJhdGluZyA9PT0gbGluZVBvcykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcykge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlvcml0eU1hdGNoOiBiZXN0TWF0Y2hSZXN1bHRQcmlvcml0eSA9PT0gLTEsXG4gICAgICBjYXB0dXJlSW5kaWNlczogYmVzdE1hdGNoQ2FwdHVyZUluZGljZXMsXG4gICAgICBtYXRjaGVkUnVsZUlkOiBiZXN0TWF0Y2hSdWxlSWRcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVJ1bGVTZWFyY2gocnVsZSwgZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gIGlmIChVc2VPbmlndXJ1bWFGaW5kT3B0aW9ucykge1xuICAgIGNvbnN0IHJ1bGVTY2FubmVyMiA9IHJ1bGUuY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSk7XG4gICAgY29uc3QgZmluZE9wdGlvbnMgPSBnZXRGaW5kT3B0aW9ucyhhbGxvd0EsIGFsbG93Ryk7XG4gICAgcmV0dXJuIHsgcnVsZVNjYW5uZXI6IHJ1bGVTY2FubmVyMiwgZmluZE9wdGlvbnMgfTtcbiAgfVxuICBjb25zdCBydWxlU2Nhbm5lciA9IHJ1bGUuY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Ryk7XG4gIHJldHVybiB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9uczogMCAvKiBOb25lICovIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlUnVsZVdoaWxlU2VhcmNoKHJ1bGUsIGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICBpZiAoVXNlT25pZ3VydW1hRmluZE9wdGlvbnMpIHtcbiAgICBjb25zdCBydWxlU2Nhbm5lcjIgPSBydWxlLmNvbXBpbGVXaGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSk7XG4gICAgY29uc3QgZmluZE9wdGlvbnMgPSBnZXRGaW5kT3B0aW9ucyhhbGxvd0EsIGFsbG93Ryk7XG4gICAgcmV0dXJuIHsgcnVsZVNjYW5uZXI6IHJ1bGVTY2FubmVyMiwgZmluZE9wdGlvbnMgfTtcbiAgfVxuICBjb25zdCBydWxlU2Nhbm5lciA9IHJ1bGUuY29tcGlsZVdoaWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKTtcbiAgcmV0dXJuIHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zOiAwIC8qIE5vbmUgKi8gfTtcbn1cbmZ1bmN0aW9uIGdldEZpbmRPcHRpb25zKGFsbG93QSwgYWxsb3dHKSB7XG4gIGxldCBvcHRpb25zID0gMCAvKiBOb25lICovO1xuICBpZiAoIWFsbG93QSkge1xuICAgIG9wdGlvbnMgfD0gMSAvKiBOb3RCZWdpblN0cmluZyAqLztcbiAgfVxuICBpZiAoIWFsbG93Rykge1xuICAgIG9wdGlvbnMgfD0gNCAvKiBOb3RCZWdpblBvc2l0aW9uICovO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2FwdHVyZXMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBzdGFjaywgbGluZVRva2VucywgY2FwdHVyZXMsIGNhcHR1cmVJbmRpY2VzKSB7XG4gIGlmIChjYXB0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGluZVRleHRDb250ZW50ID0gbGluZVRleHQuY29udGVudDtcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oY2FwdHVyZXMubGVuZ3RoLCBjYXB0dXJlSW5kaWNlcy5sZW5ndGgpO1xuICBjb25zdCBsb2NhbFN0YWNrID0gW107XG4gIGNvbnN0IG1heEVuZCA9IGNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNhcHR1cmVSdWxlID0gY2FwdHVyZXNbaV07XG4gICAgaWYgKGNhcHR1cmVSdWxlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2FwdHVyZUluZGV4ID0gY2FwdHVyZUluZGljZXNbaV07XG4gICAgaWYgKGNhcHR1cmVJbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2FwdHVyZUluZGV4LnN0YXJ0ID4gbWF4RW5kKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgd2hpbGUgKGxvY2FsU3RhY2subGVuZ3RoID4gMCAmJiBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZW5kUG9zIDw9IGNhcHR1cmVJbmRleC5zdGFydCkge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlRnJvbVNjb3Blcyhsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzLCBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZW5kUG9zKTtcbiAgICAgIGxvY2FsU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZUZyb21TY29wZXMobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLnNjb3BlcywgY2FwdHVyZUluZGV4LnN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kZXguc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoY2FwdHVyZVJ1bGUucmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCkge1xuICAgICAgY29uc3Qgc2NvcGVOYW1lID0gY2FwdHVyZVJ1bGUuZ2V0TmFtZShsaW5lVGV4dENvbnRlbnQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgICAgIGNvbnN0IG5hbWVTY29wZXNMaXN0ID0gc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKHNjb3BlTmFtZSwgZ3JhbW1hcik7XG4gICAgICBjb25zdCBjb250ZW50TmFtZSA9IGNhcHR1cmVSdWxlLmdldENvbnRlbnROYW1lKGxpbmVUZXh0Q29udGVudCwgY2FwdHVyZUluZGljZXMpO1xuICAgICAgY29uc3QgY29udGVudE5hbWVTY29wZXNMaXN0ID0gbmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoY29udGVudE5hbWUsIGdyYW1tYXIpO1xuICAgICAgY29uc3Qgc3RhY2tDbG9uZSA9IHN0YWNrLnB1c2goY2FwdHVyZVJ1bGUucmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCwgY2FwdHVyZUluZGV4LnN0YXJ0LCAtMSwgZmFsc2UsIG51bGwsIG5hbWVTY29wZXNMaXN0LCBjb250ZW50TmFtZVNjb3Blc0xpc3QpO1xuICAgICAgY29uc3Qgb25pZ1N1YlN0ciA9IGdyYW1tYXIuY3JlYXRlT25pZ1N0cmluZyhsaW5lVGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIGNhcHR1cmVJbmRleC5lbmQpKTtcbiAgICAgIF90b2tlbml6ZVN0cmluZyhcbiAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgb25pZ1N1YlN0cixcbiAgICAgICAgaXNGaXJzdExpbmUgJiYgY2FwdHVyZUluZGV4LnN0YXJ0ID09PSAwLFxuICAgICAgICBjYXB0dXJlSW5kZXguc3RhcnQsXG4gICAgICAgIHN0YWNrQ2xvbmUsXG4gICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAvKiBubyB0aW1lIGxpbWl0ICovXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBkaXNwb3NlT25pZ1N0cmluZyhvbmlnU3ViU3RyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlUnVsZVNjb3BlTmFtZSA9IGNhcHR1cmVSdWxlLmdldE5hbWUobGluZVRleHRDb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgaWYgKGNhcHR1cmVSdWxlU2NvcGVOYW1lICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBiYXNlID0gbG9jYWxTdGFjay5sZW5ndGggPiAwID8gbG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLnNjb3BlcyA6IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdDtcbiAgICAgIGNvbnN0IGNhcHR1cmVSdWxlU2NvcGVzTGlzdCA9IGJhc2UucHVzaEF0dHJpYnV0ZWQoY2FwdHVyZVJ1bGVTY29wZU5hbWUsIGdyYW1tYXIpO1xuICAgICAgbG9jYWxTdGFjay5wdXNoKG5ldyBMb2NhbFN0YWNrRWxlbWVudChjYXB0dXJlUnVsZVNjb3Blc0xpc3QsIGNhcHR1cmVJbmRleC5lbmQpKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGxvY2FsU3RhY2subGVuZ3RoID4gMCkge1xuICAgIGxpbmVUb2tlbnMucHJvZHVjZUZyb21TY29wZXMobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLnNjb3BlcywgbG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmVuZFBvcyk7XG4gICAgbG9jYWxTdGFjay5wb3AoKTtcbiAgfVxufVxudmFyIExvY2FsU3RhY2tFbGVtZW50ID0gY2xhc3Mge1xuICBzY29wZXM7XG4gIGVuZFBvcztcbiAgY29uc3RydWN0b3Ioc2NvcGVzLCBlbmRQb3MpIHtcbiAgICB0aGlzLnNjb3BlcyA9IHNjb3BlcztcbiAgICB0aGlzLmVuZFBvcyA9IGVuZFBvcztcbiAgfVxufTtcblxuLy8gc3JjL2dyYW1tYXIvZ3JhbW1hci50c1xuZnVuY3Rpb24gY3JlYXRlR3JhbW1hcihzY29wZU5hbWUsIGdyYW1tYXIsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMsIHRva2VuVHlwZXMsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycywgZ3JhbW1hclJlcG9zaXRvcnksIG9uaWdMaWIpIHtcbiAgcmV0dXJuIG5ldyBHcmFtbWFyKFxuICAgIHNjb3BlTmFtZSxcbiAgICBncmFtbWFyLFxuICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICB0b2tlblR5cGVzLFxuICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyxcbiAgICBncmFtbWFyUmVwb3NpdG9yeSxcbiAgICBvbmlnTGliXG4gICk7XG59XG5mdW5jdGlvbiBjb2xsZWN0SW5qZWN0aW9ucyhyZXN1bHQsIHNlbGVjdG9yLCBydWxlLCBydWxlRmFjdG9yeUhlbHBlciwgZ3JhbW1hcikge1xuICBjb25zdCBtYXRjaGVycyA9IGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcik7XG4gIGNvbnN0IHJ1bGVJZCA9IFJ1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKHJ1bGUsIHJ1bGVGYWN0b3J5SGVscGVyLCBncmFtbWFyLnJlcG9zaXRvcnkpO1xuICBmb3IgKGNvbnN0IG1hdGNoZXIgb2YgbWF0Y2hlcnMpIHtcbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBkZWJ1Z1NlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIG1hdGNoZXI6IG1hdGNoZXIubWF0Y2hlcixcbiAgICAgIHJ1bGVJZCxcbiAgICAgIGdyYW1tYXIsXG4gICAgICBwcmlvcml0eTogbWF0Y2hlci5wcmlvcml0eVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBuYW1lTWF0Y2hlcihpZGVudGlmZXJzLCBzY29wZXMpIHtcbiAgaWYgKHNjb3Blcy5sZW5ndGggPCBpZGVudGlmZXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIGlkZW50aWZlcnMuZXZlcnkoKGlkZW50aWZpZXIpID0+IHtcbiAgICBmb3IgKGxldCBpID0gbGFzdEluZGV4OyBpIDwgc2NvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2NvcGVzQXJlTWF0Y2hpbmcoc2NvcGVzW2ldLCBpZGVudGlmaWVyKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzY29wZXNBcmVNYXRjaGluZyh0aGlzU2NvcGVOYW1lLCBzY29wZU5hbWUpIHtcbiAgaWYgKCF0aGlzU2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzU2NvcGVOYW1lID09PSBzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBsZW4gPSBzY29wZU5hbWUubGVuZ3RoO1xuICByZXR1cm4gdGhpc1Njb3BlTmFtZS5sZW5ndGggPiBsZW4gJiYgdGhpc1Njb3BlTmFtZS5zdWJzdHIoMCwgbGVuKSA9PT0gc2NvcGVOYW1lICYmIHRoaXNTY29wZU5hbWVbbGVuXSA9PT0gXCIuXCI7XG59XG52YXIgR3JhbW1hciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3Jvb3RTY29wZU5hbWUsIGdyYW1tYXIsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMsIHRva2VuVHlwZXMsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycywgZ3JhbW1hclJlcG9zaXRvcnksIF9vbmlnTGliKSB7XG4gICAgdGhpcy5fcm9vdFNjb3BlTmFtZSA9IF9yb290U2NvcGVOYW1lO1xuICAgIHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzID0gYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzO1xuICAgIHRoaXMuX29uaWdMaWIgPSBfb25pZ0xpYjtcbiAgICB0aGlzLl9iYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyID0gbmV3IEJhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIoXG4gICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICBlbWJlZGRlZExhbmd1YWdlc1xuICAgICk7XG4gICAgdGhpcy5fcm9vdElkID0gLTE7XG4gICAgdGhpcy5fbGFzdFJ1bGVJZCA9IDA7XG4gICAgdGhpcy5fcnVsZUlkMmRlc2MgPSBbbnVsbF07XG4gICAgdGhpcy5faW5jbHVkZWRHcmFtbWFycyA9IHt9O1xuICAgIHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5ID0gZ3JhbW1hclJlcG9zaXRvcnk7XG4gICAgdGhpcy5fZ3JhbW1hciA9IGluaXRHcmFtbWFyKGdyYW1tYXIsIG51bGwpO1xuICAgIHRoaXMuX2luamVjdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuX3Rva2VuVHlwZU1hdGNoZXJzID0gW107XG4gICAgaWYgKHRva2VuVHlwZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2YgT2JqZWN0LmtleXModG9rZW5UeXBlcykpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcnMgPSBjcmVhdGVNYXRjaGVycyhzZWxlY3RvciwgbmFtZU1hdGNoZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoZXIgb2YgbWF0Y2hlcnMpIHtcbiAgICAgICAgICB0aGlzLl90b2tlblR5cGVNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICAgIG1hdGNoZXI6IG1hdGNoZXIubWF0Y2hlcixcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHlwZXNbc2VsZWN0b3JdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jvb3RJZDtcbiAgX2xhc3RSdWxlSWQ7XG4gIF9ydWxlSWQyZGVzYztcbiAgX2luY2x1ZGVkR3JhbW1hcnM7XG4gIF9ncmFtbWFyUmVwb3NpdG9yeTtcbiAgX2dyYW1tYXI7XG4gIF9pbmplY3Rpb25zO1xuICBfYmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlcjtcbiAgX3Rva2VuVHlwZU1hdGNoZXJzO1xuICBnZXQgdGhlbWVQcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5fcnVsZUlkMmRlc2MpIHtcbiAgICAgIGlmIChydWxlKSB7XG4gICAgICAgIHJ1bGUuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVPbmlnU2Nhbm5lcihzb3VyY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uaWdMaWIuY3JlYXRlT25pZ1NjYW5uZXIoc291cmNlcyk7XG4gIH1cbiAgY3JlYXRlT25pZ1N0cmluZyhzb3VyY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uaWdMaWIuY3JlYXRlT25pZ1N0cmluZyhzb3VyY2VzKTtcbiAgfVxuICBnZXRNZXRhZGF0YUZvclNjb3BlKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIuZ2V0QmFzaWNTY29wZUF0dHJpYnV0ZXMoc2NvcGUpO1xuICB9XG4gIF9jb2xsZWN0SW5qZWN0aW9ucygpIHtcbiAgICBjb25zdCBncmFtbWFyUmVwb3NpdG9yeSA9IHtcbiAgICAgIGxvb2t1cDogKHNjb3BlTmFtZTIpID0+IHtcbiAgICAgICAgaWYgKHNjb3BlTmFtZTIgPT09IHRoaXMuX3Jvb3RTY29wZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ3JhbW1hcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHRlcm5hbEdyYW1tYXIoc2NvcGVOYW1lMik7XG4gICAgICB9LFxuICAgICAgaW5qZWN0aW9uczogKHNjb3BlTmFtZTIpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5LmluamVjdGlvbnMoc2NvcGVOYW1lMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzY29wZU5hbWUgPSB0aGlzLl9yb290U2NvcGVOYW1lO1xuICAgIGNvbnN0IGdyYW1tYXIgPSBncmFtbWFyUmVwb3NpdG9yeS5sb29rdXAoc2NvcGVOYW1lKTtcbiAgICBpZiAoZ3JhbW1hcikge1xuICAgICAgY29uc3QgcmF3SW5qZWN0aW9ucyA9IGdyYW1tYXIuaW5qZWN0aW9ucztcbiAgICAgIGlmIChyYXdJbmplY3Rpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGV4cHJlc3Npb24gaW4gcmF3SW5qZWN0aW9ucykge1xuICAgICAgICAgIGNvbGxlY3RJbmplY3Rpb25zKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHJhd0luamVjdGlvbnNbZXhwcmVzc2lvbl0sXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZ3JhbW1hclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGluamVjdGlvblNjb3BlTmFtZXMgPSB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeS5pbmplY3Rpb25zKHNjb3BlTmFtZSk7XG4gICAgICBpZiAoaW5qZWN0aW9uU2NvcGVOYW1lcykge1xuICAgICAgICBpbmplY3Rpb25TY29wZU5hbWVzLmZvckVhY2goKGluamVjdGlvblNjb3BlTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGluamVjdGlvbkdyYW1tYXIgPSB0aGlzLmdldEV4dGVybmFsR3JhbW1hcihpbmplY3Rpb25TY29wZU5hbWUpO1xuICAgICAgICAgIGlmIChpbmplY3Rpb25HcmFtbWFyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGluamVjdGlvbkdyYW1tYXIuaW5qZWN0aW9uU2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgY29sbGVjdEluamVjdGlvbnMoXG4gICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGluamVjdGlvbkdyYW1tYXIsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBpbmplY3Rpb25HcmFtbWFyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNvcnQoKGkxLCBpMikgPT4gaTEucHJpb3JpdHkgLSBpMi5wcmlvcml0eSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRJbmplY3Rpb25zKCkge1xuICAgIGlmICh0aGlzLl9pbmplY3Rpb25zID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9pbmplY3Rpb25zID0gdGhpcy5fY29sbGVjdEluamVjdGlvbnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luamVjdGlvbnM7XG4gIH1cbiAgcmVnaXN0ZXJSdWxlKGZhY3RvcnkpIHtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fbGFzdFJ1bGVJZDtcbiAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5KHJ1bGVJZEZyb21OdW1iZXIoaWQpKTtcbiAgICB0aGlzLl9ydWxlSWQyZGVzY1tpZF0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSdWxlKHJ1bGVJZCkge1xuICAgIHJldHVybiB0aGlzLl9ydWxlSWQyZGVzY1tydWxlSWRUb051bWJlcihydWxlSWQpXTtcbiAgfVxuICBnZXRFeHRlcm5hbEdyYW1tYXIoc2NvcGVOYW1lLCByZXBvc2l0b3J5KSB7XG4gICAgaWYgKHRoaXMuX2luY2x1ZGVkR3JhbW1hcnNbc2NvcGVOYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luY2x1ZGVkR3JhbW1hcnNbc2NvcGVOYW1lXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5KSB7XG4gICAgICBjb25zdCByYXdJbmNsdWRlZEdyYW1tYXIgPSB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeS5sb29rdXAoc2NvcGVOYW1lKTtcbiAgICAgIGlmIChyYXdJbmNsdWRlZEdyYW1tYXIpIHtcbiAgICAgICAgdGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdID0gaW5pdEdyYW1tYXIoXG4gICAgICAgICAgcmF3SW5jbHVkZWRHcmFtbWFyLFxuICAgICAgICAgIHJlcG9zaXRvcnkgJiYgcmVwb3NpdG9yeS4kYmFzZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHRva2VuaXplTGluZShsaW5lVGV4dCwgcHJldlN0YXRlLCB0aW1lTGltaXQgPSAwKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3Rva2VuaXplKGxpbmVUZXh0LCBwcmV2U3RhdGUsIGZhbHNlLCB0aW1lTGltaXQpO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IHIubGluZVRva2Vucy5nZXRSZXN1bHQoci5ydWxlU3RhY2ssIHIubGluZUxlbmd0aCksXG4gICAgICBydWxlU3RhY2s6IHIucnVsZVN0YWNrLFxuICAgICAgc3RvcHBlZEVhcmx5OiByLnN0b3BwZWRFYXJseVxuICAgIH07XG4gIH1cbiAgdG9rZW5pemVMaW5lMihsaW5lVGV4dCwgcHJldlN0YXRlLCB0aW1lTGltaXQgPSAwKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3Rva2VuaXplKGxpbmVUZXh0LCBwcmV2U3RhdGUsIHRydWUsIHRpbWVMaW1pdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2Vuczogci5saW5lVG9rZW5zLmdldEJpbmFyeVJlc3VsdChyLnJ1bGVTdGFjaywgci5saW5lTGVuZ3RoKSxcbiAgICAgIHJ1bGVTdGFjazogci5ydWxlU3RhY2ssXG4gICAgICBzdG9wcGVkRWFybHk6IHIuc3RvcHBlZEVhcmx5XG4gICAgfTtcbiAgfVxuICBfdG9rZW5pemUobGluZVRleHQsIHByZXZTdGF0ZSwgZW1pdEJpbmFyeVRva2VucywgdGltZUxpbWl0KSB7XG4gICAgaWYgKHRoaXMuX3Jvb3RJZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3Jvb3RJZCA9IFJ1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKFxuICAgICAgICB0aGlzLl9ncmFtbWFyLnJlcG9zaXRvcnkuJHNlbGYsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuX2dyYW1tYXIucmVwb3NpdG9yeVxuICAgICAgKTtcbiAgICAgIHRoaXMuZ2V0SW5qZWN0aW9ucygpO1xuICAgIH1cbiAgICBsZXQgaXNGaXJzdExpbmU7XG4gICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlID09PSBTdGF0ZVN0YWNrSW1wbC5OVUxMKSB7XG4gICAgICBpc0ZpcnN0TGluZSA9IHRydWU7XG4gICAgICBjb25zdCByYXdEZWZhdWx0TWV0YWRhdGEgPSB0aGlzLl9iYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyLmdldERlZmF1bHRBdHRyaWJ1dGVzKCk7XG4gICAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSB0aGlzLnRoZW1lUHJvdmlkZXIuZ2V0RGVmYXVsdHMoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YSA9IEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgICAgMCxcbiAgICAgICAgcmF3RGVmYXVsdE1ldGFkYXRhLmxhbmd1YWdlSWQsXG4gICAgICAgIHJhd0RlZmF1bHRNZXRhZGF0YS50b2tlblR5cGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGRlZmF1bHRTdHlsZS5mb250U3R5bGUsXG4gICAgICAgIGRlZmF1bHRTdHlsZS5mb3JlZ3JvdW5kSWQsXG4gICAgICAgIGRlZmF1bHRTdHlsZS5iYWNrZ3JvdW5kSWRcbiAgICAgICk7XG4gICAgICBjb25zdCByb290U2NvcGVOYW1lID0gdGhpcy5nZXRSdWxlKHRoaXMuX3Jvb3RJZCkuZ2V0TmFtZShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIGxldCBzY29wZUxpc3Q7XG4gICAgICBpZiAocm9vdFNjb3BlTmFtZSkge1xuICAgICAgICBzY29wZUxpc3QgPSBBdHRyaWJ1dGVkU2NvcGVTdGFjay5jcmVhdGVSb290QW5kTG9va1VwU2NvcGVOYW1lKFxuICAgICAgICAgIHJvb3RTY29wZU5hbWUsXG4gICAgICAgICAgZGVmYXVsdE1ldGFkYXRhLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlTGlzdCA9IEF0dHJpYnV0ZWRTY29wZVN0YWNrLmNyZWF0ZVJvb3QoXG4gICAgICAgICAgXCJ1bmtub3duXCIsXG4gICAgICAgICAgZGVmYXVsdE1ldGFkYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcmV2U3RhdGUgPSBuZXcgU3RhdGVTdGFja0ltcGwoXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuX3Jvb3RJZCxcbiAgICAgICAgLTEsXG4gICAgICAgIC0xLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgc2NvcGVMaXN0LFxuICAgICAgICBzY29wZUxpc3RcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzRmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICBwcmV2U3RhdGUucmVzZXQoKTtcbiAgICB9XG4gICAgbGluZVRleHQgPSBsaW5lVGV4dCArIFwiXFxuXCI7XG4gICAgY29uc3Qgb25pZ0xpbmVUZXh0ID0gdGhpcy5jcmVhdGVPbmlnU3RyaW5nKGxpbmVUZXh0KTtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gb25pZ0xpbmVUZXh0LmNvbnRlbnQubGVuZ3RoO1xuICAgIGNvbnN0IGxpbmVUb2tlbnMgPSBuZXcgTGluZVRva2VucyhcbiAgICAgIGVtaXRCaW5hcnlUb2tlbnMsXG4gICAgICBsaW5lVGV4dCxcbiAgICAgIHRoaXMuX3Rva2VuVHlwZU1hdGNoZXJzLFxuICAgICAgdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnNcbiAgICApO1xuICAgIGNvbnN0IHIgPSBfdG9rZW5pemVTdHJpbmcoXG4gICAgICB0aGlzLFxuICAgICAgb25pZ0xpbmVUZXh0LFxuICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAwLFxuICAgICAgcHJldlN0YXRlLFxuICAgICAgbGluZVRva2VucyxcbiAgICAgIHRydWUsXG4gICAgICB0aW1lTGltaXRcbiAgICApO1xuICAgIGRpc3Bvc2VPbmlnU3RyaW5nKG9uaWdMaW5lVGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVMZW5ndGgsXG4gICAgICBsaW5lVG9rZW5zLFxuICAgICAgcnVsZVN0YWNrOiByLnN0YWNrLFxuICAgICAgc3RvcHBlZEVhcmx5OiByLnN0b3BwZWRFYXJseVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBpbml0R3JhbW1hcihncmFtbWFyLCBiYXNlKSB7XG4gIGdyYW1tYXIgPSBjbG9uZShncmFtbWFyKTtcbiAgZ3JhbW1hci5yZXBvc2l0b3J5ID0gZ3JhbW1hci5yZXBvc2l0b3J5IHx8IHt9O1xuICBncmFtbWFyLnJlcG9zaXRvcnkuJHNlbGYgPSB7XG4gICAgJHZzY29kZVRleHRtYXRlTG9jYXRpb246IGdyYW1tYXIuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgcGF0dGVybnM6IGdyYW1tYXIucGF0dGVybnMsXG4gICAgbmFtZTogZ3JhbW1hci5zY29wZU5hbWVcbiAgfTtcbiAgZ3JhbW1hci5yZXBvc2l0b3J5LiRiYXNlID0gYmFzZSB8fCBncmFtbWFyLnJlcG9zaXRvcnkuJHNlbGY7XG4gIHJldHVybiBncmFtbWFyO1xufVxudmFyIEF0dHJpYnV0ZWRTY29wZVN0YWNrID0gY2xhc3MgX0F0dHJpYnV0ZWRTY29wZVN0YWNrIHtcbiAgLyoqXG4gICAqIEludmFyaWFudDpcbiAgICogYGBgXG4gICAqIGlmIChwYXJlbnQgJiYgIXNjb3BlUGF0aC5leHRlbmRzKHBhcmVudC5zY29wZVBhdGgpKSB7XG4gICAqIFx0dGhyb3cgbmV3IEVycm9yKCk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHNjb3BlUGF0aCwgdG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zY29wZVBhdGggPSBzY29wZVBhdGg7XG4gICAgdGhpcy50b2tlbkF0dHJpYnV0ZXMgPSB0b2tlbkF0dHJpYnV0ZXM7XG4gIH1cbiAgc3RhdGljIGZyb21FeHRlbnNpb24obmFtZXNTY29wZUxpc3QsIGNvbnRlbnROYW1lU2NvcGVzTGlzdCkge1xuICAgIGxldCBjdXJyZW50ID0gbmFtZXNTY29wZUxpc3Q7XG4gICAgbGV0IHNjb3BlTmFtZXMgPSBuYW1lc1Njb3BlTGlzdD8uc2NvcGVQYXRoID8/IG51bGw7XG4gICAgZm9yIChjb25zdCBmcmFtZSBvZiBjb250ZW50TmFtZVNjb3Blc0xpc3QpIHtcbiAgICAgIHNjb3BlTmFtZXMgPSBTY29wZVN0YWNrLnB1c2goc2NvcGVOYW1lcywgZnJhbWUuc2NvcGVOYW1lcyk7XG4gICAgICBjdXJyZW50ID0gbmV3IF9BdHRyaWJ1dGVkU2NvcGVTdGFjayhjdXJyZW50LCBzY29wZU5hbWVzLCBmcmFtZS5lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJvb3Qoc2NvcGVOYW1lLCB0b2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gbmV3IF9BdHRyaWJ1dGVkU2NvcGVTdGFjayhudWxsLCBuZXcgU2NvcGVTdGFjayhudWxsLCBzY29wZU5hbWUpLCB0b2tlbkF0dHJpYnV0ZXMpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVSb290QW5kTG9va1VwU2NvcGVOYW1lKHNjb3BlTmFtZSwgdG9rZW5BdHRyaWJ1dGVzLCBncmFtbWFyKSB7XG4gICAgY29uc3QgcmF3Um9vdE1ldGFkYXRhID0gZ3JhbW1hci5nZXRNZXRhZGF0YUZvclNjb3BlKHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc2NvcGVQYXRoID0gbmV3IFNjb3BlU3RhY2sobnVsbCwgc2NvcGVOYW1lKTtcbiAgICBjb25zdCByb290U3R5bGUgPSBncmFtbWFyLnRoZW1lUHJvdmlkZXIudGhlbWVNYXRjaChzY29wZVBhdGgpO1xuICAgIGNvbnN0IHJlc29sdmVkVG9rZW5BdHRyaWJ1dGVzID0gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLm1lcmdlQXR0cmlidXRlcyhcbiAgICAgIHRva2VuQXR0cmlidXRlcyxcbiAgICAgIHJhd1Jvb3RNZXRhZGF0YSxcbiAgICAgIHJvb3RTdHlsZVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBfQXR0cmlidXRlZFNjb3BlU3RhY2sobnVsbCwgc2NvcGVQYXRoLCByZXNvbHZlZFRva2VuQXR0cmlidXRlcyk7XG4gIH1cbiAgZ2V0IHNjb3BlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVBhdGguc2NvcGVOYW1lO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjb3BlTmFtZXMoKS5qb2luKFwiIFwiKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLmVxdWFscyh0aGlzLCBvdGhlcik7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgZG8ge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGEuc2NvcGVOYW1lICE9PSBiLnNjb3BlTmFtZSB8fCBhLnRva2VuQXR0cmlidXRlcyAhPT0gYi50b2tlbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYSA9IGEucGFyZW50O1xuICAgICAgYiA9IGIucGFyZW50O1xuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG4gIHN0YXRpYyBtZXJnZUF0dHJpYnV0ZXMoZXhpc3RpbmdUb2tlbkF0dHJpYnV0ZXMsIGJhc2ljU2NvcGVBdHRyaWJ1dGVzLCBzdHlsZUF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgZm9udFN0eWxlID0gLTEgLyogTm90U2V0ICovO1xuICAgIGxldCBmb3JlZ3JvdW5kID0gMDtcbiAgICBsZXQgYmFja2dyb3VuZCA9IDA7XG4gICAgaWYgKHN0eWxlQXR0cmlidXRlcyAhPT0gbnVsbCkge1xuICAgICAgZm9udFN0eWxlID0gc3R5bGVBdHRyaWJ1dGVzLmZvbnRTdHlsZTtcbiAgICAgIGZvcmVncm91bmQgPSBzdHlsZUF0dHJpYnV0ZXMuZm9yZWdyb3VuZElkO1xuICAgICAgYmFja2dyb3VuZCA9IHN0eWxlQXR0cmlidXRlcy5iYWNrZ3JvdW5kSWQ7XG4gICAgfVxuICAgIHJldHVybiBFbmNvZGVkVG9rZW5NZXRhZGF0YS5zZXQoXG4gICAgICBleGlzdGluZ1Rva2VuQXR0cmlidXRlcyxcbiAgICAgIGJhc2ljU2NvcGVBdHRyaWJ1dGVzLmxhbmd1YWdlSWQsXG4gICAgICBiYXNpY1Njb3BlQXR0cmlidXRlcy50b2tlblR5cGUsXG4gICAgICBudWxsLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9yZWdyb3VuZCxcbiAgICAgIGJhY2tncm91bmRcbiAgICApO1xuICB9XG4gIHB1c2hBdHRyaWJ1dGVkKHNjb3BlUGF0aCwgZ3JhbW1hcikge1xuICAgIGlmIChzY29wZVBhdGggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoc2NvcGVQYXRoLmluZGV4T2YoXCIgXCIpID09PSAtMSkge1xuICAgICAgcmV0dXJuIF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5fcHVzaEF0dHJpYnV0ZWQodGhpcywgc2NvcGVQYXRoLCBncmFtbWFyKTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gc2NvcGVQYXRoLnNwbGl0KC8gL2cpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzO1xuICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICByZXN1bHQgPSBfQXR0cmlidXRlZFNjb3BlU3RhY2suX3B1c2hBdHRyaWJ1dGVkKHJlc3VsdCwgc2NvcGUsIGdyYW1tYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBfcHVzaEF0dHJpYnV0ZWQodGFyZ2V0LCBzY29wZU5hbWUsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByYXdNZXRhZGF0YSA9IGdyYW1tYXIuZ2V0TWV0YWRhdGFGb3JTY29wZShzY29wZU5hbWUpO1xuICAgIGNvbnN0IG5ld1BhdGggPSB0YXJnZXQuc2NvcGVQYXRoLnB1c2goc2NvcGVOYW1lKTtcbiAgICBjb25zdCBzY29wZVRoZW1lTWF0Y2hSZXN1bHQgPSBncmFtbWFyLnRoZW1lUHJvdmlkZXIudGhlbWVNYXRjaChuZXdQYXRoKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5tZXJnZUF0dHJpYnV0ZXMoXG4gICAgICB0YXJnZXQudG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgcmF3TWV0YWRhdGEsXG4gICAgICBzY29wZVRoZW1lTWF0Y2hSZXN1bHRcbiAgICApO1xuICAgIHJldHVybiBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKHRhcmdldCwgbmV3UGF0aCwgbWV0YWRhdGEpO1xuICB9XG4gIGdldFNjb3BlTmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVQYXRoLmdldFNlZ21lbnRzKCk7XG4gIH1cbiAgZ2V0RXh0ZW5zaW9uSWZEZWZpbmVkKGJhc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgd2hpbGUgKHNlbGYgJiYgc2VsZiAhPT0gYmFzZSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzOiBzZWxmLnRva2VuQXR0cmlidXRlcyxcbiAgICAgICAgc2NvcGVOYW1lczogc2VsZi5zY29wZVBhdGguZ2V0RXh0ZW5zaW9uSWZEZWZpbmVkKHNlbGYucGFyZW50Py5zY29wZVBhdGggPz8gbnVsbClcbiAgICAgIH0pO1xuICAgICAgc2VsZiA9IHNlbGYucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gc2VsZiA9PT0gYmFzZSA/IHJlc3VsdC5yZXZlcnNlKCkgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgU3RhdGVTdGFja0ltcGwgPSBjbGFzcyBfU3RhdGVTdGFja0ltcGwge1xuICAvKipcbiAgICogSW52YXJpYW50OlxuICAgKiBgYGBcbiAgICogaWYgKGNvbnRlbnROYW1lU2NvcGVzTGlzdCAhPT0gbmFtZVNjb3Blc0xpc3QgJiYgY29udGVudE5hbWVTY29wZXNMaXN0Py5wYXJlbnQgIT09IG5hbWVTY29wZXNMaXN0KSB7XG4gICAqIFx0dGhyb3cgbmV3IEVycm9yKCk7XG4gICAqIH1cbiAgICogaWYgKHRoaXMucGFyZW50ICYmICFuYW1lU2NvcGVzTGlzdC5leHRlbmRzKHRoaXMucGFyZW50LmNvbnRlbnROYW1lU2NvcGVzTGlzdCkpIHtcbiAgICogXHR0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgcnVsZUlkLCBlbnRlclBvcywgYW5jaG9yUG9zLCBiZWdpblJ1bGVDYXB0dXJlZEVPTCwgZW5kUnVsZSwgbmFtZVNjb3Blc0xpc3QsIGNvbnRlbnROYW1lU2NvcGVzTGlzdCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucnVsZUlkID0gcnVsZUlkO1xuICAgIHRoaXMuYmVnaW5SdWxlQ2FwdHVyZWRFT0wgPSBiZWdpblJ1bGVDYXB0dXJlZEVPTDtcbiAgICB0aGlzLmVuZFJ1bGUgPSBlbmRSdWxlO1xuICAgIHRoaXMubmFtZVNjb3Blc0xpc3QgPSBuYW1lU2NvcGVzTGlzdDtcbiAgICB0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdCA9IGNvbnRlbnROYW1lU2NvcGVzTGlzdDtcbiAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5kZXB0aCArIDEgOiAxO1xuICAgIHRoaXMuX2VudGVyUG9zID0gZW50ZXJQb3M7XG4gICAgdGhpcy5fYW5jaG9yUG9zID0gYW5jaG9yUG9zO1xuICB9XG4gIF9zdGFja0VsZW1lbnRCcmFuZCA9IHZvaWQgMDtcbiAgLy8gVE9ETyByZW1vdmUgbWVcbiAgc3RhdGljIE5VTEwgPSBuZXcgX1N0YXRlU3RhY2tJbXBsKFxuICAgIG51bGwsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgZmFsc2UsXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIG51bGxcbiAgKTtcbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvbiB0aGUgY3VycmVudCBsaW5lIHdoZXJlIHRoaXMgc3RhdGUgd2FzIHB1c2hlZC5cbiAgICogVGhpcyBpcyByZWxldmFudCBvbmx5IHdoaWxlIHRva2VuaXppbmcgYSBsaW5lLCB0byBkZXRlY3QgZW5kbGVzcyBsb29wcy5cbiAgICogSXRzIHZhbHVlIGlzIG1lYW5pbmdsZXNzIGFjcm9zcyBsaW5lcy5cbiAgICovXG4gIF9lbnRlclBvcztcbiAgLyoqXG4gICAqIFRoZSBjYXB0dXJlZCBhbmNob3IgcG9zaXRpb24gd2hlbiB0aGlzIHN0YWNrIGVsZW1lbnQgd2FzIHB1c2hlZC5cbiAgICogVGhpcyBpcyByZWxldmFudCBvbmx5IHdoaWxlIHRva2VuaXppbmcgYSBsaW5lLCB0byByZXN0b3JlIHRoZSBhbmNob3IgcG9zaXRpb24gd2hlbiBwb3BwaW5nLlxuICAgKiBJdHMgdmFsdWUgaXMgbWVhbmluZ2xlc3MgYWNyb3NzIGxpbmVzLlxuICAgKi9cbiAgX2FuY2hvclBvcztcbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBvZiB0aGUgc3RhY2suXG4gICAqL1xuICBkZXB0aDtcbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfU3RhdGVTdGFja0ltcGwuX2VxdWFscyh0aGlzLCBvdGhlcik7XG4gIH1cbiAgc3RhdGljIF9lcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdHJ1Y3R1cmFsRXF1YWxzKGEsIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBBdHRyaWJ1dGVkU2NvcGVTdGFjay5lcXVhbHMoYS5jb250ZW50TmFtZVNjb3Blc0xpc3QsIGIuY29udGVudE5hbWVTY29wZXNMaXN0KTtcbiAgfVxuICAvKipcbiAgICogQSBzdHJ1Y3R1cmFsIGVxdWFscyBjaGVjay4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgYHNjb3Blc2AuXG4gICAqL1xuICBzdGF0aWMgX3N0cnVjdHVyYWxFcXVhbHMoYSwgYikge1xuICAgIGRvIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmRlcHRoICE9PSBiLmRlcHRoIHx8IGEucnVsZUlkICE9PSBiLnJ1bGVJZCB8fCBhLmVuZFJ1bGUgIT09IGIuZW5kUnVsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgICBiID0gYi5wYXJlbnQ7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIF9yZXNldChlbCkge1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgZWwuX2VudGVyUG9zID0gLTE7XG4gICAgICBlbC5fYW5jaG9yUG9zID0gLTE7XG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgX1N0YXRlU3RhY2tJbXBsLl9yZXNldCh0aGlzKTtcbiAgfVxuICBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICB9XG4gIHNhZmVQb3AoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2gocnVsZUlkLCBlbnRlclBvcywgYW5jaG9yUG9zLCBiZWdpblJ1bGVDYXB0dXJlZEVPTCwgZW5kUnVsZSwgbmFtZVNjb3Blc0xpc3QsIGNvbnRlbnROYW1lU2NvcGVzTGlzdCkge1xuICAgIHJldHVybiBuZXcgX1N0YXRlU3RhY2tJbXBsKFxuICAgICAgdGhpcyxcbiAgICAgIHJ1bGVJZCxcbiAgICAgIGVudGVyUG9zLFxuICAgICAgYW5jaG9yUG9zLFxuICAgICAgYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICBlbmRSdWxlLFxuICAgICAgbmFtZVNjb3Blc0xpc3QsXG4gICAgICBjb250ZW50TmFtZVNjb3Blc0xpc3RcbiAgICApO1xuICB9XG4gIGdldEVudGVyUG9zKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRlclBvcztcbiAgfVxuICBnZXRBbmNob3JQb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvclBvcztcbiAgfVxuICBnZXRSdWxlKGdyYW1tYXIpIHtcbiAgICByZXR1cm4gZ3JhbW1hci5nZXRSdWxlKHRoaXMucnVsZUlkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgdGhpcy5fd3JpdGVTdHJpbmcociwgMCk7XG4gICAgcmV0dXJuIFwiW1wiICsgci5qb2luKFwiLFwiKSArIFwiXVwiO1xuICB9XG4gIF93cml0ZVN0cmluZyhyZXMsIG91dEluZGV4KSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBvdXRJbmRleCA9IHRoaXMucGFyZW50Ll93cml0ZVN0cmluZyhyZXMsIG91dEluZGV4KTtcbiAgICB9XG4gICAgcmVzW291dEluZGV4KytdID0gYCgke3RoaXMucnVsZUlkfSwgJHt0aGlzLm5hbWVTY29wZXNMaXN0Py50b1N0cmluZygpfSwgJHt0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdD8udG9TdHJpbmcoKX0pYDtcbiAgICByZXR1cm4gb3V0SW5kZXg7XG4gIH1cbiAgd2l0aENvbnRlbnROYW1lU2NvcGVzTGlzdChjb250ZW50TmFtZVNjb3BlU3RhY2spIHtcbiAgICBpZiAodGhpcy5jb250ZW50TmFtZVNjb3Blc0xpc3QgPT09IGNvbnRlbnROYW1lU2NvcGVTdGFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5wdXNoKFxuICAgICAgdGhpcy5ydWxlSWQsXG4gICAgICB0aGlzLl9lbnRlclBvcyxcbiAgICAgIHRoaXMuX2FuY2hvclBvcyxcbiAgICAgIHRoaXMuYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICB0aGlzLmVuZFJ1bGUsXG4gICAgICB0aGlzLm5hbWVTY29wZXNMaXN0LFxuICAgICAgY29udGVudE5hbWVTY29wZVN0YWNrXG4gICAgKTtcbiAgfVxuICB3aXRoRW5kUnVsZShlbmRSdWxlKSB7XG4gICAgaWYgKHRoaXMuZW5kUnVsZSA9PT0gZW5kUnVsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1N0YXRlU3RhY2tJbXBsKFxuICAgICAgdGhpcy5wYXJlbnQsXG4gICAgICB0aGlzLnJ1bGVJZCxcbiAgICAgIHRoaXMuX2VudGVyUG9zLFxuICAgICAgdGhpcy5fYW5jaG9yUG9zLFxuICAgICAgdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIGVuZFJ1bGUsXG4gICAgICB0aGlzLm5hbWVTY29wZXNMaXN0LFxuICAgICAgdGhpcy5jb250ZW50TmFtZVNjb3Blc0xpc3RcbiAgICApO1xuICB9XG4gIC8vIFVzZWQgdG8gd2FybiBvZiBlbmRsZXNzIGxvb3BzXG4gIGhhc1NhbWVSdWxlQXMob3RoZXIpIHtcbiAgICBsZXQgZWwgPSB0aGlzO1xuICAgIHdoaWxlIChlbCAmJiBlbC5fZW50ZXJQb3MgPT09IG90aGVyLl9lbnRlclBvcykge1xuICAgICAgaWYgKGVsLnJ1bGVJZCA9PT0gb3RoZXIucnVsZUlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0YXRlU3RhY2tGcmFtZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcnVsZUlkOiBydWxlSWRUb051bWJlcih0aGlzLnJ1bGVJZCksXG4gICAgICBiZWdpblJ1bGVDYXB0dXJlZEVPTDogdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIGVuZFJ1bGU6IHRoaXMuZW5kUnVsZSxcbiAgICAgIG5hbWVTY29wZXNMaXN0OiB0aGlzLm5hbWVTY29wZXNMaXN0Py5nZXRFeHRlbnNpb25JZkRlZmluZWQodGhpcy5wYXJlbnQ/Lm5hbWVTY29wZXNMaXN0ID8/IG51bGwpID8/IFtdLFxuICAgICAgY29udGVudE5hbWVTY29wZXNMaXN0OiB0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdD8uZ2V0RXh0ZW5zaW9uSWZEZWZpbmVkKHRoaXMubmFtZVNjb3Blc0xpc3QpID8/IFtdXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcHVzaEZyYW1lKHNlbGYsIGZyYW1lKSB7XG4gICAgY29uc3QgbmFtZXNTY29wZUxpc3QgPSBBdHRyaWJ1dGVkU2NvcGVTdGFjay5mcm9tRXh0ZW5zaW9uKHNlbGY/Lm5hbWVTY29wZXNMaXN0ID8/IG51bGwsIGZyYW1lLm5hbWVTY29wZXNMaXN0KTtcbiAgICByZXR1cm4gbmV3IF9TdGF0ZVN0YWNrSW1wbChcbiAgICAgIHNlbGYsXG4gICAgICBydWxlSWRGcm9tTnVtYmVyKGZyYW1lLnJ1bGVJZCksXG4gICAgICBmcmFtZS5lbnRlclBvcyA/PyAtMSxcbiAgICAgIGZyYW1lLmFuY2hvclBvcyA/PyAtMSxcbiAgICAgIGZyYW1lLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZnJhbWUuZW5kUnVsZSxcbiAgICAgIG5hbWVzU2NvcGVMaXN0LFxuICAgICAgQXR0cmlidXRlZFNjb3BlU3RhY2suZnJvbUV4dGVuc2lvbihuYW1lc1Njb3BlTGlzdCwgZnJhbWUuY29udGVudE5hbWVTY29wZXNMaXN0KVxuICAgICk7XG4gIH1cbn07XG52YXIgQmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzID0gY2xhc3Mge1xuICBiYWxhbmNlZEJyYWNrZXRTY29wZXM7XG4gIHVuYmFsYW5jZWRCcmFja2V0U2NvcGVzO1xuICBhbGxvd0FueSA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihiYWxhbmNlZEJyYWNrZXRTY29wZXMsIHVuYmFsYW5jZWRCcmFja2V0U2NvcGVzKSB7XG4gICAgdGhpcy5iYWxhbmNlZEJyYWNrZXRTY29wZXMgPSBiYWxhbmNlZEJyYWNrZXRTY29wZXMuZmxhdE1hcChcbiAgICAgIChzZWxlY3RvcikgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IFwiKlwiKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd0FueSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVNYXRjaGVycyhzZWxlY3RvciwgbmFtZU1hdGNoZXIpLm1hcCgobSkgPT4gbS5tYXRjaGVyKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMudW5iYWxhbmNlZEJyYWNrZXRTY29wZXMgPSB1bmJhbGFuY2VkQnJhY2tldFNjb3Blcy5mbGF0TWFwKFxuICAgICAgKHNlbGVjdG9yKSA9PiBjcmVhdGVNYXRjaGVycyhzZWxlY3RvciwgbmFtZU1hdGNoZXIpLm1hcCgobSkgPT4gbS5tYXRjaGVyKVxuICAgICk7XG4gIH1cbiAgZ2V0IG1hdGNoZXNBbHdheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dBbnkgJiYgdGhpcy51bmJhbGFuY2VkQnJhY2tldFNjb3Blcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgZ2V0IG1hdGNoZXNOZXZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5iYWxhbmNlZEJyYWNrZXRTY29wZXMubGVuZ3RoID09PSAwICYmICF0aGlzLmFsbG93QW55O1xuICB9XG4gIG1hdGNoKHNjb3Blcykge1xuICAgIGZvciAoY29uc3QgZXhjbHVkZXIgb2YgdGhpcy51bmJhbGFuY2VkQnJhY2tldFNjb3Blcykge1xuICAgICAgaWYgKGV4Y2x1ZGVyKHNjb3BlcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluY2x1ZGVyIG9mIHRoaXMuYmFsYW5jZWRCcmFja2V0U2NvcGVzKSB7XG4gICAgICBpZiAoaW5jbHVkZXIoc2NvcGVzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dBbnk7XG4gIH1cbn07XG52YXIgTGluZVRva2VucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW1pdEJpbmFyeVRva2VucywgbGluZVRleHQsIHRva2VuVHlwZU92ZXJyaWRlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM7XG4gICAgdGhpcy5fZW1pdEJpbmFyeVRva2VucyA9IGVtaXRCaW5hcnlUb2tlbnM7XG4gICAgdGhpcy5fdG9rZW5UeXBlT3ZlcnJpZGVzID0gdG9rZW5UeXBlT3ZlcnJpZGVzO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgdGhpcy5fbGluZVRleHQgPSBsaW5lVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGluZVRleHQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl90b2tlbnMgPSBbXTtcbiAgICB0aGlzLl9iaW5hcnlUb2tlbnMgPSBbXTtcbiAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IDA7XG4gIH1cbiAgX2VtaXRCaW5hcnlUb2tlbnM7XG4gIC8qKlxuICAgKiBkZWZpbmVkIG9ubHkgaWYgYGZhbHNlYC5cbiAgICovXG4gIF9saW5lVGV4dDtcbiAgLyoqXG4gICAqIHVzZWQgb25seSBpZiBgX2VtaXRCaW5hcnlUb2tlbnNgIGlzIGZhbHNlLlxuICAgKi9cbiAgX3Rva2VucztcbiAgLyoqXG4gICAqIHVzZWQgb25seSBpZiBgX2VtaXRCaW5hcnlUb2tlbnNgIGlzIHRydWUuXG4gICAqL1xuICBfYmluYXJ5VG9rZW5zO1xuICBfbGFzdFRva2VuRW5kSW5kZXg7XG4gIF90b2tlblR5cGVPdmVycmlkZXM7XG4gIHByb2R1Y2Uoc3RhY2ssIGVuZEluZGV4KSB7XG4gICAgdGhpcy5wcm9kdWNlRnJvbVNjb3BlcyhzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3QsIGVuZEluZGV4KTtcbiAgfVxuICBwcm9kdWNlRnJvbVNjb3BlcyhzY29wZXNMaXN0LCBlbmRJbmRleCkge1xuICAgIGlmICh0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA+PSBlbmRJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdEJpbmFyeVRva2Vucykge1xuICAgICAgbGV0IG1ldGFkYXRhID0gc2NvcGVzTGlzdD8udG9rZW5BdHRyaWJ1dGVzID8/IDA7XG4gICAgICBsZXQgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM/Lm1hdGNoZXNBbHdheXMpIHtcbiAgICAgICAgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl90b2tlblR5cGVPdmVycmlkZXMubGVuZ3RoID4gMCB8fCB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyAmJiAhdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMubWF0Y2hlc0Fsd2F5cyAmJiAhdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMubWF0Y2hlc05ldmVyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlczIgPSBzY29wZXNMaXN0Py5nZXRTY29wZU5hbWVzKCkgPz8gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW5UeXBlIG9mIHRoaXMuX3Rva2VuVHlwZU92ZXJyaWRlcykge1xuICAgICAgICAgIGlmICh0b2tlblR5cGUubWF0Y2hlcihzY29wZXMyKSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBFbmNvZGVkVG9rZW5NZXRhZGF0YS5zZXQoXG4gICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICB0b09wdGlvbmFsVG9rZW5UeXBlKHRva2VuVHlwZS50eXBlKSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgLTEgLyogTm90U2V0ICovLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMpIHtcbiAgICAgICAgICBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPSB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycy5tYXRjaChzY29wZXMyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cykge1xuICAgICAgICBtZXRhZGF0YSA9IEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDggLyogTm90U2V0ICovLFxuICAgICAgICAgIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyxcbiAgICAgICAgICAtMSAvKiBOb3RTZXQgKi8sXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCA+IDAgJiYgdGhpcy5fYmluYXJ5VG9rZW5zW3RoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggLSAxXSA9PT0gbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zLnB1c2godGhpcy5fbGFzdFRva2VuRW5kSW5kZXgpO1xuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zLnB1c2gobWV0YWRhdGEpO1xuICAgICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gc2NvcGVzTGlzdD8uZ2V0U2NvcGVOYW1lcygpID8/IFtdO1xuICAgIHRoaXMuX3Rva2Vucy5wdXNoKHtcbiAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4LFxuICAgICAgZW5kSW5kZXgsXG4gICAgICAvLyB2YWx1ZTogbGluZVRleHQuc3Vic3RyaW5nKGxhc3RUb2tlbkVuZEluZGV4LCBlbmRJbmRleCksXG4gICAgICBzY29wZXNcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IGVuZEluZGV4O1xuICB9XG4gIGdldFJlc3VsdChzdGFjaywgbGluZUxlbmd0aCkge1xuICAgIGlmICh0aGlzLl90b2tlbnMubGVuZ3RoID4gMCAmJiB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdLnN0YXJ0SW5kZXggPT09IGxpbmVMZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLl90b2tlbnMucG9wKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl90b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IC0xO1xuICAgICAgdGhpcy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgIHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV0uc3RhcnRJbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90b2tlbnM7XG4gIH1cbiAgZ2V0QmluYXJ5UmVzdWx0KHN0YWNrLCBsaW5lTGVuZ3RoKSB7XG4gICAgaWYgKHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggPiAwICYmIHRoaXMuX2JpbmFyeVRva2Vuc1t0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoIC0gMl0gPT09IGxpbmVMZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucG9wKCk7XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucG9wKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IC0xO1xuICAgICAgdGhpcy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vuc1t0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoIC0gMl0gPSAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdGhpcy5fYmluYXJ5VG9rZW5zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvcmVnaXN0cnkudHNcbnZhciBTeW5jUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRoZW1lLCBfb25pZ0xpYikge1xuICAgIHRoaXMuX29uaWdMaWIgPSBfb25pZ0xpYjtcbiAgICB0aGlzLl90aGVtZSA9IHRoZW1lO1xuICB9XG4gIF9ncmFtbWFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9yYXdHcmFtbWFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9pbmplY3Rpb25HcmFtbWFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF90aGVtZTtcbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGdyYW1tYXIgb2YgdGhpcy5fZ3JhbW1hcnMudmFsdWVzKCkpIHtcbiAgICAgIGdyYW1tYXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICBzZXRUaGVtZSh0aGVtZSkge1xuICAgIHRoaXMuX3RoZW1lID0gdGhlbWU7XG4gIH1cbiAgZ2V0Q29sb3JNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW1lLmdldENvbG9yTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBgZ3JhbW1hcmAgdG8gcmVnaXN0cnkgYW5kIHJldHVybiBhIGxpc3Qgb2YgcmVmZXJlbmNlZCBzY29wZSBuYW1lc1xuICAgKi9cbiAgYWRkR3JhbW1hcihncmFtbWFyLCBpbmplY3Rpb25TY29wZU5hbWVzKSB7XG4gICAgdGhpcy5fcmF3R3JhbW1hcnMuc2V0KGdyYW1tYXIuc2NvcGVOYW1lLCBncmFtbWFyKTtcbiAgICBpZiAoaW5qZWN0aW9uU2NvcGVOYW1lcykge1xuICAgICAgdGhpcy5faW5qZWN0aW9uR3JhbW1hcnMuc2V0KGdyYW1tYXIuc2NvcGVOYW1lLCBpbmplY3Rpb25TY29wZU5hbWVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExvb2t1cCBhIHJhdyBncmFtbWFyLlxuICAgKi9cbiAgbG9va3VwKHNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9yYXdHcmFtbWFycy5nZXQoc2NvcGVOYW1lKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5qZWN0aW9ucyBmb3IgdGhlIGdpdmVuIGdyYW1tYXJcbiAgICovXG4gIGluamVjdGlvbnModGFyZ2V0U2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy5faW5qZWN0aW9uR3JhbW1hcnMuZ2V0KHRhcmdldFNjb3BlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRoZW1lIHNldHRpbmdzXG4gICAqL1xuICBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWUuZ2V0RGVmYXVsdHMoKTtcbiAgfVxuICAvKipcbiAgICogTWF0Y2ggYSBzY29wZSBpbiB0aGUgdGhlbWUuXG4gICAqL1xuICB0aGVtZU1hdGNoKHNjb3BlUGF0aCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZS5tYXRjaChzY29wZVBhdGgpO1xuICB9XG4gIC8qKlxuICAgKiBMb29rdXAgYSBncmFtbWFyLlxuICAgKi9cbiAgZ3JhbW1hckZvclNjb3BlTmFtZShzY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMsIHRva2VuVHlwZXMsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycykge1xuICAgIGlmICghdGhpcy5fZ3JhbW1hcnMuaGFzKHNjb3BlTmFtZSkpIHtcbiAgICAgIGxldCByYXdHcmFtbWFyID0gdGhpcy5fcmF3R3JhbW1hcnMuZ2V0KHNjb3BlTmFtZSk7XG4gICAgICBpZiAoIXJhd0dyYW1tYXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9ncmFtbWFycy5zZXQoc2NvcGVOYW1lLCBjcmVhdGVHcmFtbWFyKFxuICAgICAgICBzY29wZU5hbWUsXG4gICAgICAgIHJhd0dyYW1tYXIsXG4gICAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgICAgZW1iZWRkZWRMYW5ndWFnZXMsXG4gICAgICAgIHRva2VuVHlwZXMsXG4gICAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fb25pZ0xpYlxuICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ncmFtbWFycy5nZXQoc2NvcGVOYW1lKTtcbiAgfVxufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgUmVnaXN0cnkgPSBjbGFzcyB7XG4gIF9vcHRpb25zO1xuICBfc3luY1JlZ2lzdHJ5O1xuICBfZW5zdXJlR3JhbW1hckNhY2hlO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5ID0gbmV3IFN5bmNSZWdpc3RyeShcbiAgICAgIFRoZW1lLmNyZWF0ZUZyb21SYXdUaGVtZShvcHRpb25zLnRoZW1lLCBvcHRpb25zLmNvbG9yTWFwKSxcbiAgICAgIG9wdGlvbnMub25pZ0xpYlxuICAgICk7XG4gICAgdGhpcy5fZW5zdXJlR3JhbW1hckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgdGhlbWUuIE9uY2UgY2FsbGVkLCBubyBwcmV2aW91cyBgcnVsZVN0YWNrYCBzaG91bGQgYmUgdXNlZCBhbnltb3JlLlxuICAgKi9cbiAgc2V0VGhlbWUodGhlbWUsIGNvbG9yTWFwKSB7XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5LnNldFRoZW1lKFRoZW1lLmNyZWF0ZUZyb21SYXdUaGVtZSh0aGVtZSwgY29sb3JNYXApKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGxvb2t1cCBhcnJheSBmb3IgY29sb3IgaWRzLlxuICAgKi9cbiAgZ2V0Q29sb3JNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNSZWdpc3RyeS5nZXRDb2xvck1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIHRoZSBncmFtbWFyIGZvciBgc2NvcGVOYW1lYCBhbmQgYWxsIHJlZmVyZW5jZWQgaW5jbHVkZWQgZ3JhbW1hcnMgYXN5bmNocm9ub3VzbHkuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIGxhbmd1YWdlIGlkIDAuXG4gICAqL1xuICBsb2FkR3JhbW1hcldpdGhFbWJlZGRlZExhbmd1YWdlcyhpbml0aWFsU2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEdyYW1tYXJXaXRoQ29uZmlndXJhdGlvbihpbml0aWFsU2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIHsgZW1iZWRkZWRMYW5ndWFnZXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGdyYW1tYXIgZm9yIGBzY29wZU5hbWVgIGFuZCBhbGwgcmVmZXJlbmNlZCBpbmNsdWRlZCBncmFtbWFycyBhc3luY2hyb25vdXNseS5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgbGFuZ3VhZ2UgaWQgMC5cbiAgICovXG4gIGxvYWRHcmFtbWFyV2l0aENvbmZpZ3VyYXRpb24oaW5pdGlhbFNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRHcmFtbWFyKFxuICAgICAgaW5pdGlhbFNjb3BlTmFtZSxcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGNvbmZpZ3VyYXRpb24uZW1iZWRkZWRMYW5ndWFnZXMsXG4gICAgICBjb25maWd1cmF0aW9uLnRva2VuVHlwZXMsXG4gICAgICBuZXcgQmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKFxuICAgICAgICBjb25maWd1cmF0aW9uLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyB8fCBbXSxcbiAgICAgICAgY29uZmlndXJhdGlvbi51bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyB8fCBbXVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGdyYW1tYXIgZm9yIGBzY29wZU5hbWVgIGFuZCBhbGwgcmVmZXJlbmNlZCBpbmNsdWRlZCBncmFtbWFycyBhc3luY2hyb25vdXNseS5cbiAgICovXG4gIGxvYWRHcmFtbWFyKGluaXRpYWxTY29wZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZEdyYW1tYXIoaW5pdGlhbFNjb3BlTmFtZSwgMCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH1cbiAgX2xvYWRHcmFtbWFyKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMsIHRva2VuVHlwZXMsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycykge1xuICAgIGNvbnN0IGRlcGVuZGVuY3lQcm9jZXNzb3IgPSBuZXcgU2NvcGVEZXBlbmRlbmN5UHJvY2Vzc29yKHRoaXMuX3N5bmNSZWdpc3RyeSwgaW5pdGlhbFNjb3BlTmFtZSk7XG4gICAgd2hpbGUgKGRlcGVuZGVuY3lQcm9jZXNzb3IuUS5sZW5ndGggPiAwKSB7XG4gICAgICBkZXBlbmRlbmN5UHJvY2Vzc29yLlEubWFwKChyZXF1ZXN0KSA9PiB0aGlzLl9sb2FkU2luZ2xlR3JhbW1hcihyZXF1ZXN0LnNjb3BlTmFtZSkpO1xuICAgICAgZGVwZW5kZW5jeVByb2Nlc3Nvci5wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJGb3JTY29wZU5hbWUoXG4gICAgICBpbml0aWFsU2NvcGVOYW1lLFxuICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgZW1iZWRkZWRMYW5ndWFnZXMsXG4gICAgICB0b2tlblR5cGVzLFxuICAgICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzXG4gICAgKTtcbiAgfVxuICBfbG9hZFNpbmdsZUdyYW1tYXIoc2NvcGVOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9lbnN1cmVHcmFtbWFyQ2FjaGUuaGFzKHNjb3BlTmFtZSkpIHtcbiAgICAgIHRoaXMuX2RvTG9hZFNpbmdsZUdyYW1tYXIoc2NvcGVOYW1lKTtcbiAgICAgIHRoaXMuX2Vuc3VyZUdyYW1tYXJDYWNoZS5zZXQoc2NvcGVOYW1lLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX2RvTG9hZFNpbmdsZUdyYW1tYXIoc2NvcGVOYW1lKSB7XG4gICAgY29uc3QgZ3JhbW1hciA9IHRoaXMuX29wdGlvbnMubG9hZEdyYW1tYXIoc2NvcGVOYW1lKTtcbiAgICBpZiAoZ3JhbW1hcikge1xuICAgICAgY29uc3QgaW5qZWN0aW9ucyA9IHR5cGVvZiB0aGlzLl9vcHRpb25zLmdldEluamVjdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX29wdGlvbnMuZ2V0SW5qZWN0aW9ucyhzY29wZU5hbWUpIDogdm9pZCAwO1xuICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5LmFkZEdyYW1tYXIoZ3JhbW1hciwgaW5qZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmF3R3JhbW1hci5cbiAgICovXG4gIGFkZEdyYW1tYXIocmF3R3JhbW1hciwgaW5qZWN0aW9ucyA9IFtdLCBpbml0aWFsTGFuZ3VhZ2UgPSAwLCBlbWJlZGRlZExhbmd1YWdlcyA9IG51bGwpIHtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuYWRkR3JhbW1hcihyYXdHcmFtbWFyLCBpbmplY3Rpb25zKTtcbiAgICByZXR1cm4gdGhpcy5fZ3JhbW1hckZvclNjb3BlTmFtZShyYXdHcmFtbWFyLnNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAuIFRoZSBncmFtbWFyIG11c3QgZmlyc3QgYmUgY3JlYXRlZCB2aWEgYGxvYWRHcmFtbWFyYCBvciBgYWRkR3JhbW1hcmAuXG4gICAqL1xuICBfZ3JhbW1hckZvclNjb3BlTmFtZShzY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSA9IDAsIGVtYmVkZGVkTGFuZ3VhZ2VzID0gbnVsbCwgdG9rZW5UeXBlcyA9IG51bGwsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY1JlZ2lzdHJ5LmdyYW1tYXJGb3JTY29wZU5hbWUoXG4gICAgICBzY29wZU5hbWUsXG4gICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgIHRva2VuVHlwZXMsXG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnNcbiAgICApO1xuICB9XG59O1xudmFyIElOSVRJQUwgPSBTdGF0ZVN0YWNrSW1wbC5OVUxMO1xuZXhwb3J0IHtcbiAgRW5jb2RlZFRva2VuTWV0YWRhdGEsXG4gIEZpbmRPcHRpb24sXG4gIEZvbnRTdHlsZSxcbiAgSU5JVElBTCxcbiAgUmVnaXN0cnksXG4gIFRoZW1lLFxuICBkaXNwb3NlT25pZ1N0cmluZ1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\n");

/***/ })

};
;