/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fhirpath@3.18.0";
exports.ids = ["vendor-chunks/fhirpath@3.18.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/package.json":
/*!********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/package.json ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"fhirpath","version":"3.18.0","description":"A FHIRPath engine","main":"src/fhirpath.js","types":"src/fhirpath.d.ts","dependencies":{"@lhncbc/ucum-lhc":"^5.0.0","antlr4":"~4.9.3","commander":"^2.18.0","date-fns":"^1.30.1","js-yaml":"^3.13.1"},"devDependencies":{"@babel/core":"^7.21.4","@babel/eslint-parser":"^7.17.0","@babel/preset-env":"^7.16.11","babel-loader":"^8.2.3","benny":"github:caderek/benny#0ad058d3c7ef0b488a8fe9ae3519159fc7f36bb6","bestzip":"^2.2.0","copy-webpack-plugin":"^12.0.2","cypress":"^13.7.2","eslint":"^8.10.0","fhir":"^4.10.3","grunt":"^1.5.2","grunt-cli":"^1.4.3","grunt-text-replace":"^0.4.0","jasmine-spec-reporter":"^4.2.1","jest":"^29.7.0","jit-grunt":"^0.10.0","lodash":"^4.17.21","open":"^8.4.0","rimraf":"^3.0.0","tmp":"0.0.33","tsd":"^0.31.1","webpack":"^5.11.1","webpack-bundle-analyzer":"^4.4.2","webpack-cli":"^4.9.1","xml2js":"^0.5.0","yargs":"^15.1.0"},"engines":{"node":">=8.9.0"},"tsd":{"directory":"test/typescript"},"scripts":{"preinstall":"node bin/install-demo.js","postinstall":"echo \\"Building the Benny package based on a pull request which fixes an issue with \'statusShift\'... \\" && (cd node_modules/benny && npm i && npm run build > /dev/null) || echo \\"Building the Benny package is completed.\\"","generateParser":"cd src/parser; rimraf ./generated/*; java -Xmx500M -cp \\"../../antlr-4.9.3-complete.jar:$CLASSPATH\\" org.antlr.v4.Tool -o generated -Dlanguage=JavaScript FHIRPath.g4; grunt updateParserRequirements","build":"cd browser-build && webpack && rimraf fhirpath.zip && bestzip fhirpath.zip LICENSE.md fhirpath.min.js fhirpath.r5.min.js fhirpath.r4.min.js fhirpath.stu3.min.js fhirpath.dstu2.min.js && rimraf  LICENSE.md","test:unit":"node --use_strict node_modules/.bin/jest && TZ=America/New_York node --use_strict node_modules/.bin/jest && TZ=Europe/Paris node --use_strict node_modules/.bin/jest","test:unit:debug":"echo \'open chrome chrome://inspect/\' && node --inspect node_modules/.bin/jest --runInBand","build:demo":"npm run build && cd demo && npm run build","test:e2e":"npm run build:demo && cypress run","test:tsd":"tsd","test":"npm run lint && npm run test:tsd && npm run test:unit && npm run test:e2e && echo \\"For tests specific to IE 11, open browser-build/test/index.html in IE 11, and confirm that the tests on that page pass.\\"","lint":"eslint src/parser/index.js src/*.js converter/","compare-performance":"node ./test/benchmark.js"},"bin":{"fhirpath":"bin/fhirpath"},"files":["CHANGELOG.md","bin","fhir-context","src"],"repository":"github:HL7/fhirpath.js","license":"SEE LICENSE in LICENSE.md"}');

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/additional.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/additional.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Contains the additional FHIRPath functions.\n// See https://build.fhir.org/fhirpath.html#functions for details.\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst Terminologies = __webpack_require__(/*! ./terminologies */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/terminologies.js\");\n\nlet engine = {};\n\n/**\n * Returns true if the code is a member of the given valueset.\n * @param {(string|Object)[]} coll - input collection with a single Coding,\n *  CodeableConcept, or code element.\n * @param {string} valueset - value set URL\n * @return {Promise<boolean>|[]} - promise of a boolean value indicating that\n *  there is one element in the input collection whose code is a member of the\n *  specified value set.\n */\nengine.memberOf = function (coll, valueset ) {\n  if (!this.async) {\n    throw new Error('The asynchronous function \"memberOf\" is not allowed. ' +\n      'To enable asynchronous functions, use the async=true or async=\"always\"' +\n      ' option.');\n  }\n  // If the input is empty or has more than one value, the return value is empty\n  if (coll.length !== 1 || coll[0] == null) {\n    return [];\n  }\n\n  if (typeof valueset === 'string' && /^https?:\\/\\/.*/.test(valueset)) {\n    const terminologies = this.processedVars.terminologies;\n    if (!terminologies) {\n      throw new Error('Option \"terminologyUrl\" is not specified.');\n    }\n    return Terminologies.validateVS.call(this,\n      [terminologies], valueset, util.valData(coll[0]), ''\n    ).then(params => {\n      return params.parameter.find((p) => p.name === \"result\").valueBoolean;\n    }, () => []);\n  }\n\n  // If the valueset cannot be resolved as an uri to a value set,\n  // the return value is empty.\n  return [];\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2FkZGl0aW9uYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQywrR0FBaUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2FkZGl0aW9uYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29udGFpbnMgdGhlIGFkZGl0aW9uYWwgRkhJUlBhdGggZnVuY3Rpb25zLlxuLy8gU2VlIGh0dHBzOi8vYnVpbGQuZmhpci5vcmcvZmhpcnBhdGguaHRtbCNmdW5jdGlvbnMgZm9yIGRldGFpbHMuXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xuY29uc3QgVGVybWlub2xvZ2llcyA9IHJlcXVpcmUoJy4vdGVybWlub2xvZ2llcycpO1xuXG5sZXQgZW5naW5lID0ge307XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2RlIGlzIGEgbWVtYmVyIG9mIHRoZSBnaXZlbiB2YWx1ZXNldC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpW119IGNvbGwgLSBpbnB1dCBjb2xsZWN0aW9uIHdpdGggYSBzaW5nbGUgQ29kaW5nLFxuICogIENvZGVhYmxlQ29uY2VwdCwgb3IgY29kZSBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlc2V0IC0gdmFsdWUgc2V0IFVSTFxuICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPnxbXX0gLSBwcm9taXNlIG9mIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHRoYXRcbiAqICB0aGVyZSBpcyBvbmUgZWxlbWVudCBpbiB0aGUgaW5wdXQgY29sbGVjdGlvbiB3aG9zZSBjb2RlIGlzIGEgbWVtYmVyIG9mIHRoZVxuICogIHNwZWNpZmllZCB2YWx1ZSBzZXQuXG4gKi9cbmVuZ2luZS5tZW1iZXJPZiA9IGZ1bmN0aW9uIChjb2xsLCB2YWx1ZXNldCApIHtcbiAgaWYgKCF0aGlzLmFzeW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIFwibWVtYmVyT2ZcIiBpcyBub3QgYWxsb3dlZC4gJyArXG4gICAgICAnVG8gZW5hYmxlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMsIHVzZSB0aGUgYXN5bmM9dHJ1ZSBvciBhc3luYz1cImFsd2F5c1wiJyArXG4gICAgICAnIG9wdGlvbi4nKTtcbiAgfVxuICAvLyBJZiB0aGUgaW5wdXQgaXMgZW1wdHkgb3IgaGFzIG1vcmUgdGhhbiBvbmUgdmFsdWUsIHRoZSByZXR1cm4gdmFsdWUgaXMgZW1wdHlcbiAgaWYgKGNvbGwubGVuZ3RoICE9PSAxIHx8IGNvbGxbMF0gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWVzZXQgPT09ICdzdHJpbmcnICYmIC9eaHR0cHM/OlxcL1xcLy4qLy50ZXN0KHZhbHVlc2V0KSkge1xuICAgIGNvbnN0IHRlcm1pbm9sb2dpZXMgPSB0aGlzLnByb2Nlc3NlZFZhcnMudGVybWlub2xvZ2llcztcbiAgICBpZiAoIXRlcm1pbm9sb2dpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIFwidGVybWlub2xvZ3lVcmxcIiBpcyBub3Qgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gVGVybWlub2xvZ2llcy52YWxpZGF0ZVZTLmNhbGwodGhpcyxcbiAgICAgIFt0ZXJtaW5vbG9naWVzXSwgdmFsdWVzZXQsIHV0aWwudmFsRGF0YShjb2xsWzBdKSwgJydcbiAgICApLnRoZW4ocGFyYW1zID0+IHtcbiAgICAgIHJldHVybiBwYXJhbXMucGFyYW1ldGVyLmZpbmQoKHApID0+IHAubmFtZSA9PT0gXCJyZXN1bHRcIikudmFsdWVCb29sZWFuO1xuICAgIH0sICgpID0+IFtdKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB2YWx1ZXNldCBjYW5ub3QgYmUgcmVzb2x2ZWQgYXMgYW4gdXJpIHRvIGEgdmFsdWUgc2V0LFxuICAvLyB0aGUgcmV0dXJuIHZhbHVlIGlzIGVtcHR5LlxuICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/additional.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/aggregate.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/aggregate.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Contains the FHIRPath Aggregate functions.\n// (Section 7 of the FHIRPath 2.0.0 (N1) specification).\n\nlet engine = {};\nconst math = __webpack_require__(/*! ./math */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/math.js\");\nconst equality  = __webpack_require__(/*! ./equality */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/equality.js\");\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n\nengine.aggregateMacro = function(data, expr, initialValue) {\n  return data.reduce((total, x, i) => {\n    if (total instanceof Promise) {\n      return total.then((t) => {\n        this.$index = i;\n        this.$total = t;\n        return this.$total = expr(x);\n      });\n    } else {\n      this.$index = i;\n      return this.$total = expr(x);\n    }\n  }, this.$total = initialValue);\n};\n\nengine.countFn = function(x) {\n  if (x && x.length) {\n    return x.length;\n  } else {\n    return 0;\n  }\n};\n\n// Shortcut for \"value.tail().aggregate($this+$total, value.first())\" `\nengine.sumFn = function(data) {\n  return engine.aggregateMacro.apply(this, [data.slice(1), ($this) => {\n    let x = util.arraify($this).filter(i => util.valData(i) != null);\n    let y = util.arraify(this.$total).filter(i => util.valData(i) != null);\n    if (x.length === 0 || y.length === 0) {\n      return [];\n    }\n    return math.plus(x, y);\n  }, data[0]]);\n};\n\n/**\n * Shortcut for \"[source collection].aggregate(iif($total.empty(), $this, iif($this [operator] $total, $this, $total)))\"\n * Used for functions min() and max().\n * @param {Array} data - source collection\n * @param {Function} fn - operator function\n * @return {Array}\n */\nfunction minMaxShortcutTemplate(data, fn) {\n  let $total;\n  if (data.length === 0 || util.valData(data[0]) == null) {\n    $total = [];\n  } else {\n    $total = [data[0]];\n    for (let i = 1; i < data.length; i++) {\n      if (util.valData(data[i]) == null) {\n        $total = [];\n        break;\n      }\n      const $this = [data[i]];\n      $total = util.isTrue(fn($this, $total)) ? $this : $total;\n    }\n  }\n  return $total;\n}\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))\"\nengine.minFn = function (data) {\n  return minMaxShortcutTemplate(data, equality.lt);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))\"\nengine.maxFn = function (data) {\n  return minMaxShortcutTemplate(data, equality.gt);\n};\n\n// Shortcut for \"value.sum()/value.count()\"\nengine.avgFn = function (data) {\n  const x = util.arraify(engine.sumFn(data));\n  const y = util.arraify(engine.countFn(data));\n  if (x.length === 0 || y.length === 0) {\n    return [];\n  }\n  return math.div(x, y);\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2FnZ3JlZ2F0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZGQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2FnZ3JlZ2F0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250YWlucyB0aGUgRkhJUlBhdGggQWdncmVnYXRlIGZ1bmN0aW9ucy5cbi8vIChTZWN0aW9uIDcgb2YgdGhlIEZISVJQYXRoIDIuMC4wIChOMSkgc3BlY2lmaWNhdGlvbikuXG5cbmxldCBlbmdpbmUgPSB7fTtcbmNvbnN0IG1hdGggPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xuY29uc3QgZXF1YWxpdHkgID0gcmVxdWlyZShcIi4vZXF1YWxpdHlcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuZW5naW5lLmFnZ3JlZ2F0ZU1hY3JvID0gZnVuY3Rpb24oZGF0YSwgZXhwciwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZSgodG90YWwsIHgsIGkpID0+IHtcbiAgICBpZiAodG90YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdG90YWwudGhlbigodCkgPT4ge1xuICAgICAgICB0aGlzLiRpbmRleCA9IGk7XG4gICAgICAgIHRoaXMuJHRvdGFsID0gdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRvdGFsID0gZXhwcih4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRpbmRleCA9IGk7XG4gICAgICByZXR1cm4gdGhpcy4kdG90YWwgPSBleHByKHgpO1xuICAgIH1cbiAgfSwgdGhpcy4kdG90YWwgPSBpbml0aWFsVmFsdWUpO1xufTtcblxuZW5naW5lLmNvdW50Rm4gPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ICYmIHgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vLyBTaG9ydGN1dCBmb3IgXCJ2YWx1ZS50YWlsKCkuYWdncmVnYXRlKCR0aGlzKyR0b3RhbCwgdmFsdWUuZmlyc3QoKSlcIiBgXG5lbmdpbmUuc3VtRm4gPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBlbmdpbmUuYWdncmVnYXRlTWFjcm8uYXBwbHkodGhpcywgW2RhdGEuc2xpY2UoMSksICgkdGhpcykgPT4ge1xuICAgIGxldCB4ID0gdXRpbC5hcnJhaWZ5KCR0aGlzKS5maWx0ZXIoaSA9PiB1dGlsLnZhbERhdGEoaSkgIT0gbnVsbCk7XG4gICAgbGV0IHkgPSB1dGlsLmFycmFpZnkodGhpcy4kdG90YWwpLmZpbHRlcihpID0+IHV0aWwudmFsRGF0YShpKSAhPSBudWxsKTtcbiAgICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGgucGx1cyh4LCB5KTtcbiAgfSwgZGF0YVswXV0pO1xufTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmb3IgXCJbc291cmNlIGNvbGxlY3Rpb25dLmFnZ3JlZ2F0ZShpaWYoJHRvdGFsLmVtcHR5KCksICR0aGlzLCBpaWYoJHRoaXMgW29wZXJhdG9yXSAkdG90YWwsICR0aGlzLCAkdG90YWwpKSlcIlxuICogVXNlZCBmb3IgZnVuY3Rpb25zIG1pbigpIGFuZCBtYXgoKS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBzb3VyY2UgY29sbGVjdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBvcGVyYXRvciBmdW5jdGlvblxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1pbk1heFNob3J0Y3V0VGVtcGxhdGUoZGF0YSwgZm4pIHtcbiAgbGV0ICR0b3RhbDtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwIHx8IHV0aWwudmFsRGF0YShkYXRhWzBdKSA9PSBudWxsKSB7XG4gICAgJHRvdGFsID0gW107XG4gIH0gZWxzZSB7XG4gICAgJHRvdGFsID0gW2RhdGFbMF1dO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHV0aWwudmFsRGF0YShkYXRhW2ldKSA9PSBudWxsKSB7XG4gICAgICAgICR0b3RhbCA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0ICR0aGlzID0gW2RhdGFbaV1dO1xuICAgICAgJHRvdGFsID0gdXRpbC5pc1RydWUoZm4oJHRoaXMsICR0b3RhbCkpID8gJHRoaXMgOiAkdG90YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiAkdG90YWw7XG59XG5cbi8vIFNob3J0Y3V0IGZvciBcInZhbHVlLmFnZ3JlZ2F0ZShpaWYoJHRvdGFsLmVtcHR5KCksICR0aGlzLCBpaWYoJHRoaXMgPCAkdG90YWwsICR0aGlzLCAkdG90YWwpKSlcIlxuZW5naW5lLm1pbkZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIG1pbk1heFNob3J0Y3V0VGVtcGxhdGUoZGF0YSwgZXF1YWxpdHkubHQpO1xufTtcblxuLy8gU2hvcnRjdXQgZm9yIFwidmFsdWUuYWdncmVnYXRlKGlpZigkdG90YWwuZW1wdHkoKSwgJHRoaXMsIGlpZigkdGhpcyA+ICR0b3RhbCwgJHRoaXMsICR0b3RhbCkpKVwiXG5lbmdpbmUubWF4Rm4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gbWluTWF4U2hvcnRjdXRUZW1wbGF0ZShkYXRhLCBlcXVhbGl0eS5ndCk7XG59O1xuXG4vLyBTaG9ydGN1dCBmb3IgXCJ2YWx1ZS5zdW0oKS92YWx1ZS5jb3VudCgpXCJcbmVuZ2luZS5hdmdGbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IHggPSB1dGlsLmFycmFpZnkoZW5naW5lLnN1bUZuKGRhdGEpKTtcbiAgY29uc3QgeSA9IHV0aWwuYXJyYWlmeShlbmdpbmUuY291bnRGbihkYXRhKSk7XG4gIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gbWF0aC5kaXYoeCwgeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/aggregate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/collections.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/collections.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds code to hande the FHIRPath Math functions.\n\nconst { deepEqual } = __webpack_require__(/*! ./deep-equal */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\");\n\nconst engine = {};\n\n\n// \"b\" is assumed to have one element and it tests whether \"b[0]\" is in \"a\"\nfunction containsImpl(a,b){\n  for(var i = 0; i < a.length; i++){\n    if(deepEqual(a[i], b[0])) { return true; }\n  }\n  return false;\n}\n\nengine.contains = function(a, b){\n  if(b.length == 0) { return []; }\n  if(a.length == 0) { return false; }\n  if(b.length > 1) {\n    throw new Error(\"Expected singleton on right side of contains, got \" + JSON.stringify(b));\n  }\n  return containsImpl(a,b);\n};\n\nengine.in = function(a, b){\n  if(a.length == 0) { return []; }\n  if(b.length == 0) { return false; }\n  if(a.length > 1) {\n    throw new Error(\"Expected singleton on right side of in, got \" + JSON.stringify(b));\n  }\n  return containsImpl(b,a);\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2NvbGxlY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUdBQWM7O0FBRTVDOzs7QUFHQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vZmhpcnBhdGhAMy4xOC4wL25vZGVfbW9kdWxlcy9maGlycGF0aC9zcmMvY29sbGVjdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGhvbGRzIGNvZGUgdG8gaGFuZGUgdGhlIEZISVJQYXRoIE1hdGggZnVuY3Rpb25zLlxuXG5jb25zdCB7IGRlZXBFcXVhbCB9ID0gcmVxdWlyZSgnLi9kZWVwLWVxdWFsJyk7XG5cbmNvbnN0IGVuZ2luZSA9IHt9O1xuXG5cbi8vIFwiYlwiIGlzIGFzc3VtZWQgdG8gaGF2ZSBvbmUgZWxlbWVudCBhbmQgaXQgdGVzdHMgd2hldGhlciBcImJbMF1cIiBpcyBpbiBcImFcIlxuZnVuY3Rpb24gY29udGFpbnNJbXBsKGEsYil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKXtcbiAgICBpZihkZWVwRXF1YWwoYVtpXSwgYlswXSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmVuZ2luZS5jb250YWlucyA9IGZ1bmN0aW9uKGEsIGIpe1xuICBpZihiLmxlbmd0aCA9PSAwKSB7IHJldHVybiBbXTsgfVxuICBpZihhLmxlbmd0aCA9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZihiLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzaW5nbGV0b24gb24gcmlnaHQgc2lkZSBvZiBjb250YWlucywgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoYikpO1xuICB9XG4gIHJldHVybiBjb250YWluc0ltcGwoYSxiKTtcbn07XG5cbmVuZ2luZS5pbiA9IGZ1bmN0aW9uKGEsIGIpe1xuICBpZihhLmxlbmd0aCA9PSAwKSB7IHJldHVybiBbXTsgfVxuICBpZihiLmxlbmd0aCA9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZihhLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzaW5nbGV0b24gb24gcmlnaHQgc2lkZSBvZiBpbiwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoYikpO1xuICB9XG4gIHJldHVybiBjb250YWluc0ltcGwoYixhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/collections.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/combining.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/combining.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds code to hande the FHIRPath Combining functions.\n\nconst combineFns = {};\nconst { distinctFn } = __webpack_require__(/*! ./filtering */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js\");\nconst hashObject = __webpack_require__(/*! ./hash-object */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js\");\nconst { deepEqual, maxCollSizeForDeepEqual } = __webpack_require__(/*! ./deep-equal */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\");\nconst { TypeInfo } = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\n\ncombineFns.union = function(coll1, coll2){\n  return distinctFn(coll1.concat(coll2));\n};\n\ncombineFns.combineFn = function(coll1, coll2){\n  return coll1.concat(coll2);\n};\n\ncombineFns.intersect = function(coll1, coll2) {\n  let result = [];\n  const coll1Length = coll1.length;\n  let uncheckedLength = coll2.length;\n\n  if (coll1Length && uncheckedLength) {\n    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) ||\n      coll2.some(i => TypeInfo.isPrimitiveValue(i));\n    if (!hasPrimitive && coll1Length + uncheckedLength > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      let coll2hash = {};\n      coll2.forEach(item => {\n        const hash = hashObject(item);\n        if (coll2hash[hash]) {\n          uncheckedLength--;\n        } else {\n          coll2hash[hash] = true;\n        }\n      });\n\n      for (let i = 0; i < coll1Length && uncheckedLength > 0; ++i) {\n        let item = coll1[i];\n        let hash = hashObject(item);\n        if (coll2hash[hash]) {\n          result.push(item);\n          coll2hash[hash] = false;\n          uncheckedLength--;\n        }\n      }\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      result = distinctFn(coll1, hasPrimitive).filter(\n        obj1 => coll2.some(obj2 => deepEqual(obj1, obj2))\n      );\n    }\n  }\n\n  return result;\n};\n\n\ncombineFns.exclude = function(coll1, coll2) {\n  let result = [];\n\n  const coll1Length = coll1.length;\n  const coll2Length = coll2.length;\n\n  if (!coll2Length) {\n    return coll1;\n  }\n  if (coll1Length) {\n    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) ||\n      coll2.some(i => TypeInfo.isPrimitiveValue(i));\n\n    if (!hasPrimitive && coll1Length + coll2Length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      let coll2hash = {};\n      coll2.forEach(item => {\n        const hash = hashObject(item);\n        coll2hash[hash] = true;\n      });\n\n      result = coll1.filter(item => !coll2hash[hashObject(item)]);\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      result = coll1.filter(item => {\n        return !coll2.some(item2 => deepEqual(item, item2));\n      });\n    }\n  }\n\n  return result;\n};\n\n\nmodule.exports = combineFns;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2NvbWJpbmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsdUdBQWE7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsMkdBQWU7QUFDMUMsUUFBUSxxQ0FBcUMsRUFBRSxtQkFBTyxDQUFDLHlHQUFjO0FBQ3JFLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsK0ZBQVM7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxzQkFBc0Isd0NBQXdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9jb21iaW5pbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGhvbGRzIGNvZGUgdG8gaGFuZGUgdGhlIEZISVJQYXRoIENvbWJpbmluZyBmdW5jdGlvbnMuXG5cbmNvbnN0IGNvbWJpbmVGbnMgPSB7fTtcbmNvbnN0IHsgZGlzdGluY3RGbiB9ID0gcmVxdWlyZSgnLi9maWx0ZXJpbmcnKTtcbmNvbnN0IGhhc2hPYmplY3QgPSByZXF1aXJlKCcuL2hhc2gtb2JqZWN0Jyk7XG5jb25zdCB7IGRlZXBFcXVhbCwgbWF4Q29sbFNpemVGb3JEZWVwRXF1YWwgfSA9IHJlcXVpcmUoJy4vZGVlcC1lcXVhbCcpO1xuY29uc3QgeyBUeXBlSW5mbyB9ID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmNvbWJpbmVGbnMudW5pb24gPSBmdW5jdGlvbihjb2xsMSwgY29sbDIpe1xuICByZXR1cm4gZGlzdGluY3RGbihjb2xsMS5jb25jYXQoY29sbDIpKTtcbn07XG5cbmNvbWJpbmVGbnMuY29tYmluZUZuID0gZnVuY3Rpb24oY29sbDEsIGNvbGwyKXtcbiAgcmV0dXJuIGNvbGwxLmNvbmNhdChjb2xsMik7XG59O1xuXG5jb21iaW5lRm5zLmludGVyc2VjdCA9IGZ1bmN0aW9uKGNvbGwxLCBjb2xsMikge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbGwxTGVuZ3RoID0gY29sbDEubGVuZ3RoO1xuICBsZXQgdW5jaGVja2VkTGVuZ3RoID0gY29sbDIubGVuZ3RoO1xuXG4gIGlmIChjb2xsMUxlbmd0aCAmJiB1bmNoZWNrZWRMZW5ndGgpIHtcbiAgICBjb25zdCBoYXNQcmltaXRpdmUgPSBjb2xsMS5zb21lKGkgPT4gVHlwZUluZm8uaXNQcmltaXRpdmVWYWx1ZShpKSkgfHxcbiAgICAgIGNvbGwyLnNvbWUoaSA9PiBUeXBlSW5mby5pc1ByaW1pdGl2ZVZhbHVlKGkpKTtcbiAgICBpZiAoIWhhc1ByaW1pdGl2ZSAmJiBjb2xsMUxlbmd0aCArIHVuY2hlY2tlZExlbmd0aCA+IG1heENvbGxTaXplRm9yRGVlcEVxdWFsKSB7XG4gICAgICAvLyBXaGVuIHdlIGhhdmUgbW9yZSB0aGFuIG1heENvbGxTaXplRm9yRGVlcEVxdWFsIGl0ZW1zIGluIGlucHV0IGNvbGxlY3Rpb25zLFxuICAgICAgLy8gd2UgdXNlIGEgaGFzaCB0YWJsZSAob24gSlNPTiBzdHJpbmdzKSBmb3IgZWZmaWNpZW5jeS5cbiAgICAgIGxldCBjb2xsMmhhc2ggPSB7fTtcbiAgICAgIGNvbGwyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoT2JqZWN0KGl0ZW0pO1xuICAgICAgICBpZiAoY29sbDJoYXNoW2hhc2hdKSB7XG4gICAgICAgICAgdW5jaGVja2VkTGVuZ3RoLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sbDJoYXNoW2hhc2hdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sbDFMZW5ndGggJiYgdW5jaGVja2VkTGVuZ3RoID4gMDsgKytpKSB7XG4gICAgICAgIGxldCBpdGVtID0gY29sbDFbaV07XG4gICAgICAgIGxldCBoYXNoID0gaGFzaE9iamVjdChpdGVtKTtcbiAgICAgICAgaWYgKGNvbGwyaGFzaFtoYXNoXSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGNvbGwyaGFzaFtoYXNoXSA9IGZhbHNlO1xuICAgICAgICAgIHVuY2hlY2tlZExlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gcGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICAgIHJlc3VsdCA9IGRpc3RpbmN0Rm4oY29sbDEsIGhhc1ByaW1pdGl2ZSkuZmlsdGVyKFxuICAgICAgICBvYmoxID0+IGNvbGwyLnNvbWUob2JqMiA9PiBkZWVwRXF1YWwob2JqMSwgb2JqMikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbmNvbWJpbmVGbnMuZXhjbHVkZSA9IGZ1bmN0aW9uKGNvbGwxLCBjb2xsMikge1xuICBsZXQgcmVzdWx0ID0gW107XG5cbiAgY29uc3QgY29sbDFMZW5ndGggPSBjb2xsMS5sZW5ndGg7XG4gIGNvbnN0IGNvbGwyTGVuZ3RoID0gY29sbDIubGVuZ3RoO1xuXG4gIGlmICghY29sbDJMZW5ndGgpIHtcbiAgICByZXR1cm4gY29sbDE7XG4gIH1cbiAgaWYgKGNvbGwxTGVuZ3RoKSB7XG4gICAgY29uc3QgaGFzUHJpbWl0aXZlID0gY29sbDEuc29tZShpID0+IFR5cGVJbmZvLmlzUHJpbWl0aXZlVmFsdWUoaSkpIHx8XG4gICAgICBjb2xsMi5zb21lKGkgPT4gVHlwZUluZm8uaXNQcmltaXRpdmVWYWx1ZShpKSk7XG5cbiAgICBpZiAoIWhhc1ByaW1pdGl2ZSAmJiBjb2xsMUxlbmd0aCArIGNvbGwyTGVuZ3RoID4gbWF4Q29sbFNpemVGb3JEZWVwRXF1YWwpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSBtb3JlIHRoYW4gbWF4Q29sbFNpemVGb3JEZWVwRXF1YWwgaXRlbXMgaW4gaW5wdXQgY29sbGVjdGlvbnMsXG4gICAgICAvLyB3ZSB1c2UgYSBoYXNoIHRhYmxlIChvbiBKU09OIHN0cmluZ3MpIGZvciBlZmZpY2llbmN5LlxuICAgICAgbGV0IGNvbGwyaGFzaCA9IHt9O1xuICAgICAgY29sbDIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGhhc2hPYmplY3QoaXRlbSk7XG4gICAgICAgIGNvbGwyaGFzaFtoYXNoXSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gY29sbDEuZmlsdGVyKGl0ZW0gPT4gIWNvbGwyaGFzaFtoYXNoT2JqZWN0KGl0ZW0pXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gcGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICAgIHJlc3VsdCA9IGNvbGwxLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuICFjb2xsMi5zb21lKGl0ZW0yID0+IGRlZXBFcXVhbChpdGVtLCBpdGVtMikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb21iaW5lRm5zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/combining.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/constants.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/constants.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("// These are values that should not change during an evaluation of a FHIRPath\n// expression (e.g. the return value of today(), per the spec.)  They are\n// constant during at least one evaluation.\n\nmodule.exports = {\n  /**\n   *  Resets the constants.  Should be called when before the engine starts its\n   *  processing.\n   */\n  reset: function() {\n    this.nowDate = new Date(); // a Date object representing \"now\"\n    this.today = null;\n    this.now = null;\n    this.timeOfDay = null;\n    this.localTimezoneOffset = null;\n  },\n\n  /**\n   *  The cached value of today().\n   */\n  today: null,\n\n  /**\n   *  The cached value of now().\n   */\n  now: null,\n\n  /**\n   *  The cached value of timeOfDay().\n   */\n  timeOfDay: null\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlc2UgYXJlIHZhbHVlcyB0aGF0IHNob3VsZCBub3QgY2hhbmdlIGR1cmluZyBhbiBldmFsdWF0aW9uIG9mIGEgRkhJUlBhdGhcbi8vIGV4cHJlc3Npb24gKGUuZy4gdGhlIHJldHVybiB2YWx1ZSBvZiB0b2RheSgpLCBwZXIgdGhlIHNwZWMuKSAgVGhleSBhcmVcbi8vIGNvbnN0YW50IGR1cmluZyBhdCBsZWFzdCBvbmUgZXZhbHVhdGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiAgUmVzZXRzIHRoZSBjb25zdGFudHMuICBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYmVmb3JlIHRoZSBlbmdpbmUgc3RhcnRzIGl0c1xuICAgKiAgcHJvY2Vzc2luZy5cbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5vd0RhdGUgPSBuZXcgRGF0ZSgpOyAvLyBhIERhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBcIm5vd1wiXG4gICAgdGhpcy50b2RheSA9IG51bGw7XG4gICAgdGhpcy5ub3cgPSBudWxsO1xuICAgIHRoaXMudGltZU9mRGF5ID0gbnVsbDtcbiAgICB0aGlzLmxvY2FsVGltZXpvbmVPZmZzZXQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiAgVGhlIGNhY2hlZCB2YWx1ZSBvZiB0b2RheSgpLlxuICAgKi9cbiAgdG9kYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqICBUaGUgY2FjaGVkIHZhbHVlIG9mIG5vdygpLlxuICAgKi9cbiAgbm93OiBudWxsLFxuXG4gIC8qKlxuICAgKiAgVGhlIGNhY2hlZCB2YWx1ZSBvZiB0aW1lT2ZEYXkoKS5cbiAgICovXG4gIHRpbWVPZkRheTogbnVsbFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/datetime.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/datetime.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var engine = {};\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/constants.js\");\nconst FP_Date = types.FP_Date;\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\n/**\n *  Implements FHIRPath now().\n */\nengine.now = function(){\n  if (!constants.now) {\n    // return new FP_DateTime((new Date()).toISOString());\n    // The above would construct an FP_DateTime with a timezone of \"Z\", which\n    // would not make a difference for computation, but if the end result of an\n    // expression is \"now()\", then it would look different when output to a user.\n    // Construct it ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDateTime(now);\n    constants.now = new FP_DateTime(isoStr);\n  }\n  return constants.now;\n};\n\n\n/**\n *  Implements FHIRPath today().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.today = function(){\n  if (!constants.today) {\n    // Construct the string ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_Date.isoDate(now);\n    constants.today = new FP_Date(isoStr);\n  }\n  return constants.today;\n};\n\n/**\n *  Implements FHIRPath timeOfDay().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.timeOfDay = function() {\n  if (!constants.timeOfDay) {\n    // Construct the string ourselves to preserve timezone\n    const now = constants.nowDate; // a JS Date\n    const isoStr = FP_DateTime.isoTime(now);\n    constants.timeOfDay = new FP_Time(isoStr);\n  }\n  return constants.timeOfDay;\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2RhdGV0aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLCtGQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2RhdGV0aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbmdpbmUgPSB7fTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IEZQX0RhdGUgPSB0eXBlcy5GUF9EYXRlO1xuY29uc3QgRlBfRGF0ZVRpbWUgPSB0eXBlcy5GUF9EYXRlVGltZTtcbmNvbnN0IEZQX1RpbWUgPSB0eXBlcy5GUF9UaW1lO1xuXG4vKipcbiAqICBJbXBsZW1lbnRzIEZISVJQYXRoIG5vdygpLlxuICovXG5lbmdpbmUubm93ID0gZnVuY3Rpb24oKXtcbiAgaWYgKCFjb25zdGFudHMubm93KSB7XG4gICAgLy8gcmV0dXJuIG5ldyBGUF9EYXRlVGltZSgobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSk7XG4gICAgLy8gVGhlIGFib3ZlIHdvdWxkIGNvbnN0cnVjdCBhbiBGUF9EYXRlVGltZSB3aXRoIGEgdGltZXpvbmUgb2YgXCJaXCIsIHdoaWNoXG4gICAgLy8gd291bGQgbm90IG1ha2UgYSBkaWZmZXJlbmNlIGZvciBjb21wdXRhdGlvbiwgYnV0IGlmIHRoZSBlbmQgcmVzdWx0IG9mIGFuXG4gICAgLy8gZXhwcmVzc2lvbiBpcyBcIm5vdygpXCIsIHRoZW4gaXQgd291bGQgbG9vayBkaWZmZXJlbnQgd2hlbiBvdXRwdXQgdG8gYSB1c2VyLlxuICAgIC8vIENvbnN0cnVjdCBpdCBvdXJzZWx2ZXMgdG8gcHJlc2VydmUgdGltZXpvbmVcbiAgICB2YXIgbm93ID0gY29uc3RhbnRzLm5vd0RhdGU7IC8vIGEgSlMgRGF0ZVxuICAgIHZhciBpc29TdHIgPSBGUF9EYXRlVGltZS5pc29EYXRlVGltZShub3cpO1xuICAgIGNvbnN0YW50cy5ub3cgPSBuZXcgRlBfRGF0ZVRpbWUoaXNvU3RyKTtcbiAgfVxuICByZXR1cm4gY29uc3RhbnRzLm5vdztcbn07XG5cblxuLyoqXG4gKiAgSW1wbGVtZW50cyBGSElSUGF0aCB0b2RheSgpLiAgU2VlIGNvbW1lbnRzIGluIG5vdygpLiBUaGlzIGRvZXMgbm90XG4gKiAgaW5jbHVkZSBhIHRpbWV6b25lIG9mZnNldC5cbiAqL1xuZW5naW5lLnRvZGF5ID0gZnVuY3Rpb24oKXtcbiAgaWYgKCFjb25zdGFudHMudG9kYXkpIHtcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHN0cmluZyBvdXJzZWx2ZXMgdG8gcHJlc2VydmUgdGltZXpvbmVcbiAgICB2YXIgbm93ID0gY29uc3RhbnRzLm5vd0RhdGU7IC8vIGEgSlMgRGF0ZVxuICAgIHZhciBpc29TdHIgPSBGUF9EYXRlLmlzb0RhdGUobm93KTtcbiAgICBjb25zdGFudHMudG9kYXkgPSBuZXcgRlBfRGF0ZShpc29TdHIpO1xuICB9XG4gIHJldHVybiBjb25zdGFudHMudG9kYXk7XG59O1xuXG4vKipcbiAqICBJbXBsZW1lbnRzIEZISVJQYXRoIHRpbWVPZkRheSgpLiAgU2VlIGNvbW1lbnRzIGluIG5vdygpLiBUaGlzIGRvZXMgbm90XG4gKiAgaW5jbHVkZSBhIHRpbWV6b25lIG9mZnNldC5cbiAqL1xuZW5naW5lLnRpbWVPZkRheSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWNvbnN0YW50cy50aW1lT2ZEYXkpIHtcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHN0cmluZyBvdXJzZWx2ZXMgdG8gcHJlc2VydmUgdGltZXpvbmVcbiAgICBjb25zdCBub3cgPSBjb25zdGFudHMubm93RGF0ZTsgLy8gYSBKUyBEYXRlXG4gICAgY29uc3QgaXNvU3RyID0gRlBfRGF0ZVRpbWUuaXNvVGltZShub3cpO1xuICAgIGNvbnN0YW50cy50aW1lT2ZEYXkgPSBuZXcgRlBfVGltZShpc29TdHIpO1xuICB9XG4gIHJldHVybiBjb25zdGFudHMudGltZU9mRGF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbmdpbmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/datetime.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Originally copied from node-deep-equal\n// (https://github.com/substack/node-deep-equal), with modifications.\n// For the license for node-deep-equal, see the bottom of this file.\n\nconst {FP_Type, FP_Quantity, ResourceNode} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nvar numbers = __webpack_require__(/*! ./numbers */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js\");\nvar pSlice = Array.prototype.slice;\nvar objectKeys = Object.keys;\nvar isArguments = function (object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]';\n};\n\nfunction isString(myVar) {\n  return (typeof myVar === 'string' || myVar instanceof String);\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction normalizeStr(x) {\n  return x.toUpperCase().replace(/\\s+/, ' ');\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are equal.\n * When you need to compare many objects, you can use hashObject instead for\n * optimization (if changes are needed here, they are likely also needed there).\n * @param {any} v1 - one of the comparing objects\n * @param {any} v2 - one of the comparing objects\n * @param {Object} [opts] - comparison options\n * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for\n *   equality (see https://hl7.org/fhirpath/#equals).\n *   true, if comparing objects for equivalence\n *   (see https://hl7.org/fhirpath/#equivalent).\n * @return {boolean}\n */\nfunction deepEqual(v1, v2, opts) {\n  const v1IsResourceNode = v1 instanceof ResourceNode;\n  const v2IsResourceNode = v2 instanceof ResourceNode;\n  let actual = v1IsResourceNode ? v1.convertData() : v1;\n  let expected =  v2IsResourceNode ? v2.convertData() : v2;\n  if (!opts) opts = {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode ||\n      deepEqual(v1._data, v2._data);\n  }\n\n  if (opts.fuzzy) {\n    if(isString(actual) && isString(expected)) {\n      return normalizeStr(actual) === normalizeStr(expected);\n    }\n    if(isNumber(actual) && isNumber(expected)) {\n      return numbers.isEquivalent(actual, expected);\n    }\n  }\n  else { // !opts.fuzzy\n    // If these are numbers, they need to be rounded to the maximum supported\n    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should\n    // equal 0.3) before comparing.\n    if (typeof actual === 'number' && typeof expected === 'number') {\n      if(numbers.isEqual(actual, expected)) {\n        return v1IsResourceNode && v2IsResourceNode ?\n          deepEqual(v1._data, v2._data, opts) : true;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  if (actual instanceof Date && expected instanceof Date) {\n    return (actual.getTime() === expected.getTime()) && (\n      opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode ||\n      deepEqual(v1._data, v2._data)\n    );\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return (actual === expected) && (\n      opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode ||\n      deepEqual(v1._data, v2._data)\n    );\n  }\n  else {\n    var actualIsFPT = actual instanceof FP_Type;\n    var expectedIsFPT = expected instanceof FP_Type;\n    if (actualIsFPT && expectedIsFPT) { // if both are FP_Type\n      if (opts.fuzzy) {\n        return actual.equivalentTo(expected);\n      } else {\n        let result = actual.equals(expected); // May return undefined\n        if (result) {\n          return !v1IsResourceNode || !v2IsResourceNode ||\n            deepEqual(v1._data, v2._data) &&\n            deepEqual(v1.data?.id, v2.data?.id) &&\n            deepEqual(v1.data?.extension, v2.data?.extension);\n        } else {\n          return result;\n        }\n      }\n    }\n    else if (actualIsFPT || expectedIsFPT) { // if only one is an FP_Type\n      let anotherIsNumber = false;\n      if (typeof actual == 'number') {\n        actual = new FP_Quantity(actual, \"'1'\");\n        anotherIsNumber = true;\n      }\n      if (typeof expected == 'number') {\n        expected = new FP_Quantity(expected, \"'1'\");\n        anotherIsNumber = true;\n      }\n      if (anotherIsNumber) {\n        return opts.fuzzy ? actual.equivalentTo(expected) :\n          actual.equals(expected);\n      }\n      return false;\n    }\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if(isArguments(a) || isArguments(b)) {\n    a = isArguments(a) ? pSlice.call(a) : a;\n    b = isArguments(b) ? pSlice.call(b) : b;\n    return deepEqual(a, b, opts);\n  }\n  try {\n    var ka = objectKeys(a), kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  // If the length of the array is one, return the value of deepEqual (which can\n  // be \"undefined\".\n  if (ka.length === 1) {\n    key = ka[0];\n    return deepEqual(a[key], b[key], opts);\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\nmodule.exports = {\n  deepEqual,\n  // Maximum collection length to use deepEqual(). When comparing a large number\n  // of collection items, it is more efficient to convert the items to strings\n  // using the hashObject() function and compare them.\n  maxCollSizeForDeepEqual: 6\n};\n\n// The license for node-deep-equal, on which the above code is based, is as\n// follows:\n//\n// This software is released under the MIT license:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2RlZXAtZXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLE9BQU8sb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQywrRkFBUztBQUM5RCxjQUFjLG1CQUFPLENBQUMsbUdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2RlZXAtZXF1YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT3JpZ2luYWxseSBjb3BpZWQgZnJvbSBub2RlLWRlZXAtZXF1YWxcbi8vIChodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svbm9kZS1kZWVwLWVxdWFsKSwgd2l0aCBtb2RpZmljYXRpb25zLlxuLy8gRm9yIHRoZSBsaWNlbnNlIGZvciBub2RlLWRlZXAtZXF1YWwsIHNlZSB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuY29uc3Qge0ZQX1R5cGUsIEZQX1F1YW50aXR5LCBSZXNvdXJjZU5vZGV9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIG51bWJlcnMgPSByZXF1aXJlKCcuL251bWJlcnMnKTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGlzQXJndW1lbnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcobXlWYXIpIHtcbiAgcmV0dXJuICh0eXBlb2YgbXlWYXIgPT09ICdzdHJpbmcnIHx8IG15VmFyIGluc3RhbmNlb2YgU3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHIoeCkge1xuICByZXR1cm4geC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1xccysvLCAnICcpO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1YWwuXG4gKiBXaGVuIHlvdSBuZWVkIHRvIGNvbXBhcmUgbWFueSBvYmplY3RzLCB5b3UgY2FuIHVzZSBoYXNoT2JqZWN0IGluc3RlYWQgZm9yXG4gKiBvcHRpbWl6YXRpb24gKGlmIGNoYW5nZXMgYXJlIG5lZWRlZCBoZXJlLCB0aGV5IGFyZSBsaWtlbHkgYWxzbyBuZWVkZWQgdGhlcmUpLlxuICogQHBhcmFtIHthbnl9IHYxIC0gb25lIG9mIHRoZSBjb21wYXJpbmcgb2JqZWN0c1xuICogQHBhcmFtIHthbnl9IHYyIC0gb25lIG9mIHRoZSBjb21wYXJpbmcgb2JqZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIGNvbXBhcmlzb24gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mdXp6eV0gLSBmYWxzZSAoYnkgZGVmYXVsdCksIGlmIGNvbXBhcmluZyBvYmplY3RzIGZvclxuICogICBlcXVhbGl0eSAoc2VlIGh0dHBzOi8vaGw3Lm9yZy9maGlycGF0aC8jZXF1YWxzKS5cbiAqICAgdHJ1ZSwgaWYgY29tcGFyaW5nIG9iamVjdHMgZm9yIGVxdWl2YWxlbmNlXG4gKiAgIChzZWUgaHR0cHM6Ly9obDcub3JnL2ZoaXJwYXRoLyNlcXVpdmFsZW50KS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbCh2MSwgdjIsIG9wdHMpIHtcbiAgY29uc3QgdjFJc1Jlc291cmNlTm9kZSA9IHYxIGluc3RhbmNlb2YgUmVzb3VyY2VOb2RlO1xuICBjb25zdCB2MklzUmVzb3VyY2VOb2RlID0gdjIgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGU7XG4gIGxldCBhY3R1YWwgPSB2MUlzUmVzb3VyY2VOb2RlID8gdjEuY29udmVydERhdGEoKSA6IHYxO1xuICBsZXQgZXhwZWN0ZWQgPSAgdjJJc1Jlc291cmNlTm9kZSA/IHYyLmNvbnZlcnREYXRhKCkgOiB2MjtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG5cbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIG9wdHMuZnV6enkgfHwgIXYxSXNSZXNvdXJjZU5vZGUgfHwgIXYySXNSZXNvdXJjZU5vZGUgfHxcbiAgICAgIGRlZXBFcXVhbCh2MS5fZGF0YSwgdjIuX2RhdGEpO1xuICB9XG5cbiAgaWYgKG9wdHMuZnV6enkpIHtcbiAgICBpZihpc1N0cmluZyhhY3R1YWwpICYmIGlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVN0cihhY3R1YWwpID09PSBub3JtYWxpemVTdHIoZXhwZWN0ZWQpO1xuICAgIH1cbiAgICBpZihpc051bWJlcihhY3R1YWwpICYmIGlzTnVtYmVyKGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIG51bWJlcnMuaXNFcXVpdmFsZW50KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHsgLy8gIW9wdHMuZnV6enlcbiAgICAvLyBJZiB0aGVzZSBhcmUgbnVtYmVycywgdGhleSBuZWVkIHRvIGJlIHJvdW5kZWQgdG8gdGhlIG1heGltdW0gc3VwcG9ydGVkXG4gICAgLy8gcHJlY2lzaW9uIHRvIHJlbW92ZSBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGVycm9ycyAoZS5nLiAwLjErMC4xKzAuMSBzaG91bGRcbiAgICAvLyBlcXVhbCAwLjMpIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdudW1iZXInICYmIHR5cGVvZiBleHBlY3RlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmKG51bWJlcnMuaXNFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdjFJc1Jlc291cmNlTm9kZSAmJiB2MklzUmVzb3VyY2VOb2RlID9cbiAgICAgICAgICBkZWVwRXF1YWwodjEuX2RhdGEsIHYyLl9kYXRhLCBvcHRzKSA6IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIChhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCkpICYmIChcbiAgICAgIG9wdHMuZnV6enkgfHwgIXYxSXNSZXNvdXJjZU5vZGUgfHwgIXYySXNSZXNvdXJjZU5vZGUgfHxcbiAgICAgIGRlZXBFcXVhbCh2MS5fZGF0YSwgdjIuX2RhdGEpXG4gICAgKTtcbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiAoYWN0dWFsID09PSBleHBlY3RlZCkgJiYgKFxuICAgICAgb3B0cy5mdXp6eSB8fCAhdjFJc1Jlc291cmNlTm9kZSB8fCAhdjJJc1Jlc291cmNlTm9kZSB8fFxuICAgICAgZGVlcEVxdWFsKHYxLl9kYXRhLCB2Mi5fZGF0YSlcbiAgICApO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBhY3R1YWxJc0ZQVCA9IGFjdHVhbCBpbnN0YW5jZW9mIEZQX1R5cGU7XG4gICAgdmFyIGV4cGVjdGVkSXNGUFQgPSBleHBlY3RlZCBpbnN0YW5jZW9mIEZQX1R5cGU7XG4gICAgaWYgKGFjdHVhbElzRlBUICYmIGV4cGVjdGVkSXNGUFQpIHsgLy8gaWYgYm90aCBhcmUgRlBfVHlwZVxuICAgICAgaWYgKG9wdHMuZnV6enkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5lcXVpdmFsZW50VG8oZXhwZWN0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGFjdHVhbC5lcXVhbHMoZXhwZWN0ZWQpOyAvLyBNYXkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuICF2MUlzUmVzb3VyY2VOb2RlIHx8ICF2MklzUmVzb3VyY2VOb2RlIHx8XG4gICAgICAgICAgICBkZWVwRXF1YWwodjEuX2RhdGEsIHYyLl9kYXRhKSAmJlxuICAgICAgICAgICAgZGVlcEVxdWFsKHYxLmRhdGE/LmlkLCB2Mi5kYXRhPy5pZCkgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbCh2MS5kYXRhPy5leHRlbnNpb24sIHYyLmRhdGE/LmV4dGVuc2lvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhY3R1YWxJc0ZQVCB8fCBleHBlY3RlZElzRlBUKSB7IC8vIGlmIG9ubHkgb25lIGlzIGFuIEZQX1R5cGVcbiAgICAgIGxldCBhbm90aGVySXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsID09ICdudW1iZXInKSB7XG4gICAgICAgIGFjdHVhbCA9IG5ldyBGUF9RdWFudGl0eShhY3R1YWwsIFwiJzEnXCIpO1xuICAgICAgICBhbm90aGVySXNOdW1iZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBleHBlY3RlZCA9IG5ldyBGUF9RdWFudGl0eShleHBlY3RlZCwgXCInMSdcIik7XG4gICAgICAgIGFub3RoZXJJc051bWJlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5vdGhlcklzTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmZ1enp5ID8gYWN0dWFsLmVxdWl2YWxlbnRUbyhleHBlY3RlZCkgOlxuICAgICAgICAgIGFjdHVhbC5lcXVhbHMoZXhwZWN0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gICAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAgIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gICAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYoaXNBcmd1bWVudHMoYSkgfHwgaXNBcmd1bWVudHMoYikpIHtcbiAgICBhID0gaXNBcmd1bWVudHMoYSkgPyBwU2xpY2UuY2FsbChhKSA6IGE7XG4gICAgYiA9IGlzQXJndW1lbnRzKGIpID8gcFNsaWNlLmNhbGwoYikgOiBiO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLCBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMgb25lLCByZXR1cm4gdGhlIHZhbHVlIG9mIGRlZXBFcXVhbCAod2hpY2ggY2FuXG4gIC8vIGJlIFwidW5kZWZpbmVkXCIuXG4gIGlmIChrYS5sZW5ndGggPT09IDEpIHtcbiAgICBrZXkgPSBrYVswXTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKTtcbiAgfVxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWVwRXF1YWwsXG4gIC8vIE1heGltdW0gY29sbGVjdGlvbiBsZW5ndGggdG8gdXNlIGRlZXBFcXVhbCgpLiBXaGVuIGNvbXBhcmluZyBhIGxhcmdlIG51bWJlclxuICAvLyBvZiBjb2xsZWN0aW9uIGl0ZW1zLCBpdCBpcyBtb3JlIGVmZmljaWVudCB0byBjb252ZXJ0IHRoZSBpdGVtcyB0byBzdHJpbmdzXG4gIC8vIHVzaW5nIHRoZSBoYXNoT2JqZWN0KCkgZnVuY3Rpb24gYW5kIGNvbXBhcmUgdGhlbS5cbiAgbWF4Q29sbFNpemVGb3JEZWVwRXF1YWw6IDZcbn07XG5cbi8vIFRoZSBsaWNlbnNlIGZvciBub2RlLWRlZXAtZXF1YWwsIG9uIHdoaWNoIHRoZSBhYm92ZSBjb2RlIGlzIGJhc2VkLCBpcyBhc1xuLy8gZm9sbG93czpcbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4vLyB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4vLyB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4vLyB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuLy8gdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuLy8gc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4vLyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1Jcbi8vIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuLy8gSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbi8vIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/equality.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/equality.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds code to handle the FHIRPath Math functions.\n\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst { deepEqual } = __webpack_require__(/*! ./deep-equal */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst FP_Type = types.FP_Type;\nconst FP_DateTime = types.FP_DateTime;\n\nvar engine = {};\n\nfunction equality(x,y){\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y);\n}\n\nfunction equivalence(x,y){\n  if(util.isEmpty(x) && util.isEmpty(y)) { return [true]; }\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y, {fuzzy: true});\n}\n\nengine.equal = function(a, b){\n  return equality(a, b);\n};\n\nengine.unequal = function(a, b){\n  var eq = equality(a, b);\n  return eq === undefined ? undefined : !eq;\n};\n\nengine.equival = function(a, b){\n  return equivalence(a, b);\n};\n\nengine.unequival = function(a, b){\n  return !equivalence(a, b);\n};\n\n/**\n *  Checks that the types of a and b are suitable for comparison in an\n *  inequality expression.\n * @param a the left side of the inequality expression (which should be an array of\n *  one value).\n * @param b the right side of the inequality expression (which should be an array of\n *  one value).\n * @return the singleton values of the arrays a, and b.  If one was an FP_Type\n *  and the other was convertible, the converted value will be returned.\n */\nfunction typecheck(a, b){\n  util.assertOnlyOne(a, \"Singleton was expected\");\n  util.assertOnlyOne(b, \"Singleton was expected\");\n  a = util.valDataConverted(a[0]);\n  b = util.valDataConverted(b[0]);\n  if (a != null && b != null) {\n    let lClass = a instanceof FP_DateTime ? FP_DateTime : a.constructor;\n    let rClass = b instanceof FP_DateTime ? FP_DateTime : b.constructor;\n    if (lClass !== rClass) {\n      util.raiseError('Type of \"' + a + '\" (' + lClass.name + ') did not match type of \"' +\n        b + '\" (' + rClass.name + ')', 'InequalityExpression');\n    }\n  }\n  return [a, b];\n}\n\nengine.lt = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare < 0;\n  }\n  return a0 < b0;\n};\n\nengine.gt = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare > 0;\n  }\n  return a0 > b0;\n};\n\nengine.lte = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare <= 0;\n  }\n  return  a0 <= b0;\n};\n\nengine.gte = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare >= 0;\n  }\n  return a0 >= b0;\n};\n\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2VxdWFsaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHlHQUFjO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQywrRkFBUztBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDBCQUEwQixZQUFZO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9lcXVhbGl0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaG9sZHMgY29kZSB0byBoYW5kbGUgdGhlIEZISVJQYXRoIE1hdGggZnVuY3Rpb25zLlxuXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xuY29uc3QgeyBkZWVwRXF1YWwgfSA9IHJlcXVpcmUoJy4vZGVlcC1lcXVhbCcpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBGUF9UeXBlID0gdHlwZXMuRlBfVHlwZTtcbmNvbnN0IEZQX0RhdGVUaW1lID0gdHlwZXMuRlBfRGF0ZVRpbWU7XG5cbnZhciBlbmdpbmUgPSB7fTtcblxuZnVuY3Rpb24gZXF1YWxpdHkoeCx5KXtcbiAgaWYodXRpbC5pc0VtcHR5KHgpIHx8IHV0aWwuaXNFbXB0eSh5KSkgeyByZXR1cm4gW107IH1cbiAgcmV0dXJuIGRlZXBFcXVhbCh4LCB5KTtcbn1cblxuZnVuY3Rpb24gZXF1aXZhbGVuY2UoeCx5KXtcbiAgaWYodXRpbC5pc0VtcHR5KHgpICYmIHV0aWwuaXNFbXB0eSh5KSkgeyByZXR1cm4gW3RydWVdOyB9XG4gIGlmKHV0aWwuaXNFbXB0eSh4KSB8fCB1dGlsLmlzRW1wdHkoeSkpIHsgcmV0dXJuIFtdOyB9XG4gIHJldHVybiBkZWVwRXF1YWwoeCwgeSwge2Z1enp5OiB0cnVlfSk7XG59XG5cbmVuZ2luZS5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gZXF1YWxpdHkoYSwgYik7XG59O1xuXG5lbmdpbmUudW5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZXEgPSBlcXVhbGl0eShhLCBiKTtcbiAgcmV0dXJuIGVxID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAhZXE7XG59O1xuXG5lbmdpbmUuZXF1aXZhbCA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gZXF1aXZhbGVuY2UoYSwgYik7XG59O1xuXG5lbmdpbmUudW5lcXVpdmFsID0gZnVuY3Rpb24oYSwgYil7XG4gIHJldHVybiAhZXF1aXZhbGVuY2UoYSwgYik7XG59O1xuXG4vKipcbiAqICBDaGVja3MgdGhhdCB0aGUgdHlwZXMgb2YgYSBhbmQgYiBhcmUgc3VpdGFibGUgZm9yIGNvbXBhcmlzb24gaW4gYW5cbiAqICBpbmVxdWFsaXR5IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gYSB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmVxdWFsaXR5IGV4cHJlc3Npb24gKHdoaWNoIHNob3VsZCBiZSBhbiBhcnJheSBvZlxuICogIG9uZSB2YWx1ZSkuXG4gKiBAcGFyYW0gYiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5lcXVhbGl0eSBleHByZXNzaW9uICh3aGljaCBzaG91bGQgYmUgYW4gYXJyYXkgb2ZcbiAqICBvbmUgdmFsdWUpLlxuICogQHJldHVybiB0aGUgc2luZ2xldG9uIHZhbHVlcyBvZiB0aGUgYXJyYXlzIGEsIGFuZCBiLiAgSWYgb25lIHdhcyBhbiBGUF9UeXBlXG4gKiAgYW5kIHRoZSBvdGhlciB3YXMgY29udmVydGlibGUsIHRoZSBjb252ZXJ0ZWQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gdHlwZWNoZWNrKGEsIGIpe1xuICB1dGlsLmFzc2VydE9ubHlPbmUoYSwgXCJTaW5nbGV0b24gd2FzIGV4cGVjdGVkXCIpO1xuICB1dGlsLmFzc2VydE9ubHlPbmUoYiwgXCJTaW5nbGV0b24gd2FzIGV4cGVjdGVkXCIpO1xuICBhID0gdXRpbC52YWxEYXRhQ29udmVydGVkKGFbMF0pO1xuICBiID0gdXRpbC52YWxEYXRhQ29udmVydGVkKGJbMF0pO1xuICBpZiAoYSAhPSBudWxsICYmIGIgIT0gbnVsbCkge1xuICAgIGxldCBsQ2xhc3MgPSBhIGluc3RhbmNlb2YgRlBfRGF0ZVRpbWUgPyBGUF9EYXRlVGltZSA6IGEuY29uc3RydWN0b3I7XG4gICAgbGV0IHJDbGFzcyA9IGIgaW5zdGFuY2VvZiBGUF9EYXRlVGltZSA/IEZQX0RhdGVUaW1lIDogYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAobENsYXNzICE9PSByQ2xhc3MpIHtcbiAgICAgIHV0aWwucmFpc2VFcnJvcignVHlwZSBvZiBcIicgKyBhICsgJ1wiICgnICsgbENsYXNzLm5hbWUgKyAnKSBkaWQgbm90IG1hdGNoIHR5cGUgb2YgXCInICtcbiAgICAgICAgYiArICdcIiAoJyArIHJDbGFzcy5uYW1lICsgJyknLCAnSW5lcXVhbGl0eUV4cHJlc3Npb24nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZW5naW5lLmx0ID0gZnVuY3Rpb24oYSwgYil7XG4gIGNvbnN0IFthMCwgYjBdID0gdHlwZWNoZWNrKGEsYik7XG4gIGlmIChhMCA9PSBudWxsIHx8IGIwID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGEwIGluc3RhbmNlb2YgRlBfVHlwZSkge1xuICAgIGNvbnN0IGNvbXBhcmUgPSBhMC5jb21wYXJlKGIwKTtcbiAgICByZXR1cm4gY29tcGFyZSA9PT0gbnVsbCA/IFtdIDogY29tcGFyZSA8IDA7XG4gIH1cbiAgcmV0dXJuIGEwIDwgYjA7XG59O1xuXG5lbmdpbmUuZ3QgPSBmdW5jdGlvbihhLCBiKXtcbiAgY29uc3QgW2EwLCBiMF0gPSB0eXBlY2hlY2soYSxiKTtcbiAgaWYgKGEwID09IG51bGwgfHwgYjAgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoYTAgaW5zdGFuY2VvZiBGUF9UeXBlKSB7XG4gICAgY29uc3QgY29tcGFyZSA9IGEwLmNvbXBhcmUoYjApO1xuICAgIHJldHVybiBjb21wYXJlID09PSBudWxsID8gW10gOiBjb21wYXJlID4gMDtcbiAgfVxuICByZXR1cm4gYTAgPiBiMDtcbn07XG5cbmVuZ2luZS5sdGUgPSBmdW5jdGlvbihhLCBiKXtcbiAgY29uc3QgW2EwLCBiMF0gPSB0eXBlY2hlY2soYSxiKTtcbiAgaWYgKGEwID09IG51bGwgfHwgYjAgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoYTAgaW5zdGFuY2VvZiBGUF9UeXBlKSB7XG4gICAgY29uc3QgY29tcGFyZSA9IGEwLmNvbXBhcmUoYjApO1xuICAgIHJldHVybiBjb21wYXJlID09PSBudWxsID8gW10gOiBjb21wYXJlIDw9IDA7XG4gIH1cbiAgcmV0dXJuICBhMCA8PSBiMDtcbn07XG5cbmVuZ2luZS5ndGUgPSBmdW5jdGlvbihhLCBiKXtcbiAgY29uc3QgW2EwLCBiMF0gPSB0eXBlY2hlY2soYSxiKTtcbiAgaWYgKGEwID09IG51bGwgfHwgYjAgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoYTAgaW5zdGFuY2VvZiBGUF9UeXBlKSB7XG4gICAgY29uc3QgY29tcGFyZSA9IGEwLmNvbXBhcmUoYjApO1xuICAgIHJldHVybiBjb21wYXJlID09PSBudWxsID8gW10gOiBjb21wYXJlID49IDA7XG4gIH1cbiAgcmV0dXJuIGEwID49IGIwO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/equality.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/existence.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/existence.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst {whereMacro, distinctFn} = __webpack_require__(/*! ./filtering */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js\");\nconst misc = __webpack_require__(/*! ./misc */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js\");\nconst hashObject = __webpack_require__(/*! ./hash-object */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js\");\nconst { deepEqual, maxCollSizeForDeepEqual } = __webpack_require__(/*! ./deep-equal */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\");\nconst {TypeInfo} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\n\nconst engine = {};\nengine.emptyFn = util.isEmpty;\n\nengine.notFn = function(coll) {\n  let d = misc.singleton(coll, 'Boolean');\n  return (typeof (d) === 'boolean') ? !d : [];\n};\n\nengine.existsMacro  = function(coll, expr) {\n  if (expr) {\n    const exprRes = whereMacro.call(this, coll, expr);\n    if (exprRes instanceof Promise) {\n      return exprRes.then(r => engine.existsMacro(r));\n    }\n    return engine.existsMacro(exprRes);\n  }\n  return !util.isEmpty(coll);\n};\n\nengine.allMacro = function(coll, expr) {\n  const promises = [];\n  for (let i=0, len=coll.length; i<len; ++i) {\n    this.$index = i;\n    const exprRes = expr(coll[i]);\n    if (exprRes instanceof Promise) {\n      promises.push(exprRes);\n    } else if(!util.isTrue(exprRes)){\n      return [false];\n    }\n  }\n  if (promises.length) {\n    return Promise.all(promises).then(r => r.some(i => !util.isTrue(i)) ? [false] : [true]);\n  }\n  return [true];\n};\n\nengine.allTrueFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.anyTrueFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.allFalseFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\nengine.anyFalseFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\n\n/**\n *  Returns true if coll1 is a subset of coll2.\n */\nfunction subsetOf(coll1, coll2) {\n  const coll1Length = coll1.length;\n  const coll2Length = coll2.length;\n  let rtn = coll1Length <= coll2Length;\n  if (rtn) {\n    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) ||\n      coll2.some(i => TypeInfo.isPrimitiveValue(i));\n    if (!hasPrimitive && coll1Length + coll2Length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      const c2Hash = coll2.reduce((hash, item) => {\n        hash[hashObject(item)] = true;\n        return hash;\n      }, {});\n      rtn = !coll1.some(item => !c2Hash[hashObject(item)]);\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      for (let p=0, pLen=coll1.length; p<pLen && rtn; ++p) {\n        let obj1 = util.valData(coll1[p]);\n        rtn = coll2.some(obj2 => deepEqual(obj1, util.valData(obj2)));\n      }\n    }\n  }\n  return rtn;\n}\n\nengine.subsetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll1, coll2)];\n};\n\nengine.supersetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll2, coll1)];\n};\n\nengine.isDistinctFn = function(x) {\n  return [x.length === distinctFn(x).length];\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2V4aXN0ZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxPQUFPLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsdUdBQWE7QUFDdEQsYUFBYSxtQkFBTyxDQUFDLDZGQUFRO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLDJHQUFlO0FBQzFDLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyx5R0FBYztBQUNyRSxPQUFPLFVBQVUsRUFBRSxtQkFBTyxDQUFDLCtGQUFTOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2V4aXN0ZW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaG9sZHMgY29kZSB0byBoYW5kZSB0aGUgRkhJUlBhdGggRXhpc3RlbmNlIGZ1bmN0aW9ucyAoNS4xIGluIHRoZVxuLy8gc3BlY2lmaWNhdGlvbikuXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5jb25zdCB7d2hlcmVNYWNybywgZGlzdGluY3RGbn0gPSByZXF1aXJlKFwiLi9maWx0ZXJpbmdcIik7XG5jb25zdCBtaXNjID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcbmNvbnN0IGhhc2hPYmplY3QgPSByZXF1aXJlKCcuL2hhc2gtb2JqZWN0Jyk7XG5jb25zdCB7IGRlZXBFcXVhbCwgbWF4Q29sbFNpemVGb3JEZWVwRXF1YWwgfSA9IHJlcXVpcmUoJy4vZGVlcC1lcXVhbCcpO1xuY29uc3Qge1R5cGVJbmZvfSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3QgZW5naW5lID0ge307XG5lbmdpbmUuZW1wdHlGbiA9IHV0aWwuaXNFbXB0eTtcblxuZW5naW5lLm5vdEZuID0gZnVuY3Rpb24oY29sbCkge1xuICBsZXQgZCA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdCb29sZWFuJyk7XG4gIHJldHVybiAodHlwZW9mIChkKSA9PT0gJ2Jvb2xlYW4nKSA/ICFkIDogW107XG59O1xuXG5lbmdpbmUuZXhpc3RzTWFjcm8gID0gZnVuY3Rpb24oY29sbCwgZXhwcikge1xuICBpZiAoZXhwcikge1xuICAgIGNvbnN0IGV4cHJSZXMgPSB3aGVyZU1hY3JvLmNhbGwodGhpcywgY29sbCwgZXhwcik7XG4gICAgaWYgKGV4cHJSZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gZXhwclJlcy50aGVuKHIgPT4gZW5naW5lLmV4aXN0c01hY3JvKHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZ2luZS5leGlzdHNNYWNybyhleHByUmVzKTtcbiAgfVxuICByZXR1cm4gIXV0aWwuaXNFbXB0eShjb2xsKTtcbn07XG5cbmVuZ2luZS5hbGxNYWNybyA9IGZ1bmN0aW9uKGNvbGwsIGV4cHIpIHtcbiAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsZW49Y29sbC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB0aGlzLiRpbmRleCA9IGk7XG4gICAgY29uc3QgZXhwclJlcyA9IGV4cHIoY29sbFtpXSk7XG4gICAgaWYgKGV4cHJSZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKGV4cHJSZXMpO1xuICAgIH0gZWxzZSBpZighdXRpbC5pc1RydWUoZXhwclJlcykpe1xuICAgICAgcmV0dXJuIFtmYWxzZV07XG4gICAgfVxuICB9XG4gIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4ociA9PiByLnNvbWUoaSA9PiAhdXRpbC5pc1RydWUoaSkpID8gW2ZhbHNlXSA6IFt0cnVlXSk7XG4gIH1cbiAgcmV0dXJuIFt0cnVlXTtcbn07XG5cbmVuZ2luZS5hbGxUcnVlRm4gID0gZnVuY3Rpb24oeCkge1xuICBsZXQgcnRuID0gdHJ1ZTtcbiAgZm9yIChsZXQgaT0wLCBsZW49eC5sZW5ndGg7IGk8bGVuICYmIHJ0bjsgKytpKSB7XG4gICAgbGV0IHhpID0gdXRpbC5hc3NlcnRUeXBlKHhbaV0sIFtcImJvb2xlYW5cIl0sIFwiYWxsVHJ1ZVwiKTtcbiAgICBydG4gPSB4aSA9PT0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gW3J0bl07XG59O1xuXG5lbmdpbmUuYW55VHJ1ZUZuICA9IGZ1bmN0aW9uKHgpIHtcbiAgbGV0IHJ0biA9IGZhbHNlO1xuICBmb3IgKGxldCBpPTAsIGxlbj14Lmxlbmd0aDsgaTxsZW4gJiYgIXJ0bjsgKytpKSB7XG4gICAgbGV0IHhpID0gdXRpbC5hc3NlcnRUeXBlKHhbaV0sIFtcImJvb2xlYW5cIl0sIFwiYW55VHJ1ZVwiKTtcbiAgICBydG4gPSB4aSA9PT0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gW3J0bl07XG59O1xuXG5lbmdpbmUuYWxsRmFsc2VGbiAgPSBmdW5jdGlvbih4KSB7XG4gIGxldCBydG4gPSB0cnVlO1xuICBmb3IgKGxldCBpPTAsIGxlbj14Lmxlbmd0aDsgaTxsZW4gJiYgcnRuOyArK2kpIHtcbiAgICBsZXQgeGkgPSB1dGlsLmFzc2VydFR5cGUoeFtpXSwgW1wiYm9vbGVhblwiXSwgXCJhbGxGYWxzZVwiKTtcbiAgICBydG4gPSB4aSA9PT0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFtydG5dO1xufTtcblxuZW5naW5lLmFueUZhbHNlRm4gID0gZnVuY3Rpb24oeCkge1xuICBsZXQgcnRuID0gZmFsc2U7XG4gIGZvciAobGV0IGk9MCwgbGVuPXgubGVuZ3RoOyBpPGxlbiAmJiAhcnRuOyArK2kpIHtcbiAgICBsZXQgeGkgPSB1dGlsLmFzc2VydFR5cGUoeFtpXSwgW1wiYm9vbGVhblwiXSwgXCJhbnlGYWxzZVwiKTtcbiAgICBydG4gPSB4aSA9PT0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFtydG5dO1xufTtcblxuXG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgY29sbDEgaXMgYSBzdWJzZXQgb2YgY29sbDIuXG4gKi9cbmZ1bmN0aW9uIHN1YnNldE9mKGNvbGwxLCBjb2xsMikge1xuICBjb25zdCBjb2xsMUxlbmd0aCA9IGNvbGwxLmxlbmd0aDtcbiAgY29uc3QgY29sbDJMZW5ndGggPSBjb2xsMi5sZW5ndGg7XG4gIGxldCBydG4gPSBjb2xsMUxlbmd0aCA8PSBjb2xsMkxlbmd0aDtcbiAgaWYgKHJ0bikge1xuICAgIGNvbnN0IGhhc1ByaW1pdGl2ZSA9IGNvbGwxLnNvbWUoaSA9PiBUeXBlSW5mby5pc1ByaW1pdGl2ZVZhbHVlKGkpKSB8fFxuICAgICAgY29sbDIuc29tZShpID0+IFR5cGVJbmZvLmlzUHJpbWl0aXZlVmFsdWUoaSkpO1xuICAgIGlmICghaGFzUHJpbWl0aXZlICYmIGNvbGwxTGVuZ3RoICsgY29sbDJMZW5ndGggPiBtYXhDb2xsU2l6ZUZvckRlZXBFcXVhbCkge1xuICAgICAgLy8gV2hlbiB3ZSBoYXZlIG1vcmUgdGhhbiBtYXhDb2xsU2l6ZUZvckRlZXBFcXVhbCBpdGVtcyBpbiBpbnB1dCBjb2xsZWN0aW9ucyxcbiAgICAgIC8vIHdlIHVzZSBhIGhhc2ggdGFibGUgKG9uIEpTT04gc3RyaW5ncykgZm9yIGVmZmljaWVuY3kuXG4gICAgICBjb25zdCBjMkhhc2ggPSBjb2xsMi5yZWR1Y2UoKGhhc2gsIGl0ZW0pID0+IHtcbiAgICAgICAgaGFzaFtoYXNoT2JqZWN0KGl0ZW0pXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSwge30pO1xuICAgICAgcnRuID0gIWNvbGwxLnNvbWUoaXRlbSA9PiAhYzJIYXNoW2hhc2hPYmplY3QoaXRlbSldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBtb3JlIGVmZmljaWVudCB0byBwZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uLlxuICAgICAgZm9yIChsZXQgcD0wLCBwTGVuPWNvbGwxLmxlbmd0aDsgcDxwTGVuICYmIHJ0bjsgKytwKSB7XG4gICAgICAgIGxldCBvYmoxID0gdXRpbC52YWxEYXRhKGNvbGwxW3BdKTtcbiAgICAgICAgcnRuID0gY29sbDIuc29tZShvYmoyID0+IGRlZXBFcXVhbChvYmoxLCB1dGlsLnZhbERhdGEob2JqMikpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ0bjtcbn1cblxuZW5naW5lLnN1YnNldE9mRm4gPSBmdW5jdGlvbihjb2xsMSwgY29sbDIpIHtcbiAgcmV0dXJuIFtzdWJzZXRPZihjb2xsMSwgY29sbDIpXTtcbn07XG5cbmVuZ2luZS5zdXBlcnNldE9mRm4gPSBmdW5jdGlvbihjb2xsMSwgY29sbDIpIHtcbiAgcmV0dXJuIFtzdWJzZXRPZihjb2xsMiwgY29sbDEpXTtcbn07XG5cbmVuZ2luZS5pc0Rpc3RpbmN0Rm4gPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBbeC5sZW5ndGggPT09IGRpc3RpbmN0Rm4oeCkubGVuZ3RoXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/existence.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/factory.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/factory.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file contains a class that implements the Type Factory API.\n// See https://hl7.org/fhir/fhirpath.html#factory for details.\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst { ResourceNode, TypeInfo, instantRE, timeRE, dateRE, dateTimeRE} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\n\nclass Factory {\n  // Same as fhirpath.invocationTable, but for %factory methods\n  static invocationTable = {\n    Extension: {fn: Factory.Extension, arity: {2: ['String', 'AnyAtRoot']}},\n    Identifier: {\n      fn: Factory.Identifier,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String'],\n        4: ['String', 'String', 'String', 'Any']\n      }\n    },\n    HumanName: {\n      fn: Factory.HumanName,\n      arity: {\n        1: ['String'],\n        2: ['String', 'AnyAtRoot'],\n        3: ['String', 'AnyAtRoot', 'String'],\n        4: ['String', 'AnyAtRoot', 'String', 'String'],\n        5: ['String', 'AnyAtRoot', 'String', 'String', 'String'],\n        6: ['String', 'AnyAtRoot', 'String', 'String', 'String', 'String']\n      },\n    },\n    ContactPoint: {\n      fn: Factory.ContactPoint,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String']\n      },\n    },\n    Address: {\n      fn: Factory.Address,\n      arity: {\n        1: ['AnyAtRoot'],\n        2: ['AnyAtRoot', 'String'],\n        3: ['AnyAtRoot', 'String', 'String'],\n        4: ['AnyAtRoot', 'String', 'String', 'String'],\n        5: ['AnyAtRoot', 'String', 'String', 'String', 'String'],\n        6: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String'],\n        7: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String', 'String']\n      },\n    },\n    Quantity: {\n      fn: Factory.Quantity,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'StringOrNumber'],\n        4: ['String', 'String', 'StringOrNumber', 'String']\n      }\n    },\n    Coding: {\n      fn: Factory.Coding,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String'],\n        4: ['String', 'String', 'String', 'String']\n      }\n    },\n    CodeableConcept: {\n      fn: Factory.CodeableConcept,\n      arity: {\n        1: ['AnyAtRoot'],\n        2: ['AnyAtRoot', 'String']\n      }\n    },\n    create: {\n      fn: Factory.create,\n      arity: {\n        1: ['TypeSpecifier']\n      }\n    },\n    withExtension: {\n      fn: Factory.withExtension,\n      arity: {\n        3: ['AnyAtRoot', 'String', 'AnyAtRoot']\n      }\n    },\n    withProperty: {\n      fn: Factory.withProperty,\n      arity: {\n        3: ['AnyAtRoot', 'String', 'AnyAtRoot']\n      }\n    }\n  };\n\n  // Create functions to create primitive types and add these functions to the\n  // invocationTable.\n  static {\n    [\n      {\n        type: 'string',\n        getValue: function (v) {\n          if (typeof v  === 'string' && /^[\\s\\S]+$/.test(v)) {\n            return String(v);\n          }\n          throw new Error(`\"${v}\" is not a string.` );\n        }\n      },\n      {\n        type: 'integer',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n)) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an integer.` );\n        }\n      },\n      {\n        type: 'unsignedInt',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n) && n >= 0) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an unsignedInt.` );\n        }\n      },\n      {\n        type: 'positiveInt',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n) && n > 0) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not a positiveInt.` );\n        }\n      },\n      {\n        type: 'integer64',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n)) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an integer.` );\n        }\n      },\n      {\n        type: 'markdown',\n        getValue(v) {\n          if (typeof v  === 'string' && /^[\\s\\S]+$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a markdown.` );\n        }\n      },\n      {\n        type: 'url',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a url.` );\n        }\n      },\n      {\n        type: 'uri',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a uri.` );\n        }\n      },\n      {\n        type: 'instant',\n        getValue(v) {\n          if (typeof v  === 'string' && instantRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an instant.` );\n        }\n      },\n      {\n        type: 'time',\n        getValue(v) {\n          if (typeof v  === 'string' && timeRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a time.` );\n        }\n      },\n      {\n        type: 'date',\n        getValue(v) {\n          if (typeof v  === 'string' && dateRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a date.` );\n        }\n      },\n      {\n        type: 'dateTime',\n        getValue(v) {\n          if (typeof v  === 'string' && dateTimeRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a dateTime.` );\n        }\n      },\n      {\n        type: 'base64Binary',\n        getValue(v) {\n          if (typeof v  === 'string' &&\n            /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/\n              .test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a base64Binary.` );\n        }\n      },\n      {\n        type: 'decimal',\n        getValue(v) {\n          const n = Number(v);\n          if (Number.isNaN(n)) {\n            throw new Error(`\"${v}\" is not an decimal.` );\n          }\n          return n;\n        }\n      },\n      {\n        type: 'boolean',\n        getValue(v) {\n          if (v === true || v === 'true') {\n            return true;\n          } else if (v === false || v === 'false') {\n            return false;\n          } else {\n            throw new Error(`\"${v}\" is not a boolean.` );\n          }\n        }\n      },\n      {\n        type: 'code',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S+( \\S+)*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a code.` );\n        }\n      },\n      {\n        type: 'id',\n        getValue(v) {\n          if (typeof v  === 'string' && /^[A-Za-z0-9\\-.]{1,64}$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an id.` );\n        }\n      },\n      {\n        type: 'oid',\n        getValue(v) {\n          if (typeof v  === 'string' && /^urn:oid:[0-2](\\.(0|[1-9][0-9]*))+$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an oid.` );\n        }\n      },\n      {\n        type: 'uuid',\n        getValue(v) {\n          if (typeof v  === 'string' && /^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an uuid.` );\n        }\n      },\n      {\n        type: 'canonical',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an canonical.` );\n        }\n      }\n    ].forEach(({type: primitiveType, getValue}) => {\n      /**\n       * Creates an instance of the type with the value and possibly one or more\n       * extensions.\n       * See primitive type descriptions here:\n       * https://hl7.org/fhir/datatypes.html#primitive\n       * @param {Factory[]} self - an array with one element, which is the\n       *  Factory class.\n       * @param {*} valueColl - a collection that should contain a single value\n       *  of a primitive type.\n       * @param {Extension[]} [extensions] - an optional array of Extensions.\n       * @return {ResourceNode} - a new ResourceNode.\n       */\n      Factory[primitiveType] = function (self, valueColl, extensions) {\n        let data;\n        if (valueColl.length > 1) {\n          throw new Error('Unexpected collection ' + JSON.stringify(valueColl) +\n            ` as a value for %factory.${primitiveType}(value, extensions)`);\n        } else if (valueColl.length === 0) {\n          data = null;\n        } else {\n          const v = util.valData(valueColl[0]);\n          if (v == null) {\n            data = null;\n          } if (typeof v !== 'object') {\n            data = getValue(v);\n          } else {\n            throw new Error(`\"${v}\" is not a ${primitiveType}` );\n          }\n        }\n\n        let _data = null;\n        if (extensions?.length > 0) {\n          _data = {\n            extension: extensions.map(e => {\n              const extensionDataType = TypeInfo.fromValue(e);\n              if (TypeInfo.isType(extensionDataType.name, 'Extension')) {\n                return util.valData(e);\n              } else {\n                throw new Error(`Expected \"FHIR.Extension\", got \"${extensionDataType}\"` );\n              }\n            })\n          };\n        }\n\n        return ResourceNode.makeResNode(data, null, primitiveType, _data, primitiveType);\n      };\n\n      Factory.invocationTable[primitiveType] = {\n        fn: Factory[primitiveType],\n        arity: {1: ['AnyAtRoot'], 2: ['AnyAtRoot', 'Any']}\n      };\n    });\n  }\n\n  /**\n   * Creates an extension with the given url and value\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} url - a string value that identifies the extension\n   * @param {*} value - the value of the extension (any valid type for\n   *  extension.value[x]).\n   * @return {ResourceNode}\n   */\n  static Extension(self, url, value) {\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.Extension(url, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.Extension(url, value)\");\n      }\n    } else {\n      return ResourceNode.makeResNode(Factory.createExtensionObject(url, value[0]),\n        null, 'Extension', null, 'Extension');\n    }\n  }\n\n  /**\n   * Creates an object to store the extension value.\n   * @param {string} url - a string value that identifies the extension\n   * @param {*} value - the value of the extension (any valid type for\n   *  extension.value[x]).\n   * @return {{[p: string]: *, url}}\n   */\n  static createExtensionObject(url, value) {\n    const valuePropertyName = 'value' +\n      TypeInfo.fromValue(value).name.replace(/^\\w/, c => c.toUpperCase());\n    return {\n      url,\n      [valuePropertyName]: util.valData(value)\n    };\n  }\n\n  /**\n   * Creates an identifier with the given properties.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Identifier.system.\n   * @param {string} value - a string value that goes in Identifier.value.\n   * @param {string} use - a string value that goes in Identifier.use.\n   * @param {ResourceNode[]} typeColl - a CodeableConcept that goes in\n   *  Identifier.type.\n   * @return {ResourceNode}\n   */\n  static Identifier (self, system, value, use, typeColl) {\n    if (typeColl?.length > 1) {\n      throw new Error(\"Unexpected collection \" + JSON.stringify(typeColl) +\n        \" as a type for %factory.Identifier{system, value, use, type)\");\n    }\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(value)) {\n      data.value = value;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    if (util.isSome(typeColl)) {\n      const typeInfo = TypeInfo.fromValue(typeColl[0]);\n      if (!TypeInfo.isType(typeInfo.name, 'CodeableConcept')) {\n        throw new Error(`Expected \"FHIR.CodeableConcept\", got \"${typeInfo}\"` );\n      }\n      data.type = typeColl[0];\n    }\n    return ResourceNode.makeResNode(data, null, 'Identifier', null,\n      'Identifier');\n  }\n\n  /**\n   * Create a human name with the given properties.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} family - a string value that goes in HumanName.system.\n   * @param {ResourceNode[]} givenColl - a collection of string values that goes\n   *  in HumanName.given.\n   * @param {string} prefix - a string value that goes in HumanName.prefix.\n   * @param {string} suffix - a string value that goes in HumanName.suffix.\n   * @param {string} text - a string value that goes in HumanName.text.\n   * @param {string} use - a string value that goes in HumanName.use.\n   * @return {ResourceNode}\n   */\n  static HumanName(self, family, givenColl, prefix, suffix, text, use) {\n    const data = {};\n    if (util.isSome(family)) {\n      data.family = family;\n    }\n    if (util.isSome(givenColl)) {\n      data.given = givenColl.map(given => {\n        const v = util.valData(given);\n        if (typeof v === \"string\") {\n          return v;\n        }\n        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);\n      });\n    }\n    if (util.isSome(prefix)) {\n      data.prefix = prefix;\n    }\n    if (util.isSome(suffix)) {\n      data.suffix = suffix;\n    }\n    if (util.isSome(text)) {\n      data.text = text;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    return ResourceNode.makeResNode(data, null, 'HumanName', null,\n      'HumanName');\n  }\n\n  /**\n   * Creates a ContactPoint.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in ContactPoint.system.\n   * @param {string} value - a string value that goes in ContactPoint.value.\n   * @param {string} use - a string value that goes in ContactPoint.use.\n   * @return {ResourceNode}\n   */\n  static ContactPoint(self, system, value, use) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(value)) {\n      data.value = value;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    return ResourceNode.makeResNode(data, null, 'ContactPoint', null,\n      'ContactPoint');\n  }\n\n  /**\n   * Creates an Address\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {ResourceNode[]} lineColl - a collection of string values that goes\n   *  in Address.line.\n   * @param {string} city - a string value that goes in Address.city.\n   * @param {string} state - a string value that goes in Address.state.\n   * @param {string} postalCode - a string value that goes in Address.postalCode.\n   * @param {string} country - a string value that goes in Address.country.\n   * @param {string} use - a string value that goes in Address.use.\n   * @param {string} type - a string value that goes in Address.type.\n   * @return {ResourceNode}\n   */\n  static Address(self, lineColl, city, state, postalCode, country, use, type) {\n    const data = {};\n    if (util.isSome(lineColl)) {\n      data.line = lineColl.map(line => {\n        const v = util.valData(line);\n        if (typeof v === \"string\") {\n          return v;\n        }\n        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);\n      });\n    }\n    if (util.isSome(city)) {\n      data.city = city;\n    }\n    if (util.isSome(state)) {\n      data.state = state;\n    }\n    if (util.isSome(postalCode)) {\n      data.postalCode = postalCode;\n    }\n    if (util.isSome(country)) {\n      data.country = country;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    if (util.isSome(type)) {\n      data.type = type;\n    }\n    return ResourceNode.makeResNode(data, null, 'Address', null,\n      'Address');\n  }\n\n  /**\n   * Creates a Quantity.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Quantity.system.\n   * @param {string} code - a string value that goes in Quantity.code.\n   * @param {string} value - a string or decimal value that goes in\n   *  Quantity.value.\n   * @param {string} unit - a string value that goes in Quantity.unit.\n   * @return {ResourceNode}\n   */\n  static Quantity(self, system, code, value, unit) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(code)) {\n      data.code = code;\n    }\n    if (util.isSome(value)) {\n      data.value = Number(value);\n    }\n    if (util.isSome(unit)) {\n      data.unit = unit;\n    }\n    return ResourceNode.makeResNode(data, null, 'Quantity', null,\n      'Quantity');\n  }\n\n  /**\n   * Creates a Coding.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Coding.system.\n   * @param {string} code - a string value that goes in Coding.code.\n   * @param {string} display - a string value that goes in Coding.display.\n   * @param {string} version - a string value that goes in Coding.version.\n   * @return {ResourceNode}\n   */\n  static Coding(self, system, code, display, version) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(code)) {\n      data.code = code;\n    }\n    if (util.isSome(display)) {\n      data.display = display;\n    }\n    if (util.isSome(version)) {\n      data.version = version;\n    }\n    return ResourceNode.makeResNode(data, null, 'Coding', null,\n      'Coding');\n  }\n\n  /**\n   * Creates a CodeableConcept.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {ResourceNode[]} valueColl - a collection of Coding that goes in\n   *  CodeableConcept.coding.\n   * @param {string} text - a string value that goes in CodeableConcept.text.\n   * @return {ResourceNode}\n   */\n  static CodeableConcept(self, valueColl, text) {\n    const data = valueColl?.length > 0 ?\n      {\n        coding: valueColl.map(coding => {\n          if (coding instanceof ResourceNode &&\n            coding.getTypeInfo().name === 'Coding') {\n            return util.valData(coding);\n          }\n          throw new Error(\"Unexpected value \" + JSON.stringify(coding) +\n            \"; expected value of type Coding\");\n        })\n      }\n      : {};\n\n    if (util.isSome(text)) {\n      data.text = text;\n    }\n\n    return ResourceNode.makeResNode(data, null, 'CodeableConcept', null,\n      'CodeableConcept');\n  }\n\n  /**\n   * Create an instance of the named type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {TypeInfo} typeInfo - a value that is the type to create.\n   * @return {ResourceNode}\n   */\n  static create(self, typeInfo) {\n    if (typeInfo.namespace === TypeInfo.System) {\n      throw new Error('%factory.create(type) doesn\\'t support system types.');\n    }\n    return ResourceNode.makeResNode(null, null, typeInfo.name, null,\n      typeInfo.name);\n  }\n\n  /**\n   * Add an extension, and return the new type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {ResourceNode[]} instanceColl - a collection that should contain the\n   *  instance to which the extension is to be added.\n   * @param {string} url - a string value that goes in Extension.url.\n   *  specification this could also be an actual ValueSet, but I don't want to\n   *  complicate this example.\n   * @param {ResourceNode[]} value - the value of the extension.\n   * @return {ResourceNode|[]}\n   */\n  static withExtension(self, instanceColl, url, value) {\n    if (instanceColl.length > 1 ) {\n      throw  new Error(\"Unexpected collection \" + JSON.stringify(instanceColl) +\n        \" as an instance for %factory.withExtension(instance, url, value)\");\n    }\n\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withExtension(instance, url, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withExtension(instance, url, value)\");\n      }\n    }\n\n    if (instanceColl.length === 0) {\n      return [];\n    }\n\n    const instance = instanceColl[0];\n\n    if (instance instanceof ResourceNode) {\n      let data = instance.data;\n      let _data = instance._data;\n      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {\n        _data = {\n          ...(instance._data || {}),\n          extension: [\n            ...(instance._data?.extension || []),\n            Factory.createExtensionObject(url, value[0])\n          ]\n        };\n      } else {\n        data = {\n          ...(instance.data || {}),\n          extension: [\n            ...(instance.data?.extension || []),\n            Factory.createExtensionObject(url, value[0])\n          ]\n        };\n      }\n      return  ResourceNode.makeResNode(data, null, instance.path, _data,\n        instance.fhirNodeDataType);\n    } else {\n      throw new Error('Expected a ResourceNode.');\n    }\n  }\n\n  /**\n   * Set a property value, and return the new type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {ResourceNode[]} instanceColl - a collection that should contain the\n   *  instance to set the property on.\n   * @param {string} name - a string value that identifies the property to set.\n   * @param {string} value - the value of the property\n   * @return {ResourceNode|*[]}\n   */\n  static withProperty(self, instanceColl, name, value) {\n    if (instanceColl.length > 1 ) {\n      throw  new Error(\"Unexpected collection \" + JSON.stringify(instanceColl) +\n        \" as an instance for %factory.withProperty(instance, name, value)\");\n    }\n\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withProperty(instance, name, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withProperty(instance, name, value)\");\n      }\n    }\n\n    if (instanceColl.length === 0) {\n      return [];\n    }\n\n    const instance = instanceColl[0];\n\n    if (instance instanceof ResourceNode) {\n      let data = instance.data;\n      let _data = instance._data;\n      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {\n        _data = {\n          ...(instance._data || {}),\n          [name]: util.valData(value[0]),\n          ...(value[0]?._data ? { ['_' + name]: value[0]._data } : {})\n        };\n      } else {\n        data = {\n          ...(instance.data || {}),\n          [name]: util.valData(value[0]),\n          ...(value[0]?._data ? { ['_' + name]: value[0]._data } : {})\n        };\n      }\n      return  ResourceNode.makeResNode(data, null, instance.path, _data,\n        instance.fhirNodeDataType);\n    } else {\n      throw new Error('Expected a ResourceNode.');\n    }\n  }\n\n}\n\nmodule.exports = Factory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxRQUFRLCtEQUErRCxFQUFFLG1CQUFPLENBQUMsK0ZBQVM7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0IsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1osZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxHQUFHO0FBQy9HO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaLGdDQUFnQyxFQUFFLGFBQWEsY0FBYztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1FQUFtRSxrQkFBa0I7QUFDckY7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0MsK0JBQStCLElBQUk7QUFDckU7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxrQ0FBa0MsK0JBQStCLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9mYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBjb250YWlucyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgVHlwZSBGYWN0b3J5IEFQSS5cbi8vIFNlZSBodHRwczovL2hsNy5vcmcvZmhpci9maGlycGF0aC5odG1sI2ZhY3RvcnkgZm9yIGRldGFpbHMuXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xuY29uc3QgeyBSZXNvdXJjZU5vZGUsIFR5cGVJbmZvLCBpbnN0YW50UkUsIHRpbWVSRSwgZGF0ZVJFLCBkYXRlVGltZVJFfSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5jbGFzcyBGYWN0b3J5IHtcbiAgLy8gU2FtZSBhcyBmaGlycGF0aC5pbnZvY2F0aW9uVGFibGUsIGJ1dCBmb3IgJWZhY3RvcnkgbWV0aG9kc1xuICBzdGF0aWMgaW52b2NhdGlvblRhYmxlID0ge1xuICAgIEV4dGVuc2lvbjoge2ZuOiBGYWN0b3J5LkV4dGVuc2lvbiwgYXJpdHk6IHsyOiBbJ1N0cmluZycsICdBbnlBdFJvb3QnXX19LFxuICAgIElkZW50aWZpZXI6IHtcbiAgICAgIGZuOiBGYWN0b3J5LklkZW50aWZpZXIsXG4gICAgICBhcml0eToge1xuICAgICAgICAxOiBbJ1N0cmluZyddLFxuICAgICAgICAyOiBbJ1N0cmluZycsICdTdHJpbmcnXSxcbiAgICAgICAgMzogWydTdHJpbmcnLCAnU3RyaW5nJywgJ1N0cmluZyddLFxuICAgICAgICA0OiBbJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJywgJ0FueSddXG4gICAgICB9XG4gICAgfSxcbiAgICBIdW1hbk5hbWU6IHtcbiAgICAgIGZuOiBGYWN0b3J5Lkh1bWFuTmFtZSxcbiAgICAgIGFyaXR5OiB7XG4gICAgICAgIDE6IFsnU3RyaW5nJ10sXG4gICAgICAgIDI6IFsnU3RyaW5nJywgJ0FueUF0Um9vdCddLFxuICAgICAgICAzOiBbJ1N0cmluZycsICdBbnlBdFJvb3QnLCAnU3RyaW5nJ10sXG4gICAgICAgIDQ6IFsnU3RyaW5nJywgJ0FueUF0Um9vdCcsICdTdHJpbmcnLCAnU3RyaW5nJ10sXG4gICAgICAgIDU6IFsnU3RyaW5nJywgJ0FueUF0Um9vdCcsICdTdHJpbmcnLCAnU3RyaW5nJywgJ1N0cmluZyddLFxuICAgICAgICA2OiBbJ1N0cmluZycsICdBbnlBdFJvb3QnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBDb250YWN0UG9pbnQ6IHtcbiAgICAgIGZuOiBGYWN0b3J5LkNvbnRhY3RQb2ludCxcbiAgICAgIGFyaXR5OiB7XG4gICAgICAgIDE6IFsnU3RyaW5nJ10sXG4gICAgICAgIDI6IFsnU3RyaW5nJywgJ1N0cmluZyddLFxuICAgICAgICAzOiBbJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBBZGRyZXNzOiB7XG4gICAgICBmbjogRmFjdG9yeS5BZGRyZXNzLFxuICAgICAgYXJpdHk6IHtcbiAgICAgICAgMTogWydBbnlBdFJvb3QnXSxcbiAgICAgICAgMjogWydBbnlBdFJvb3QnLCAnU3RyaW5nJ10sXG4gICAgICAgIDM6IFsnQW55QXRSb290JywgJ1N0cmluZycsICdTdHJpbmcnXSxcbiAgICAgICAgNDogWydBbnlBdFJvb3QnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnXSxcbiAgICAgICAgNTogWydBbnlBdFJvb3QnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJ10sXG4gICAgICAgIDY6IFsnQW55QXRSb290JywgJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnXSxcbiAgICAgICAgNzogWydBbnlBdFJvb3QnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIFF1YW50aXR5OiB7XG4gICAgICBmbjogRmFjdG9yeS5RdWFudGl0eSxcbiAgICAgIGFyaXR5OiB7XG4gICAgICAgIDE6IFsnU3RyaW5nJ10sXG4gICAgICAgIDI6IFsnU3RyaW5nJywgJ1N0cmluZyddLFxuICAgICAgICAzOiBbJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nT3JOdW1iZXInXSxcbiAgICAgICAgNDogWydTdHJpbmcnLCAnU3RyaW5nJywgJ1N0cmluZ09yTnVtYmVyJywgJ1N0cmluZyddXG4gICAgICB9XG4gICAgfSxcbiAgICBDb2Rpbmc6IHtcbiAgICAgIGZuOiBGYWN0b3J5LkNvZGluZyxcbiAgICAgIGFyaXR5OiB7XG4gICAgICAgIDE6IFsnU3RyaW5nJ10sXG4gICAgICAgIDI6IFsnU3RyaW5nJywgJ1N0cmluZyddLFxuICAgICAgICAzOiBbJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJ10sXG4gICAgICAgIDQ6IFsnU3RyaW5nJywgJ1N0cmluZycsICdTdHJpbmcnLCAnU3RyaW5nJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIENvZGVhYmxlQ29uY2VwdDoge1xuICAgICAgZm46IEZhY3RvcnkuQ29kZWFibGVDb25jZXB0LFxuICAgICAgYXJpdHk6IHtcbiAgICAgICAgMTogWydBbnlBdFJvb3QnXSxcbiAgICAgICAgMjogWydBbnlBdFJvb3QnLCAnU3RyaW5nJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZToge1xuICAgICAgZm46IEZhY3RvcnkuY3JlYXRlLFxuICAgICAgYXJpdHk6IHtcbiAgICAgICAgMTogWydUeXBlU3BlY2lmaWVyJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIHdpdGhFeHRlbnNpb246IHtcbiAgICAgIGZuOiBGYWN0b3J5LndpdGhFeHRlbnNpb24sXG4gICAgICBhcml0eToge1xuICAgICAgICAzOiBbJ0FueUF0Um9vdCcsICdTdHJpbmcnLCAnQW55QXRSb290J11cbiAgICAgIH1cbiAgICB9LFxuICAgIHdpdGhQcm9wZXJ0eToge1xuICAgICAgZm46IEZhY3Rvcnkud2l0aFByb3BlcnR5LFxuICAgICAgYXJpdHk6IHtcbiAgICAgICAgMzogWydBbnlBdFJvb3QnLCAnU3RyaW5nJywgJ0FueUF0Um9vdCddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENyZWF0ZSBmdW5jdGlvbnMgdG8gY3JlYXRlIHByaW1pdGl2ZSB0eXBlcyBhbmQgYWRkIHRoZXNlIGZ1bmN0aW9ucyB0byB0aGVcbiAgLy8gaW52b2NhdGlvblRhYmxlLlxuICBzdGF0aWMge1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9eW1xcc1xcU10rJC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dn1cIiBpcyBub3QgYSBzdHJpbmcuYCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgIGdldFZhbHVlOiAodikgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodik7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiBpbnRlZ2VyLmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3Vuc2lnbmVkSW50JyxcbiAgICAgICAgZ2V0VmFsdWU6ICh2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IE51bWJlcih2KTtcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiB1bnNpZ25lZEludC5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdwb3NpdGl2ZUludCcsXG4gICAgICAgIGdldFZhbHVlOiAodikgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodik7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobikgJiYgbiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhIHBvc2l0aXZlSW50LmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2ludGVnZXI2NCcsXG4gICAgICAgIGdldFZhbHVlOiAodikgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodik7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiBpbnRlZ2VyLmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgZ2V0VmFsdWUodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9eW1xcc1xcU10rJC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGEgbWFya2Rvd24uYCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAndXJsJyxcbiAgICAgICAgZ2V0VmFsdWUodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9eXFxTKiQvLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhIHVybC5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICd1cmknLFxuICAgICAgICBnZXRWYWx1ZSh2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ICA9PT0gJ3N0cmluZycgJiYgL15cXFMqJC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGEgdXJpLmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2luc3RhbnQnLFxuICAgICAgICBnZXRWYWx1ZSh2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ICA9PT0gJ3N0cmluZycgJiYgaW5zdGFudFJFLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiBpbnN0YW50LmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3RpbWUnLFxuICAgICAgICBnZXRWYWx1ZSh2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ICA9PT0gJ3N0cmluZycgJiYgdGltZVJFLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhIHRpbWUuYCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnZGF0ZScsXG4gICAgICAgIGdldFZhbHVlKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgID09PSAnc3RyaW5nJyAmJiBkYXRlUkUudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGEgZGF0ZS5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdkYXRlVGltZScsXG4gICAgICAgIGdldFZhbHVlKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgID09PSAnc3RyaW5nJyAmJiBkYXRlVGltZVJFLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhIGRhdGVUaW1lLmAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2Jhc2U2NEJpbmFyeScsXG4gICAgICAgIGdldFZhbHVlKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvXG4gICAgICAgICAgICAgIC50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dn1cIiBpcyBub3QgYSBiYXNlNjRCaW5hcnkuYCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnZGVjaW1hbCcsXG4gICAgICAgIGdldFZhbHVlKHYpIHtcbiAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHYpO1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGFuIGRlY2ltYWwuYCApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBnZXRWYWx1ZSh2KSB7XG4gICAgICAgICAgaWYgKHYgPT09IHRydWUgfHwgdiA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYgPT09IGZhbHNlIHx8IHYgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dn1cIiBpcyBub3QgYSBib29sZWFuLmAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgZ2V0VmFsdWUodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9eXFxTKyggXFxTKykqJC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGEgY29kZS5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdpZCcsXG4gICAgICAgIGdldFZhbHVlKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgID09PSAnc3RyaW5nJyAmJiAvXltBLVphLXowLTlcXC0uXXsxLDY0fSQvLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiBpZC5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdvaWQnLFxuICAgICAgICBnZXRWYWx1ZSh2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ICA9PT0gJ3N0cmluZycgJiYgL151cm46b2lkOlswLTJdKFxcLigwfFsxLTldWzAtOV0qKSkrJC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGFuIG9pZC5gICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICd1dWlkJyxcbiAgICAgICAgZ2V0VmFsdWUodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9edXJuOnV1aWQ6WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC8udGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGFuIHV1aWQuYCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnY2Fub25pY2FsJyxcbiAgICAgICAgZ2V0VmFsdWUodikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAgPT09ICdzdHJpbmcnICYmIC9eXFxTKiQvLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2fVwiIGlzIG5vdCBhbiBjYW5vbmljYWwuYCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXS5mb3JFYWNoKCh7dHlwZTogcHJpbWl0aXZlVHlwZSwgZ2V0VmFsdWV9KSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgd2l0aCB0aGUgdmFsdWUgYW5kIHBvc3NpYmx5IG9uZSBvciBtb3JlXG4gICAgICAgKiBleHRlbnNpb25zLlxuICAgICAgICogU2VlIHByaW1pdGl2ZSB0eXBlIGRlc2NyaXB0aW9ucyBoZXJlOlxuICAgICAgICogaHR0cHM6Ly9obDcub3JnL2ZoaXIvZGF0YXR5cGVzLmh0bWwjcHJpbWl0aXZlXG4gICAgICAgKiBAcGFyYW0ge0ZhY3RvcnlbXX0gc2VsZiAtIGFuIGFycmF5IHdpdGggb25lIGVsZW1lbnQsIHdoaWNoIGlzIHRoZVxuICAgICAgICogIEZhY3RvcnkgY2xhc3MuXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlQ29sbCAtIGEgY29sbGVjdGlvbiB0aGF0IHNob3VsZCBjb250YWluIGEgc2luZ2xlIHZhbHVlXG4gICAgICAgKiAgb2YgYSBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAqIEBwYXJhbSB7RXh0ZW5zaW9uW119IFtleHRlbnNpb25zXSAtIGFuIG9wdGlvbmFsIGFycmF5IG9mIEV4dGVuc2lvbnMuXG4gICAgICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9IC0gYSBuZXcgUmVzb3VyY2VOb2RlLlxuICAgICAgICovXG4gICAgICBGYWN0b3J5W3ByaW1pdGl2ZVR5cGVdID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlQ29sbCwgZXh0ZW5zaW9ucykge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKHZhbHVlQ29sbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbGxlY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlQ29sbCkgK1xuICAgICAgICAgICAgYCBhcyBhIHZhbHVlIGZvciAlZmFjdG9yeS4ke3ByaW1pdGl2ZVR5cGV9KHZhbHVlLCBleHRlbnNpb25zKWApO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlQ29sbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB2ID0gdXRpbC52YWxEYXRhKHZhbHVlQ29sbFswXSk7XG4gICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgfSBpZiAodHlwZW9mIHYgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0VmFsdWUodik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Z9XCIgaXMgbm90IGEgJHtwcmltaXRpdmVUeXBlfWAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgX2RhdGEgPSBudWxsO1xuICAgICAgICBpZiAoZXh0ZW5zaW9ucz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF9kYXRhID0ge1xuICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRlbnNpb25zLm1hcChlID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uRGF0YVR5cGUgPSBUeXBlSW5mby5mcm9tVmFsdWUoZSk7XG4gICAgICAgICAgICAgIGlmIChUeXBlSW5mby5pc1R5cGUoZXh0ZW5zaW9uRGF0YVR5cGUubmFtZSwgJ0V4dGVuc2lvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwudmFsRGF0YShlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiRkhJUi5FeHRlbnNpb25cIiwgZ290IFwiJHtleHRlbnNpb25EYXRhVHlwZX1cImAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlc291cmNlTm9kZS5tYWtlUmVzTm9kZShkYXRhLCBudWxsLCBwcmltaXRpdmVUeXBlLCBfZGF0YSwgcHJpbWl0aXZlVHlwZSk7XG4gICAgICB9O1xuXG4gICAgICBGYWN0b3J5Lmludm9jYXRpb25UYWJsZVtwcmltaXRpdmVUeXBlXSA9IHtcbiAgICAgICAgZm46IEZhY3RvcnlbcHJpbWl0aXZlVHlwZV0sXG4gICAgICAgIGFyaXR5OiB7MTogWydBbnlBdFJvb3QnXSwgMjogWydBbnlBdFJvb3QnLCAnQW55J119XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIHVybCBhbmQgdmFsdWVcbiAgICogQHBhcmFtIHtGYWN0b3J5W119IHNlbGYgLSBhbiBhcnJheSB3aXRoIG9uZSBlbGVtZW50LCB3aGljaCBpcyB0aGUgRmFjdG9yeVxuICAgKiAgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGlkZW50aWZpZXMgdGhlIGV4dGVuc2lvblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBleHRlbnNpb24gKGFueSB2YWxpZCB0eXBlIGZvclxuICAgKiAgZXh0ZW5zaW9uLnZhbHVlW3hdKS5cbiAgICogQHJldHVybiB7UmVzb3VyY2VOb2RlfVxuICAgKi9cbiAgc3RhdGljIEV4dGVuc2lvbihzZWxmLCB1cmwsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjb2xsZWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICtcbiAgICAgICAgICBcIiBhcyBhIHZhbHVlIGZvciAlZmFjdG9yeS5FeHRlbnNpb24odXJsLCB2YWx1ZSlcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBjb2xsZWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICtcbiAgICAgICAgICBcIiBhcyBhIHZhbHVlIGZvciAlZmFjdG9yeS5FeHRlbnNpb24odXJsLCB2YWx1ZSlcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUoRmFjdG9yeS5jcmVhdGVFeHRlbnNpb25PYmplY3QodXJsLCB2YWx1ZVswXSksXG4gICAgICAgIG51bGwsICdFeHRlbnNpb24nLCBudWxsLCAnRXh0ZW5zaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRvIHN0b3JlIHRoZSBleHRlbnNpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGlkZW50aWZpZXMgdGhlIGV4dGVuc2lvblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBleHRlbnNpb24gKGFueSB2YWxpZCB0eXBlIGZvclxuICAgKiAgZXh0ZW5zaW9uLnZhbHVlW3hdKS5cbiAgICogQHJldHVybiB7e1twOiBzdHJpbmddOiAqLCB1cmx9fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUV4dGVuc2lvbk9iamVjdCh1cmwsIHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVQcm9wZXJ0eU5hbWUgPSAndmFsdWUnICtcbiAgICAgIFR5cGVJbmZvLmZyb21WYWx1ZSh2YWx1ZSkubmFtZS5yZXBsYWNlKC9eXFx3LywgYyA9PiBjLnRvVXBwZXJDYXNlKCkpO1xuICAgIHJldHVybiB7XG4gICAgICB1cmwsXG4gICAgICBbdmFsdWVQcm9wZXJ0eU5hbWVdOiB1dGlsLnZhbERhdGEodmFsdWUpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGlkZW50aWZpZXIgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtGYWN0b3J5W119IHNlbGYgLSBhbiBhcnJheSB3aXRoIG9uZSBlbGVtZW50LCB3aGljaCBpcyB0aGUgRmFjdG9yeVxuICAgKiAgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeXN0ZW0gLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gSWRlbnRpZmllci5zeXN0ZW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBJZGVudGlmaWVyLnZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlIC0gYSBzdHJpbmcgdmFsdWUgdGhhdCBnb2VzIGluIElkZW50aWZpZXIudXNlLlxuICAgKiBAcGFyYW0ge1Jlc291cmNlTm9kZVtdfSB0eXBlQ29sbCAtIGEgQ29kZWFibGVDb25jZXB0IHRoYXQgZ29lcyBpblxuICAgKiAgSWRlbnRpZmllci50eXBlLlxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9XG4gICAqL1xuICBzdGF0aWMgSWRlbnRpZmllciAoc2VsZiwgc3lzdGVtLCB2YWx1ZSwgdXNlLCB0eXBlQ29sbCkge1xuICAgIGlmICh0eXBlQ29sbD8ubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjb2xsZWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZUNvbGwpICtcbiAgICAgICAgXCIgYXMgYSB0eXBlIGZvciAlZmFjdG9yeS5JZGVudGlmaWVye3N5c3RlbSwgdmFsdWUsIHVzZSwgdHlwZSlcIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBpZiAodXRpbC5pc1NvbWUoc3lzdGVtKSkge1xuICAgICAgZGF0YS5zeXN0ZW0gPSBzeXN0ZW07XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZSh2YWx1ZSkpIHtcbiAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHVzZSkpIHtcbiAgICAgIGRhdGEudXNlID0gdXNlO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUodHlwZUNvbGwpKSB7XG4gICAgICBjb25zdCB0eXBlSW5mbyA9IFR5cGVJbmZvLmZyb21WYWx1ZSh0eXBlQ29sbFswXSk7XG4gICAgICBpZiAoIVR5cGVJbmZvLmlzVHlwZSh0eXBlSW5mby5uYW1lLCAnQ29kZWFibGVDb25jZXB0JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBcIkZISVIuQ29kZWFibGVDb25jZXB0XCIsIGdvdCBcIiR7dHlwZUluZm99XCJgICk7XG4gICAgICB9XG4gICAgICBkYXRhLnR5cGUgPSB0eXBlQ29sbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc291cmNlTm9kZS5tYWtlUmVzTm9kZShkYXRhLCBudWxsLCAnSWRlbnRpZmllcicsIG51bGwsXG4gICAgICAnSWRlbnRpZmllcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGh1bWFuIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtGYWN0b3J5W119IHNlbGYgLSBhbiBhcnJheSB3aXRoIG9uZSBlbGVtZW50LCB3aGljaCBpcyB0aGUgRmFjdG9yeVxuICAgKiAgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHkgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gSHVtYW5OYW1lLnN5c3RlbS5cbiAgICogQHBhcmFtIHtSZXNvdXJjZU5vZGVbXX0gZ2l2ZW5Db2xsIC0gYSBjb2xsZWN0aW9uIG9mIHN0cmluZyB2YWx1ZXMgdGhhdCBnb2VzXG4gICAqICBpbiBIdW1hbk5hbWUuZ2l2ZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gSHVtYW5OYW1lLnByZWZpeC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1ZmZpeCAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBIdW1hbk5hbWUuc3VmZml4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBIdW1hbk5hbWUudGV4dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBIdW1hbk5hbWUudXNlLlxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9XG4gICAqL1xuICBzdGF0aWMgSHVtYW5OYW1lKHNlbGYsIGZhbWlseSwgZ2l2ZW5Db2xsLCBwcmVmaXgsIHN1ZmZpeCwgdGV4dCwgdXNlKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGlmICh1dGlsLmlzU29tZShmYW1pbHkpKSB7XG4gICAgICBkYXRhLmZhbWlseSA9IGZhbWlseTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKGdpdmVuQ29sbCkpIHtcbiAgICAgIGRhdGEuZ2l2ZW4gPSBnaXZlbkNvbGwubWFwKGdpdmVuID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHV0aWwudmFsRGF0YShnaXZlbik7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBidXQgZ290OiAke0pTT04uc3RyaW5naWZ5KHYpfWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZShwcmVmaXgpKSB7XG4gICAgICBkYXRhLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHN1ZmZpeCkpIHtcbiAgICAgIGRhdGEuc3VmZml4ID0gc3VmZml4O1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUodGV4dCkpIHtcbiAgICAgIGRhdGEudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZSh1c2UpKSB7XG4gICAgICBkYXRhLnVzZSA9IHVzZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc291cmNlTm9kZS5tYWtlUmVzTm9kZShkYXRhLCBudWxsLCAnSHVtYW5OYW1lJywgbnVsbCxcbiAgICAgICdIdW1hbk5hbWUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29udGFjdFBvaW50LlxuICAgKiBAcGFyYW0ge0ZhY3RvcnlbXX0gc2VsZiAtIGFuIGFycmF5IHdpdGggb25lIGVsZW1lbnQsIHdoaWNoIGlzIHRoZSBGYWN0b3J5XG4gICAqICBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5c3RlbSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBDb250YWN0UG9pbnQuc3lzdGVtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gQ29udGFjdFBvaW50LnZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlIC0gYSBzdHJpbmcgdmFsdWUgdGhhdCBnb2VzIGluIENvbnRhY3RQb2ludC51c2UuXG4gICAqIEByZXR1cm4ge1Jlc291cmNlTm9kZX1cbiAgICovXG4gIHN0YXRpYyBDb250YWN0UG9pbnQoc2VsZiwgc3lzdGVtLCB2YWx1ZSwgdXNlKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGlmICh1dGlsLmlzU29tZShzeXN0ZW0pKSB7XG4gICAgICBkYXRhLnN5c3RlbSA9IHN5c3RlbTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHZhbHVlKSkge1xuICAgICAgZGF0YS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUodXNlKSkge1xuICAgICAgZGF0YS51c2UgPSB1c2U7XG4gICAgfVxuICAgIHJldHVybiBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUoZGF0YSwgbnVsbCwgJ0NvbnRhY3RQb2ludCcsIG51bGwsXG4gICAgICAnQ29udGFjdFBvaW50Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBZGRyZXNzXG4gICAqIEBwYXJhbSB7RmFjdG9yeVtdfSBzZWxmIC0gYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCwgd2hpY2ggaXMgdGhlIEZhY3RvcnlcbiAgICogIGNsYXNzLlxuICAgKiBAcGFyYW0ge1Jlc291cmNlTm9kZVtdfSBsaW5lQ29sbCAtIGEgY29sbGVjdGlvbiBvZiBzdHJpbmcgdmFsdWVzIHRoYXQgZ29lc1xuICAgKiAgaW4gQWRkcmVzcy5saW5lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2l0eSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBBZGRyZXNzLmNpdHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBBZGRyZXNzLnN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zdGFsQ29kZSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBBZGRyZXNzLnBvc3RhbENvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb3VudHJ5IC0gYSBzdHJpbmcgdmFsdWUgdGhhdCBnb2VzIGluIEFkZHJlc3MuY291bnRyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZSAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBBZGRyZXNzLnVzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gQWRkcmVzcy50eXBlLlxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9XG4gICAqL1xuICBzdGF0aWMgQWRkcmVzcyhzZWxmLCBsaW5lQ29sbCwgY2l0eSwgc3RhdGUsIHBvc3RhbENvZGUsIGNvdW50cnksIHVzZSwgdHlwZSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBpZiAodXRpbC5pc1NvbWUobGluZUNvbGwpKSB7XG4gICAgICBkYXRhLmxpbmUgPSBsaW5lQ29sbC5tYXAobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSB1dGlsLnZhbERhdGEobGluZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBidXQgZ290OiAke0pTT04uc3RyaW5naWZ5KHYpfWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZShjaXR5KSkge1xuICAgICAgZGF0YS5jaXR5ID0gY2l0eTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHN0YXRlKSkge1xuICAgICAgZGF0YS5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUocG9zdGFsQ29kZSkpIHtcbiAgICAgIGRhdGEucG9zdGFsQ29kZSA9IHBvc3RhbENvZGU7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZShjb3VudHJ5KSkge1xuICAgICAgZGF0YS5jb3VudHJ5ID0gY291bnRyeTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHVzZSkpIHtcbiAgICAgIGRhdGEudXNlID0gdXNlO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUodHlwZSkpIHtcbiAgICAgIGRhdGEudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUoZGF0YSwgbnVsbCwgJ0FkZHJlc3MnLCBudWxsLFxuICAgICAgJ0FkZHJlc3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUXVhbnRpdHkuXG4gICAqIEBwYXJhbSB7RmFjdG9yeVtdfSBzZWxmIC0gYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCwgd2hpY2ggaXMgdGhlIEZhY3RvcnlcbiAgICogIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gYSBzdHJpbmcgdmFsdWUgdGhhdCBnb2VzIGluIFF1YW50aXR5LnN5c3RlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gUXVhbnRpdHkuY29kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gYSBzdHJpbmcgb3IgZGVjaW1hbCB2YWx1ZSB0aGF0IGdvZXMgaW5cbiAgICogIFF1YW50aXR5LnZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBRdWFudGl0eS51bml0LlxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9XG4gICAqL1xuICBzdGF0aWMgUXVhbnRpdHkoc2VsZiwgc3lzdGVtLCBjb2RlLCB2YWx1ZSwgdW5pdCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBpZiAodXRpbC5pc1NvbWUoc3lzdGVtKSkge1xuICAgICAgZGF0YS5zeXN0ZW0gPSBzeXN0ZW07XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZShjb2RlKSkge1xuICAgICAgZGF0YS5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHZhbHVlKSkge1xuICAgICAgZGF0YS52YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZSh1bml0KSkge1xuICAgICAgZGF0YS51bml0ID0gdW5pdDtcbiAgICB9XG4gICAgcmV0dXJuIFJlc291cmNlTm9kZS5tYWtlUmVzTm9kZShkYXRhLCBudWxsLCAnUXVhbnRpdHknLCBudWxsLFxuICAgICAgJ1F1YW50aXR5Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIENvZGluZy5cbiAgICogQHBhcmFtIHtGYWN0b3J5W119IHNlbGYgLSBhbiBhcnJheSB3aXRoIG9uZSBlbGVtZW50LCB3aGljaCBpcyB0aGUgRmFjdG9yeVxuICAgKiAgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeXN0ZW0gLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gQ29kaW5nLnN5c3RlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gQ29kaW5nLmNvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5IC0gYSBzdHJpbmcgdmFsdWUgdGhhdCBnb2VzIGluIENvZGluZy5kaXNwbGF5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBDb2RpbmcudmVyc2lvbi5cbiAgICogQHJldHVybiB7UmVzb3VyY2VOb2RlfVxuICAgKi9cbiAgc3RhdGljIENvZGluZyhzZWxmLCBzeXN0ZW0sIGNvZGUsIGRpc3BsYXksIHZlcnNpb24pIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgaWYgKHV0aWwuaXNTb21lKHN5c3RlbSkpIHtcbiAgICAgIGRhdGEuc3lzdGVtID0gc3lzdGVtO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1NvbWUoY29kZSkpIHtcbiAgICAgIGRhdGEuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzU29tZShkaXNwbGF5KSkge1xuICAgICAgZGF0YS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNTb21lKHZlcnNpb24pKSB7XG4gICAgICBkYXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gUmVzb3VyY2VOb2RlLm1ha2VSZXNOb2RlKGRhdGEsIG51bGwsICdDb2RpbmcnLCBudWxsLFxuICAgICAgJ0NvZGluZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDb2RlYWJsZUNvbmNlcHQuXG4gICAqIEBwYXJhbSB7RmFjdG9yeVtdfSBzZWxmIC0gYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCwgd2hpY2ggaXMgdGhlIEZhY3RvcnlcbiAgICogIGNsYXNzLlxuICAgKiBAcGFyYW0ge1Jlc291cmNlTm9kZVtdfSB2YWx1ZUNvbGwgLSBhIGNvbGxlY3Rpb24gb2YgQ29kaW5nIHRoYXQgZ29lcyBpblxuICAgKiAgQ29kZWFibGVDb25jZXB0LmNvZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGdvZXMgaW4gQ29kZWFibGVDb25jZXB0LnRleHQuXG4gICAqIEByZXR1cm4ge1Jlc291cmNlTm9kZX1cbiAgICovXG4gIHN0YXRpYyBDb2RlYWJsZUNvbmNlcHQoc2VsZiwgdmFsdWVDb2xsLCB0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHZhbHVlQ29sbD8ubGVuZ3RoID4gMCA/XG4gICAgICB7XG4gICAgICAgIGNvZGluZzogdmFsdWVDb2xsLm1hcChjb2RpbmcgPT4ge1xuICAgICAgICAgIGlmIChjb2RpbmcgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGUgJiZcbiAgICAgICAgICAgIGNvZGluZy5nZXRUeXBlSW5mbygpLm5hbWUgPT09ICdDb2RpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC52YWxEYXRhKGNvZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgXCIgKyBKU09OLnN0cmluZ2lmeShjb2RpbmcpICtcbiAgICAgICAgICAgIFwiOyBleHBlY3RlZCB2YWx1ZSBvZiB0eXBlIENvZGluZ1wiKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIDoge307XG5cbiAgICBpZiAodXRpbC5pc1NvbWUodGV4dCkpIHtcbiAgICAgIGRhdGEudGV4dCA9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlc291cmNlTm9kZS5tYWtlUmVzTm9kZShkYXRhLCBudWxsLCAnQ29kZWFibGVDb25jZXB0JywgbnVsbCxcbiAgICAgICdDb2RlYWJsZUNvbmNlcHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5hbWVkIHR5cGUuXG4gICAqIEBwYXJhbSB7RmFjdG9yeVtdfSBzZWxmIC0gYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCB0aGF0IHJlZmVycyB0b1xuICAgKiAgdGhlIGN1cnJlbnQgRmFjdG9yeSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtUeXBlSW5mb30gdHlwZUluZm8gLSBhIHZhbHVlIHRoYXQgaXMgdGhlIHR5cGUgdG8gY3JlYXRlLlxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKHNlbGYsIHR5cGVJbmZvKSB7XG4gICAgaWYgKHR5cGVJbmZvLm5hbWVzcGFjZSA9PT0gVHlwZUluZm8uU3lzdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyVmYWN0b3J5LmNyZWF0ZSh0eXBlKSBkb2VzblxcJ3Qgc3VwcG9ydCBzeXN0ZW0gdHlwZXMuJyk7XG4gICAgfVxuICAgIHJldHVybiBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUobnVsbCwgbnVsbCwgdHlwZUluZm8ubmFtZSwgbnVsbCxcbiAgICAgIHR5cGVJbmZvLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlbnNpb24sIGFuZCByZXR1cm4gdGhlIG5ldyB0eXBlLlxuICAgKiBAcGFyYW0ge0ZhY3RvcnlbXX0gc2VsZiAtIGFuIGFycmF5IHdpdGggb25lIGVsZW1lbnQgdGhhdCByZWZlcnMgdG9cbiAgICogIHRoZSBjdXJyZW50IEZhY3RvcnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlW119IGluc3RhbmNlQ29sbCAtIGEgY29sbGVjdGlvbiB0aGF0IHNob3VsZCBjb250YWluIHRoZVxuICAgKiAgaW5zdGFuY2UgdG8gd2hpY2ggdGhlIGV4dGVuc2lvbiBpcyB0byBiZSBhZGRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIGEgc3RyaW5nIHZhbHVlIHRoYXQgZ29lcyBpbiBFeHRlbnNpb24udXJsLlxuICAgKiAgc3BlY2lmaWNhdGlvbiB0aGlzIGNvdWxkIGFsc28gYmUgYW4gYWN0dWFsIFZhbHVlU2V0LCBidXQgSSBkb24ndCB3YW50IHRvXG4gICAqICBjb21wbGljYXRlIHRoaXMgZXhhbXBsZS5cbiAgICogQHBhcmFtIHtSZXNvdXJjZU5vZGVbXX0gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGV4dGVuc2lvbi5cbiAgICogQHJldHVybiB7UmVzb3VyY2VOb2RlfFtdfVxuICAgKi9cbiAgc3RhdGljIHdpdGhFeHRlbnNpb24oc2VsZiwgaW5zdGFuY2VDb2xsLCB1cmwsIHZhbHVlKSB7XG4gICAgaWYgKGluc3RhbmNlQ29sbC5sZW5ndGggPiAxICkge1xuICAgICAgdGhyb3cgIG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY29sbGVjdGlvbiBcIiArIEpTT04uc3RyaW5naWZ5KGluc3RhbmNlQ29sbCkgK1xuICAgICAgICBcIiBhcyBhbiBpbnN0YW5jZSBmb3IgJWZhY3Rvcnkud2l0aEV4dGVuc2lvbihpbnN0YW5jZSwgdXJsLCB2YWx1ZSlcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjb2xsZWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICtcbiAgICAgICAgICBcIiBhcyBhIHZhbHVlIGZvciAlZmFjdG9yeS53aXRoRXh0ZW5zaW9uKGluc3RhbmNlLCB1cmwsIHZhbHVlKVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IGNvbGxlY3Rpb24gXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgK1xuICAgICAgICAgIFwiIGFzIGEgdmFsdWUgZm9yICVmYWN0b3J5LndpdGhFeHRlbnNpb24oaW5zdGFuY2UsIHVybCwgdmFsdWUpXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZUNvbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZUNvbGxbMF07XG5cbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGUpIHtcbiAgICAgIGxldCBkYXRhID0gaW5zdGFuY2UuZGF0YTtcbiAgICAgIGxldCBfZGF0YSA9IGluc3RhbmNlLl9kYXRhO1xuICAgICAgaWYgKFR5cGVJbmZvLmlzUHJpbWl0aXZlKGluc3RhbmNlLmdldFR5cGVJbmZvKCkpKSB7XG4gICAgICAgIF9kYXRhID0ge1xuICAgICAgICAgIC4uLihpbnN0YW5jZS5fZGF0YSB8fCB7fSksXG4gICAgICAgICAgZXh0ZW5zaW9uOiBbXG4gICAgICAgICAgICAuLi4oaW5zdGFuY2UuX2RhdGE/LmV4dGVuc2lvbiB8fCBbXSksXG4gICAgICAgICAgICBGYWN0b3J5LmNyZWF0ZUV4dGVuc2lvbk9iamVjdCh1cmwsIHZhbHVlWzBdKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgLi4uKGluc3RhbmNlLmRhdGEgfHwge30pLFxuICAgICAgICAgIGV4dGVuc2lvbjogW1xuICAgICAgICAgICAgLi4uKGluc3RhbmNlLmRhdGE/LmV4dGVuc2lvbiB8fCBbXSksXG4gICAgICAgICAgICBGYWN0b3J5LmNyZWF0ZUV4dGVuc2lvbk9iamVjdCh1cmwsIHZhbHVlWzBdKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAgUmVzb3VyY2VOb2RlLm1ha2VSZXNOb2RlKGRhdGEsIG51bGwsIGluc3RhbmNlLnBhdGgsIF9kYXRhLFxuICAgICAgICBpbnN0YW5jZS5maGlyTm9kZURhdGFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFJlc291cmNlTm9kZS4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcHJvcGVydHkgdmFsdWUsIGFuZCByZXR1cm4gdGhlIG5ldyB0eXBlLlxuICAgKiBAcGFyYW0ge0ZhY3RvcnlbXX0gc2VsZiAtIGFuIGFycmF5IHdpdGggb25lIGVsZW1lbnQgdGhhdCByZWZlcnMgdG9cbiAgICogIHRoZSBjdXJyZW50IEZhY3RvcnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlW119IGluc3RhbmNlQ29sbCAtIGEgY29sbGVjdGlvbiB0aGF0IHNob3VsZCBjb250YWluIHRoZVxuICAgKiAgaW5zdGFuY2UgdG8gc2V0IHRoZSBwcm9wZXJ0eSBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBhIHN0cmluZyB2YWx1ZSB0aGF0IGlkZW50aWZpZXMgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtSZXNvdXJjZU5vZGV8KltdfVxuICAgKi9cbiAgc3RhdGljIHdpdGhQcm9wZXJ0eShzZWxmLCBpbnN0YW5jZUNvbGwsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGluc3RhbmNlQ29sbC5sZW5ndGggPiAxICkge1xuICAgICAgdGhyb3cgIG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY29sbGVjdGlvbiBcIiArIEpTT04uc3RyaW5naWZ5KGluc3RhbmNlQ29sbCkgK1xuICAgICAgICBcIiBhcyBhbiBpbnN0YW5jZSBmb3IgJWZhY3Rvcnkud2l0aFByb3BlcnR5KGluc3RhbmNlLCBuYW1lLCB2YWx1ZSlcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjb2xsZWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICtcbiAgICAgICAgICBcIiBhcyBhIHZhbHVlIGZvciAlZmFjdG9yeS53aXRoUHJvcGVydHkoaW5zdGFuY2UsIG5hbWUsIHZhbHVlKVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IGNvbGxlY3Rpb24gXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgK1xuICAgICAgICAgIFwiIGFzIGEgdmFsdWUgZm9yICVmYWN0b3J5LndpdGhQcm9wZXJ0eShpbnN0YW5jZSwgbmFtZSwgdmFsdWUpXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZUNvbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZUNvbGxbMF07XG5cbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGUpIHtcbiAgICAgIGxldCBkYXRhID0gaW5zdGFuY2UuZGF0YTtcbiAgICAgIGxldCBfZGF0YSA9IGluc3RhbmNlLl9kYXRhO1xuICAgICAgaWYgKFR5cGVJbmZvLmlzUHJpbWl0aXZlKGluc3RhbmNlLmdldFR5cGVJbmZvKCkpKSB7XG4gICAgICAgIF9kYXRhID0ge1xuICAgICAgICAgIC4uLihpbnN0YW5jZS5fZGF0YSB8fCB7fSksXG4gICAgICAgICAgW25hbWVdOiB1dGlsLnZhbERhdGEodmFsdWVbMF0pLFxuICAgICAgICAgIC4uLih2YWx1ZVswXT8uX2RhdGEgPyB7IFsnXycgKyBuYW1lXTogdmFsdWVbMF0uX2RhdGEgfSA6IHt9KVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAuLi4oaW5zdGFuY2UuZGF0YSB8fCB7fSksXG4gICAgICAgICAgW25hbWVdOiB1dGlsLnZhbERhdGEodmFsdWVbMF0pLFxuICAgICAgICAgIC4uLih2YWx1ZVswXT8uX2RhdGEgPyB7IFsnXycgKyBuYW1lXTogdmFsdWVbMF0uX2RhdGEgfSA6IHt9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuICBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUoZGF0YSwgbnVsbCwgaW5zdGFuY2UucGF0aCwgX2RhdGEsXG4gICAgICAgIGluc3RhbmNlLmZoaXJOb2RlRGF0YVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgUmVzb3VyY2VOb2RlLicpO1xuICAgIH1cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/factory.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/fhirpath.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/fhirpath.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This is fhirpath interpreter\n// everything starts at evaluate function,\n// which is passed  fhirpath AST and resource.\n//\n// We reduce/eval recursively each node in AST\n// passing the context and current data\n//\n// each AST node has eval function, which should be registered in evalTable\n// and named after node type\n// if node needs to eval father it's children it has to call `doEval` function\n//\n// most of nodes do function or operator invocation at the end\n//\n// For invocation's and operator's there is one lookup table -\n// invocationTable and two helper functions doInvoke and infixInvoke for\n// operators\n// 1. operator or function is looked up in table\n// 2. using signature (in  .arity property) unpack parameters\n// 3. check params types\n// 4. do call function\n// 5. wrap result by util.arraify\n//\n// if function is nullable\n// and one of parameters is empty/null - function will not be invoked and empty\n// result returned\n//\n// Not solved problem is overloading functions by types - for example + operator defined\n// for strings and numbers\n// we can make dispatching params type dependent - let see\n\nconst {version} = __webpack_require__(/*! ../package.json */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/package.json\");\nconst parser = __webpack_require__(/*! ./parser */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/index.js\");\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n__webpack_require__(/*! ./polyfill */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/polyfill.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/constants.js\");\n\nlet engine    = {}; // the object with all FHIRPath functions and operations\nlet existence = __webpack_require__(/*! ./existence */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/existence.js\");\nlet filtering = __webpack_require__(/*! ./filtering */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js\");\nlet aggregate = __webpack_require__(/*! ./aggregate */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/aggregate.js\");\nlet supplements = __webpack_require__(/*! ./sdc-ig-supplements */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/sdc-ig-supplements.js\");\nlet combining = __webpack_require__(/*! ./combining */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/combining.js\");\nlet misc      = __webpack_require__(/*! ./misc */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js\");\nlet equality  = __webpack_require__(/*! ./equality */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/equality.js\");\nlet collections  = __webpack_require__(/*! ./collections */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/collections.js\");\nlet math      = __webpack_require__(/*! ./math */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/math.js\");\nlet strings   = __webpack_require__(/*! ./strings */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/strings.js\");\nlet navigation= __webpack_require__(/*! ./navigation */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/navigation.js\");\nlet datetime  = __webpack_require__(/*! ./datetime */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/datetime.js\");\nlet additional  = __webpack_require__(/*! ./additional */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/additional.js\");\nlet logic  = __webpack_require__(/*! ./logic */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/logic.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst {\n  FP_Date, FP_DateTime, FP_Time, FP_Quantity,\n  FP_Type, ResourceNode, TypeInfo\n} = types;\nlet makeResNode = ResourceNode.makeResNode;\nconst Terminologies = __webpack_require__(/*! ./terminologies */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/terminologies.js\");\nconst Factory = __webpack_require__(/*! ./factory */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/factory.js\");\n\n// * fn: handler\n// * arity: is index map with type signature\n//   if type is in array (like [Boolean]) - this means\n//   function accepts value of this type or empty value {}\n// * nullable:  means propagate empty result, i.e. instead\n//   calling function if one of params is  empty return empty\n\nengine.invocationTable = {\n  memberOf:     {fn: additional.memberOf, arity: { 1: ['String']} },\n  empty:        {fn: existence.emptyFn},\n  not:          {fn: existence.notFn},\n  exists:       {fn: existence.existsMacro, arity: {0: [], 1: [\"Expr\"]}},\n  all:          {fn: existence.allMacro, arity: {1: [\"Expr\"]}},\n  allTrue:      {fn: existence.allTrueFn},\n  anyTrue:      {fn: existence.anyTrueFn},\n  allFalse:     {fn: existence.allFalseFn},\n  anyFalse:     {fn: existence.anyFalseFn},\n  subsetOf:     {fn: existence.subsetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  supersetOf:   {fn: existence.supersetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  isDistinct:   {fn: existence.isDistinctFn},\n  distinct:     {fn: filtering.distinctFn},\n  count:        {fn: aggregate.countFn},\n  where:        {fn: filtering.whereMacro, arity: {1: [\"Expr\"]}},\n  extension:    {fn: filtering.extension, arity: {1: [\"String\"]}},\n  select:       {fn: filtering.selectMacro, arity: {1: [\"Expr\"]}},\n  aggregate:    {fn: aggregate.aggregateMacro, arity: {1: [\"Expr\"], 2: [\"Expr\", \"AnyAtRoot\"]}},\n  sum:          {fn: aggregate.sumFn},\n  min:          {fn: aggregate.minFn},\n  max:          {fn: aggregate.maxFn},\n  avg:          {fn: aggregate.avgFn},\n  weight:       {fn: supplements.weight},\n  ordinal:      {fn: supplements.weight},\n  single:       {fn: filtering.singleFn},\n  first:        {fn: filtering.firstFn},\n  last:         {fn: filtering.lastFn},\n  type:         {fn: types.typeFn, arity: {0: []}},\n  ofType:       {fn: filtering.ofTypeFn, arity: {1: [\"TypeSpecifier\"]}},\n  is:           {fn: types.isFn, arity: {1: [\"TypeSpecifier\"]}},\n  as:           {fn: types.asFn, arity: {1: [\"TypeSpecifier\"]}},\n  tail:         {fn: filtering.tailFn},\n  take:         {fn: filtering.takeFn, arity: {1: [\"Integer\"]}},\n  skip:         {fn: filtering.skipFn, arity: {1: [\"Integer\"]}},\n  combine:      {fn: combining.combineFn, arity: {1: [\"AnyAtRoot\"]}},\n  union:        {fn: combining.union,   arity: {1: [\"AnyAtRoot\"]}},\n  intersect:    {fn: combining.intersect,   arity: {1: [\"AnyAtRoot\"]}},\n  exclude:      {fn: combining.exclude,   arity: {1: [\"AnyAtRoot\"]}},\n  iif:          {fn: misc.iifMacro,    arity: {2: [\"Expr\", \"Expr\"], 3: [\"Expr\", \"Expr\", \"Expr\"]}},\n  trace:        {fn: misc.traceFn,     arity: {1: [\"String\"], 2: [\"String\", \"Expr\"]}},\n  defineVariable: {fn: misc.defineVariable,     arity: {1: [\"String\"], 2: [\"String\", \"Expr\"]}},\n  toInteger:    {fn: misc.toInteger},\n  toDecimal:    {fn: misc.toDecimal},\n  toString:     {fn: misc.toString},\n  toDate:       {fn: misc.toDate},\n  toDateTime:   {fn: misc.toDateTime},\n  toTime:       {fn: misc.toTime},\n  toBoolean:    {fn: misc.toBoolean},\n  toQuantity:   {fn: misc.toQuantity, arity: {0: [], 1: [\"String\"]}},\n  hasValue:     {fn: misc.hasValueFn},\n  getValue:     {fn: misc.getValueFn},\n  convertsToBoolean:    {fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')},\n  convertsToInteger:    {fn: misc.createConvertsToFn(misc.toInteger, 'number')},\n  convertsToDecimal:    {fn: misc.createConvertsToFn(misc.toDecimal, 'number')},\n  convertsToString:     {fn: misc.createConvertsToFn(misc.toString, 'string')},\n  convertsToDate:       {fn: misc.createConvertsToFn(misc.toDate, FP_Date)},\n  convertsToDateTime:   {fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)},\n  convertsToTime:       {fn: misc.createConvertsToFn(misc.toTime, FP_Time)},\n  convertsToQuantity:   {fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)},\n\n  indexOf:        {fn: strings.indexOf,          arity: {1: [\"String\"]}},\n  substring:      {fn: strings.substring,        arity: {1: [\"Integer\"], 2: [\"Integer\",\"Integer\"]}},\n  startsWith:     {fn: strings.startsWith,       arity: {1: [\"String\"]}},\n  endsWith:       {fn: strings.endsWith,         arity: {1: [\"String\"]}},\n  contains:       {fn: strings.containsFn,       arity: {1: [\"String\"]}},\n  upper:          {fn: strings.upper},\n  lower:          {fn: strings.lower},\n  replace:        {fn: strings.replace,          arity: {2: [\"String\", \"String\"]}},\n  matches:        {fn: strings.matches,          arity: {1: [\"String\"]}},\n  replaceMatches: {fn: strings.replaceMatches,   arity: {2: [\"String\", \"String\"]}},\n  length:         {fn: strings.length },\n  toChars:        {fn: strings.toChars },\n  join:           {fn: strings.joinFn,           arity: {0: [], 1: [\"String\"]}},\n  split:          {fn: strings.splitFn,          arity: {1: [\"String\"]}},\n  trim:           {fn: strings.trimFn},\n\n  encode:         {fn: strings.encodeFn,         arity: {1: [\"String\"]}},\n  decode:         {fn: strings.decodeFn,         arity: {1: [\"String\"]}},\n\n  abs:            {fn: math.abs},\n  ceiling:        {fn: math.ceiling},\n  exp:            {fn: math.exp},\n  floor:          {fn: math.floor},\n  ln:             {fn: math.ln},\n  log:            {fn: math.log, arity:  {1: [\"Number\"]}, nullable: true},\n  power:          {fn: math.power, arity:  {1: [\"Number\"]}, nullable: true},\n  round:          {fn: math.round, arity:  {0: [], 1: [\"Number\"]}},\n  sqrt:           {fn: math.sqrt},\n  truncate:       {fn: math.truncate},\n\n  now:            {fn: datetime.now },\n  today:          {fn: datetime.today },\n  timeOfDay:      {fn: datetime.timeOfDay },\n\n  repeat:          {fn: filtering.repeatMacro, arity: {1: [\"Expr\"]}},\n  children:        {fn: navigation.children },\n  descendants:     {fn: navigation.descendants },\n\n  \"|\":          {fn: combining.union,   arity: {2: [\"Any\", \"Any\"]}},\n  \"=\":          {fn: equality.equal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"!=\":         {fn: equality.unequal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"~\":          {fn: equality.equival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"!~\":         {fn: equality.unequival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"<\":          {fn: equality.lt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">\":          {fn: equality.gt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"<=\":         {fn: equality.lte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">=\":         {fn: equality.gte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"containsOp\": {fn: collections.contains,   arity: {2: [\"Any\", \"Any\"]}},\n  \"inOp\":       {fn: collections.in,  arity: {2: [\"Any\", \"Any\"]}},\n  \"isOp\":       {fn: types.isFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"asOp\":       {fn: types.asFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"&\":          {fn: math.amp,     arity:  {2: [\"String\", \"String\"]}},\n  \"+\":          {fn: math.plus,    arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"-\":          {fn: math.minus,   arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"*\":          {fn: math.mul,     arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"/\":          {fn: math.div,     arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"mod\":        {fn: math.mod,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"div\":        {fn: math.intdiv,  arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n\n  \"or\":        {fn: logic.orOp,  arity:       {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"and\":       {fn: logic.andOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"xor\":       {fn: logic.xorOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"implies\":   {fn: logic.impliesOp,  arity:  {2: [[\"Boolean\"], [\"Boolean\"]]}},\n};\n\nengine.InvocationExpression = function(ctx, parentData, node) {\n  return node.children.reduce(function(acc, ch) {\n    return engine.doEval(ctx, acc, ch);\n  }, parentData);\n};\n\nengine.TermExpression = function(ctx, parentData, node) {\n  if (parentData) {\n    parentData = parentData.map((x) => {\n      if (x instanceof Object && x.resourceType) {\n        return makeResNode(x, null, null, null, null, ctx.model);\n      }\n      return x;\n    });\n  }\n\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\nengine.PolarityExpression = function(ctx, parentData, node) {\n  var sign = node.terminalNodeText[0]; // either - or + per grammar\n  var rtn = engine.doEval(ctx,parentData, node.children[0]);\n  if (rtn.length !== 1) {  // not yet in spec, but per Bryn Rhodes\n    throw new Error('Unary ' + sign +\n     ' can only be applied to an individual number or Quantity.');\n  }\n  if (rtn[0] instanceof FP_Quantity) {\n    if (sign === '-') {\n      rtn[0] = new FP_Quantity(-rtn[0].value, rtn[0].unit);\n    }\n  } else if (typeof rtn[0] === 'number' && !isNaN(rtn[0])) {\n    if (sign === '-') {\n      rtn[0] = -rtn[0];\n    }\n  } else {\n    throw new Error('Unary ' + sign + ' can only be applied to a number or Quantity.');\n  }\n\n  return rtn;\n};\n\nengine.TypeSpecifier = function(ctx, parentData, node) {\n  let namespace, name;\n  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, \"\"));\n  switch (identifiers.length) {\n    case 2:\n      [namespace, name] = identifiers;\n      break;\n    case 1:\n      [name] = identifiers;\n      break;\n    default:\n      throw new Error(\"Expected TypeSpecifier node, got \" + JSON.stringify(node));\n  }\n\n  const typeInfo =  new TypeInfo({ namespace, name });\n  if (!typeInfo.isValid(ctx.model)) {\n    throw new Error('\"' + typeInfo + '\" cannot be resolved to a valid type identifier');\n  }\n  return typeInfo;\n};\n\nengine.ExternalConstantTerm = function(ctx, parentData, node) {\n  let varName;\n  const extConstant = node.children[0];\n  // externalConstant(variable name) is defined in the grammar as:\n  // '%' ( identifier | STRING )\n  if (extConstant.terminalNodeText.length === 2) {\n    // if the variable name is a STRING\n    varName = getStringLiteralVal(extConstant.terminalNodeText[1]);\n  } else {\n    // otherwise, it is an identifier\n    varName = getIdentifierVal(extConstant.children[0].text);\n  }\n\n  let value;\n  // Check the user-defined environment variables first as the user can override\n  // the \"context\" variable like we do in unit tests. In this case, the user\n  // environment variable can replace the system environment variable in \"processedVars\".\n  // If the user-defined environment variable has been processed, we don't need to process it again.\n  if (varName in ctx.vars && !ctx.processedUserVarNames.has(varName)) {\n    // Restore the ResourceNodes for the top-level objects of the environment\n    // variables. The nested objects will be converted to ResourceNodes\n    // in the MemberInvocation method.\n    value = ctx.vars[varName];\n    if (Array.isArray(value)) {\n      value = value.map(\n        i => i?.__path__\n          ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null,\n            i.__path__.fhirNodeDataType, i.__path__.model)\n          : i?.resourceType\n            ? makeResNode(i, null, null, null, null, ctx.model)\n            : i );\n    } else {\n      value = value?.__path__\n        ? makeResNode(value, value.__path__.parentResNode, value.__path__.path, null,\n          value.__path__.fhirNodeDataType, value.__path__.model)\n        : value?.resourceType\n          ? makeResNode(value, null, null, null, null, ctx.model)\n          : value;\n    }\n    ctx.processedVars[varName] = value;\n    ctx.processedUserVarNames.add(varName);\n  } else if (varName in ctx.processedVars) {\n    // \"processedVars\" are variables with ready-to-use values that have already\n    // been converted to ResourceNodes if necessary.\n    value = ctx.processedVars[varName];\n  } else  if (ctx.definedVars && varName in ctx.definedVars) {\n    // \"definedVars\" are variables defined with the \"defineVariable\" function.\n    value = ctx.definedVars[varName];\n  } else {\n    throw new Error(\n      \"Attempting to access an undefined environment variable: \" + varName\n    );\n  }\n  // For convenience, all variable values could be passed in without their array\n  // wrapper.  However, when evaluating, we need to put the array back in.\n  return value === undefined || value === null\n    ? []\n    : value instanceof Array ? value : [value];\n};\n\nengine.LiteralTerm = function(ctx, parentData, node) {\n  var term = node.children[0];\n  if(term){\n    return engine.doEval(ctx, parentData, term);\n  } else {\n    return [node.text];\n  }\n};\n\nengine.StringLiteral = function(ctx, parentData, node) {\n  return [getStringLiteralVal(node.text)];\n};\n\n/**\n * Removes the beginning and ending single-quotes and replaces string escape\n * sequences.\n * @param {string} str - string literal\n * @return {string}\n */\nfunction getStringLiteralVal(str) {\n  return str.replace(/(^'|'$)/g, \"\")\n    .replace(/\\\\(u\\d{4}|.)/g, function(match, submatch) {\n      switch(match) {\n        case '\\\\r':\n          return '\\r';\n        case '\\\\n':\n          return \"\\n\";\n        case '\\\\t':\n          return '\\t';\n        case '\\\\f':\n          return '\\f';\n        default:\n          if (submatch.length > 1)\n            return String.fromCharCode('0x'+submatch.slice(1));\n          else\n            return submatch;\n      }\n    });\n}\n\nengine.BooleanLiteral = function(ctx, parentData, node) {\n  if(node.text  === \"true\") {\n    return [true];\n  } else {\n    return [false];\n  }\n};\n\nengine.QuantityLiteral = function(ctx, parentData, node) {\n  var valueNode = node.children[0];\n  var value = Number(valueNode.terminalNodeText[0]);\n  var unitNode = valueNode.children[0];\n  var unit = unitNode.terminalNodeText[0];\n  // Sometimes the unit is in a child node of the child\n  if (!unit && unitNode.children)\n    unit = unitNode.children[0].terminalNodeText[0];\n\n  return [new FP_Quantity(value, unit)];\n};\n\nengine.DateTimeLiteral = function(ctx, parentData, node) {\n  var dateStr = node.text.slice(1); // Remove the @\n  return [new FP_DateTime(dateStr)];\n};\n\nengine.TimeLiteral = function(ctx, parentData, node) {\n  var timeStr = node.text.slice(1); // Remove the @\n  return [new FP_Time(timeStr)];\n};\n\nengine.NumberLiteral = function(ctx, parentData, node) {\n  return [Number(node.text)];\n};\n\nengine.Identifier = function(ctx, parentData, node) {\n  return [getIdentifierVal(node.text)];\n};\n\n/**\n * Removes the beginning and ending back-quotes.\n * @param {string} str - identifier string\n * @return {string}\n */\nfunction getIdentifierVal(str) {\n  return str.replace(/(^`|`$)/g, \"\");\n}\n\nengine.InvocationTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\n\nengine.MemberInvocation = function(ctx, parentData, node ) {\n  const key = engine.doEval(ctx, parentData, node.children[0])[0];\n  const model = ctx.model;\n\n  if (parentData) {\n    return parentData.reduce(function(acc, res) {\n      res = makeResNode(res, null, res.__path__?.path, null,\n        res.__path__?.fhirNodeDataType, model);\n      if (res.data?.resourceType === key) {\n        acc.push(res);\n      } else {\n        util.pushFn(acc, util.makeChildResNodes(res, key, model));\n      }\n      return acc;\n    }, []);\n  } else {\n    return [];\n  }\n};\n\nengine.IndexerExpression = function(ctx, parentData, node) {\n  const coll_node = node.children[0];\n  const idx_node = node.children[1];\n  var coll = engine.doEval(ctx, parentData, coll_node);\n  var idx = engine.doEval(ctx, parentData, idx_node);\n\n  if(util.isEmpty(idx)) {\n    return [];\n  }\n\n  var idxNum = parseInt(idx[0]);\n  if(coll && util.isSome(idxNum) && coll.length>idxNum && idxNum>=0) {\n    return [coll[idxNum]];\n  } else {\n    return [];\n  }\n};\n\nengine.Functn = function(ctx, parentData, node) {\n  return node.children.map(function(x) {\n    return engine.doEval(ctx, parentData, x);\n  });\n};\n\nengine.realizeParams = function(ctx, parentData, args) {\n  if(args && args[0] && args[0].children) {\n    return args[0].children.map(function(x) {\n      return engine.doEval(ctx, parentData, x);\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction makeParam(ctx, parentData, type, param) {\n  if(type === \"Expr\"){\n    return function(data) {\n      const $this = util.arraify(data);\n      let ctxExpr = { ...ctx, $this };\n      if (ctx.definedVars) {\n        // Each parameter subexpression needs its own set of defined variables\n        // (cloned from the parent context). This way, the changes to the variables\n        // are isolated in the subexpression.\n        ctxExpr.definedVars = {...ctx.definedVars};\n      }\n      return engine.doEval(ctxExpr, $this, param);\n    };\n  }\n  if(type === \"AnyAtRoot\"){\n    const $this = ctx.$this || ctx.dataRoot;\n    let ctxExpr = { ...ctx, $this};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    return engine.doEval(ctxExpr, $this, param);\n  }\n  if(type === \"Identifier\"){\n    if(param.type === \"TermExpression\") {\n      return param.text;\n    } else {\n      throw new Error(\"Expected identifier node, got \" + JSON.stringify(param));\n    }\n  }\n\n  if(type === \"TypeSpecifier\") {\n    return engine.TypeSpecifier(ctx, parentData, param);\n  }\n\n  let res;\n  if(type === 'AnySingletonAtRoot'){\n    const $this = ctx.$this || ctx.dataRoot;\n    let ctxExpr = { ...ctx, $this};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    res = engine.doEval(ctxExpr, $this, param);\n  } else {\n    let ctxExpr = {...ctx};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    res = engine.doEval(ctxExpr, parentData, param);\n    if (type === \"Any\") {\n      return res;\n    }\n    if (Array.isArray(type)) {\n      if (res.length === 0) {\n        return [];\n      } else {\n        type = type[0];\n      }\n    }\n  }\n\n  return res instanceof Promise ?\n    res.then(r => misc.singleton(r, type)) :\n    misc.singleton(res, type);\n}\n\nfunction doInvoke(ctx, fnName, data, rawParams){\n  var invoc =\n    ctx.userInvocationTable\n    && Object.prototype.hasOwnProperty.call(ctx.userInvocationTable, fnName)\n    && ctx.userInvocationTable?.[fnName]\n    || engine.invocationTable[fnName]\n    || data.length === 1 && data[0]?.invocationTable?.[fnName];\n  var res;\n  if(invoc) {\n    if(!invoc.arity){\n      if(!rawParams){\n        res = invoc.fn.call(ctx, data);\n        return util.resolveAndArraify(res);\n      } else {\n        throw new Error(fnName + \" expects no params\");\n      }\n    } else {\n      var paramsNumber = rawParams ? rawParams.length : 0;\n      var argTypes = invoc.arity[paramsNumber];\n      if(argTypes){\n        var params = [];\n        for(var i = 0; i < paramsNumber; i++){\n          var tp = argTypes[i];\n          var pr = rawParams[i];\n          params.push(makeParam(ctx, data, tp, pr));\n        }\n        params.unshift(data);\n        if(invoc.nullable) {\n          if(params.some(isNullable)){\n            return [];\n          }\n        }\n        if (params.some(p => p instanceof Promise)) {\n          return Promise.all(params).then(p => {\n            res = invoc.fn.apply(ctx, p);\n            return util.resolveAndArraify(res);\n          });\n        }\n        res = invoc.fn.apply(ctx, params);\n        return util.resolveAndArraify(res);\n      } else {\n        console.log(fnName + \" wrong arity: got \" + paramsNumber );\n        return [];\n      }\n    }\n  } else {\n    throw new Error(\"Not implemented: \" + fnName);\n  }\n}\nfunction isNullable(x) {\n  return x === null || x === undefined || util.isEmpty(x);\n}\n\nfunction infixInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  if(invoc && invoc.fn) {\n    var paramsNumber = rawParams ? rawParams.length : 0;\n    if(paramsNumber !== 2) { throw new Error(\"Infix invoke should have arity 2\"); }\n    var argTypes = invoc.arity[paramsNumber];\n    if(argTypes){\n      var params = [];\n      for(var i = 0; i < paramsNumber; i++){\n        var tp = argTypes[i];\n        var pr = rawParams[i];\n        params.push(makeParam(ctx, data, tp, pr));\n      }\n      if(invoc.nullable) {\n        if(params.some(isNullable)){\n          return [];\n        }\n      }\n      if (params.some(p => p instanceof Promise)) {\n        return Promise.all(params).then(p => {\n          var res = invoc.fn.apply(ctx, p);\n          return util.arraify(res);\n        });\n      }\n      var res = invoc.fn.apply(ctx, params);\n      return util.arraify(res);\n    } else {\n      console.log(fnName + \" wrong arity: got \" + paramsNumber );\n      return [];\n    }\n  } else {\n    throw new Error(\"Not impl \" + fnName);\n  }\n}\n\nengine.FunctionInvocation = function(ctx, parentData, node) {\n  var args = engine.doEval(ctx, parentData, node.children[0]);\n  const fnName = args[0];\n  args.shift();\n  var rawParams = args && args[0] && args[0].children;\n  return doInvoke(ctx, fnName, parentData, rawParams);\n};\n\nengine.ParamList = function(ctx, parentData, node) {\n  // we do not eval param list because sometimes it should be passed as\n  // lambda/macro (for example in case of where(...)\n  return node;\n};\n\n\nengine.UnionExpression = function(ctx, parentData, node) {\n  return infixInvoke(ctx, '|', parentData, node.children);\n};\n\nengine.ThisInvocation = function(ctx) {\n  return ctx.$this;\n};\n\nengine.TotalInvocation = function(ctx) {\n  return util.arraify(ctx.$total);\n};\n\nengine.IndexInvocation = function(ctx) {\n  return util.arraify(ctx.$index);\n};\n\nengine.OpExpression = function(ctx, parentData, node) {\n  var op = node.terminalNodeText[0];\n  return infixInvoke(ctx, op, parentData, node.children);\n};\n\nengine.AliasOpExpression = function(map){\n  return function(ctx, parentData, node) {\n    var op = node.terminalNodeText[0];\n    var alias = map[op];\n    if(!alias) { throw new Error(\"Do not know how to alias \" + op + \" by \" + JSON.stringify(map)); }\n    return infixInvoke(ctx, alias, parentData, node.children);\n  };\n};\n\nengine.NullLiteral = function() {\n  return [];\n};\n\nengine.ParenthesizedTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\n\nengine.evalTable = { // not every evaluator is listed if they are defined on engine\n  BooleanLiteral: engine.BooleanLiteral,\n  EqualityExpression: engine.OpExpression,\n  FunctionInvocation: engine.FunctionInvocation,\n  Functn: engine.Functn,\n  Identifier: engine.Identifier,\n  IndexerExpression: engine.IndexerExpression,\n  InequalityExpression: engine.OpExpression,\n  InvocationExpression: engine.InvocationExpression,\n  AdditiveExpression: engine.OpExpression,\n  MultiplicativeExpression: engine.OpExpression,\n  TypeExpression: engine.AliasOpExpression({\"is\": \"isOp\", \"as\": \"asOp\"}),\n  MembershipExpression: engine.AliasOpExpression({\"contains\": \"containsOp\", \"in\": \"inOp\"}),\n  NullLiteral: engine.NullLiteral,\n  EntireExpression: engine.InvocationTerm,\n  InvocationTerm: engine.InvocationTerm,\n  LiteralTerm: engine.LiteralTerm,\n  MemberInvocation: engine.MemberInvocation,\n  NumberLiteral: engine.NumberLiteral,\n  ParamList: engine.ParamList,\n  ParenthesizedTerm: engine.ParenthesizedTerm,\n  StringLiteral: engine.StringLiteral,\n  TermExpression: engine.TermExpression,\n  ThisInvocation: engine.ThisInvocation,\n  TotalInvocation: engine.TotalInvocation,\n  IndexInvocation: engine.IndexInvocation,\n  UnionExpression: engine.UnionExpression,\n  OrExpression: engine.OpExpression,\n  ImpliesExpression: engine.OpExpression,\n  AndExpression: engine.OpExpression,\n  XorExpression: engine.OpExpression\n};\n\n\nengine.doEval = function(ctx, parentData, node) {\n  if (parentData instanceof Promise) {\n    return parentData.then(p => engine.doEvalSync(ctx, p, node));\n  } else {\n    return  engine.doEvalSync(ctx, parentData, node);\n  }\n};\n\nengine.doEvalSync = function(ctx, parentData, node) {\n  const evaluator = engine.evalTable[node.type] || engine[node.type];\n  if(evaluator){\n    return evaluator.call(engine, ctx, parentData, node);\n  } else {\n    throw new Error(\"No \" + node.type + \" evaluator \");\n  }\n};\n\nfunction parse(path) {\n  return parser.parse(path);\n}\n\n\n/**\n *  Applies the given parsed FHIRPath expression to the given resource,\n *  returning the result of doEval.\n * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources\n *  This resource will be modified by this function to add type information.\n * @param {object} parsedPath - a special object created by the parser that describes the structure of a fhirpath expression.\n * @param {object} envVars - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} options - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception;\n *  true or similar to true - return Promise only for asynchronous functions;\n *  \"always\" - return Promise always.\n * @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you\n *   to abort the asynchronous FHIRPath expression evaluation.\n */\nfunction applyParsedPath(resource, parsedPath, envVars, model, options) {\n  constants.reset();\n  let dataRoot = util.arraify(resource).map(\n    i => i?.__path__\n      ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null,\n        i.__path__.fhirNodeDataType, model)\n      : i?.resourceType\n        ? makeResNode(i, null, null, null, null, model)\n        : i);\n  // doEval takes a \"ctx\" object, and we store things in that as we parse, so we\n  // need to put user-provided variable data in a sub-object, ctx.vars.\n  // Set up default standard variables, and allow override from the variables.\n  // However, we'll keep our own copy of dataRoot for internal processing.\n  let ctx = {\n    dataRoot,\n    processedVars: {\n      ucum: 'http://unitsofmeasure.org',\n      context: dataRoot\n    },\n    processedUserVarNames: new Set(),\n    vars: envVars || {},\n    model\n  };\n  if (options.traceFn) {\n    ctx.customTraceFn = options.traceFn;\n  }\n  if (options.userInvocationTable) {\n    ctx.userInvocationTable = options.userInvocationTable;\n  }\n  if (options.async) {\n    ctx.async = options.async;\n  }\n  if (options.terminologyUrl) {\n    ctx.processedVars.terminologies = new Terminologies(options.terminologyUrl);\n  }\n  ctx.processedVars.factory = Factory;\n  if (options.signal) {\n    ctx.signal = options.signal;\n    if (!ctx.async) {\n      throw new Error(\n        'The \"signal\" option is only supported for asynchronous functions.');\n    }\n    if (ctx.signal.aborted) {\n      throw new Error(\n        'Evaluation of the expression was aborted before it started.');\n    }\n  }\n  const res = engine.doEval(ctx, dataRoot, parsedPath.children[0]);\n  return res instanceof Promise\n    ? res.then(r => {\n      if (ctx.signal?.aborted) {\n        return Promise.reject(new DOMException(\n          'Evaluation of the expression was aborted.', 'AbortError'));\n      } else {\n        return prepareEvalResult(r, model, options);\n      }\n    })\n    : options.async === 'always'\n      ? Promise.resolve(prepareEvalResult(res, model, options))\n      : prepareEvalResult(res, model, options);\n}\n\n/**\n * Prepares the result after evaluating an expression.\n * engine.doEval returns array of \"ResourceNode\" and/or \"FP_Type\" instances.\n * \"ResourceNode\" or \"FP_Type\" instances are not created for sub-items.\n * Resolves any internal \"ResourceNode\" instances to plain objects and if\n * options.resolveInternalTypes is true, resolve any internal \"FP_Type\"\n * instances to strings.\n * @param {Array} result - result of expression evaluation.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n * @param {object} options - additional options (see function \"applyParsedPath\").\n * @return {Array}\n */\nfunction prepareEvalResult(result, model, options) {\n  return result\n    .reduce((acc, n) => {\n      // Path for the data extracted from the resource.\n      let path;\n      let fhirNodeDataType;\n      let parentResNode;\n      if (n instanceof ResourceNode) {\n        path = n.path;\n        fhirNodeDataType = n.fhirNodeDataType;\n        parentResNode = n.parentResNode;\n      }\n      n = util.valData(n);\n      if (n instanceof FP_Type) {\n        if (options.resolveInternalTypes) {\n          n = n.toString();\n        }\n      }\n      // Exclude nulls\n      if (n != null) {\n        // Add a hidden (non-enumerable) property with the path to the data extracted\n        // from the resource.\n        if (path && typeof n === 'object' && !n.__path__) {\n          Object.defineProperty(n, '__path__', { value: {path, fhirNodeDataType, parentResNode, model} });\n        }\n        acc.push(n);\n      }\n      return acc;\n    }, []);\n}\n\n/**\n * Resolves any internal \"FP_Type\" instances in a result of FHIRPath expression\n * evaluation to standard JavaScript types.\n * @param {any} val - a result of FHIRPath expression evaluation\n * @returns {any} a new object with resolved values.\n */\nfunction resolveInternalTypes(val) {\n  if (Array.isArray(val)) {\n    for (let i=0, len=val.length; i<len; ++i)\n      val[i] = resolveInternalTypes(val[i]);\n  }\n  else if (val instanceof FP_Type) {\n    val = val.toString();\n  }\n  else if (typeof val === 'object') {\n    for (let k of Object.keys(val))\n      val[k] = resolveInternalTypes(val[k]);\n  }\n  return val;\n}\n\n/**\n *  Evaluates the \"path\" FHIRPath expression on the given resource or part of the resource,\n *  using data from \"context\" for variables mentioned in the \"path\" expression.\n * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case\n *  path.base should be provided), bundle as js object or array of resources.\n *  This object/array will be modified by this function to add type information.\n * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',\n *  or object, if fhirData represents the part of the FHIR resource:\n * @param {string} path.base - base path in resource from which fhirData was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} [envVars] - a hash of variable name/value pairs.\n * @param {object} [model] - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to standard JavaScript types (true by default).\n *  If false is passed, this conversion can be done later by calling\n *  resolveInternalTypes().\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,\n *  true or similar to true - return Promise, only for asynchronous functions,\n *  \"always\" - return Promise always.\n * @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you\n *   to abort the asynchronous FHIRPath expression evaluation.\n */\nfunction evaluate(fhirData, path, envVars, model, options) {\n  return compile(path, model, options)(fhirData, envVars);\n}\n\n/**\n *  Returns a function that takes a resource or part of the resource and an\n *  optional context hash (see \"evaluate\"), and returns the result of evaluating\n *  the given FHIRPath expression on that resource.  The advantage of this\n *  function over \"evaluate\" is that if you have multiple resources, the given\n *  FHIRPath expression will only be parsed once.\n * @param {string|object} path - string with FHIRPath expression to be parsed or object:\n * @param {string} path.base - base path in resource from which a part of\n *   the resource was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} [model] - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,\n *  true or similar to true - return Promise, only for asynchronous functions,\n *  \"always\" - return Promise always.\n * @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you\n *   to abort the asynchronous FHIRPath expression evaluation. Passing a signal\n *   to compile() whose result is used more than once will cause abortion\n *   problems.\n */\nfunction compile(path, model, options) {\n  options = {\n    resolveInternalTypes: true,\n    ... options\n  };\n\n  const userInvocationTable = options.userInvocationTable;\n  if (userInvocationTable) {\n    options.userInvocationTable = Object.keys(userInvocationTable).reduce(\n      (invocationTable, fnName) => {\n        if (userInvocationTable[fnName].internalStructures) {\n          invocationTable[fnName] = userInvocationTable[fnName];\n        } else {\n          invocationTable[fnName] = {\n            ...userInvocationTable[fnName],\n            fn: (...args) => {\n              return userInvocationTable[fnName].fn.apply(\n                // When we check Array.isArray(arg), we are checking if the\n                // singleton function has been called. An alternative to this is\n                // to check that the type of the argument is Integer, Boolean,\n                // Number, or String.\n                this, args.map(arg => Array.isArray(arg) ? arg.map(item => util.valData(item)) : arg)\n              );\n            }\n          };\n        }\n        return invocationTable;\n      }, {});\n  }\n\n  if (typeof path === 'object') {\n    const node = parse(path.expression);\n    return function (fhirData, envVars, additionalOptions) {\n      if (path.base) {\n        let basePath = model.pathsDefinedElsewhere[path.base] || path.base;\n        const baseFhirNodeDataType = model && model.path2Type[basePath];\n        basePath = baseFhirNodeDataType === 'BackboneElement' || baseFhirNodeDataType === 'Element' ? basePath : baseFhirNodeDataType || basePath;\n\n        fhirData = makeResNode(fhirData, null, basePath, null, baseFhirNodeDataType, model);\n      }\n      const actualOptions = additionalOptions ?\n        {...options, ...additionalOptions} : options;\n      return applyParsedPath(fhirData, node, envVars, model, actualOptions);\n    };\n  } else {\n    const node = parse(path);\n    return function (fhirData, envVars, additionalOptions) {\n      const actualOptions = additionalOptions ?\n        {...options, ...additionalOptions} : options;\n      return applyParsedPath(fhirData, node, envVars, model, actualOptions);\n    };\n  }\n}\n\n/**\n * Returns the type of each element in fhirpathResult array which was obtained\n * from evaluate() with option resolveInternalTypes=false.\n * @param {any} fhirpathResult - a result of FHIRPath expression evaluation.\n * @returns {string[]} an array of types, e.g. ['FHIR.Quantity', 'FHIR.date', 'System.String'].\n */\nfunction typesFn(fhirpathResult) {\n  return util.arraify(fhirpathResult).map(value => {\n    const ti = TypeInfo.fromValue(\n      value?.__path__\n        ? new ResourceNode(value, value.__path__?.parentResNode,\n          value.__path__?.path, null, value.__path__?.fhirNodeDataType, value.__path__.model)\n        : value );\n    return `${ti.namespace}.${ti.name}`;\n  });\n}\n\nmodule.exports = {\n  version,\n  parse,\n  compile,\n  evaluate,\n  resolveInternalTypes,\n  types: typesFn,\n  // Might as well export the UCUM library, since we are using it.\n  ucumUtils: (__webpack_require__(/*! @lhncbc/ucum-lhc */ \"(ssr)/../node_modules/.pnpm/@lhncbc+ucum-lhc@5.0.4/node_modules/@lhncbc/ucum-lhc/source-cjs/ucumPkg.js\").UcumLhcUtils).getInstance(),\n  // Utility functions that can be used to implement custom functions\n  util\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2ZoaXJwYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx1R0FBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHVHQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxtQkFBTyxDQUFDLHFHQUFZO0FBQ3BCLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhOztBQUV2QyxvQkFBb0I7QUFDcEIsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQWE7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMseUhBQXNCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDZGQUFRO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLDJHQUFlO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDZGQUFRO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLHlHQUFjO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQywrRkFBUztBQUM5QixjQUFjLG1CQUFPLENBQUMsK0ZBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsK0dBQWlCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0NBQWtDLGdCQUFnQjtBQUNuRSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLG1DQUFtQyxvQkFBb0I7QUFDeEUsaUJBQWlCLGdDQUFnQyxhQUFhO0FBQzlELGlCQUFpQix3QkFBd0I7QUFDekMsaUJBQWlCLHdCQUF3QjtBQUN6QyxpQkFBaUIseUJBQXlCO0FBQzFDLGlCQUFpQix5QkFBeUI7QUFDMUMsaUJBQWlCLGtDQUFrQyxrQkFBa0I7QUFDckUsaUJBQWlCLG9DQUFvQyxrQkFBa0I7QUFDdkUsaUJBQWlCLDJCQUEyQjtBQUM1QyxpQkFBaUIseUJBQXlCO0FBQzFDLGlCQUFpQixzQkFBc0I7QUFDdkMsaUJBQWlCLGtDQUFrQyxhQUFhO0FBQ2hFLGlCQUFpQixpQ0FBaUMsZUFBZTtBQUNqRSxpQkFBaUIsbUNBQW1DLGFBQWE7QUFDakUsaUJBQWlCLHNDQUFzQyx1Q0FBdUM7QUFDOUYsaUJBQWlCLG9CQUFvQjtBQUNyQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLG9CQUFvQjtBQUNyQyxpQkFBaUIsdUJBQXVCO0FBQ3hDLGlCQUFpQix1QkFBdUI7QUFDeEMsaUJBQWlCLHVCQUF1QjtBQUN4QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQixxQkFBcUI7QUFDdEMsaUJBQWlCLDBCQUEwQixPQUFPO0FBQ2xELGlCQUFpQixnQ0FBZ0Msc0JBQXNCO0FBQ3ZFLGlCQUFpQix3QkFBd0Isc0JBQXNCO0FBQy9ELGlCQUFpQix3QkFBd0Isc0JBQXNCO0FBQy9ELGlCQUFpQixxQkFBcUI7QUFDdEMsaUJBQWlCLDhCQUE4QixnQkFBZ0I7QUFDL0QsaUJBQWlCLDhCQUE4QixnQkFBZ0I7QUFDL0QsaUJBQWlCLGlDQUFpQyxrQkFBa0I7QUFDcEUsaUJBQWlCLCtCQUErQixrQkFBa0I7QUFDbEUsaUJBQWlCLG1DQUFtQyxrQkFBa0I7QUFDdEUsaUJBQWlCLGlDQUFpQyxrQkFBa0I7QUFDcEUsaUJBQWlCLDhCQUE4QixrREFBa0Q7QUFDakcsaUJBQWlCLDhCQUE4QixzQ0FBc0M7QUFDckYsbUJBQW1CLHFDQUFxQyxzQ0FBc0M7QUFDOUYsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUIsbUJBQW1CO0FBQ3BDLGlCQUFpQixrQkFBa0I7QUFDbkMsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUIsNkJBQTZCLHNCQUFzQjtBQUNwRSxpQkFBaUIsb0JBQW9CO0FBQ3JDLGlCQUFpQixvQkFBb0I7QUFDckMseUJBQXlCLHVEQUF1RDtBQUNoRix5QkFBeUIsc0RBQXNEO0FBQy9FLHlCQUF5QixzREFBc0Q7QUFDL0UseUJBQXlCLHFEQUFxRDtBQUM5RSx5QkFBeUIsa0RBQWtEO0FBQzNFLHlCQUF5QiwwREFBMEQ7QUFDbkYseUJBQXlCLGtEQUFrRDtBQUMzRSx5QkFBeUIsMERBQTBEOztBQUVuRixtQkFBbUIsc0NBQXNDLGVBQWU7QUFDeEUsbUJBQW1CLHNDQUFzQywwQ0FBMEM7QUFDbkcsbUJBQW1CLHNDQUFzQyxlQUFlO0FBQ3hFLG1CQUFtQixzQ0FBc0MsZUFBZTtBQUN4RSxtQkFBbUIsc0NBQXNDLGVBQWU7QUFDeEUsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixzQ0FBc0MseUJBQXlCO0FBQ2xGLG1CQUFtQixzQ0FBc0MsZUFBZTtBQUN4RSxtQkFBbUIsc0NBQXNDLHlCQUF5QjtBQUNsRixtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixxQkFBcUI7QUFDeEMsbUJBQW1CLHNDQUFzQyxzQkFBc0I7QUFDL0UsbUJBQW1CLHNDQUFzQyxlQUFlO0FBQ3hFLG1CQUFtQixtQkFBbUI7O0FBRXRDLG1CQUFtQixzQ0FBc0MsZUFBZTtBQUN4RSxtQkFBbUIsc0NBQXNDLGVBQWU7O0FBRXhFLG1CQUFtQixhQUFhO0FBQ2hDLG1CQUFtQixpQkFBaUI7QUFDcEMsbUJBQW1CLGFBQWE7QUFDaEMsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CLHVCQUF1QixjQUFjLGlCQUFpQjtBQUN6RSxtQkFBbUIseUJBQXlCLGNBQWMsaUJBQWlCO0FBQzNFLG1CQUFtQix5QkFBeUIsc0JBQXNCO0FBQ2xFLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixrQkFBa0I7O0FBRXJDLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsd0JBQXdCOztBQUUzQyxvQkFBb0IsbUNBQW1DLGFBQWE7QUFDcEUsb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IsNEJBQTRCOztBQUVoRCxpQkFBaUIsK0JBQStCLG1CQUFtQjtBQUNuRSxpQkFBaUIsOEJBQThCLGtCQUFrQixpQkFBaUI7QUFDbEYsaUJBQWlCLGdDQUFnQyxrQkFBa0IsaUJBQWlCO0FBQ3BGLGlCQUFpQixnQ0FBZ0MsbUJBQW1CO0FBQ3BFLGlCQUFpQixrQ0FBa0MsbUJBQW1CO0FBQ3RFLGlCQUFpQiwyQkFBMkIsa0JBQWtCLGlCQUFpQjtBQUMvRSxpQkFBaUIsMkJBQTJCLGtCQUFrQixpQkFBaUI7QUFDL0UsaUJBQWlCLDJCQUEyQixrQkFBa0IsaUJBQWlCO0FBQy9FLGlCQUFpQiwyQkFBMkIsa0JBQWtCLGlCQUFpQjtBQUMvRSxpQkFBaUIsb0NBQW9DLG1CQUFtQjtBQUN4RSxpQkFBaUIsNkJBQTZCLG1CQUFtQjtBQUNqRSxpQkFBaUIseUJBQXlCLDZCQUE2QjtBQUN2RSxpQkFBaUIseUJBQXlCLDZCQUE2QjtBQUN2RSxpQkFBaUIsMkJBQTJCLHlCQUF5QjtBQUNyRSxpQkFBaUIsMkJBQTJCLGtCQUFrQixpQkFBaUI7QUFDL0UsaUJBQWlCLDJCQUEyQixrQkFBa0IsaUJBQWlCO0FBQy9FLGlCQUFpQiwyQkFBMkIsa0JBQWtCLGlCQUFpQjtBQUMvRSxpQkFBaUIsMkJBQTJCLGtCQUFrQixpQkFBaUI7QUFDL0UsaUJBQWlCLDJCQUEyQix3QkFBd0IsaUJBQWlCO0FBQ3JGLGlCQUFpQiwyQkFBMkIsd0JBQXdCLGlCQUFpQjs7QUFFckYsZ0JBQWdCLCtCQUErQiwrQkFBK0I7QUFDOUUsZ0JBQWdCLCtCQUErQiwrQkFBK0I7QUFDOUUsZ0JBQWdCLCtCQUErQiwrQkFBK0I7QUFDOUUsZ0JBQWdCLCtCQUErQiwrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkUsa0RBQWtELHVDQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSwrQ0FBK0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtDQUFrQztBQUMzQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxHQUFHLFFBQVE7QUFDdEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9LQUF3QztBQUNyRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2ZoaXJwYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaXMgZmhpcnBhdGggaW50ZXJwcmV0ZXJcbi8vIGV2ZXJ5dGhpbmcgc3RhcnRzIGF0IGV2YWx1YXRlIGZ1bmN0aW9uLFxuLy8gd2hpY2ggaXMgcGFzc2VkICBmaGlycGF0aCBBU1QgYW5kIHJlc291cmNlLlxuLy9cbi8vIFdlIHJlZHVjZS9ldmFsIHJlY3Vyc2l2ZWx5IGVhY2ggbm9kZSBpbiBBU1Rcbi8vIHBhc3NpbmcgdGhlIGNvbnRleHQgYW5kIGN1cnJlbnQgZGF0YVxuLy9cbi8vIGVhY2ggQVNUIG5vZGUgaGFzIGV2YWwgZnVuY3Rpb24sIHdoaWNoIHNob3VsZCBiZSByZWdpc3RlcmVkIGluIGV2YWxUYWJsZVxuLy8gYW5kIG5hbWVkIGFmdGVyIG5vZGUgdHlwZVxuLy8gaWYgbm9kZSBuZWVkcyB0byBldmFsIGZhdGhlciBpdCdzIGNoaWxkcmVuIGl0IGhhcyB0byBjYWxsIGBkb0V2YWxgIGZ1bmN0aW9uXG4vL1xuLy8gbW9zdCBvZiBub2RlcyBkbyBmdW5jdGlvbiBvciBvcGVyYXRvciBpbnZvY2F0aW9uIGF0IHRoZSBlbmRcbi8vXG4vLyBGb3IgaW52b2NhdGlvbidzIGFuZCBvcGVyYXRvcidzIHRoZXJlIGlzIG9uZSBsb29rdXAgdGFibGUgLVxuLy8gaW52b2NhdGlvblRhYmxlIGFuZCB0d28gaGVscGVyIGZ1bmN0aW9ucyBkb0ludm9rZSBhbmQgaW5maXhJbnZva2UgZm9yXG4vLyBvcGVyYXRvcnNcbi8vIDEuIG9wZXJhdG9yIG9yIGZ1bmN0aW9uIGlzIGxvb2tlZCB1cCBpbiB0YWJsZVxuLy8gMi4gdXNpbmcgc2lnbmF0dXJlIChpbiAgLmFyaXR5IHByb3BlcnR5KSB1bnBhY2sgcGFyYW1ldGVyc1xuLy8gMy4gY2hlY2sgcGFyYW1zIHR5cGVzXG4vLyA0LiBkbyBjYWxsIGZ1bmN0aW9uXG4vLyA1LiB3cmFwIHJlc3VsdCBieSB1dGlsLmFycmFpZnlcbi8vXG4vLyBpZiBmdW5jdGlvbiBpcyBudWxsYWJsZVxuLy8gYW5kIG9uZSBvZiBwYXJhbWV0ZXJzIGlzIGVtcHR5L251bGwgLSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGFuZCBlbXB0eVxuLy8gcmVzdWx0IHJldHVybmVkXG4vL1xuLy8gTm90IHNvbHZlZCBwcm9ibGVtIGlzIG92ZXJsb2FkaW5nIGZ1bmN0aW9ucyBieSB0eXBlcyAtIGZvciBleGFtcGxlICsgb3BlcmF0b3IgZGVmaW5lZFxuLy8gZm9yIHN0cmluZ3MgYW5kIG51bWJlcnNcbi8vIHdlIGNhbiBtYWtlIGRpc3BhdGNoaW5nIHBhcmFtcyB0eXBlIGRlcGVuZGVudCAtIGxldCBzZWVcblxuY29uc3Qge3ZlcnNpb259ID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xucmVxdWlyZShcIi4vcG9seWZpbGxcIik7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5sZXQgZW5naW5lICAgID0ge307IC8vIHRoZSBvYmplY3Qgd2l0aCBhbGwgRkhJUlBhdGggZnVuY3Rpb25zIGFuZCBvcGVyYXRpb25zXG5sZXQgZXhpc3RlbmNlID0gcmVxdWlyZShcIi4vZXhpc3RlbmNlXCIpO1xubGV0IGZpbHRlcmluZyA9IHJlcXVpcmUoXCIuL2ZpbHRlcmluZ1wiKTtcbmxldCBhZ2dyZWdhdGUgPSByZXF1aXJlKFwiLi9hZ2dyZWdhdGVcIik7XG5sZXQgc3VwcGxlbWVudHMgPSByZXF1aXJlKFwiLi9zZGMtaWctc3VwcGxlbWVudHNcIik7XG5sZXQgY29tYmluaW5nID0gcmVxdWlyZShcIi4vY29tYmluaW5nXCIpO1xubGV0IG1pc2MgICAgICA9IHJlcXVpcmUoXCIuL21pc2NcIik7XG5sZXQgZXF1YWxpdHkgID0gcmVxdWlyZShcIi4vZXF1YWxpdHlcIik7XG5sZXQgY29sbGVjdGlvbnMgID0gcmVxdWlyZShcIi4vY29sbGVjdGlvbnNcIik7XG5sZXQgbWF0aCAgICAgID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbmxldCBzdHJpbmdzICAgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xubGV0IG5hdmlnYXRpb249IHJlcXVpcmUoXCIuL25hdmlnYXRpb25cIik7XG5sZXQgZGF0ZXRpbWUgID0gcmVxdWlyZShcIi4vZGF0ZXRpbWVcIik7XG5sZXQgYWRkaXRpb25hbCAgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsXCIpO1xubGV0IGxvZ2ljICA9IHJlcXVpcmUoXCIuL2xvZ2ljXCIpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHtcbiAgRlBfRGF0ZSwgRlBfRGF0ZVRpbWUsIEZQX1RpbWUsIEZQX1F1YW50aXR5LFxuICBGUF9UeXBlLCBSZXNvdXJjZU5vZGUsIFR5cGVJbmZvXG59ID0gdHlwZXM7XG5sZXQgbWFrZVJlc05vZGUgPSBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGU7XG5jb25zdCBUZXJtaW5vbG9naWVzID0gcmVxdWlyZSgnLi90ZXJtaW5vbG9naWVzJyk7XG5jb25zdCBGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3J5Jyk7XG5cbi8vICogZm46IGhhbmRsZXJcbi8vICogYXJpdHk6IGlzIGluZGV4IG1hcCB3aXRoIHR5cGUgc2lnbmF0dXJlXG4vLyAgIGlmIHR5cGUgaXMgaW4gYXJyYXkgKGxpa2UgW0Jvb2xlYW5dKSAtIHRoaXMgbWVhbnNcbi8vICAgZnVuY3Rpb24gYWNjZXB0cyB2YWx1ZSBvZiB0aGlzIHR5cGUgb3IgZW1wdHkgdmFsdWUge31cbi8vICogbnVsbGFibGU6ICBtZWFucyBwcm9wYWdhdGUgZW1wdHkgcmVzdWx0LCBpLmUuIGluc3RlYWRcbi8vICAgY2FsbGluZyBmdW5jdGlvbiBpZiBvbmUgb2YgcGFyYW1zIGlzICBlbXB0eSByZXR1cm4gZW1wdHlcblxuZW5naW5lLmludm9jYXRpb25UYWJsZSA9IHtcbiAgbWVtYmVyT2Y6ICAgICB7Zm46IGFkZGl0aW9uYWwubWVtYmVyT2YsIGFyaXR5OiB7IDE6IFsnU3RyaW5nJ119IH0sXG4gIGVtcHR5OiAgICAgICAge2ZuOiBleGlzdGVuY2UuZW1wdHlGbn0sXG4gIG5vdDogICAgICAgICAge2ZuOiBleGlzdGVuY2Uubm90Rm59LFxuICBleGlzdHM6ICAgICAgIHtmbjogZXhpc3RlbmNlLmV4aXN0c01hY3JvLCBhcml0eTogezA6IFtdLCAxOiBbXCJFeHByXCJdfX0sXG4gIGFsbDogICAgICAgICAge2ZuOiBleGlzdGVuY2UuYWxsTWFjcm8sIGFyaXR5OiB7MTogW1wiRXhwclwiXX19LFxuICBhbGxUcnVlOiAgICAgIHtmbjogZXhpc3RlbmNlLmFsbFRydWVGbn0sXG4gIGFueVRydWU6ICAgICAge2ZuOiBleGlzdGVuY2UuYW55VHJ1ZUZufSxcbiAgYWxsRmFsc2U6ICAgICB7Zm46IGV4aXN0ZW5jZS5hbGxGYWxzZUZufSxcbiAgYW55RmFsc2U6ICAgICB7Zm46IGV4aXN0ZW5jZS5hbnlGYWxzZUZufSxcbiAgc3Vic2V0T2Y6ICAgICB7Zm46IGV4aXN0ZW5jZS5zdWJzZXRPZkZuLCBhcml0eTogezE6IFtcIkFueUF0Um9vdFwiXX19LFxuICBzdXBlcnNldE9mOiAgIHtmbjogZXhpc3RlbmNlLnN1cGVyc2V0T2ZGbiwgYXJpdHk6IHsxOiBbXCJBbnlBdFJvb3RcIl19fSxcbiAgaXNEaXN0aW5jdDogICB7Zm46IGV4aXN0ZW5jZS5pc0Rpc3RpbmN0Rm59LFxuICBkaXN0aW5jdDogICAgIHtmbjogZmlsdGVyaW5nLmRpc3RpbmN0Rm59LFxuICBjb3VudDogICAgICAgIHtmbjogYWdncmVnYXRlLmNvdW50Rm59LFxuICB3aGVyZTogICAgICAgIHtmbjogZmlsdGVyaW5nLndoZXJlTWFjcm8sIGFyaXR5OiB7MTogW1wiRXhwclwiXX19LFxuICBleHRlbnNpb246ICAgIHtmbjogZmlsdGVyaW5nLmV4dGVuc2lvbiwgYXJpdHk6IHsxOiBbXCJTdHJpbmdcIl19fSxcbiAgc2VsZWN0OiAgICAgICB7Zm46IGZpbHRlcmluZy5zZWxlY3RNYWNybywgYXJpdHk6IHsxOiBbXCJFeHByXCJdfX0sXG4gIGFnZ3JlZ2F0ZTogICAge2ZuOiBhZ2dyZWdhdGUuYWdncmVnYXRlTWFjcm8sIGFyaXR5OiB7MTogW1wiRXhwclwiXSwgMjogW1wiRXhwclwiLCBcIkFueUF0Um9vdFwiXX19LFxuICBzdW06ICAgICAgICAgIHtmbjogYWdncmVnYXRlLnN1bUZufSxcbiAgbWluOiAgICAgICAgICB7Zm46IGFnZ3JlZ2F0ZS5taW5Gbn0sXG4gIG1heDogICAgICAgICAge2ZuOiBhZ2dyZWdhdGUubWF4Rm59LFxuICBhdmc6ICAgICAgICAgIHtmbjogYWdncmVnYXRlLmF2Z0ZufSxcbiAgd2VpZ2h0OiAgICAgICB7Zm46IHN1cHBsZW1lbnRzLndlaWdodH0sXG4gIG9yZGluYWw6ICAgICAge2ZuOiBzdXBwbGVtZW50cy53ZWlnaHR9LFxuICBzaW5nbGU6ICAgICAgIHtmbjogZmlsdGVyaW5nLnNpbmdsZUZufSxcbiAgZmlyc3Q6ICAgICAgICB7Zm46IGZpbHRlcmluZy5maXJzdEZufSxcbiAgbGFzdDogICAgICAgICB7Zm46IGZpbHRlcmluZy5sYXN0Rm59LFxuICB0eXBlOiAgICAgICAgIHtmbjogdHlwZXMudHlwZUZuLCBhcml0eTogezA6IFtdfX0sXG4gIG9mVHlwZTogICAgICAge2ZuOiBmaWx0ZXJpbmcub2ZUeXBlRm4sIGFyaXR5OiB7MTogW1wiVHlwZVNwZWNpZmllclwiXX19LFxuICBpczogICAgICAgICAgIHtmbjogdHlwZXMuaXNGbiwgYXJpdHk6IHsxOiBbXCJUeXBlU3BlY2lmaWVyXCJdfX0sXG4gIGFzOiAgICAgICAgICAge2ZuOiB0eXBlcy5hc0ZuLCBhcml0eTogezE6IFtcIlR5cGVTcGVjaWZpZXJcIl19fSxcbiAgdGFpbDogICAgICAgICB7Zm46IGZpbHRlcmluZy50YWlsRm59LFxuICB0YWtlOiAgICAgICAgIHtmbjogZmlsdGVyaW5nLnRha2VGbiwgYXJpdHk6IHsxOiBbXCJJbnRlZ2VyXCJdfX0sXG4gIHNraXA6ICAgICAgICAge2ZuOiBmaWx0ZXJpbmcuc2tpcEZuLCBhcml0eTogezE6IFtcIkludGVnZXJcIl19fSxcbiAgY29tYmluZTogICAgICB7Zm46IGNvbWJpbmluZy5jb21iaW5lRm4sIGFyaXR5OiB7MTogW1wiQW55QXRSb290XCJdfX0sXG4gIHVuaW9uOiAgICAgICAge2ZuOiBjb21iaW5pbmcudW5pb24sICAgYXJpdHk6IHsxOiBbXCJBbnlBdFJvb3RcIl19fSxcbiAgaW50ZXJzZWN0OiAgICB7Zm46IGNvbWJpbmluZy5pbnRlcnNlY3QsICAgYXJpdHk6IHsxOiBbXCJBbnlBdFJvb3RcIl19fSxcbiAgZXhjbHVkZTogICAgICB7Zm46IGNvbWJpbmluZy5leGNsdWRlLCAgIGFyaXR5OiB7MTogW1wiQW55QXRSb290XCJdfX0sXG4gIGlpZjogICAgICAgICAge2ZuOiBtaXNjLmlpZk1hY3JvLCAgICBhcml0eTogezI6IFtcIkV4cHJcIiwgXCJFeHByXCJdLCAzOiBbXCJFeHByXCIsIFwiRXhwclwiLCBcIkV4cHJcIl19fSxcbiAgdHJhY2U6ICAgICAgICB7Zm46IG1pc2MudHJhY2VGbiwgICAgIGFyaXR5OiB7MTogW1wiU3RyaW5nXCJdLCAyOiBbXCJTdHJpbmdcIiwgXCJFeHByXCJdfX0sXG4gIGRlZmluZVZhcmlhYmxlOiB7Zm46IG1pc2MuZGVmaW5lVmFyaWFibGUsICAgICBhcml0eTogezE6IFtcIlN0cmluZ1wiXSwgMjogW1wiU3RyaW5nXCIsIFwiRXhwclwiXX19LFxuICB0b0ludGVnZXI6ICAgIHtmbjogbWlzYy50b0ludGVnZXJ9LFxuICB0b0RlY2ltYWw6ICAgIHtmbjogbWlzYy50b0RlY2ltYWx9LFxuICB0b1N0cmluZzogICAgIHtmbjogbWlzYy50b1N0cmluZ30sXG4gIHRvRGF0ZTogICAgICAge2ZuOiBtaXNjLnRvRGF0ZX0sXG4gIHRvRGF0ZVRpbWU6ICAge2ZuOiBtaXNjLnRvRGF0ZVRpbWV9LFxuICB0b1RpbWU6ICAgICAgIHtmbjogbWlzYy50b1RpbWV9LFxuICB0b0Jvb2xlYW46ICAgIHtmbjogbWlzYy50b0Jvb2xlYW59LFxuICB0b1F1YW50aXR5OiAgIHtmbjogbWlzYy50b1F1YW50aXR5LCBhcml0eTogezA6IFtdLCAxOiBbXCJTdHJpbmdcIl19fSxcbiAgaGFzVmFsdWU6ICAgICB7Zm46IG1pc2MuaGFzVmFsdWVGbn0sXG4gIGdldFZhbHVlOiAgICAge2ZuOiBtaXNjLmdldFZhbHVlRm59LFxuICBjb252ZXJ0c1RvQm9vbGVhbjogICAge2ZuOiBtaXNjLmNyZWF0ZUNvbnZlcnRzVG9GbihtaXNjLnRvQm9vbGVhbiwgJ2Jvb2xlYW4nKX0sXG4gIGNvbnZlcnRzVG9JbnRlZ2VyOiAgICB7Zm46IG1pc2MuY3JlYXRlQ29udmVydHNUb0ZuKG1pc2MudG9JbnRlZ2VyLCAnbnVtYmVyJyl9LFxuICBjb252ZXJ0c1RvRGVjaW1hbDogICAge2ZuOiBtaXNjLmNyZWF0ZUNvbnZlcnRzVG9GbihtaXNjLnRvRGVjaW1hbCwgJ251bWJlcicpfSxcbiAgY29udmVydHNUb1N0cmluZzogICAgIHtmbjogbWlzYy5jcmVhdGVDb252ZXJ0c1RvRm4obWlzYy50b1N0cmluZywgJ3N0cmluZycpfSxcbiAgY29udmVydHNUb0RhdGU6ICAgICAgIHtmbjogbWlzYy5jcmVhdGVDb252ZXJ0c1RvRm4obWlzYy50b0RhdGUsIEZQX0RhdGUpfSxcbiAgY29udmVydHNUb0RhdGVUaW1lOiAgIHtmbjogbWlzYy5jcmVhdGVDb252ZXJ0c1RvRm4obWlzYy50b0RhdGVUaW1lLCBGUF9EYXRlVGltZSl9LFxuICBjb252ZXJ0c1RvVGltZTogICAgICAge2ZuOiBtaXNjLmNyZWF0ZUNvbnZlcnRzVG9GbihtaXNjLnRvVGltZSwgRlBfVGltZSl9LFxuICBjb252ZXJ0c1RvUXVhbnRpdHk6ICAge2ZuOiBtaXNjLmNyZWF0ZUNvbnZlcnRzVG9GbihtaXNjLnRvUXVhbnRpdHksIEZQX1F1YW50aXR5KX0sXG5cbiAgaW5kZXhPZjogICAgICAgIHtmbjogc3RyaW5ncy5pbmRleE9mLCAgICAgICAgICBhcml0eTogezE6IFtcIlN0cmluZ1wiXX19LFxuICBzdWJzdHJpbmc6ICAgICAge2ZuOiBzdHJpbmdzLnN1YnN0cmluZywgICAgICAgIGFyaXR5OiB7MTogW1wiSW50ZWdlclwiXSwgMjogW1wiSW50ZWdlclwiLFwiSW50ZWdlclwiXX19LFxuICBzdGFydHNXaXRoOiAgICAge2ZuOiBzdHJpbmdzLnN0YXJ0c1dpdGgsICAgICAgIGFyaXR5OiB7MTogW1wiU3RyaW5nXCJdfX0sXG4gIGVuZHNXaXRoOiAgICAgICB7Zm46IHN0cmluZ3MuZW5kc1dpdGgsICAgICAgICAgYXJpdHk6IHsxOiBbXCJTdHJpbmdcIl19fSxcbiAgY29udGFpbnM6ICAgICAgIHtmbjogc3RyaW5ncy5jb250YWluc0ZuLCAgICAgICBhcml0eTogezE6IFtcIlN0cmluZ1wiXX19LFxuICB1cHBlcjogICAgICAgICAge2ZuOiBzdHJpbmdzLnVwcGVyfSxcbiAgbG93ZXI6ICAgICAgICAgIHtmbjogc3RyaW5ncy5sb3dlcn0sXG4gIHJlcGxhY2U6ICAgICAgICB7Zm46IHN0cmluZ3MucmVwbGFjZSwgICAgICAgICAgYXJpdHk6IHsyOiBbXCJTdHJpbmdcIiwgXCJTdHJpbmdcIl19fSxcbiAgbWF0Y2hlczogICAgICAgIHtmbjogc3RyaW5ncy5tYXRjaGVzLCAgICAgICAgICBhcml0eTogezE6IFtcIlN0cmluZ1wiXX19LFxuICByZXBsYWNlTWF0Y2hlczoge2ZuOiBzdHJpbmdzLnJlcGxhY2VNYXRjaGVzLCAgIGFyaXR5OiB7MjogW1wiU3RyaW5nXCIsIFwiU3RyaW5nXCJdfX0sXG4gIGxlbmd0aDogICAgICAgICB7Zm46IHN0cmluZ3MubGVuZ3RoIH0sXG4gIHRvQ2hhcnM6ICAgICAgICB7Zm46IHN0cmluZ3MudG9DaGFycyB9LFxuICBqb2luOiAgICAgICAgICAge2ZuOiBzdHJpbmdzLmpvaW5GbiwgICAgICAgICAgIGFyaXR5OiB7MDogW10sIDE6IFtcIlN0cmluZ1wiXX19LFxuICBzcGxpdDogICAgICAgICAge2ZuOiBzdHJpbmdzLnNwbGl0Rm4sICAgICAgICAgIGFyaXR5OiB7MTogW1wiU3RyaW5nXCJdfX0sXG4gIHRyaW06ICAgICAgICAgICB7Zm46IHN0cmluZ3MudHJpbUZufSxcblxuICBlbmNvZGU6ICAgICAgICAge2ZuOiBzdHJpbmdzLmVuY29kZUZuLCAgICAgICAgIGFyaXR5OiB7MTogW1wiU3RyaW5nXCJdfX0sXG4gIGRlY29kZTogICAgICAgICB7Zm46IHN0cmluZ3MuZGVjb2RlRm4sICAgICAgICAgYXJpdHk6IHsxOiBbXCJTdHJpbmdcIl19fSxcblxuICBhYnM6ICAgICAgICAgICAge2ZuOiBtYXRoLmFic30sXG4gIGNlaWxpbmc6ICAgICAgICB7Zm46IG1hdGguY2VpbGluZ30sXG4gIGV4cDogICAgICAgICAgICB7Zm46IG1hdGguZXhwfSxcbiAgZmxvb3I6ICAgICAgICAgIHtmbjogbWF0aC5mbG9vcn0sXG4gIGxuOiAgICAgICAgICAgICB7Zm46IG1hdGgubG59LFxuICBsb2c6ICAgICAgICAgICAge2ZuOiBtYXRoLmxvZywgYXJpdHk6ICB7MTogW1wiTnVtYmVyXCJdfSwgbnVsbGFibGU6IHRydWV9LFxuICBwb3dlcjogICAgICAgICAge2ZuOiBtYXRoLnBvd2VyLCBhcml0eTogIHsxOiBbXCJOdW1iZXJcIl19LCBudWxsYWJsZTogdHJ1ZX0sXG4gIHJvdW5kOiAgICAgICAgICB7Zm46IG1hdGgucm91bmQsIGFyaXR5OiAgezA6IFtdLCAxOiBbXCJOdW1iZXJcIl19fSxcbiAgc3FydDogICAgICAgICAgIHtmbjogbWF0aC5zcXJ0fSxcbiAgdHJ1bmNhdGU6ICAgICAgIHtmbjogbWF0aC50cnVuY2F0ZX0sXG5cbiAgbm93OiAgICAgICAgICAgIHtmbjogZGF0ZXRpbWUubm93IH0sXG4gIHRvZGF5OiAgICAgICAgICB7Zm46IGRhdGV0aW1lLnRvZGF5IH0sXG4gIHRpbWVPZkRheTogICAgICB7Zm46IGRhdGV0aW1lLnRpbWVPZkRheSB9LFxuXG4gIHJlcGVhdDogICAgICAgICAge2ZuOiBmaWx0ZXJpbmcucmVwZWF0TWFjcm8sIGFyaXR5OiB7MTogW1wiRXhwclwiXX19LFxuICBjaGlsZHJlbjogICAgICAgIHtmbjogbmF2aWdhdGlvbi5jaGlsZHJlbiB9LFxuICBkZXNjZW5kYW50czogICAgIHtmbjogbmF2aWdhdGlvbi5kZXNjZW5kYW50cyB9LFxuXG4gIFwifFwiOiAgICAgICAgICB7Zm46IGNvbWJpbmluZy51bmlvbiwgICBhcml0eTogezI6IFtcIkFueVwiLCBcIkFueVwiXX19LFxuICBcIj1cIjogICAgICAgICAge2ZuOiBlcXVhbGl0eS5lcXVhbCwgICBhcml0eTogezI6IFtcIkFueVwiLCBcIkFueVwiXX0sIG51bGxhYmxlOiB0cnVlfSxcbiAgXCIhPVwiOiAgICAgICAgIHtmbjogZXF1YWxpdHkudW5lcXVhbCwgICBhcml0eTogezI6IFtcIkFueVwiLCBcIkFueVwiXX0sIG51bGxhYmxlOiB0cnVlfSxcbiAgXCJ+XCI6ICAgICAgICAgIHtmbjogZXF1YWxpdHkuZXF1aXZhbCwgICBhcml0eTogezI6IFtcIkFueVwiLCBcIkFueVwiXX19LFxuICBcIiF+XCI6ICAgICAgICAge2ZuOiBlcXVhbGl0eS51bmVxdWl2YWwsICAgYXJpdHk6IHsyOiBbXCJBbnlcIiwgXCJBbnlcIl19fSxcbiAgXCI8XCI6ICAgICAgICAgIHtmbjogZXF1YWxpdHkubHQsICAgYXJpdHk6IHsyOiBbXCJBbnlcIiwgXCJBbnlcIl19LCBudWxsYWJsZTogdHJ1ZX0sXG4gIFwiPlwiOiAgICAgICAgICB7Zm46IGVxdWFsaXR5Lmd0LCAgIGFyaXR5OiB7MjogW1wiQW55XCIsIFwiQW55XCJdfSwgbnVsbGFibGU6IHRydWV9LFxuICBcIjw9XCI6ICAgICAgICAge2ZuOiBlcXVhbGl0eS5sdGUsICBhcml0eTogezI6IFtcIkFueVwiLCBcIkFueVwiXX0sIG51bGxhYmxlOiB0cnVlfSxcbiAgXCI+PVwiOiAgICAgICAgIHtmbjogZXF1YWxpdHkuZ3RlLCAgYXJpdHk6IHsyOiBbXCJBbnlcIiwgXCJBbnlcIl19LCBudWxsYWJsZTogdHJ1ZX0sXG4gIFwiY29udGFpbnNPcFwiOiB7Zm46IGNvbGxlY3Rpb25zLmNvbnRhaW5zLCAgIGFyaXR5OiB7MjogW1wiQW55XCIsIFwiQW55XCJdfX0sXG4gIFwiaW5PcFwiOiAgICAgICB7Zm46IGNvbGxlY3Rpb25zLmluLCAgYXJpdHk6IHsyOiBbXCJBbnlcIiwgXCJBbnlcIl19fSxcbiAgXCJpc09wXCI6ICAgICAgIHtmbjogdHlwZXMuaXNGbiwgIGFyaXR5OiB7MjogW1wiQW55XCIsIFwiVHlwZVNwZWNpZmllclwiXX19LFxuICBcImFzT3BcIjogICAgICAge2ZuOiB0eXBlcy5hc0ZuLCAgYXJpdHk6IHsyOiBbXCJBbnlcIiwgXCJUeXBlU3BlY2lmaWVyXCJdfX0sXG4gIFwiJlwiOiAgICAgICAgICB7Zm46IG1hdGguYW1wLCAgICAgYXJpdHk6ICB7MjogW1wiU3RyaW5nXCIsIFwiU3RyaW5nXCJdfX0sXG4gIFwiK1wiOiAgICAgICAgICB7Zm46IG1hdGgucGx1cywgICAgYXJpdHk6ICB7MjogW1wiQW55XCIsIFwiQW55XCJdfSwgbnVsbGFibGU6IHRydWV9LFxuICBcIi1cIjogICAgICAgICAge2ZuOiBtYXRoLm1pbnVzLCAgIGFyaXR5OiAgezI6IFtcIkFueVwiLCBcIkFueVwiXX0sIG51bGxhYmxlOiB0cnVlfSxcbiAgXCIqXCI6ICAgICAgICAgIHtmbjogbWF0aC5tdWwsICAgICBhcml0eTogIHsyOiBbXCJBbnlcIiwgXCJBbnlcIl19LCBudWxsYWJsZTogdHJ1ZX0sXG4gIFwiL1wiOiAgICAgICAgICB7Zm46IG1hdGguZGl2LCAgICAgYXJpdHk6ICB7MjogW1wiQW55XCIsIFwiQW55XCJdfSwgbnVsbGFibGU6IHRydWV9LFxuICBcIm1vZFwiOiAgICAgICAge2ZuOiBtYXRoLm1vZCwgICAgIGFyaXR5OiAgezI6IFtcIk51bWJlclwiLCBcIk51bWJlclwiXX0sIG51bGxhYmxlOiB0cnVlfSxcbiAgXCJkaXZcIjogICAgICAgIHtmbjogbWF0aC5pbnRkaXYsICBhcml0eTogIHsyOiBbXCJOdW1iZXJcIiwgXCJOdW1iZXJcIl19LCBudWxsYWJsZTogdHJ1ZX0sXG5cbiAgXCJvclwiOiAgICAgICAge2ZuOiBsb2dpYy5vck9wLCAgYXJpdHk6ICAgICAgIHsyOiBbW1wiQm9vbGVhblwiXSwgW1wiQm9vbGVhblwiXV19fSxcbiAgXCJhbmRcIjogICAgICAge2ZuOiBsb2dpYy5hbmRPcCwgIGFyaXR5OiAgICAgIHsyOiBbW1wiQm9vbGVhblwiXSwgW1wiQm9vbGVhblwiXV19fSxcbiAgXCJ4b3JcIjogICAgICAge2ZuOiBsb2dpYy54b3JPcCwgIGFyaXR5OiAgICAgIHsyOiBbW1wiQm9vbGVhblwiXSwgW1wiQm9vbGVhblwiXV19fSxcbiAgXCJpbXBsaWVzXCI6ICAge2ZuOiBsb2dpYy5pbXBsaWVzT3AsICBhcml0eTogIHsyOiBbW1wiQm9vbGVhblwiXSwgW1wiQm9vbGVhblwiXV19fSxcbn07XG5cbmVuZ2luZS5JbnZvY2F0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSkge1xuICByZXR1cm4gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBjaCkge1xuICAgIHJldHVybiBlbmdpbmUuZG9FdmFsKGN0eCwgYWNjLCBjaCk7XG4gIH0sIHBhcmVudERhdGEpO1xufTtcblxuZW5naW5lLlRlcm1FeHByZXNzaW9uID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIGlmIChwYXJlbnREYXRhKSB7XG4gICAgcGFyZW50RGF0YSA9IHBhcmVudERhdGEubWFwKCh4KSA9PiB7XG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIE9iamVjdCAmJiB4LnJlc291cmNlVHlwZSkge1xuICAgICAgICByZXR1cm4gbWFrZVJlc05vZGUoeCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgY3R4Lm1vZGVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVuZ2luZS5kb0V2YWwoY3R4LHBhcmVudERhdGEsIG5vZGUuY2hpbGRyZW5bMF0pO1xufTtcblxuZW5naW5lLlBvbGFyaXR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSkge1xuICB2YXIgc2lnbiA9IG5vZGUudGVybWluYWxOb2RlVGV4dFswXTsgLy8gZWl0aGVyIC0gb3IgKyBwZXIgZ3JhbW1hclxuICB2YXIgcnRuID0gZW5naW5lLmRvRXZhbChjdHgscGFyZW50RGF0YSwgbm9kZS5jaGlsZHJlblswXSk7XG4gIGlmIChydG4ubGVuZ3RoICE9PSAxKSB7ICAvLyBub3QgeWV0IGluIHNwZWMsIGJ1dCBwZXIgQnJ5biBSaG9kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYXJ5ICcgKyBzaWduICtcbiAgICAgJyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGFuIGluZGl2aWR1YWwgbnVtYmVyIG9yIFF1YW50aXR5LicpO1xuICB9XG4gIGlmIChydG5bMF0gaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgIGlmIChzaWduID09PSAnLScpIHtcbiAgICAgIHJ0blswXSA9IG5ldyBGUF9RdWFudGl0eSgtcnRuWzBdLnZhbHVlLCBydG5bMF0udW5pdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBydG5bMF0gPT09ICdudW1iZXInICYmICFpc05hTihydG5bMF0pKSB7XG4gICAgaWYgKHNpZ24gPT09ICctJykge1xuICAgICAgcnRuWzBdID0gLXJ0blswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFyeSAnICsgc2lnbiArICcgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhIG51bWJlciBvciBRdWFudGl0eS4nKTtcbiAgfVxuXG4gIHJldHVybiBydG47XG59O1xuXG5lbmdpbmUuVHlwZVNwZWNpZmllciA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSkge1xuICBsZXQgbmFtZXNwYWNlLCBuYW1lO1xuICBjb25zdCBpZGVudGlmaWVycyA9IG5vZGUudGV4dC5zcGxpdCgnLicpLm1hcChpID0+IGkucmVwbGFjZSgvKF5gfGAkKS9nLCBcIlwiKSk7XG4gIHN3aXRjaCAoaWRlbnRpZmllcnMubGVuZ3RoKSB7XG4gICAgY2FzZSAyOlxuICAgICAgW25hbWVzcGFjZSwgbmFtZV0gPSBpZGVudGlmaWVycztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIFtuYW1lXSA9IGlkZW50aWZpZXJzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFR5cGVTcGVjaWZpZXIgbm9kZSwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuICB9XG5cbiAgY29uc3QgdHlwZUluZm8gPSAgbmV3IFR5cGVJbmZvKHsgbmFtZXNwYWNlLCBuYW1lIH0pO1xuICBpZiAoIXR5cGVJbmZvLmlzVmFsaWQoY3R4Lm1vZGVsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgdHlwZUluZm8gKyAnXCIgY2Fubm90IGJlIHJlc29sdmVkIHRvIGEgdmFsaWQgdHlwZSBpZGVudGlmaWVyJyk7XG4gIH1cbiAgcmV0dXJuIHR5cGVJbmZvO1xufTtcblxuZW5naW5lLkV4dGVybmFsQ29uc3RhbnRUZXJtID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIGxldCB2YXJOYW1lO1xuICBjb25zdCBleHRDb25zdGFudCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gIC8vIGV4dGVybmFsQ29uc3RhbnQodmFyaWFibGUgbmFtZSkgaXMgZGVmaW5lZCBpbiB0aGUgZ3JhbW1hciBhczpcbiAgLy8gJyUnICggaWRlbnRpZmllciB8IFNUUklORyApXG4gIGlmIChleHRDb25zdGFudC50ZXJtaW5hbE5vZGVUZXh0Lmxlbmd0aCA9PT0gMikge1xuICAgIC8vIGlmIHRoZSB2YXJpYWJsZSBuYW1lIGlzIGEgU1RSSU5HXG4gICAgdmFyTmFtZSA9IGdldFN0cmluZ0xpdGVyYWxWYWwoZXh0Q29uc3RhbnQudGVybWluYWxOb2RlVGV4dFsxXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBpdCBpcyBhbiBpZGVudGlmaWVyXG4gICAgdmFyTmFtZSA9IGdldElkZW50aWZpZXJWYWwoZXh0Q29uc3RhbnQuY2hpbGRyZW5bMF0udGV4dCk7XG4gIH1cblxuICBsZXQgdmFsdWU7XG4gIC8vIENoZWNrIHRoZSB1c2VyLWRlZmluZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZpcnN0IGFzIHRoZSB1c2VyIGNhbiBvdmVycmlkZVxuICAvLyB0aGUgXCJjb250ZXh0XCIgdmFyaWFibGUgbGlrZSB3ZSBkbyBpbiB1bml0IHRlc3RzLiBJbiB0aGlzIGNhc2UsIHRoZSB1c2VyXG4gIC8vIGVudmlyb25tZW50IHZhcmlhYmxlIGNhbiByZXBsYWNlIHRoZSBzeXN0ZW0gZW52aXJvbm1lbnQgdmFyaWFibGUgaW4gXCJwcm9jZXNzZWRWYXJzXCIuXG4gIC8vIElmIHRoZSB1c2VyLWRlZmluZWQgZW52aXJvbm1lbnQgdmFyaWFibGUgaGFzIGJlZW4gcHJvY2Vzc2VkLCB3ZSBkb24ndCBuZWVkIHRvIHByb2Nlc3MgaXQgYWdhaW4uXG4gIGlmICh2YXJOYW1lIGluIGN0eC52YXJzICYmICFjdHgucHJvY2Vzc2VkVXNlclZhck5hbWVzLmhhcyh2YXJOYW1lKSkge1xuICAgIC8vIFJlc3RvcmUgdGhlIFJlc291cmNlTm9kZXMgZm9yIHRoZSB0b3AtbGV2ZWwgb2JqZWN0cyBvZiB0aGUgZW52aXJvbm1lbnRcbiAgICAvLyB2YXJpYWJsZXMuIFRoZSBuZXN0ZWQgb2JqZWN0cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBSZXNvdXJjZU5vZGVzXG4gICAgLy8gaW4gdGhlIE1lbWJlckludm9jYXRpb24gbWV0aG9kLlxuICAgIHZhbHVlID0gY3R4LnZhcnNbdmFyTmFtZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChcbiAgICAgICAgaSA9PiBpPy5fX3BhdGhfX1xuICAgICAgICAgID8gbWFrZVJlc05vZGUoaSwgaS5fX3BhdGhfXy5wYXJlbnRSZXNOb2RlLCBpLl9fcGF0aF9fLnBhdGgsIG51bGwsXG4gICAgICAgICAgICBpLl9fcGF0aF9fLmZoaXJOb2RlRGF0YVR5cGUsIGkuX19wYXRoX18ubW9kZWwpXG4gICAgICAgICAgOiBpPy5yZXNvdXJjZVR5cGVcbiAgICAgICAgICAgID8gbWFrZVJlc05vZGUoaSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgY3R4Lm1vZGVsKVxuICAgICAgICAgICAgOiBpICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWU/Ll9fcGF0aF9fXG4gICAgICAgID8gbWFrZVJlc05vZGUodmFsdWUsIHZhbHVlLl9fcGF0aF9fLnBhcmVudFJlc05vZGUsIHZhbHVlLl9fcGF0aF9fLnBhdGgsIG51bGwsXG4gICAgICAgICAgdmFsdWUuX19wYXRoX18uZmhpck5vZGVEYXRhVHlwZSwgdmFsdWUuX19wYXRoX18ubW9kZWwpXG4gICAgICAgIDogdmFsdWU/LnJlc291cmNlVHlwZVxuICAgICAgICAgID8gbWFrZVJlc05vZGUodmFsdWUsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGN0eC5tb2RlbClcbiAgICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgICBjdHgucHJvY2Vzc2VkVmFyc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIGN0eC5wcm9jZXNzZWRVc2VyVmFyTmFtZXMuYWRkKHZhck5hbWUpO1xuICB9IGVsc2UgaWYgKHZhck5hbWUgaW4gY3R4LnByb2Nlc3NlZFZhcnMpIHtcbiAgICAvLyBcInByb2Nlc3NlZFZhcnNcIiBhcmUgdmFyaWFibGVzIHdpdGggcmVhZHktdG8tdXNlIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeVxuICAgIC8vIGJlZW4gY29udmVydGVkIHRvIFJlc291cmNlTm9kZXMgaWYgbmVjZXNzYXJ5LlxuICAgIHZhbHVlID0gY3R4LnByb2Nlc3NlZFZhcnNbdmFyTmFtZV07XG4gIH0gZWxzZSAgaWYgKGN0eC5kZWZpbmVkVmFycyAmJiB2YXJOYW1lIGluIGN0eC5kZWZpbmVkVmFycykge1xuICAgIC8vIFwiZGVmaW5lZFZhcnNcIiBhcmUgdmFyaWFibGVzIGRlZmluZWQgd2l0aCB0aGUgXCJkZWZpbmVWYXJpYWJsZVwiIGZ1bmN0aW9uLlxuICAgIHZhbHVlID0gY3R4LmRlZmluZWRWYXJzW3Zhck5hbWVdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gdW5kZWZpbmVkIGVudmlyb25tZW50IHZhcmlhYmxlOiBcIiArIHZhck5hbWVcbiAgICApO1xuICB9XG4gIC8vIEZvciBjb252ZW5pZW5jZSwgYWxsIHZhcmlhYmxlIHZhbHVlcyBjb3VsZCBiZSBwYXNzZWQgaW4gd2l0aG91dCB0aGVpciBhcnJheVxuICAvLyB3cmFwcGVyLiAgSG93ZXZlciwgd2hlbiBldmFsdWF0aW5nLCB3ZSBuZWVkIHRvIHB1dCB0aGUgYXJyYXkgYmFjayBpbi5cbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGxcbiAgICA/IFtdXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xufTtcblxuZW5naW5lLkxpdGVyYWxUZXJtID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHZhciB0ZXJtID0gbm9kZS5jaGlsZHJlblswXTtcbiAgaWYodGVybSl7XG4gICAgcmV0dXJuIGVuZ2luZS5kb0V2YWwoY3R4LCBwYXJlbnREYXRhLCB0ZXJtKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW25vZGUudGV4dF07XG4gIH1cbn07XG5cbmVuZ2luZS5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHJldHVybiBbZ2V0U3RyaW5nTGl0ZXJhbFZhbChub2RlLnRleHQpXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgc2luZ2xlLXF1b3RlcyBhbmQgcmVwbGFjZXMgc3RyaW5nIGVzY2FwZVxuICogc2VxdWVuY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyBsaXRlcmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ0xpdGVyYWxWYWwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKF4nfCckKS9nLCBcIlwiKVxuICAgIC5yZXBsYWNlKC9cXFxcKHVcXGR7NH18LikvZywgZnVuY3Rpb24obWF0Y2gsIHN1Ym1hdGNoKSB7XG4gICAgICBzd2l0Y2gobWF0Y2gpIHtcbiAgICAgICAgY2FzZSAnXFxcXHInOlxuICAgICAgICAgIHJldHVybiAnXFxyJztcbiAgICAgICAgY2FzZSAnXFxcXG4nOlxuICAgICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgICBjYXNlICdcXFxcdCc6XG4gICAgICAgICAgcmV0dXJuICdcXHQnO1xuICAgICAgICBjYXNlICdcXFxcZic6XG4gICAgICAgICAgcmV0dXJuICdcXGYnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChzdWJtYXRjaC5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoJzB4JytzdWJtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN1Ym1hdGNoO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5lbmdpbmUuQm9vbGVhbkxpdGVyYWwgPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgaWYobm9kZS50ZXh0ICA9PT0gXCJ0cnVlXCIpIHtcbiAgICByZXR1cm4gW3RydWVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbZmFsc2VdO1xuICB9XG59O1xuXG5lbmdpbmUuUXVhbnRpdHlMaXRlcmFsID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHZhciB2YWx1ZU5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuICB2YXIgdmFsdWUgPSBOdW1iZXIodmFsdWVOb2RlLnRlcm1pbmFsTm9kZVRleHRbMF0pO1xuICB2YXIgdW5pdE5vZGUgPSB2YWx1ZU5vZGUuY2hpbGRyZW5bMF07XG4gIHZhciB1bml0ID0gdW5pdE5vZGUudGVybWluYWxOb2RlVGV4dFswXTtcbiAgLy8gU29tZXRpbWVzIHRoZSB1bml0IGlzIGluIGEgY2hpbGQgbm9kZSBvZiB0aGUgY2hpbGRcbiAgaWYgKCF1bml0ICYmIHVuaXROb2RlLmNoaWxkcmVuKVxuICAgIHVuaXQgPSB1bml0Tm9kZS5jaGlsZHJlblswXS50ZXJtaW5hbE5vZGVUZXh0WzBdO1xuXG4gIHJldHVybiBbbmV3IEZQX1F1YW50aXR5KHZhbHVlLCB1bml0KV07XG59O1xuXG5lbmdpbmUuRGF0ZVRpbWVMaXRlcmFsID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHZhciBkYXRlU3RyID0gbm9kZS50ZXh0LnNsaWNlKDEpOyAvLyBSZW1vdmUgdGhlIEBcbiAgcmV0dXJuIFtuZXcgRlBfRGF0ZVRpbWUoZGF0ZVN0cildO1xufTtcblxuZW5naW5lLlRpbWVMaXRlcmFsID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHZhciB0aW1lU3RyID0gbm9kZS50ZXh0LnNsaWNlKDEpOyAvLyBSZW1vdmUgdGhlIEBcbiAgcmV0dXJuIFtuZXcgRlBfVGltZSh0aW1lU3RyKV07XG59O1xuXG5lbmdpbmUuTnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSkge1xuICByZXR1cm4gW051bWJlcihub2RlLnRleHQpXTtcbn07XG5cbmVuZ2luZS5JZGVudGlmaWVyID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHJldHVybiBbZ2V0SWRlbnRpZmllclZhbChub2RlLnRleHQpXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYmFjay1xdW90ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gaWRlbnRpZmllciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SWRlbnRpZmllclZhbChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXmB8YCQpL2csIFwiXCIpO1xufVxuXG5lbmdpbmUuSW52b2NhdGlvblRlcm0gPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgcmV0dXJuIGVuZ2luZS5kb0V2YWwoY3R4LHBhcmVudERhdGEsIG5vZGUuY2hpbGRyZW5bMF0pO1xufTtcblxuXG5lbmdpbmUuTWVtYmVySW52b2NhdGlvbiA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSApIHtcbiAgY29uc3Qga2V5ID0gZW5naW5lLmRvRXZhbChjdHgsIHBhcmVudERhdGEsIG5vZGUuY2hpbGRyZW5bMF0pWzBdO1xuICBjb25zdCBtb2RlbCA9IGN0eC5tb2RlbDtcblxuICBpZiAocGFyZW50RGF0YSkge1xuICAgIHJldHVybiBwYXJlbnREYXRhLnJlZHVjZShmdW5jdGlvbihhY2MsIHJlcykge1xuICAgICAgcmVzID0gbWFrZVJlc05vZGUocmVzLCBudWxsLCByZXMuX19wYXRoX18/LnBhdGgsIG51bGwsXG4gICAgICAgIHJlcy5fX3BhdGhfXz8uZmhpck5vZGVEYXRhVHlwZSwgbW9kZWwpO1xuICAgICAgaWYgKHJlcy5kYXRhPy5yZXNvdXJjZVR5cGUgPT09IGtleSkge1xuICAgICAgICBhY2MucHVzaChyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5wdXNoRm4oYWNjLCB1dGlsLm1ha2VDaGlsZFJlc05vZGVzKHJlcywga2V5LCBtb2RlbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5lbmdpbmUuSW5kZXhlckV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgY29uc3QgY29sbF9ub2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgY29uc3QgaWR4X25vZGUgPSBub2RlLmNoaWxkcmVuWzFdO1xuICB2YXIgY29sbCA9IGVuZ2luZS5kb0V2YWwoY3R4LCBwYXJlbnREYXRhLCBjb2xsX25vZGUpO1xuICB2YXIgaWR4ID0gZW5naW5lLmRvRXZhbChjdHgsIHBhcmVudERhdGEsIGlkeF9ub2RlKTtcblxuICBpZih1dGlsLmlzRW1wdHkoaWR4KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBpZHhOdW0gPSBwYXJzZUludChpZHhbMF0pO1xuICBpZihjb2xsICYmIHV0aWwuaXNTb21lKGlkeE51bSkgJiYgY29sbC5sZW5ndGg+aWR4TnVtICYmIGlkeE51bT49MCkge1xuICAgIHJldHVybiBbY29sbFtpZHhOdW1dXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbmVuZ2luZS5GdW5jdG4gPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZW5naW5lLmRvRXZhbChjdHgsIHBhcmVudERhdGEsIHgpO1xuICB9KTtcbn07XG5cbmVuZ2luZS5yZWFsaXplUGFyYW1zID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBhcmdzKSB7XG4gIGlmKGFyZ3MgJiYgYXJnc1swXSAmJiBhcmdzWzBdLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGFyZ3NbMF0uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBlbmdpbmUuZG9FdmFsKGN0eCwgcGFyZW50RGF0YSwgeCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlUGFyYW0oY3R4LCBwYXJlbnREYXRhLCB0eXBlLCBwYXJhbSkge1xuICBpZih0eXBlID09PSBcIkV4cHJcIil7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbnN0ICR0aGlzID0gdXRpbC5hcnJhaWZ5KGRhdGEpO1xuICAgICAgbGV0IGN0eEV4cHIgPSB7IC4uLmN0eCwgJHRoaXMgfTtcbiAgICAgIGlmIChjdHguZGVmaW5lZFZhcnMpIHtcbiAgICAgICAgLy8gRWFjaCBwYXJhbWV0ZXIgc3ViZXhwcmVzc2lvbiBuZWVkcyBpdHMgb3duIHNldCBvZiBkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgICAvLyAoY2xvbmVkIGZyb20gdGhlIHBhcmVudCBjb250ZXh0KS4gVGhpcyB3YXksIHRoZSBjaGFuZ2VzIHRvIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgLy8gYXJlIGlzb2xhdGVkIGluIHRoZSBzdWJleHByZXNzaW9uLlxuICAgICAgICBjdHhFeHByLmRlZmluZWRWYXJzID0gey4uLmN0eC5kZWZpbmVkVmFyc307XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5naW5lLmRvRXZhbChjdHhFeHByLCAkdGhpcywgcGFyYW0pO1xuICAgIH07XG4gIH1cbiAgaWYodHlwZSA9PT0gXCJBbnlBdFJvb3RcIil7XG4gICAgY29uc3QgJHRoaXMgPSBjdHguJHRoaXMgfHwgY3R4LmRhdGFSb290O1xuICAgIGxldCBjdHhFeHByID0geyAuLi5jdHgsICR0aGlzfTtcbiAgICBpZiAoY3R4LmRlZmluZWRWYXJzKSB7XG4gICAgICAvLyBFYWNoIHBhcmFtZXRlciBzdWJleHByZXNzaW9uIG5lZWRzIGl0cyBvd24gc2V0IG9mIGRlZmluZWQgdmFyaWFibGVzXG4gICAgICAvLyAoY2xvbmVkIGZyb20gdGhlIHBhcmVudCBjb250ZXh0KS4gVGhpcyB3YXksIHRoZSBjaGFuZ2VzIHRvIHRoZSB2YXJpYWJsZXNcbiAgICAgIC8vIGFyZSBpc29sYXRlZCBpbiB0aGUgc3ViZXhwcmVzc2lvbi5cbiAgICAgIGN0eEV4cHIuZGVmaW5lZFZhcnMgPSB7Li4uY3R4LmRlZmluZWRWYXJzfTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZ2luZS5kb0V2YWwoY3R4RXhwciwgJHRoaXMsIHBhcmFtKTtcbiAgfVxuICBpZih0eXBlID09PSBcIklkZW50aWZpZXJcIil7XG4gICAgaWYocGFyYW0udHlwZSA9PT0gXCJUZXJtRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gcGFyYW0udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaWRlbnRpZmllciBub2RlLCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGUgPT09IFwiVHlwZVNwZWNpZmllclwiKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5UeXBlU3BlY2lmaWVyKGN0eCwgcGFyZW50RGF0YSwgcGFyYW0pO1xuICB9XG5cbiAgbGV0IHJlcztcbiAgaWYodHlwZSA9PT0gJ0FueVNpbmdsZXRvbkF0Um9vdCcpe1xuICAgIGNvbnN0ICR0aGlzID0gY3R4LiR0aGlzIHx8IGN0eC5kYXRhUm9vdDtcbiAgICBsZXQgY3R4RXhwciA9IHsgLi4uY3R4LCAkdGhpc307XG4gICAgaWYgKGN0eC5kZWZpbmVkVmFycykge1xuICAgICAgLy8gRWFjaCBwYXJhbWV0ZXIgc3ViZXhwcmVzc2lvbiBuZWVkcyBpdHMgb3duIHNldCBvZiBkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgLy8gKGNsb25lZCBmcm9tIHRoZSBwYXJlbnQgY29udGV4dCkuIFRoaXMgd2F5LCB0aGUgY2hhbmdlcyB0byB0aGUgdmFyaWFibGVzXG4gICAgICAvLyBhcmUgaXNvbGF0ZWQgaW4gdGhlIHN1YmV4cHJlc3Npb24uXG4gICAgICBjdHhFeHByLmRlZmluZWRWYXJzID0gey4uLmN0eC5kZWZpbmVkVmFyc307XG4gICAgfVxuICAgIHJlcyA9IGVuZ2luZS5kb0V2YWwoY3R4RXhwciwgJHRoaXMsIHBhcmFtKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY3R4RXhwciA9IHsuLi5jdHh9O1xuICAgIGlmIChjdHguZGVmaW5lZFZhcnMpIHtcbiAgICAgIC8vIEVhY2ggcGFyYW1ldGVyIHN1YmV4cHJlc3Npb24gbmVlZHMgaXRzIG93biBzZXQgb2YgZGVmaW5lZCB2YXJpYWJsZXNcbiAgICAgIC8vIChjbG9uZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRleHQpLiBUaGlzIHdheSwgdGhlIGNoYW5nZXMgdG8gdGhlIHZhcmlhYmxlc1xuICAgICAgLy8gYXJlIGlzb2xhdGVkIGluIHRoZSBzdWJleHByZXNzaW9uLlxuICAgICAgY3R4RXhwci5kZWZpbmVkVmFycyA9IHsuLi5jdHguZGVmaW5lZFZhcnN9O1xuICAgIH1cbiAgICByZXMgPSBlbmdpbmUuZG9FdmFsKGN0eEV4cHIsIHBhcmVudERhdGEsIHBhcmFtKTtcbiAgICBpZiAodHlwZSA9PT0gXCJBbnlcIikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGlmIChyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSB0eXBlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgaW5zdGFuY2VvZiBQcm9taXNlID9cbiAgICByZXMudGhlbihyID0+IG1pc2Muc2luZ2xldG9uKHIsIHR5cGUpKSA6XG4gICAgbWlzYy5zaW5nbGV0b24ocmVzLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZG9JbnZva2UoY3R4LCBmbk5hbWUsIGRhdGEsIHJhd1BhcmFtcyl7XG4gIHZhciBpbnZvYyA9XG4gICAgY3R4LnVzZXJJbnZvY2F0aW9uVGFibGVcbiAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LnVzZXJJbnZvY2F0aW9uVGFibGUsIGZuTmFtZSlcbiAgICAmJiBjdHgudXNlckludm9jYXRpb25UYWJsZT8uW2ZuTmFtZV1cbiAgICB8fCBlbmdpbmUuaW52b2NhdGlvblRhYmxlW2ZuTmFtZV1cbiAgICB8fCBkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdPy5pbnZvY2F0aW9uVGFibGU/Lltmbk5hbWVdO1xuICB2YXIgcmVzO1xuICBpZihpbnZvYykge1xuICAgIGlmKCFpbnZvYy5hcml0eSl7XG4gICAgICBpZighcmF3UGFyYW1zKXtcbiAgICAgICAgcmVzID0gaW52b2MuZm4uY2FsbChjdHgsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdXRpbC5yZXNvbHZlQW5kQXJyYWlmeShyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiIGV4cGVjdHMgbm8gcGFyYW1zXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyYW1zTnVtYmVyID0gcmF3UGFyYW1zID8gcmF3UGFyYW1zLmxlbmd0aCA6IDA7XG4gICAgICB2YXIgYXJnVHlwZXMgPSBpbnZvYy5hcml0eVtwYXJhbXNOdW1iZXJdO1xuICAgICAgaWYoYXJnVHlwZXMpe1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJhbXNOdW1iZXI7IGkrKyl7XG4gICAgICAgICAgdmFyIHRwID0gYXJnVHlwZXNbaV07XG4gICAgICAgICAgdmFyIHByID0gcmF3UGFyYW1zW2ldO1xuICAgICAgICAgIHBhcmFtcy5wdXNoKG1ha2VQYXJhbShjdHgsIGRhdGEsIHRwLCBwcikpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KGRhdGEpO1xuICAgICAgICBpZihpbnZvYy5udWxsYWJsZSkge1xuICAgICAgICAgIGlmKHBhcmFtcy5zb21lKGlzTnVsbGFibGUpKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5zb21lKHAgPT4gcCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcmFtcykudGhlbihwID0+IHtcbiAgICAgICAgICAgIHJlcyA9IGludm9jLmZuLmFwcGx5KGN0eCwgcCk7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5yZXNvbHZlQW5kQXJyYWlmeShyZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGludm9jLmZuLmFwcGx5KGN0eCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHV0aWwucmVzb2x2ZUFuZEFycmFpZnkocmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGZuTmFtZSArIFwiIHdyb25nIGFyaXR5OiBnb3QgXCIgKyBwYXJhbXNOdW1iZXIgKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IFwiICsgZm5OYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNOdWxsYWJsZSh4KSB7XG4gIHJldHVybiB4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCB8fCB1dGlsLmlzRW1wdHkoeCk7XG59XG5cbmZ1bmN0aW9uIGluZml4SW52b2tlKGN0eCwgZm5OYW1lLCBkYXRhLCByYXdQYXJhbXMpe1xuICB2YXIgaW52b2MgPSBlbmdpbmUuaW52b2NhdGlvblRhYmxlW2ZuTmFtZV07XG4gIGlmKGludm9jICYmIGludm9jLmZuKSB7XG4gICAgdmFyIHBhcmFtc051bWJlciA9IHJhd1BhcmFtcyA/IHJhd1BhcmFtcy5sZW5ndGggOiAwO1xuICAgIGlmKHBhcmFtc051bWJlciAhPT0gMikgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbmZpeCBpbnZva2Ugc2hvdWxkIGhhdmUgYXJpdHkgMlwiKTsgfVxuICAgIHZhciBhcmdUeXBlcyA9IGludm9jLmFyaXR5W3BhcmFtc051bWJlcl07XG4gICAgaWYoYXJnVHlwZXMpe1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcmFtc051bWJlcjsgaSsrKXtcbiAgICAgICAgdmFyIHRwID0gYXJnVHlwZXNbaV07XG4gICAgICAgIHZhciBwciA9IHJhd1BhcmFtc1tpXTtcbiAgICAgICAgcGFyYW1zLnB1c2gobWFrZVBhcmFtKGN0eCwgZGF0YSwgdHAsIHByKSk7XG4gICAgICB9XG4gICAgICBpZihpbnZvYy5udWxsYWJsZSkge1xuICAgICAgICBpZihwYXJhbXMuc29tZShpc051bGxhYmxlKSl7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNvbWUocCA9PiBwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcmFtcykudGhlbihwID0+IHtcbiAgICAgICAgICB2YXIgcmVzID0gaW52b2MuZm4uYXBwbHkoY3R4LCBwKTtcbiAgICAgICAgICByZXR1cm4gdXRpbC5hcnJhaWZ5KHJlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IGludm9jLmZuLmFwcGx5KGN0eCwgcGFyYW1zKTtcbiAgICAgIHJldHVybiB1dGlsLmFycmFpZnkocmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coZm5OYW1lICsgXCIgd3JvbmcgYXJpdHk6IGdvdCBcIiArIHBhcmFtc051bWJlciApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbCBcIiArIGZuTmFtZSk7XG4gIH1cbn1cblxuZW5naW5lLkZ1bmN0aW9uSW52b2NhdGlvbiA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50RGF0YSwgbm9kZSkge1xuICB2YXIgYXJncyA9IGVuZ2luZS5kb0V2YWwoY3R4LCBwYXJlbnREYXRhLCBub2RlLmNoaWxkcmVuWzBdKTtcbiAgY29uc3QgZm5OYW1lID0gYXJnc1swXTtcbiAgYXJncy5zaGlmdCgpO1xuICB2YXIgcmF3UGFyYW1zID0gYXJncyAmJiBhcmdzWzBdICYmIGFyZ3NbMF0uY2hpbGRyZW47XG4gIHJldHVybiBkb0ludm9rZShjdHgsIGZuTmFtZSwgcGFyZW50RGF0YSwgcmF3UGFyYW1zKTtcbn07XG5cbmVuZ2luZS5QYXJhbUxpc3QgPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgLy8gd2UgZG8gbm90IGV2YWwgcGFyYW0gbGlzdCBiZWNhdXNlIHNvbWV0aW1lcyBpdCBzaG91bGQgYmUgcGFzc2VkIGFzXG4gIC8vIGxhbWJkYS9tYWNybyAoZm9yIGV4YW1wbGUgaW4gY2FzZSBvZiB3aGVyZSguLi4pXG4gIHJldHVybiBub2RlO1xufTtcblxuXG5lbmdpbmUuVW5pb25FeHByZXNzaW9uID0gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gIHJldHVybiBpbmZpeEludm9rZShjdHgsICd8JywgcGFyZW50RGF0YSwgbm9kZS5jaGlsZHJlbik7XG59O1xuXG5lbmdpbmUuVGhpc0ludm9jYXRpb24gPSBmdW5jdGlvbihjdHgpIHtcbiAgcmV0dXJuIGN0eC4kdGhpcztcbn07XG5cbmVuZ2luZS5Ub3RhbEludm9jYXRpb24gPSBmdW5jdGlvbihjdHgpIHtcbiAgcmV0dXJuIHV0aWwuYXJyYWlmeShjdHguJHRvdGFsKTtcbn07XG5cbmVuZ2luZS5JbmRleEludm9jYXRpb24gPSBmdW5jdGlvbihjdHgpIHtcbiAgcmV0dXJuIHV0aWwuYXJyYWlmeShjdHguJGluZGV4KTtcbn07XG5cbmVuZ2luZS5PcEV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgdmFyIG9wID0gbm9kZS50ZXJtaW5hbE5vZGVUZXh0WzBdO1xuICByZXR1cm4gaW5maXhJbnZva2UoY3R4LCBvcCwgcGFyZW50RGF0YSwgbm9kZS5jaGlsZHJlbik7XG59O1xuXG5lbmdpbmUuQWxpYXNPcEV4cHJlc3Npb24gPSBmdW5jdGlvbihtYXApe1xuICByZXR1cm4gZnVuY3Rpb24oY3R4LCBwYXJlbnREYXRhLCBub2RlKSB7XG4gICAgdmFyIG9wID0gbm9kZS50ZXJtaW5hbE5vZGVUZXh0WzBdO1xuICAgIHZhciBhbGlhcyA9IG1hcFtvcF07XG4gICAgaWYoIWFsaWFzKSB7IHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCBrbm93IGhvdyB0byBhbGlhcyBcIiArIG9wICsgXCIgYnkgXCIgKyBKU09OLnN0cmluZ2lmeShtYXApKTsgfVxuICAgIHJldHVybiBpbmZpeEludm9rZShjdHgsIGFsaWFzLCBwYXJlbnREYXRhLCBub2RlLmNoaWxkcmVuKTtcbiAgfTtcbn07XG5cbmVuZ2luZS5OdWxsTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW107XG59O1xuXG5lbmdpbmUuUGFyZW50aGVzaXplZFRlcm0gPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgcmV0dXJuIGVuZ2luZS5kb0V2YWwoY3R4LCBwYXJlbnREYXRhLCBub2RlLmNoaWxkcmVuWzBdKTtcbn07XG5cblxuZW5naW5lLmV2YWxUYWJsZSA9IHsgLy8gbm90IGV2ZXJ5IGV2YWx1YXRvciBpcyBsaXN0ZWQgaWYgdGhleSBhcmUgZGVmaW5lZCBvbiBlbmdpbmVcbiAgQm9vbGVhbkxpdGVyYWw6IGVuZ2luZS5Cb29sZWFuTGl0ZXJhbCxcbiAgRXF1YWxpdHlFeHByZXNzaW9uOiBlbmdpbmUuT3BFeHByZXNzaW9uLFxuICBGdW5jdGlvbkludm9jYXRpb246IGVuZ2luZS5GdW5jdGlvbkludm9jYXRpb24sXG4gIEZ1bmN0bjogZW5naW5lLkZ1bmN0bixcbiAgSWRlbnRpZmllcjogZW5naW5lLklkZW50aWZpZXIsXG4gIEluZGV4ZXJFeHByZXNzaW9uOiBlbmdpbmUuSW5kZXhlckV4cHJlc3Npb24sXG4gIEluZXF1YWxpdHlFeHByZXNzaW9uOiBlbmdpbmUuT3BFeHByZXNzaW9uLFxuICBJbnZvY2F0aW9uRXhwcmVzc2lvbjogZW5naW5lLkludm9jYXRpb25FeHByZXNzaW9uLFxuICBBZGRpdGl2ZUV4cHJlc3Npb246IGVuZ2luZS5PcEV4cHJlc3Npb24sXG4gIE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbjogZW5naW5lLk9wRXhwcmVzc2lvbixcbiAgVHlwZUV4cHJlc3Npb246IGVuZ2luZS5BbGlhc09wRXhwcmVzc2lvbih7XCJpc1wiOiBcImlzT3BcIiwgXCJhc1wiOiBcImFzT3BcIn0pLFxuICBNZW1iZXJzaGlwRXhwcmVzc2lvbjogZW5naW5lLkFsaWFzT3BFeHByZXNzaW9uKHtcImNvbnRhaW5zXCI6IFwiY29udGFpbnNPcFwiLCBcImluXCI6IFwiaW5PcFwifSksXG4gIE51bGxMaXRlcmFsOiBlbmdpbmUuTnVsbExpdGVyYWwsXG4gIEVudGlyZUV4cHJlc3Npb246IGVuZ2luZS5JbnZvY2F0aW9uVGVybSxcbiAgSW52b2NhdGlvblRlcm06IGVuZ2luZS5JbnZvY2F0aW9uVGVybSxcbiAgTGl0ZXJhbFRlcm06IGVuZ2luZS5MaXRlcmFsVGVybSxcbiAgTWVtYmVySW52b2NhdGlvbjogZW5naW5lLk1lbWJlckludm9jYXRpb24sXG4gIE51bWJlckxpdGVyYWw6IGVuZ2luZS5OdW1iZXJMaXRlcmFsLFxuICBQYXJhbUxpc3Q6IGVuZ2luZS5QYXJhbUxpc3QsXG4gIFBhcmVudGhlc2l6ZWRUZXJtOiBlbmdpbmUuUGFyZW50aGVzaXplZFRlcm0sXG4gIFN0cmluZ0xpdGVyYWw6IGVuZ2luZS5TdHJpbmdMaXRlcmFsLFxuICBUZXJtRXhwcmVzc2lvbjogZW5naW5lLlRlcm1FeHByZXNzaW9uLFxuICBUaGlzSW52b2NhdGlvbjogZW5naW5lLlRoaXNJbnZvY2F0aW9uLFxuICBUb3RhbEludm9jYXRpb246IGVuZ2luZS5Ub3RhbEludm9jYXRpb24sXG4gIEluZGV4SW52b2NhdGlvbjogZW5naW5lLkluZGV4SW52b2NhdGlvbixcbiAgVW5pb25FeHByZXNzaW9uOiBlbmdpbmUuVW5pb25FeHByZXNzaW9uLFxuICBPckV4cHJlc3Npb246IGVuZ2luZS5PcEV4cHJlc3Npb24sXG4gIEltcGxpZXNFeHByZXNzaW9uOiBlbmdpbmUuT3BFeHByZXNzaW9uLFxuICBBbmRFeHByZXNzaW9uOiBlbmdpbmUuT3BFeHByZXNzaW9uLFxuICBYb3JFeHByZXNzaW9uOiBlbmdpbmUuT3BFeHByZXNzaW9uXG59O1xuXG5cbmVuZ2luZS5kb0V2YWwgPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgaWYgKHBhcmVudERhdGEgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHBhcmVudERhdGEudGhlbihwID0+IGVuZ2luZS5kb0V2YWxTeW5jKGN0eCwgcCwgbm9kZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAgZW5naW5lLmRvRXZhbFN5bmMoY3R4LCBwYXJlbnREYXRhLCBub2RlKTtcbiAgfVxufTtcblxuZW5naW5lLmRvRXZhbFN5bmMgPSBmdW5jdGlvbihjdHgsIHBhcmVudERhdGEsIG5vZGUpIHtcbiAgY29uc3QgZXZhbHVhdG9yID0gZW5naW5lLmV2YWxUYWJsZVtub2RlLnR5cGVdIHx8IGVuZ2luZVtub2RlLnR5cGVdO1xuICBpZihldmFsdWF0b3Ipe1xuICAgIHJldHVybiBldmFsdWF0b3IuY2FsbChlbmdpbmUsIGN0eCwgcGFyZW50RGF0YSwgbm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gXCIgKyBub2RlLnR5cGUgKyBcIiBldmFsdWF0b3IgXCIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHJldHVybiBwYXJzZXIucGFyc2UocGF0aCk7XG59XG5cblxuLyoqXG4gKiAgQXBwbGllcyB0aGUgZ2l2ZW4gcGFyc2VkIEZISVJQYXRoIGV4cHJlc3Npb24gdG8gdGhlIGdpdmVuIHJlc291cmNlLFxuICogIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIGRvRXZhbC5cbiAqIEBwYXJhbSB7KG9iamVjdHxvYmplY3RbXSl9IHJlc291cmNlIC0gIEZISVIgcmVzb3VyY2UsIGJ1bmRsZSBhcyBqcyBvYmplY3Qgb3IgYXJyYXkgb2YgcmVzb3VyY2VzXG4gKiAgVGhpcyByZXNvdXJjZSB3aWxsIGJlIG1vZGlmaWVkIGJ5IHRoaXMgZnVuY3Rpb24gdG8gYWRkIHR5cGUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkUGF0aCAtIGEgc3BlY2lhbCBvYmplY3QgY3JlYXRlZCBieSB0aGUgcGFyc2VyIHRoYXQgZGVzY3JpYmVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBmaGlycGF0aCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGVudlZhcnMgLSBhIGhhc2ggb2YgdmFyaWFibGUgbmFtZS92YWx1ZSBwYWlycy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCAtIFRoZSBcIm1vZGVsXCIgZGF0YSBvYmplY3Qgc3BlY2lmaWMgdG8gYSBkb21haW4sIGUuZy4gUjQuXG4gKiAgRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBwYXNzIGluIHRoZSByZXN1bHQgb2YgcmVxdWlyZShcImZoaXJwYXRoL2ZoaXItY29udGV4dC9yNFwiKTtcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zOlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNvbHZlSW50ZXJuYWxUeXBlc10gLSB3aGV0aGVyIHZhbHVlcyBvZiBpbnRlcm5hbFxuICogIHR5cGVzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5ncywgdHJ1ZSBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudHJhY2VGbl0gLSBBbiBvcHRpb25hbCB0cmFjZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdHJhY2luZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy51c2VySW52b2NhdGlvblRhYmxlXSAtIGEgdXNlciBpbnZvY2F0aW9uIHRhYmxlIHVzZWRcbiAqICB0byByZXBsYWNlIGFueSBleGlzdGluZyBvciBkZWZpbmUgbmV3IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLmFzeW5jXSAtIGRlZmluZXMgaG93IHRvIHN1cHBvcnQgYXN5bmNocm9ub3VzIGZ1bmN0aW9uczpcbiAqICBmYWxzZSBvciBzaW1pbGFyIHRvIGZhbHNlLCBlLmcuIHVuZGVmaW5lZCwgbnVsbCwgb3IgMCAoZGVmYXVsdCkgLSB0aHJvdyBhbiBleGNlcHRpb247XG4gKiAgdHJ1ZSBvciBzaW1pbGFyIHRvIHRydWUgLSByZXR1cm4gUHJvbWlzZSBvbmx5IGZvciBhc3luY2hyb25vdXMgZnVuY3Rpb25zO1xuICogIFwiYWx3YXlzXCIgLSByZXR1cm4gUHJvbWlzZSBhbHdheXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGVybWlub2xvZ3lVcmxdIC0gYSBVUkwgdGhhdCBwb2ludHMgdG8gYSBGSElSXG4gKiAgIFJFU1RmdWwgQVBJIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgJXRlcm1pbm9sb2dpZXMgdGhhdCBpbXBsZW1lbnRzXG4gKiAgIHRoZSBUZXJtaW5vbG9neSBTZXJ2aWNlIEFQSS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRpb25zLnNpZ25hbF0gLSBhbiBBYm9ydFNpZ25hbCBvYmplY3QgdGhhdCBhbGxvd3MgeW91XG4gKiAgIHRvIGFib3J0IHRoZSBhc3luY2hyb25vdXMgRkhJUlBhdGggZXhwcmVzc2lvbiBldmFsdWF0aW9uLlxuICovXG5mdW5jdGlvbiBhcHBseVBhcnNlZFBhdGgocmVzb3VyY2UsIHBhcnNlZFBhdGgsIGVudlZhcnMsIG1vZGVsLCBvcHRpb25zKSB7XG4gIGNvbnN0YW50cy5yZXNldCgpO1xuICBsZXQgZGF0YVJvb3QgPSB1dGlsLmFycmFpZnkocmVzb3VyY2UpLm1hcChcbiAgICBpID0+IGk/Ll9fcGF0aF9fXG4gICAgICA/IG1ha2VSZXNOb2RlKGksIGkuX19wYXRoX18ucGFyZW50UmVzTm9kZSwgaS5fX3BhdGhfXy5wYXRoLCBudWxsLFxuICAgICAgICBpLl9fcGF0aF9fLmZoaXJOb2RlRGF0YVR5cGUsIG1vZGVsKVxuICAgICAgOiBpPy5yZXNvdXJjZVR5cGVcbiAgICAgICAgPyBtYWtlUmVzTm9kZShpLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBtb2RlbClcbiAgICAgICAgOiBpKTtcbiAgLy8gZG9FdmFsIHRha2VzIGEgXCJjdHhcIiBvYmplY3QsIGFuZCB3ZSBzdG9yZSB0aGluZ3MgaW4gdGhhdCBhcyB3ZSBwYXJzZSwgc28gd2VcbiAgLy8gbmVlZCB0byBwdXQgdXNlci1wcm92aWRlZCB2YXJpYWJsZSBkYXRhIGluIGEgc3ViLW9iamVjdCwgY3R4LnZhcnMuXG4gIC8vIFNldCB1cCBkZWZhdWx0IHN0YW5kYXJkIHZhcmlhYmxlcywgYW5kIGFsbG93IG92ZXJyaWRlIGZyb20gdGhlIHZhcmlhYmxlcy5cbiAgLy8gSG93ZXZlciwgd2UnbGwga2VlcCBvdXIgb3duIGNvcHkgb2YgZGF0YVJvb3QgZm9yIGludGVybmFsIHByb2Nlc3NpbmcuXG4gIGxldCBjdHggPSB7XG4gICAgZGF0YVJvb3QsXG4gICAgcHJvY2Vzc2VkVmFyczoge1xuICAgICAgdWN1bTogJ2h0dHA6Ly91bml0c29mbWVhc3VyZS5vcmcnLFxuICAgICAgY29udGV4dDogZGF0YVJvb3RcbiAgICB9LFxuICAgIHByb2Nlc3NlZFVzZXJWYXJOYW1lczogbmV3IFNldCgpLFxuICAgIHZhcnM6IGVudlZhcnMgfHwge30sXG4gICAgbW9kZWxcbiAgfTtcbiAgaWYgKG9wdGlvbnMudHJhY2VGbikge1xuICAgIGN0eC5jdXN0b21UcmFjZUZuID0gb3B0aW9ucy50cmFjZUZuO1xuICB9XG4gIGlmIChvcHRpb25zLnVzZXJJbnZvY2F0aW9uVGFibGUpIHtcbiAgICBjdHgudXNlckludm9jYXRpb25UYWJsZSA9IG9wdGlvbnMudXNlckludm9jYXRpb25UYWJsZTtcbiAgfVxuICBpZiAob3B0aW9ucy5hc3luYykge1xuICAgIGN0eC5hc3luYyA9IG9wdGlvbnMuYXN5bmM7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVybWlub2xvZ3lVcmwpIHtcbiAgICBjdHgucHJvY2Vzc2VkVmFycy50ZXJtaW5vbG9naWVzID0gbmV3IFRlcm1pbm9sb2dpZXMob3B0aW9ucy50ZXJtaW5vbG9neVVybCk7XG4gIH1cbiAgY3R4LnByb2Nlc3NlZFZhcnMuZmFjdG9yeSA9IEZhY3Rvcnk7XG4gIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgIGN0eC5zaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICBpZiAoIWN0eC5hc3luYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIFwic2lnbmFsXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBhc3luY2hyb25vdXMgZnVuY3Rpb25zLicpO1xuICAgIH1cbiAgICBpZiAoY3R4LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdmFsdWF0aW9uIG9mIHRoZSBleHByZXNzaW9uIHdhcyBhYm9ydGVkIGJlZm9yZSBpdCBzdGFydGVkLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBlbmdpbmUuZG9FdmFsKGN0eCwgZGF0YVJvb3QsIHBhcnNlZFBhdGguY2hpbGRyZW5bMF0pO1xuICByZXR1cm4gcmVzIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgID8gcmVzLnRoZW4ociA9PiB7XG4gICAgICBpZiAoY3R4LnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnRXZhbHVhdGlvbiBvZiB0aGUgZXhwcmVzc2lvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmVwYXJlRXZhbFJlc3VsdChyLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSlcbiAgICA6IG9wdGlvbnMuYXN5bmMgPT09ICdhbHdheXMnXG4gICAgICA/IFByb21pc2UucmVzb2x2ZShwcmVwYXJlRXZhbFJlc3VsdChyZXMsIG1vZGVsLCBvcHRpb25zKSlcbiAgICAgIDogcHJlcGFyZUV2YWxSZXN1bHQocmVzLCBtb2RlbCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIHJlc3VsdCBhZnRlciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24uXG4gKiBlbmdpbmUuZG9FdmFsIHJldHVybnMgYXJyYXkgb2YgXCJSZXNvdXJjZU5vZGVcIiBhbmQvb3IgXCJGUF9UeXBlXCIgaW5zdGFuY2VzLlxuICogXCJSZXNvdXJjZU5vZGVcIiBvciBcIkZQX1R5cGVcIiBpbnN0YW5jZXMgYXJlIG5vdCBjcmVhdGVkIGZvciBzdWItaXRlbXMuXG4gKiBSZXNvbHZlcyBhbnkgaW50ZXJuYWwgXCJSZXNvdXJjZU5vZGVcIiBpbnN0YW5jZXMgdG8gcGxhaW4gb2JqZWN0cyBhbmQgaWZcbiAqIG9wdGlvbnMucmVzb2x2ZUludGVybmFsVHlwZXMgaXMgdHJ1ZSwgcmVzb2x2ZSBhbnkgaW50ZXJuYWwgXCJGUF9UeXBlXCJcbiAqIGluc3RhbmNlcyB0byBzdHJpbmdzLlxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IC0gcmVzdWx0IG9mIGV4cHJlc3Npb24gZXZhbHVhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCAtIFRoZSBcIm1vZGVsXCIgZGF0YSBvYmplY3Qgc3BlY2lmaWMgdG8gYSBkb21haW4sIGUuZy4gUjQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucyAoc2VlIGZ1bmN0aW9uIFwiYXBwbHlQYXJzZWRQYXRoXCIpLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVFdmFsUmVzdWx0KHJlc3VsdCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlc3VsdFxuICAgIC5yZWR1Y2UoKGFjYywgbikgPT4ge1xuICAgICAgLy8gUGF0aCBmb3IgdGhlIGRhdGEgZXh0cmFjdGVkIGZyb20gdGhlIHJlc291cmNlLlxuICAgICAgbGV0IHBhdGg7XG4gICAgICBsZXQgZmhpck5vZGVEYXRhVHlwZTtcbiAgICAgIGxldCBwYXJlbnRSZXNOb2RlO1xuICAgICAgaWYgKG4gaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGUpIHtcbiAgICAgICAgcGF0aCA9IG4ucGF0aDtcbiAgICAgICAgZmhpck5vZGVEYXRhVHlwZSA9IG4uZmhpck5vZGVEYXRhVHlwZTtcbiAgICAgICAgcGFyZW50UmVzTm9kZSA9IG4ucGFyZW50UmVzTm9kZTtcbiAgICAgIH1cbiAgICAgIG4gPSB1dGlsLnZhbERhdGEobik7XG4gICAgICBpZiAobiBpbnN0YW5jZW9mIEZQX1R5cGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzb2x2ZUludGVybmFsVHlwZXMpIHtcbiAgICAgICAgICBuID0gbi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFeGNsdWRlIG51bGxzXG4gICAgICBpZiAobiAhPSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBhIGhpZGRlbiAobm9uLWVudW1lcmFibGUpIHByb3BlcnR5IHdpdGggdGhlIHBhdGggdG8gdGhlIGRhdGEgZXh0cmFjdGVkXG4gICAgICAgIC8vIGZyb20gdGhlIHJlc291cmNlLlxuICAgICAgICBpZiAocGF0aCAmJiB0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgIW4uX19wYXRoX18pIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgJ19fcGF0aF9fJywgeyB2YWx1ZToge3BhdGgsIGZoaXJOb2RlRGF0YVR5cGUsIHBhcmVudFJlc05vZGUsIG1vZGVsfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBhY2MucHVzaChuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGFueSBpbnRlcm5hbCBcIkZQX1R5cGVcIiBpbnN0YW5jZXMgaW4gYSByZXN1bHQgb2YgRkhJUlBhdGggZXhwcmVzc2lvblxuICogZXZhbHVhdGlvbiB0byBzdGFuZGFyZCBKYXZhU2NyaXB0IHR5cGVzLlxuICogQHBhcmFtIHthbnl9IHZhbCAtIGEgcmVzdWx0IG9mIEZISVJQYXRoIGV4cHJlc3Npb24gZXZhbHVhdGlvblxuICogQHJldHVybnMge2FueX0gYSBuZXcgb2JqZWN0IHdpdGggcmVzb2x2ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlSW50ZXJuYWxUeXBlcyh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAobGV0IGk9MCwgbGVuPXZhbC5sZW5ndGg7IGk8bGVuOyArK2kpXG4gICAgICB2YWxbaV0gPSByZXNvbHZlSW50ZXJuYWxUeXBlcyh2YWxbaV0pO1xuICB9XG4gIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEZQX1R5cGUpIHtcbiAgICB2YWwgPSB2YWwudG9TdHJpbmcoKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXModmFsKSlcbiAgICAgIHZhbFtrXSA9IHJlc29sdmVJbnRlcm5hbFR5cGVzKHZhbFtrXSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiAgRXZhbHVhdGVzIHRoZSBcInBhdGhcIiBGSElSUGF0aCBleHByZXNzaW9uIG9uIHRoZSBnaXZlbiByZXNvdXJjZSBvciBwYXJ0IG9mIHRoZSByZXNvdXJjZSxcbiAqICB1c2luZyBkYXRhIGZyb20gXCJjb250ZXh0XCIgZm9yIHZhcmlhYmxlcyBtZW50aW9uZWQgaW4gdGhlIFwicGF0aFwiIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0geyhvYmplY3R8b2JqZWN0W10pfSBmaGlyRGF0YSAtICBGSElSIHJlc291cmNlLCBwYXJ0IG9mIGEgcmVzb3VyY2UgKGluIHRoaXMgY2FzZVxuICogIHBhdGguYmFzZSBzaG91bGQgYmUgcHJvdmlkZWQpLCBidW5kbGUgYXMganMgb2JqZWN0IG9yIGFycmF5IG9mIHJlc291cmNlcy5cbiAqICBUaGlzIG9iamVjdC9hcnJheSB3aWxsIGJlIG1vZGlmaWVkIGJ5IHRoaXMgZnVuY3Rpb24gdG8gYWRkIHR5cGUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHBhdGggLSBzdHJpbmcgd2l0aCBGSElSUGF0aCBleHByZXNzaW9uLCBzYW1wbGUgJ1BhdGllbnQubmFtZS5naXZlbicsXG4gKiAgb3Igb2JqZWN0LCBpZiBmaGlyRGF0YSByZXByZXNlbnRzIHRoZSBwYXJ0IG9mIHRoZSBGSElSIHJlc291cmNlOlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGguYmFzZSAtIGJhc2UgcGF0aCBpbiByZXNvdXJjZSBmcm9tIHdoaWNoIGZoaXJEYXRhIHdhcyBleHRyYWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoLmV4cHJlc3Npb24gLSBGSElSUGF0aCBleHByZXNzaW9uIHJlbGF0aXZlIHRvIHBhdGguYmFzZVxuICogQHBhcmFtIHtvYmplY3R9IFtlbnZWYXJzXSAtIGEgaGFzaCBvZiB2YXJpYWJsZSBuYW1lL3ZhbHVlIHBhaXJzLlxuICogQHBhcmFtIHtvYmplY3R9IFttb2RlbF0gLSBUaGUgXCJtb2RlbFwiIGRhdGEgb2JqZWN0IHNwZWNpZmljIHRvIGEgZG9tYWluLCBlLmcuIFI0LlxuICogIEZvciBleGFtcGxlLCB5b3UgY291bGQgcGFzcyBpbiB0aGUgcmVzdWx0IG9mIHJlcXVpcmUoXCJmaGlycGF0aC9maGlyLWNvbnRleHQvcjRcIik7XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gYWRkaXRpb25hbCBvcHRpb25zOlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNvbHZlSW50ZXJuYWxUeXBlc10gLSB3aGV0aGVyIHZhbHVlcyBvZiBpbnRlcm5hbFxuICogIHR5cGVzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gc3RhbmRhcmQgSmF2YVNjcmlwdCB0eXBlcyAodHJ1ZSBieSBkZWZhdWx0KS5cbiAqICBJZiBmYWxzZSBpcyBwYXNzZWQsIHRoaXMgY29udmVyc2lvbiBjYW4gYmUgZG9uZSBsYXRlciBieSBjYWxsaW5nXG4gKiAgcmVzb2x2ZUludGVybmFsVHlwZXMoKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNlRm5dIC0gQW4gb3B0aW9uYWwgdHJhY2UgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRyYWNpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudXNlckludm9jYXRpb25UYWJsZV0gLSBhIHVzZXIgaW52b2NhdGlvbiB0YWJsZSB1c2VkXG4gKiAgdG8gcmVwbGFjZSBhbnkgZXhpc3Rpbmcgb3IgZGVmaW5lIG5ldyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5hc3luY10gLSBkZWZpbmVzIGhvdyB0byBzdXBwb3J0IGFzeW5jaHJvbm91cyBmdW5jdGlvbnM6XG4gKiAgZmFsc2Ugb3Igc2ltaWxhciB0byBmYWxzZSwgZS5nLiB1bmRlZmluZWQsIG51bGwsIG9yIDAgKGRlZmF1bHQpIC0gdGhyb3cgYW4gZXhjZXB0aW9uLFxuICogIHRydWUgb3Igc2ltaWxhciB0byB0cnVlIC0gcmV0dXJuIFByb21pc2UsIG9ubHkgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMsXG4gKiAgXCJhbHdheXNcIiAtIHJldHVybiBQcm9taXNlIGFsd2F5cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXJtaW5vbG9neVVybF0gLSBhIFVSTCB0aGF0IHBvaW50cyB0byBhIEZISVJcbiAqICAgUkVTVGZ1bCBBUEkgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSAldGVybWlub2xvZ2llcyB0aGF0IGltcGxlbWVudHNcbiAqICAgdGhlIFRlcm1pbm9sb2d5IFNlcnZpY2UgQVBJLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSAtIGFuIEFib3J0U2lnbmFsIG9iamVjdCB0aGF0IGFsbG93cyB5b3VcbiAqICAgdG8gYWJvcnQgdGhlIGFzeW5jaHJvbm91cyBGSElSUGF0aCBleHByZXNzaW9uIGV2YWx1YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlKGZoaXJEYXRhLCBwYXRoLCBlbnZWYXJzLCBtb2RlbCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcGlsZShwYXRoLCBtb2RlbCwgb3B0aW9ucykoZmhpckRhdGEsIGVudlZhcnMpO1xufVxuXG4vKipcbiAqICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlc291cmNlIG9yIHBhcnQgb2YgdGhlIHJlc291cmNlIGFuZCBhblxuICogIG9wdGlvbmFsIGNvbnRleHQgaGFzaCAoc2VlIFwiZXZhbHVhdGVcIiksIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZ1xuICogIHRoZSBnaXZlbiBGSElSUGF0aCBleHByZXNzaW9uIG9uIHRoYXQgcmVzb3VyY2UuICBUaGUgYWR2YW50YWdlIG9mIHRoaXNcbiAqICBmdW5jdGlvbiBvdmVyIFwiZXZhbHVhdGVcIiBpcyB0aGF0IGlmIHlvdSBoYXZlIG11bHRpcGxlIHJlc291cmNlcywgdGhlIGdpdmVuXG4gKiAgRkhJUlBhdGggZXhwcmVzc2lvbiB3aWxsIG9ubHkgYmUgcGFyc2VkIG9uY2UuXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHBhdGggLSBzdHJpbmcgd2l0aCBGSElSUGF0aCBleHByZXNzaW9uIHRvIGJlIHBhcnNlZCBvciBvYmplY3Q6XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aC5iYXNlIC0gYmFzZSBwYXRoIGluIHJlc291cmNlIGZyb20gd2hpY2ggYSBwYXJ0IG9mXG4gKiAgIHRoZSByZXNvdXJjZSB3YXMgZXh0cmFjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aC5leHByZXNzaW9uIC0gRkhJUlBhdGggZXhwcmVzc2lvbiByZWxhdGl2ZSB0byBwYXRoLmJhc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbbW9kZWxdIC0gVGhlIFwibW9kZWxcIiBkYXRhIG9iamVjdCBzcGVjaWZpYyB0byBhIGRvbWFpbiwgZS5nLiBSNC5cbiAqICBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHBhc3MgaW4gdGhlIHJlc3VsdCBvZiByZXF1aXJlKFwiZmhpcnBhdGgvZmhpci1jb250ZXh0L3I0XCIpO1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIGFkZGl0aW9uYWwgb3B0aW9uczpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzb2x2ZUludGVybmFsVHlwZXNdIC0gd2hldGhlciB2YWx1ZXMgb2YgaW50ZXJuYWxcbiAqICB0eXBlcyBzaG91bGQgYmUgY29udmVydGVkIHRvIHN0cmluZ3MsIHRydWUgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNlRm5dIC0gQW4gb3B0aW9uYWwgdHJhY2UgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRyYWNpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudXNlckludm9jYXRpb25UYWJsZV0gLSBhIHVzZXIgaW52b2NhdGlvbiB0YWJsZSB1c2VkXG4gKiAgdG8gcmVwbGFjZSBhbnkgZXhpc3Rpbmcgb3IgZGVmaW5lIG5ldyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5hc3luY10gLSBkZWZpbmVzIGhvdyB0byBzdXBwb3J0IGFzeW5jaHJvbm91cyBmdW5jdGlvbnM6XG4gKiAgZmFsc2Ugb3Igc2ltaWxhciB0byBmYWxzZSwgZS5nLiB1bmRlZmluZWQsIG51bGwsIG9yIDAgKGRlZmF1bHQpIC0gdGhyb3cgYW4gZXhjZXB0aW9uLFxuICogIHRydWUgb3Igc2ltaWxhciB0byB0cnVlIC0gcmV0dXJuIFByb21pc2UsIG9ubHkgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMsXG4gKiAgXCJhbHdheXNcIiAtIHJldHVybiBQcm9taXNlIGFsd2F5cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXJtaW5vbG9neVVybF0gLSBhIFVSTCB0aGF0IHBvaW50cyB0byBhIEZISVJcbiAqICAgUkVTVGZ1bCBBUEkgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSAldGVybWlub2xvZ2llcyB0aGF0IGltcGxlbWVudHNcbiAqICAgdGhlIFRlcm1pbm9sb2d5IFNlcnZpY2UgQVBJLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSAtIGFuIEFib3J0U2lnbmFsIG9iamVjdCB0aGF0IGFsbG93cyB5b3VcbiAqICAgdG8gYWJvcnQgdGhlIGFzeW5jaHJvbm91cyBGSElSUGF0aCBleHByZXNzaW9uIGV2YWx1YXRpb24uIFBhc3NpbmcgYSBzaWduYWxcbiAqICAgdG8gY29tcGlsZSgpIHdob3NlIHJlc3VsdCBpcyB1c2VkIG1vcmUgdGhhbiBvbmNlIHdpbGwgY2F1c2UgYWJvcnRpb25cbiAqICAgcHJvYmxlbXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUocGF0aCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHtcbiAgICByZXNvbHZlSW50ZXJuYWxUeXBlczogdHJ1ZSxcbiAgICAuLi4gb3B0aW9uc1xuICB9O1xuXG4gIGNvbnN0IHVzZXJJbnZvY2F0aW9uVGFibGUgPSBvcHRpb25zLnVzZXJJbnZvY2F0aW9uVGFibGU7XG4gIGlmICh1c2VySW52b2NhdGlvblRhYmxlKSB7XG4gICAgb3B0aW9ucy51c2VySW52b2NhdGlvblRhYmxlID0gT2JqZWN0LmtleXModXNlckludm9jYXRpb25UYWJsZSkucmVkdWNlKFxuICAgICAgKGludm9jYXRpb25UYWJsZSwgZm5OYW1lKSA9PiB7XG4gICAgICAgIGlmICh1c2VySW52b2NhdGlvblRhYmxlW2ZuTmFtZV0uaW50ZXJuYWxTdHJ1Y3R1cmVzKSB7XG4gICAgICAgICAgaW52b2NhdGlvblRhYmxlW2ZuTmFtZV0gPSB1c2VySW52b2NhdGlvblRhYmxlW2ZuTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52b2NhdGlvblRhYmxlW2ZuTmFtZV0gPSB7XG4gICAgICAgICAgICAuLi51c2VySW52b2NhdGlvblRhYmxlW2ZuTmFtZV0sXG4gICAgICAgICAgICBmbjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVzZXJJbnZvY2F0aW9uVGFibGVbZm5OYW1lXS5mbi5hcHBseShcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGNoZWNrIEFycmF5LmlzQXJyYXkoYXJnKSwgd2UgYXJlIGNoZWNraW5nIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZXRvbiBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQuIEFuIGFsdGVybmF0aXZlIHRvIHRoaXMgaXNcbiAgICAgICAgICAgICAgICAvLyB0byBjaGVjayB0aGF0IHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudCBpcyBJbnRlZ2VyLCBCb29sZWFuLFxuICAgICAgICAgICAgICAgIC8vIE51bWJlciwgb3IgU3RyaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMsIGFyZ3MubWFwKGFyZyA9PiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcubWFwKGl0ZW0gPT4gdXRpbC52YWxEYXRhKGl0ZW0pKSA6IGFyZylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnZvY2F0aW9uVGFibGU7XG4gICAgICB9LCB7fSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhcnNlKHBhdGguZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaGlyRGF0YSwgZW52VmFycywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXRoLmJhc2UpIHtcbiAgICAgICAgbGV0IGJhc2VQYXRoID0gbW9kZWwucGF0aHNEZWZpbmVkRWxzZXdoZXJlW3BhdGguYmFzZV0gfHwgcGF0aC5iYXNlO1xuICAgICAgICBjb25zdCBiYXNlRmhpck5vZGVEYXRhVHlwZSA9IG1vZGVsICYmIG1vZGVsLnBhdGgyVHlwZVtiYXNlUGF0aF07XG4gICAgICAgIGJhc2VQYXRoID0gYmFzZUZoaXJOb2RlRGF0YVR5cGUgPT09ICdCYWNrYm9uZUVsZW1lbnQnIHx8IGJhc2VGaGlyTm9kZURhdGFUeXBlID09PSAnRWxlbWVudCcgPyBiYXNlUGF0aCA6IGJhc2VGaGlyTm9kZURhdGFUeXBlIHx8IGJhc2VQYXRoO1xuXG4gICAgICAgIGZoaXJEYXRhID0gbWFrZVJlc05vZGUoZmhpckRhdGEsIG51bGwsIGJhc2VQYXRoLCBudWxsLCBiYXNlRmhpck5vZGVEYXRhVHlwZSwgbW9kZWwpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IGFkZGl0aW9uYWxPcHRpb25zID9cbiAgICAgICAgey4uLm9wdGlvbnMsIC4uLmFkZGl0aW9uYWxPcHRpb25zfSA6IG9wdGlvbnM7XG4gICAgICByZXR1cm4gYXBwbHlQYXJzZWRQYXRoKGZoaXJEYXRhLCBub2RlLCBlbnZWYXJzLCBtb2RlbCwgYWN0dWFsT3B0aW9ucyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub2RlID0gcGFyc2UocGF0aCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaGlyRGF0YSwgZW52VmFycywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBhZGRpdGlvbmFsT3B0aW9ucyA/XG4gICAgICAgIHsuLi5vcHRpb25zLCAuLi5hZGRpdGlvbmFsT3B0aW9uc30gOiBvcHRpb25zO1xuICAgICAgcmV0dXJuIGFwcGx5UGFyc2VkUGF0aChmaGlyRGF0YSwgbm9kZSwgZW52VmFycywgbW9kZWwsIGFjdHVhbE9wdGlvbnMpO1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGVhY2ggZWxlbWVudCBpbiBmaGlycGF0aFJlc3VsdCBhcnJheSB3aGljaCB3YXMgb2J0YWluZWRcbiAqIGZyb20gZXZhbHVhdGUoKSB3aXRoIG9wdGlvbiByZXNvbHZlSW50ZXJuYWxUeXBlcz1mYWxzZS5cbiAqIEBwYXJhbSB7YW55fSBmaGlycGF0aFJlc3VsdCAtIGEgcmVzdWx0IG9mIEZISVJQYXRoIGV4cHJlc3Npb24gZXZhbHVhdGlvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gYW4gYXJyYXkgb2YgdHlwZXMsIGUuZy4gWydGSElSLlF1YW50aXR5JywgJ0ZISVIuZGF0ZScsICdTeXN0ZW0uU3RyaW5nJ10uXG4gKi9cbmZ1bmN0aW9uIHR5cGVzRm4oZmhpcnBhdGhSZXN1bHQpIHtcbiAgcmV0dXJuIHV0aWwuYXJyYWlmeShmaGlycGF0aFJlc3VsdCkubWFwKHZhbHVlID0+IHtcbiAgICBjb25zdCB0aSA9IFR5cGVJbmZvLmZyb21WYWx1ZShcbiAgICAgIHZhbHVlPy5fX3BhdGhfX1xuICAgICAgICA/IG5ldyBSZXNvdXJjZU5vZGUodmFsdWUsIHZhbHVlLl9fcGF0aF9fPy5wYXJlbnRSZXNOb2RlLFxuICAgICAgICAgIHZhbHVlLl9fcGF0aF9fPy5wYXRoLCBudWxsLCB2YWx1ZS5fX3BhdGhfXz8uZmhpck5vZGVEYXRhVHlwZSwgdmFsdWUuX19wYXRoX18ubW9kZWwpXG4gICAgICAgIDogdmFsdWUgKTtcbiAgICByZXR1cm4gYCR7dGkubmFtZXNwYWNlfS4ke3RpLm5hbWV9YDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uLFxuICBwYXJzZSxcbiAgY29tcGlsZSxcbiAgZXZhbHVhdGUsXG4gIHJlc29sdmVJbnRlcm5hbFR5cGVzLFxuICB0eXBlczogdHlwZXNGbixcbiAgLy8gTWlnaHQgYXMgd2VsbCBleHBvcnQgdGhlIFVDVU0gbGlicmFyeSwgc2luY2Ugd2UgYXJlIHVzaW5nIGl0LlxuICB1Y3VtVXRpbHM6IHJlcXVpcmUoJ0BsaG5jYmMvdWN1bS1saGMnKS5VY3VtTGhjVXRpbHMuZ2V0SW5zdGFuY2UoKSxcbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgY3VzdG9tIGZ1bmN0aW9uc1xuICB1dGlsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/fhirpath.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of\n// the FHIRPath 1.0.0 specification).\n\n/**\n *  Adds the filtering and projection functions to the given FHIRPath engine.\n */\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst {TypeInfo, ResourceNode} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst hashObject = __webpack_require__(/*! ./hash-object */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js\");\nconst { deepEqual, maxCollSizeForDeepEqual } = __webpack_require__(/*! ./deep-equal */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/deep-equal.js\");\n\nvar engine = {};\nengine.whereMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const condition = expr(x);\n    if (condition instanceof Promise) {\n      return condition.then(c => c[0] ? x : []);\n    }\n    return condition[0] ? x : [];\n  }));\n};\n\nengine.extension = function(parentData, url) {\n  const ctx = this;\n  if(parentData !== false && ! parentData || !url) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const extensions = (x && (x.data && x.data.extension || x._data && x._data.extension));\n    if (extensions) {\n      return extensions\n        .filter(extension => extension.url === url)\n        .map(e => ResourceNode.makeResNode(e, x, 'Extension', null, 'Extension', ctx.model));\n    }\n    return [];\n  }));\n};\n\nengine.selectMacro = function(data, expr) {\n  if(data !== false && ! data) { return []; }\n  return util.flatten(data.map((x, i) => {\n    this.$index = i;\n    return expr(x);\n  }));\n};\n\nengine.repeatMacro = function(parentData, expr, state = { res: [], unique: {}, hasPrimitive: false }) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  let newItems = [].concat(...parentData.map(i => expr(i)));\n  if (newItems.some(i => i instanceof Promise)) {\n    return Promise.all(newItems).then(items => {\n      items = [].concat(...items);\n      if (items.length) {\n        return engine.repeatMacro(getNewItems(items, state), expr, state);\n      }\n      return state.res;\n    });\n  } else if (newItems.length) {\n    return engine.repeatMacro(getNewItems(newItems, state), expr, state);\n  } else {\n    return state.res;\n  }\n};\n\n/**\n * Returns new items from the input array that are not in the hash of existing\n * unique items and adds them to the result array.\n * @param {Array<*>} items - inout array.\n * @param {Object} state - current state object.\n * @param {{[key: string]: *}} state.unique - hash of existing unique items.\n * @param {Array<*>} state.res - result array.\n * @param {boolean} state.hasPrimitive - flag indicating if the result array has\n *  primitives.\n * @return {Array<*>}\n */\nfunction getNewItems(items, state) {\n  let newItems;\n  state.hasPrimitive = state.hasPrimitive || items.some(i => TypeInfo.isPrimitiveValue(i));\n  if (!state.hasPrimitive && items.length + state.res.length > maxCollSizeForDeepEqual) {\n    newItems = items.filter(item => {\n      const key = hashObject(item);\n      const isUnique = !state.unique[key];\n      if (isUnique) {\n        state.unique[key] = true;\n      }\n      return isUnique;\n    });\n    state.res.push.apply(state.res, newItems);\n  } else {\n    newItems = items.filter(item => {\n      const isUnique = !state.res.some(i => deepEqual(i, item));\n      if (isUnique) {\n        state.res.push(item);\n      }\n      return isUnique;\n    });\n  }\n  return newItems;\n}\n\n//TODO: behavior on object?\nengine.singleFn = function(x) {\n  if(x.length === 1){\n    return x;\n  } else if (x.length === 0) {\n    return [];\n  } else {\n    throw new Error(\"Expected single\");\n  }\n};\n\n\nengine.firstFn = function(x) {\n  return x[0];\n};\n\nengine.lastFn = function(x) {\n  return x[x.length - 1];\n};\n\nengine.tailFn = function(x) {\n  return x.slice(1, x.length);\n};\n\nengine.takeFn = function(x, n) {\n  return x.slice(0, n);\n};\n\nengine.skipFn = function(x, num) {\n  return x.slice(num, x.length);\n};\n\nengine.ofTypeFn = function(coll, typeInfo) {\n  const ctx = this;\n  return coll.filter(value => {\n    return TypeInfo.fromValue(value).is(typeInfo, ctx.model);\n  });\n};\n\nengine.distinctFn = function(x, hasPrimitive = undefined) {\n  let unique = [];\n  if (x.length > 0) {\n    hasPrimitive = hasPrimitive ?? x.some(i => TypeInfo.isPrimitiveValue(i));\n    if (!hasPrimitive && x.length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collection,\n      // we use a hash table (on JSON strings) for efficiency.\n      let uniqueHash = {};\n      for (let i = 0, len = x.length; i < len; ++i) {\n        let xObj = x[i];\n        let xStr = hashObject(xObj);\n        if (!uniqueHash[xStr]) {\n          unique.push(xObj);\n          uniqueHash[xStr] = true;\n        }\n      }\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      // Use reverse() + pop() instead of shift() to improve performance and\n      // maintain order.\n      x = x.concat().reverse();\n      do {\n        let xObj = x.pop();\n        unique.push(xObj);\n        x = x.filter(o => !deepEqual(xObj, o));\n      } while (x.length);\n    }\n  }\n  return unique;\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2ZpbHRlcmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTtBQUNsQyxPQUFPLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsK0ZBQVM7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsMkdBQWU7QUFDMUMsUUFBUSxxQ0FBcUMsRUFBRSxtQkFBTyxDQUFDLHlHQUFjOztBQUVyRTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBEQUEwRCxtQkFBbUIsdUJBQXVCO0FBQ3BHLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxtQkFBbUI7QUFDL0IsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2ZpbHRlcmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250YWlucyB0aGUgRkhJUlBhdGggRmlsdGVyaW5nIGFuZCBQcm9qZWN0aW9uIGZ1bmN0aW9ucy4gIChTZWN0aW9uIDUuMiBvZlxuLy8gdGhlIEZISVJQYXRoIDEuMC4wIHNwZWNpZmljYXRpb24pLlxuXG4vKipcbiAqICBBZGRzIHRoZSBmaWx0ZXJpbmcgYW5kIHByb2plY3Rpb24gZnVuY3Rpb25zIHRvIHRoZSBnaXZlbiBGSElSUGF0aCBlbmdpbmUuXG4gKi9cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpO1xuY29uc3Qge1R5cGVJbmZvLCBSZXNvdXJjZU5vZGV9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgaGFzaE9iamVjdCA9IHJlcXVpcmUoJy4vaGFzaC1vYmplY3QnKTtcbmNvbnN0IHsgZGVlcEVxdWFsLCBtYXhDb2xsU2l6ZUZvckRlZXBFcXVhbCB9ID0gcmVxdWlyZSgnLi9kZWVwLWVxdWFsJyk7XG5cbnZhciBlbmdpbmUgPSB7fTtcbmVuZ2luZS53aGVyZU1hY3JvID0gZnVuY3Rpb24ocGFyZW50RGF0YSwgZXhwcikge1xuICBpZihwYXJlbnREYXRhICE9PSBmYWxzZSAmJiAhIHBhcmVudERhdGEpIHsgcmV0dXJuIFtdOyB9XG5cbiAgcmV0dXJuIHV0aWwuZmxhdHRlbihwYXJlbnREYXRhLm1hcCgoeCwgaSkgPT4ge1xuICAgIHRoaXMuJGluZGV4ID0gaTtcbiAgICBjb25zdCBjb25kaXRpb24gPSBleHByKHgpO1xuICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uLnRoZW4oYyA9PiBjWzBdID8geCA6IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmRpdGlvblswXSA/IHggOiBbXTtcbiAgfSkpO1xufTtcblxuZW5naW5lLmV4dGVuc2lvbiA9IGZ1bmN0aW9uKHBhcmVudERhdGEsIHVybCkge1xuICBjb25zdCBjdHggPSB0aGlzO1xuICBpZihwYXJlbnREYXRhICE9PSBmYWxzZSAmJiAhIHBhcmVudERhdGEgfHwgIXVybCkgeyByZXR1cm4gW107IH1cblxuICByZXR1cm4gdXRpbC5mbGF0dGVuKHBhcmVudERhdGEubWFwKCh4LCBpKSA9PiB7XG4gICAgdGhpcy4kaW5kZXggPSBpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSAoeCAmJiAoeC5kYXRhICYmIHguZGF0YS5leHRlbnNpb24gfHwgeC5fZGF0YSAmJiB4Ll9kYXRhLmV4dGVuc2lvbikpO1xuICAgIGlmIChleHRlbnNpb25zKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udXJsID09PSB1cmwpXG4gICAgICAgIC5tYXAoZSA9PiBSZXNvdXJjZU5vZGUubWFrZVJlc05vZGUoZSwgeCwgJ0V4dGVuc2lvbicsIG51bGwsICdFeHRlbnNpb24nLCBjdHgubW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9KSk7XG59O1xuXG5lbmdpbmUuc2VsZWN0TWFjcm8gPSBmdW5jdGlvbihkYXRhLCBleHByKSB7XG4gIGlmKGRhdGEgIT09IGZhbHNlICYmICEgZGF0YSkgeyByZXR1cm4gW107IH1cbiAgcmV0dXJuIHV0aWwuZmxhdHRlbihkYXRhLm1hcCgoeCwgaSkgPT4ge1xuICAgIHRoaXMuJGluZGV4ID0gaTtcbiAgICByZXR1cm4gZXhwcih4KTtcbiAgfSkpO1xufTtcblxuZW5naW5lLnJlcGVhdE1hY3JvID0gZnVuY3Rpb24ocGFyZW50RGF0YSwgZXhwciwgc3RhdGUgPSB7IHJlczogW10sIHVuaXF1ZToge30sIGhhc1ByaW1pdGl2ZTogZmFsc2UgfSkge1xuICBpZihwYXJlbnREYXRhICE9PSBmYWxzZSAmJiAhIHBhcmVudERhdGEpIHsgcmV0dXJuIFtdOyB9XG5cbiAgbGV0IG5ld0l0ZW1zID0gW10uY29uY2F0KC4uLnBhcmVudERhdGEubWFwKGkgPT4gZXhwcihpKSkpO1xuICBpZiAobmV3SXRlbXMuc29tZShpID0+IGkgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChuZXdJdGVtcykudGhlbihpdGVtcyA9PiB7XG4gICAgICBpdGVtcyA9IFtdLmNvbmNhdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlbmdpbmUucmVwZWF0TWFjcm8oZ2V0TmV3SXRlbXMoaXRlbXMsIHN0YXRlKSwgZXhwciwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLnJlcztcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChuZXdJdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZW5naW5lLnJlcGVhdE1hY3JvKGdldE5ld0l0ZW1zKG5ld0l0ZW1zLCBzdGF0ZSksIGV4cHIsIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGUucmVzO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgbmV3IGl0ZW1zIGZyb20gdGhlIGlucHV0IGFycmF5IHRoYXQgYXJlIG5vdCBpbiB0aGUgaGFzaCBvZiBleGlzdGluZ1xuICogdW5pcXVlIGl0ZW1zIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGl0ZW1zIC0gaW5vdXQgYXJyYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgLSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAqIEBwYXJhbSB7e1trZXk6IHN0cmluZ106ICp9fSBzdGF0ZS51bmlxdWUgLSBoYXNoIG9mIGV4aXN0aW5nIHVuaXF1ZSBpdGVtcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0YXRlLnJlcyAtIHJlc3VsdCBhcnJheS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUuaGFzUHJpbWl0aXZlIC0gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSByZXN1bHQgYXJyYXkgaGFzXG4gKiAgcHJpbWl0aXZlcy5cbiAqIEByZXR1cm4ge0FycmF5PCo+fVxuICovXG5mdW5jdGlvbiBnZXROZXdJdGVtcyhpdGVtcywgc3RhdGUpIHtcbiAgbGV0IG5ld0l0ZW1zO1xuICBzdGF0ZS5oYXNQcmltaXRpdmUgPSBzdGF0ZS5oYXNQcmltaXRpdmUgfHwgaXRlbXMuc29tZShpID0+IFR5cGVJbmZvLmlzUHJpbWl0aXZlVmFsdWUoaSkpO1xuICBpZiAoIXN0YXRlLmhhc1ByaW1pdGl2ZSAmJiBpdGVtcy5sZW5ndGggKyBzdGF0ZS5yZXMubGVuZ3RoID4gbWF4Q29sbFNpemVGb3JEZWVwRXF1YWwpIHtcbiAgICBuZXdJdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGhhc2hPYmplY3QoaXRlbSk7XG4gICAgICBjb25zdCBpc1VuaXF1ZSA9ICFzdGF0ZS51bmlxdWVba2V5XTtcbiAgICAgIGlmIChpc1VuaXF1ZSkge1xuICAgICAgICBzdGF0ZS51bmlxdWVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNVbmlxdWU7XG4gICAgfSk7XG4gICAgc3RhdGUucmVzLnB1c2guYXBwbHkoc3RhdGUucmVzLCBuZXdJdGVtcyk7XG4gIH0gZWxzZSB7XG4gICAgbmV3SXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpc1VuaXF1ZSA9ICFzdGF0ZS5yZXMuc29tZShpID0+IGRlZXBFcXVhbChpLCBpdGVtKSk7XG4gICAgICBpZiAoaXNVbmlxdWUpIHtcbiAgICAgICAgc3RhdGUucmVzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNVbmlxdWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld0l0ZW1zO1xufVxuXG4vL1RPRE86IGJlaGF2aW9yIG9uIG9iamVjdD9cbmVuZ2luZS5zaW5nbGVGbiA9IGZ1bmN0aW9uKHgpIHtcbiAgaWYoeC5sZW5ndGggPT09IDEpe1xuICAgIHJldHVybiB4O1xuICB9IGVsc2UgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNpbmdsZVwiKTtcbiAgfVxufTtcblxuXG5lbmdpbmUuZmlyc3RGbiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHhbMF07XG59O1xuXG5lbmdpbmUubGFzdEZuID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xufTtcblxuZW5naW5lLnRhaWxGbiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHguc2xpY2UoMSwgeC5sZW5ndGgpO1xufTtcblxuZW5naW5lLnRha2VGbiA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgcmV0dXJuIHguc2xpY2UoMCwgbik7XG59O1xuXG5lbmdpbmUuc2tpcEZuID0gZnVuY3Rpb24oeCwgbnVtKSB7XG4gIHJldHVybiB4LnNsaWNlKG51bSwgeC5sZW5ndGgpO1xufTtcblxuZW5naW5lLm9mVHlwZUZuID0gZnVuY3Rpb24oY29sbCwgdHlwZUluZm8pIHtcbiAgY29uc3QgY3R4ID0gdGhpcztcbiAgcmV0dXJuIGNvbGwuZmlsdGVyKHZhbHVlID0+IHtcbiAgICByZXR1cm4gVHlwZUluZm8uZnJvbVZhbHVlKHZhbHVlKS5pcyh0eXBlSW5mbywgY3R4Lm1vZGVsKTtcbiAgfSk7XG59O1xuXG5lbmdpbmUuZGlzdGluY3RGbiA9IGZ1bmN0aW9uKHgsIGhhc1ByaW1pdGl2ZSA9IHVuZGVmaW5lZCkge1xuICBsZXQgdW5pcXVlID0gW107XG4gIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICBoYXNQcmltaXRpdmUgPSBoYXNQcmltaXRpdmUgPz8geC5zb21lKGkgPT4gVHlwZUluZm8uaXNQcmltaXRpdmVWYWx1ZShpKSk7XG4gICAgaWYgKCFoYXNQcmltaXRpdmUgJiYgeC5sZW5ndGggPiBtYXhDb2xsU2l6ZUZvckRlZXBFcXVhbCkge1xuICAgICAgLy8gV2hlbiB3ZSBoYXZlIG1vcmUgdGhhbiBtYXhDb2xsU2l6ZUZvckRlZXBFcXVhbCBpdGVtcyBpbiBpbnB1dCBjb2xsZWN0aW9uLFxuICAgICAgLy8gd2UgdXNlIGEgaGFzaCB0YWJsZSAob24gSlNPTiBzdHJpbmdzKSBmb3IgZWZmaWNpZW5jeS5cbiAgICAgIGxldCB1bmlxdWVIYXNoID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgeE9iaiA9IHhbaV07XG4gICAgICAgIGxldCB4U3RyID0gaGFzaE9iamVjdCh4T2JqKTtcbiAgICAgICAgaWYgKCF1bmlxdWVIYXNoW3hTdHJdKSB7XG4gICAgICAgICAgdW5pcXVlLnB1c2goeE9iaik7XG4gICAgICAgICAgdW5pcXVlSGFzaFt4U3RyXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBtb3JlIGVmZmljaWVudCB0byBwZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uLlxuICAgICAgLy8gVXNlIHJldmVyc2UoKSArIHBvcCgpIGluc3RlYWQgb2Ygc2hpZnQoKSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGFuZFxuICAgICAgLy8gbWFpbnRhaW4gb3JkZXIuXG4gICAgICB4ID0geC5jb25jYXQoKS5yZXZlcnNlKCk7XG4gICAgICBkbyB7XG4gICAgICAgIGxldCB4T2JqID0geC5wb3AoKTtcbiAgICAgICAgdW5pcXVlLnB1c2goeE9iaik7XG4gICAgICAgIHggPSB4LmZpbHRlcihvID0+ICFkZWVwRXF1YWwoeE9iaiwgbykpO1xuICAgICAgfSB3aGlsZSAoeC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pcXVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbmdpbmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/filtering.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ucumUtils = (__webpack_require__(/*! @lhncbc/ucum-lhc */ \"(ssr)/../node_modules/.pnpm/@lhncbc+ucum-lhc@5.0.4/node_modules/@lhncbc/ucum-lhc/source-cjs/ucumPkg.js\").UcumLhcUtils).getInstance();\nconst {roundToMaxPrecision} = __webpack_require__(/*! ./numbers */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js\");\nconst {valDataConverted} = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst {FP_Type, FP_Quantity} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\n\n/**\n *  Returns a JSON version of the given object, but with the object's keys\n *  in sorted order (or at least stable order,\n *  see https://stackoverflow.com/a/35810961/360782) and the values in\n *  unified forms, e.g. \"1 year\" is converted to the same value as \"12 months\",\n *  \"3 'min'\" is converted to the same value as \"120 'sec'\".\n *  This function is used instead of deepEqual for optimization when you need\n *  to compare many objects.\n */\nfunction hashObject(obj) {\n  return JSON.stringify(prepareObject(obj));\n}\n\n/**\n * Brings an object to the unified form so that it can be serialized to JSON to\n * compare with other objects according to https://hl7.org/fhirpath/#equals\n * This function is following the logic from deepEqual (if changes are needed\n * here they are likely also needed there).\n */\nfunction prepareObject(value) {\n  value = valDataConverted(value);\n  if (value === null) {\n    return null;\n  } else if (typeof value === 'number') {\n    return roundToMaxPrecision(value);\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } if (value instanceof FP_Quantity) {\n    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];\n    if (magnitude) {\n      return '_!yearMonth!_:' + magnitude * value.value;\n    } else {\n      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);\n      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;\n      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;\n    }\n  } else if (value instanceof FP_Type) {\n    return value.toString();\n  } else if (typeof value === 'object') {\n    return Array.isArray(value) ?\n      value.map(prepareObject) :\n      Object.keys(value).sort().reduce(\n        (o, key) => {\n          const v = value[key];\n          o[key] = prepareObject(v);\n          return o;\n        }, {});\n  }\n\n  return  value;\n}\n\nmodule.exports = hashObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2hhc2gtb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixvS0FBd0M7QUFDMUQsT0FBTyxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1HQUFXO0FBQ2pELE9BQU8sa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyx1R0FBYTtBQUNoRCxPQUFPLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsK0ZBQVM7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9oYXNoLW9iamVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1Y3VtVXRpbHMgPSByZXF1aXJlKCdAbGhuY2JjL3VjdW0tbGhjJykuVWN1bUxoY1V0aWxzLmdldEluc3RhbmNlKCk7XG5jb25zdCB7cm91bmRUb01heFByZWNpc2lvbn0gPSByZXF1aXJlKCcuL251bWJlcnMnKTtcbmNvbnN0IHt2YWxEYXRhQ29udmVydGVkfSA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG5jb25zdCB7RlBfVHlwZSwgRlBfUXVhbnRpdHl9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG4vKipcbiAqICBSZXR1cm5zIGEgSlNPTiB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBvYmplY3QsIGJ1dCB3aXRoIHRoZSBvYmplY3QncyBrZXlzXG4gKiAgaW4gc29ydGVkIG9yZGVyIChvciBhdCBsZWFzdCBzdGFibGUgb3JkZXIsXG4gKiAgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNTgxMDk2MS8zNjA3ODIpIGFuZCB0aGUgdmFsdWVzIGluXG4gKiAgdW5pZmllZCBmb3JtcywgZS5nLiBcIjEgeWVhclwiIGlzIGNvbnZlcnRlZCB0byB0aGUgc2FtZSB2YWx1ZSBhcyBcIjEyIG1vbnRoc1wiLFxuICogIFwiMyAnbWluJ1wiIGlzIGNvbnZlcnRlZCB0byB0aGUgc2FtZSB2YWx1ZSBhcyBcIjEyMCAnc2VjJ1wiLlxuICogIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGRlZXBFcXVhbCBmb3Igb3B0aW1pemF0aW9uIHdoZW4geW91IG5lZWRcbiAqICB0byBjb21wYXJlIG1hbnkgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaGFzaE9iamVjdChvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXBhcmVPYmplY3Qob2JqKSk7XG59XG5cbi8qKlxuICogQnJpbmdzIGFuIG9iamVjdCB0byB0aGUgdW5pZmllZCBmb3JtIHNvIHRoYXQgaXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTiB0b1xuICogY29tcGFyZSB3aXRoIG90aGVyIG9iamVjdHMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vaGw3Lm9yZy9maGlycGF0aC8jZXF1YWxzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvbGxvd2luZyB0aGUgbG9naWMgZnJvbSBkZWVwRXF1YWwgKGlmIGNoYW5nZXMgYXJlIG5lZWRlZFxuICogaGVyZSB0aGV5IGFyZSBsaWtlbHkgYWxzbyBuZWVkZWQgdGhlcmUpLlxuICovXG5mdW5jdGlvbiBwcmVwYXJlT2JqZWN0KHZhbHVlKSB7XG4gIHZhbHVlID0gdmFsRGF0YUNvbnZlcnRlZCh2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcm91bmRUb01heFByZWNpc2lvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gIH0gaWYgKHZhbHVlIGluc3RhbmNlb2YgRlBfUXVhbnRpdHkpIHtcbiAgICBjb25zdCBtYWduaXR1ZGUgPSBGUF9RdWFudGl0eS5feWVhck1vbnRoQ29udmVyc2lvbkZhY3Rvclt2YWx1ZS51bml0XTtcbiAgICBpZiAobWFnbml0dWRlKSB7XG4gICAgICByZXR1cm4gJ18heWVhck1vbnRoIV86JyArIG1hZ25pdHVkZSAqIHZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1Y3VtUXVhbnRpdHkgPSBGUF9RdWFudGl0eS50b1VjdW1RdWFudGl0eSh2YWx1ZS52YWx1ZSwgdmFsdWUudW5pdCk7XG4gICAgICBjb25zdCB1bml0ID0gdWN1bVV0aWxzLmdldFNwZWNpZmllZFVuaXQodWN1bVF1YW50aXR5LnVuaXQpLnVuaXQ7XG4gICAgICByZXR1cm4gJ18hJyArIHVuaXQucHJvcGVydHlfICsgJyFfOicgKyB1bml0Lm1hZ25pdHVkZV8gKiB1Y3VtUXVhbnRpdHkudmFsdWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRlBfVHlwZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgP1xuICAgICAgdmFsdWUubWFwKHByZXBhcmVPYmplY3QpIDpcbiAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKFxuICAgICAgICAobywga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tleV07XG4gICAgICAgICAgb1trZXldID0gcHJlcGFyZU9iamVjdCh2KTtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSwge30pO1xuICB9XG5cbiAgcmV0dXJuICB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/hash-object.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/logic.js":
/*!********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/logic.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("var engine = {};\n\nengine.orOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return true;\n    } else if (a === false) {\n      return [];\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  return a || b;\n};\n\nengine.andOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return false;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return [];\n    } else {\n      return false;\n    }\n  }\n  return a && b;\n};\n\nengine.xorOp = function(a, b) {\n  // If a or b are arrays, they must be the empty set.\n  // In that case, the result is always the empty set.\n  if (Array.isArray(a) || Array.isArray(b))\n    return [];\n  return ( a && !b ) || ( !a && b );\n};\n\nengine.impliesOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return true;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  if(a === false) { return true; }\n  return (a && b);\n};\n\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2xvZ2ljLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL2xvZ2ljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbmdpbmUgPSB7fTtcblxuZW5naW5lLm9yT3AgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmKEFycmF5LmlzQXJyYXkoYikpe1xuICAgIGlmKGEgPT09IHRydWUpe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChhID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGEpKXtcbiAgICBpZihiID09PSB0cnVlICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYSB8fCBiO1xufTtcblxuZW5naW5lLmFuZE9wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZihBcnJheS5pc0FycmF5KGIpKXtcbiAgICBpZihhID09PSB0cnVlKXtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKGEgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoYSkpe1xuICAgIGlmKGIgPT09IHRydWUgKXtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYSAmJiBiO1xufTtcblxuZW5naW5lLnhvck9wID0gZnVuY3Rpb24oYSwgYikge1xuICAvLyBJZiBhIG9yIGIgYXJlIGFycmF5cywgdGhleSBtdXN0IGJlIHRoZSBlbXB0eSBzZXQuXG4gIC8vIEluIHRoYXQgY2FzZSwgdGhlIHJlc3VsdCBpcyBhbHdheXMgdGhlIGVtcHR5IHNldC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgQXJyYXkuaXNBcnJheShiKSlcbiAgICByZXR1cm4gW107XG4gIHJldHVybiAoIGEgJiYgIWIgKSB8fCAoICFhICYmIGIgKTtcbn07XG5cbmVuZ2luZS5pbXBsaWVzT3AgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmKEFycmF5LmlzQXJyYXkoYikpe1xuICAgIGlmKGEgPT09IHRydWUpe1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoYSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGEpKXtcbiAgICBpZihiID09PSB0cnVlICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBpZihhID09PSBmYWxzZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICByZXR1cm4gKGEgJiYgYik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/logic.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/math.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/math.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds code to hande the FHIRPath Math functions.\n\nconst {FP_Quantity, FP_Type} = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n\n/**\n *  Adds the math functions to the given FHIRPath engine.\n */\nconst engine = {};\n\n/**\n * Checks if input collection is a number singleton and runs the passed function.\n * @param {Array<ResourceNode|number|any>} x - input collection\n * @param {Function} fn - math function\n * @throws Error\n * @return {number}\n */\nfunction callFnForNumericSingleton(x, fn){\n  let res;\n  if (isEmpty(x)){\n    res = [];\n  } else if (x.length !== 1) {\n    throw new Error(\"Unexpected collection\" + JSON.stringify(x) +\n      \"; expected singleton of type number\");\n  } else {\n    const num = util.valData(x[0]);\n    if (num == null) {\n      res = [];\n    } else if (typeof num === 'number') {\n      res = fn(num);\n    } else {\n      throw new Error(\"Expected number, but got \" + JSON.stringify(num));\n    }\n  }\n  return res;\n}\n\nfunction isEmpty(x) {\n  if(typeof(x) == 'number'){\n    return false;\n  }\n  return x.length === 0;\n}\n\nengine.amp = function(x, y){\n  return (x || \"\") + (y || \"\");\n};\n\n//HACK: for only polymorphic function\n//  Actually, \"minus\" is now also polymorphic\nengine.plus = function(xs, ys){\n  let res;\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    // In the future, this and other functions might need to return ResourceNode\n    // to preserve the type information (integer vs decimal, and maybe decimal\n    // vs string if decimals are represented as strings), in order to support\n    // \"as\" and \"is\", but that support is deferred for now.\n    if (x == null || y == null) {\n      res = [];\n    } else if (typeof x == \"string\" && typeof y == \"string\") {\n      res = x + y;\n    } else if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        res = x + y;\n      } else if (y instanceof FP_Quantity) {\n        res = (new FP_Quantity(x, \"'1'\")).plus(y);\n      }\n    } else if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        res = x.plus(y);\n      } else if (y instanceof FP_Type) {\n        res = y.plus(x);\n      } else if (typeof y == \"number\") {\n        res = x.plus(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  if (res === undefined) {\n    throw new Error(\"Cannot \" + JSON.stringify(xs) + \" + \" + JSON.stringify(ys));\n  }\n  return res;\n};\n\nengine.minus = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        return x - y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).plus(new FP_Quantity(-y.value, y.unit));\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.plus(new FP_Quantity(-y.value, y.unit));\n      }\n      if (typeof y == \"number\") {\n        return x.plus(new FP_Quantity(-y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" - \" + JSON.stringify(ys));\n};\n\n\nengine.mul = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        return x * y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).mul(y);\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.mul(y);\n      }\n      if (typeof y == 'number') {\n        return x.mul(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" * \" + JSON.stringify(ys));\n};\n\nengine.div = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        if (y === 0) return [];\n        return x / y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).div(y);\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.div(y);\n      }\n      if (typeof y == \"number\") {\n        return x.div(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" / \" + JSON.stringify(ys));\n\n};\n\nengine.intdiv = function(x, y){\n  if (y === 0) return [];\n  return Math.floor(x / y);\n};\n\nengine.mod = function(x, y){\n  if (y === 0) return [];\n  return x % y;\n};\n\nengine.abs = function(x){\n  let res;\n\n  if (isEmpty(x)) {\n    res = [];\n  } else if (x.length !== 1) {\n    throw new Error(\"Unexpected collection\" + JSON.stringify(x) +\n      \"; expected singleton of type number or Quantity\");\n  } else {\n    var val = util.valData(x[0]);\n    if (val == null) {\n      res = [];\n    } else if (typeof val === 'number') {\n      res = Math.abs(val);\n    } else if (val instanceof FP_Quantity) {\n      res = new FP_Quantity(Math.abs(val.value), val.unit);\n    } else {\n      throw new Error(\"Expected number or Quantity, but got \" + JSON.stringify(val || x));\n    }\n  }\n\n  return res;\n};\n\nengine.ceiling = function(x) {\n  return callFnForNumericSingleton(x, Math.ceil);\n};\n\nengine.exp = function(x){\n  return callFnForNumericSingleton(x, Math.exp);\n};\n\nengine.floor = function(x){\n  return callFnForNumericSingleton(x, Math.floor);\n};\n\nengine.ln = function(x){\n  return callFnForNumericSingleton(x, Math.log);\n};\n\nengine.log = function(x, base){\n  return callFnForNumericSingleton(x, (num) => {\n    return (Math.log(num) / Math.log(base));\n  });\n};\n\nengine.power = function(x, exponent){\n  return callFnForNumericSingleton(x, (num) => {\n    const res = Math.pow(num, exponent);\n    return isNaN(res) ? [] : res;\n  });\n};\n\n/**\n * Implements the \"round\" function documented at\n * https://hl7.org/fhirpath/#roundprecision-integer-decimal\n * @param {Array} x - input collection\n * @param {integer} [precision] - determines what decimal place to round to\n * @return {number}\n */\nengine.round = function(x, precision){\n  return callFnForNumericSingleton(x, (num) => {\n    if (precision === undefined) {\n      return (Math.round(num));\n    } else {\n      let degree = Math.pow(10, precision);\n      return (Math.round(num * degree) / degree);\n    }\n  });\n};\n\nengine.sqrt = function(x){\n  return callFnForNumericSingleton(x, (num) => {\n    if (num < 0) {\n      return [];\n    } else {\n      return Math.sqrt(num);\n    }\n  });\n};\n\nengine.truncate = function(x){\n  return callFnForNumericSingleton(x, Math.trunc);\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL21hdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsT0FBTyxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLCtGQUFTO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyx1R0FBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vZmhpcnBhdGhAMy4xOC4wL25vZGVfbW9kdWxlcy9maGlycGF0aC9zcmMvbWF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaG9sZHMgY29kZSB0byBoYW5kZSB0aGUgRkhJUlBhdGggTWF0aCBmdW5jdGlvbnMuXG5cbmNvbnN0IHtGUF9RdWFudGl0eSwgRlBfVHlwZX0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xuXG4vKipcbiAqICBBZGRzIHRoZSBtYXRoIGZ1bmN0aW9ucyB0byB0aGUgZ2l2ZW4gRkhJUlBhdGggZW5naW5lLlxuICovXG5jb25zdCBlbmdpbmUgPSB7fTtcblxuLyoqXG4gKiBDaGVja3MgaWYgaW5wdXQgY29sbGVjdGlvbiBpcyBhIG51bWJlciBzaW5nbGV0b24gYW5kIHJ1bnMgdGhlIHBhc3NlZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8UmVzb3VyY2VOb2RlfG51bWJlcnxhbnk+fSB4IC0gaW5wdXQgY29sbGVjdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBtYXRoIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIEVycm9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNhbGxGbkZvck51bWVyaWNTaW5nbGV0b24oeCwgZm4pe1xuICBsZXQgcmVzO1xuICBpZiAoaXNFbXB0eSh4KSl7XG4gICAgcmVzID0gW107XG4gIH0gZWxzZSBpZiAoeC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNvbGxlY3Rpb25cIiArIEpTT04uc3RyaW5naWZ5KHgpICtcbiAgICAgIFwiOyBleHBlY3RlZCBzaW5nbGV0b24gb2YgdHlwZSBudW1iZXJcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbnVtID0gdXRpbC52YWxEYXRhKHhbMF0pO1xuICAgIGlmIChudW0gPT0gbnVsbCkge1xuICAgICAgcmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgICAgcmVzID0gZm4obnVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbnVtYmVyLCBidXQgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkobnVtKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkoeCkge1xuICBpZih0eXBlb2YoeCkgPT0gJ251bWJlcicpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4geC5sZW5ndGggPT09IDA7XG59XG5cbmVuZ2luZS5hbXAgPSBmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuICh4IHx8IFwiXCIpICsgKHkgfHwgXCJcIik7XG59O1xuXG4vL0hBQ0s6IGZvciBvbmx5IHBvbHltb3JwaGljIGZ1bmN0aW9uXG4vLyAgQWN0dWFsbHksIFwibWludXNcIiBpcyBub3cgYWxzbyBwb2x5bW9ycGhpY1xuZW5naW5lLnBsdXMgPSBmdW5jdGlvbih4cywgeXMpe1xuICBsZXQgcmVzO1xuICBpZih4cy5sZW5ndGggPT09IDEgJiYgeXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgeCA9IHV0aWwudmFsRGF0YUNvbnZlcnRlZCh4c1swXSk7XG4gICAgY29uc3QgeSA9IHV0aWwudmFsRGF0YUNvbnZlcnRlZCh5c1swXSk7XG4gICAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBhbmQgb3RoZXIgZnVuY3Rpb25zIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIFJlc291cmNlTm9kZVxuICAgIC8vIHRvIHByZXNlcnZlIHRoZSB0eXBlIGluZm9ybWF0aW9uIChpbnRlZ2VyIHZzIGRlY2ltYWwsIGFuZCBtYXliZSBkZWNpbWFsXG4gICAgLy8gdnMgc3RyaW5nIGlmIGRlY2ltYWxzIGFyZSByZXByZXNlbnRlZCBhcyBzdHJpbmdzKSwgaW4gb3JkZXIgdG8gc3VwcG9ydFxuICAgIC8vIFwiYXNcIiBhbmQgXCJpc1wiLCBidXQgdGhhdCBzdXBwb3J0IGlzIGRlZmVycmVkIGZvciBub3cuXG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHJlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXMgPSB4ICsgeTtcbiAgICB9IGVsc2UgaWYodHlwZW9mIHggPT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHR5cGVvZiB5ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmVzID0geCArIHk7XG4gICAgICB9IGVsc2UgaWYgKHkgaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgICAgICByZXMgPSAobmV3IEZQX1F1YW50aXR5KHgsIFwiJzEnXCIpKS5wbHVzKHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih4IGluc3RhbmNlb2YgRlBfVHlwZSkge1xuICAgICAgaWYgKHkgaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgICAgICByZXMgPSB4LnBsdXMoeSk7XG4gICAgICB9IGVsc2UgaWYgKHkgaW5zdGFuY2VvZiBGUF9UeXBlKSB7XG4gICAgICAgIHJlcyA9IHkucGx1cyh4KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHkgPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXMgPSB4LnBsdXMobmV3IEZQX1F1YW50aXR5KHksIFwiJzEnXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IFwiICsgSlNPTi5zdHJpbmdpZnkoeHMpICsgXCIgKyBcIiArIEpTT04uc3RyaW5naWZ5KHlzKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmVuZ2luZS5taW51cyA9IGZ1bmN0aW9uKHhzLCB5cyl7XG4gIGlmKHhzLmxlbmd0aCA9PT0gMSAmJiB5cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB4ID0gdXRpbC52YWxEYXRhQ29udmVydGVkKHhzWzBdKTtcbiAgICBjb25zdCB5ID0gdXRpbC52YWxEYXRhQ29udmVydGVkKHlzWzBdKTtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZih0eXBlb2YgeCA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodHlwZW9mIHkgPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geCAtIHk7XG4gICAgICB9XG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEZQX1F1YW50aXR5KSB7XG4gICAgICAgIHJldHVybiAobmV3IEZQX1F1YW50aXR5KHgsIFwiJzEnXCIpKS5wbHVzKG5ldyBGUF9RdWFudGl0eSgteS52YWx1ZSwgeS51bml0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoeCBpbnN0YW5jZW9mIEZQX1R5cGUpIHtcbiAgICAgIGlmICh5IGluc3RhbmNlb2YgRlBfUXVhbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHgucGx1cyhuZXcgRlBfUXVhbnRpdHkoLXkudmFsdWUsIHkudW5pdCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB5ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHgucGx1cyhuZXcgRlBfUXVhbnRpdHkoLXksIFwiJzEnXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IFwiICsgSlNPTi5zdHJpbmdpZnkoeHMpICsgXCIgLSBcIiArIEpTT04uc3RyaW5naWZ5KHlzKSk7XG59O1xuXG5cbmVuZ2luZS5tdWwgPSBmdW5jdGlvbih4cywgeXMpe1xuICBpZih4cy5sZW5ndGggPT09IDEgJiYgeXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgeCA9IHV0aWwudmFsRGF0YUNvbnZlcnRlZCh4c1swXSk7XG4gICAgY29uc3QgeSA9IHV0aWwudmFsRGF0YUNvbnZlcnRlZCh5c1swXSk7XG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYodHlwZW9mIHggPT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHR5cGVvZiB5ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHggKiB5O1xuICAgICAgfVxuICAgICAgaWYgKHkgaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgICAgICByZXR1cm4gKG5ldyBGUF9RdWFudGl0eSh4LCBcIicxJ1wiKSkubXVsKHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHggaW5zdGFuY2VvZiBGUF9UeXBlKSB7XG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEZQX1F1YW50aXR5KSB7XG4gICAgICAgIHJldHVybiB4Lm11bCh5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgeSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4geC5tdWwobmV3IEZQX1F1YW50aXR5KHksIFwiJzEnXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IFwiICsgSlNPTi5zdHJpbmdpZnkoeHMpICsgXCIgKiBcIiArIEpTT04uc3RyaW5naWZ5KHlzKSk7XG59O1xuXG5lbmdpbmUuZGl2ID0gZnVuY3Rpb24oeHMsIHlzKXtcbiAgaWYoeHMubGVuZ3RoID09PSAxICYmIHlzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHggPSB1dGlsLnZhbERhdGFDb252ZXJ0ZWQoeHNbMF0pO1xuICAgIGNvbnN0IHkgPSB1dGlsLnZhbERhdGFDb252ZXJ0ZWQoeXNbMF0pO1xuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmKHR5cGVvZiB4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgeSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICh5ID09PSAwKSByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB4IC8geTtcbiAgICAgIH1cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgRlBfUXVhbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRlBfUXVhbnRpdHkoeCwgXCInMSdcIikpLmRpdih5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih4IGluc3RhbmNlb2YgRlBfVHlwZSkge1xuICAgICAgaWYgKHkgaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgICAgICByZXR1cm4geC5kaXYoeSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHkgPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geC5kaXYobmV3IEZQX1F1YW50aXR5KHksIFwiJzEnXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IFwiICsgSlNPTi5zdHJpbmdpZnkoeHMpICsgXCIgLyBcIiArIEpTT04uc3RyaW5naWZ5KHlzKSk7XG5cbn07XG5cbmVuZ2luZS5pbnRkaXYgPSBmdW5jdGlvbih4LCB5KXtcbiAgaWYgKHkgPT09IDApIHJldHVybiBbXTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHkpO1xufTtcblxuZW5naW5lLm1vZCA9IGZ1bmN0aW9uKHgsIHkpe1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIFtdO1xuICByZXR1cm4geCAlIHk7XG59O1xuXG5lbmdpbmUuYWJzID0gZnVuY3Rpb24oeCl7XG4gIGxldCByZXM7XG5cbiAgaWYgKGlzRW1wdHkoeCkpIHtcbiAgICByZXMgPSBbXTtcbiAgfSBlbHNlIGlmICh4Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY29sbGVjdGlvblwiICsgSlNPTi5zdHJpbmdpZnkoeCkgK1xuICAgICAgXCI7IGV4cGVjdGVkIHNpbmdsZXRvbiBvZiB0eXBlIG51bWJlciBvciBRdWFudGl0eVwiKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsID0gdXRpbC52YWxEYXRhKHhbMF0pO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmVzID0gTWF0aC5hYnModmFsKTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEZQX1F1YW50aXR5KSB7XG4gICAgICByZXMgPSBuZXcgRlBfUXVhbnRpdHkoTWF0aC5hYnModmFsLnZhbHVlKSwgdmFsLnVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBudW1iZXIgb3IgUXVhbnRpdHksIGJ1dCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwgfHwgeCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5lbmdpbmUuY2VpbGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGNhbGxGbkZvck51bWVyaWNTaW5nbGV0b24oeCwgTWF0aC5jZWlsKTtcbn07XG5cbmVuZ2luZS5leHAgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIGNhbGxGbkZvck51bWVyaWNTaW5nbGV0b24oeCwgTWF0aC5leHApO1xufTtcblxuZW5naW5lLmZsb29yID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiBjYWxsRm5Gb3JOdW1lcmljU2luZ2xldG9uKHgsIE1hdGguZmxvb3IpO1xufTtcblxuZW5naW5lLmxuID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiBjYWxsRm5Gb3JOdW1lcmljU2luZ2xldG9uKHgsIE1hdGgubG9nKTtcbn07XG5cbmVuZ2luZS5sb2cgPSBmdW5jdGlvbih4LCBiYXNlKXtcbiAgcmV0dXJuIGNhbGxGbkZvck51bWVyaWNTaW5nbGV0b24oeCwgKG51bSkgPT4ge1xuICAgIHJldHVybiAoTWF0aC5sb2cobnVtKSAvIE1hdGgubG9nKGJhc2UpKTtcbiAgfSk7XG59O1xuXG5lbmdpbmUucG93ZXIgPSBmdW5jdGlvbih4LCBleHBvbmVudCl7XG4gIHJldHVybiBjYWxsRm5Gb3JOdW1lcmljU2luZ2xldG9uKHgsIChudW0pID0+IHtcbiAgICBjb25zdCByZXMgPSBNYXRoLnBvdyhudW0sIGV4cG9uZW50KTtcbiAgICByZXR1cm4gaXNOYU4ocmVzKSA/IFtdIDogcmVzO1xuICB9KTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJyb3VuZFwiIGZ1bmN0aW9uIGRvY3VtZW50ZWQgYXRcbiAqIGh0dHBzOi8vaGw3Lm9yZy9maGlycGF0aC8jcm91bmRwcmVjaXNpb24taW50ZWdlci1kZWNpbWFsXG4gKiBAcGFyYW0ge0FycmF5fSB4IC0gaW5wdXQgY29sbGVjdGlvblxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcHJlY2lzaW9uXSAtIGRldGVybWluZXMgd2hhdCBkZWNpbWFsIHBsYWNlIHRvIHJvdW5kIHRvXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmVuZ2luZS5yb3VuZCA9IGZ1bmN0aW9uKHgsIHByZWNpc2lvbil7XG4gIHJldHVybiBjYWxsRm5Gb3JOdW1lcmljU2luZ2xldG9uKHgsIChudW0pID0+IHtcbiAgICBpZiAocHJlY2lzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAoTWF0aC5yb3VuZChudW0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlZ3JlZSA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKG51bSAqIGRlZ3JlZSkgLyBkZWdyZWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5lbmdpbmUuc3FydCA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4gY2FsbEZuRm9yTnVtZXJpY1NpbmdsZXRvbih4LCAobnVtKSA9PiB7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChudW0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5lbmdpbmUudHJ1bmNhdGUgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIGNhbGxGbkZvck51bWVyaWNTaW5nbGV0b24oeCwgTWF0aC50cnVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/math.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nvar util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nvar types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\n\nconst { FP_Quantity, TypeInfo } = types;\n\nvar engine = {};\n\nengine.iifMacro = function(data, cond, ok, fail) {\n  const condition = cond(data);\n  if (condition instanceof Promise) {\n    return condition.then(c => iifMacroSync(data, c, ok, fail));\n  }\n  return iifMacroSync(data, condition, ok, fail);\n};\n\nfunction iifMacroSync(data, condition, ok, fail) {\n  if(util.isTrue(condition)) {\n    return ok(data);\n  } else {\n    return fail ? fail(data) : [];\n  }\n}\n\nengine.traceFn = function (x, label, expr) {\n  const exprRes = expr ? expr(x) : null;\n  if (exprRes instanceof Promise) {\n    return exprRes.then((r) => engine.traceFn(x, label, r));\n  }\n  if (this.customTraceFn) {\n    if (expr){\n      this.customTraceFn(expr(x), label ?? \"\");\n    }\n    else {\n      this.customTraceFn(x, label ?? \"\");\n    }\n  }\n  else {\n    if (expr){\n      console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(expr(x), null, \" \"));\n    }\n    else {\n      console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(x, null, \" \"));\n    }\n  }\n  return x;\n};\n\n/**\n * Defines a variable named name that is accessible in subsequent expressions\n * and has the value of expr if present, otherwise the value of the input\n * collection.\n * @param {Array} x - the input collection on which the function is executed\n * @param {string} label - the name of the variable to define\n * @param {*} [expr] - an expression to run on the input collection\n * @returns the value of the input collection (The function should be transparent\n *  to the caller)\n */\nengine.defineVariable = function (x, label, expr) {\n  let data = x;\n  if (expr){\n    data = expr(x);\n  }\n  // Just in time initialization of definedVars\n  if (!this.definedVars) this.definedVars = {};\n\n  if (label in this.vars || label in this.processedVars) {\n    throw new Error(\"Environment Variable %\" + label + \" already defined\");\n  }\n\n  if (Object.keys(this.definedVars).includes(label)) {\n    throw new Error(\"Variable %\" + label + \" already defined\");\n  }\n\n  this.definedVars[label] = data;\n  return x;\n};\n\nvar intRegex = /^[+-]?\\d+$/;\nengine.toInteger = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1;}\n  if(typeof v === \"number\") {\n    if(Number.isInteger(v)) {\n      return v;\n    } else {\n      return [];\n    }\n  }\n  if(typeof v === \"string\" && intRegex.test(v)) {\n    return parseInt(v);\n  }\n  return [];\n};\n\nconst quantityRegex = /^((\\+|-)?\\d+(\\.\\d+)?)\\s*(('[^']+')|([a-zA-Z]+))?$/,\n  quantityRegexMap = {value:1,unit:5,time:6};\nengine.toQuantity = function (coll, toUnit) {\n  let result;\n\n  if (coll.length > 1) {\n    throw new Error(\"Could not convert to quantity: input collection contains multiple items\");\n  } else if (coll.length === 1) {\n    if (toUnit) {\n      const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n      const toUnitInSeconds = FP_Quantity._calendarDuration2Seconds[toUnit];\n      if (\n        !thisUnitInSeconds !== !toUnitInSeconds &&\n        (thisUnitInSeconds > 1 || toUnitInSeconds > 1)\n      ) {\n        // Conversion from calendar duration quantities greater than seconds to\n        // time-valued UCUM quantities greater than seconds or vice versa is not\n        // allowed.\n        return null;\n      }\n\n      // Surround UCUM unit code in the toUnit parameter with single quotes\n      if (!FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {\n        toUnit = `'${toUnit}'`;\n      }\n    }\n\n    var v = util.valDataConverted(coll[0]);\n    let quantityRegexRes;\n\n    if (typeof v === \"number\") {\n      result = new FP_Quantity(v, '\\'1\\'');\n    } else if (v instanceof FP_Quantity) {\n      result = v;\n    } else if (typeof v === 'boolean') {\n      result = new FP_Quantity(v ? 1 : 0, '\\'1\\'');\n    } else if (typeof v === \"string\" && (quantityRegexRes = quantityRegex.exec(v)) ) {\n      const value = quantityRegexRes[quantityRegexMap.value],\n        unit = quantityRegexRes[quantityRegexMap.unit],\n        time = quantityRegexRes[quantityRegexMap.time];\n\n      // UCUM unit code in the input string must be surrounded with single quotes\n      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {\n        result = new FP_Quantity(Number(value), unit || time || '\\'1\\'');\n      }\n    }\n\n    if (result && toUnit && result.unit !== toUnit) {\n      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);\n    }\n  }\n\n  return result || [];\n};\n\nvar numRegex = /^[+-]?\\d+(\\.\\d+)?$/;\nengine.toDecimal = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1.0;}\n  if(typeof v === \"number\") {\n    return v;\n  }\n  if(typeof v === \"string\" && numRegex.test(v)) {\n    return parseFloat(v);\n  }\n  return [];\n};\n\nengine.toString = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valDataConverted(coll[0]);\n  if (v == null) { return []; }\n  return v.toString();\n};\n\n\n/**\n *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).\n * @param timeType The string name of a class for a time type (e.g. \"FP_DateTime\").\n */\nfunction defineTimeConverter(timeType) {\n  let timeName = timeType.slice(3); // Remove 'FP_'\n  engine['to'+timeName] = function(coll) {\n    var rtn = [];\n    if (coll.length > 1)\n      throw Error('to '+timeName+' called for a collection of length '+coll.length);\n    if (coll.length === 1) {\n      var v = util.valData(coll[0]);\n      if (typeof v === \"string\") {\n        var t = types[timeType].checkString(v);\n        if (t) {\n          rtn = t;\n        }\n      }\n    }\n    return rtn;\n  };\n}\ndefineTimeConverter('FP_Date');\ndefineTimeConverter('FP_DateTime');\ndefineTimeConverter('FP_Time');\n\n// Possible string values convertible to the true boolean value\nconst trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\n// Possible string values convertible to the false boolean value\nconst falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\nengine.toBoolean = function (coll) {\n  if(coll.length !== 1) {\n    return [];\n  }\n\n  const v = util.valData(coll[0]);\n  switch (typeof v) {\n    case 'boolean':\n      return v;\n    case 'number':\n      if (v === 1) {\n        return true;\n      }\n      if (v === 0) {\n        return false;\n      }\n      break;\n    case 'string':\n      // eslint-disable-next-line no-case-declarations\n      const lowerCaseValue = v.toLowerCase();\n      if (trueStrings[lowerCaseValue]) {\n        return true;\n      }\n      if (falseStrings[lowerCaseValue]) {\n        return false;\n      }\n  }\n  return [];\n};\n\n/**\n * Creates function that checks if toFunction returns specified type\n * @param {function(coll: array): <type|[]>} toFunction\n * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity\n * @return {function(coll: array)}\n */\nengine.createConvertsToFn = function (toFunction, type) {\n  if (typeof type === 'string') {\n    return function (coll) {\n      if (coll.length !== 1) {\n        return [];\n      }\n\n      return typeof toFunction(coll) === type;\n    };\n  }\n\n  return function (coll) {\n    if (coll.length !== 1) {\n      return [];\n    }\n\n    return toFunction(coll) instanceof type;\n  };\n};\n\nconst singletonEvalByType = {\n  \"Integer\": function(d){\n    if (Number.isInteger(d)) {\n      return d;\n    }\n  },\n  \"Boolean\": function(d){\n    if (d === true || d === false) {\n      return d;\n    } else {\n      return true;\n    }\n  },\n  \"Number\": function(d) {\n    if (typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"String\": function(d){\n    if (typeof d === \"string\") {\n      return d;\n    }\n  },\n  \"StringOrNumber\": function(d){\n    if (typeof d === \"string\" || typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"AnySingletonAtRoot\": function (d) {\n    return d;\n  }\n};\n\n/**\n * Converts a collection to a singleton of the specified type.\n * The result can be an empty array if input collection is empty.\n * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.\n * @param {Array} coll - collection\n * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'\n * @throws {Error}  if there is more than one item in input collection,\n *   or an item that is not a specified type\n * @return {*|[]} the value of specified type or empty array\n */\nengine.singleton = function (coll, type) {\n  if(coll.length > 1){\n    throw new Error(\"Unexpected collection\" + JSON.stringify(coll) +\n      \"; expected singleton of type \" + type);\n  } else if (coll.length === 0) {\n    return [];\n  }\n  const v = util.valData(coll[0]);\n  if (v == null) {\n    return [];\n  }\n  const toSingleton = singletonEvalByType[type];\n  if (toSingleton) {\n    const value = toSingleton(v);\n    if (value !== undefined) {\n      return value;\n    }\n    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);\n  }\n  throw new Error('Not supported type ' + type);\n};\n\nengine.hasValueFn = function(coll) {\n  return coll.length === 1 && util.valData(coll[0]) != null\n    && TypeInfo.isPrimitiveValue(coll[0]);\n};\n\n/**\n * Returns the underlying system value for the FHIR primitive if the input\n * collection contains a single value which is a FHIR primitive, and it has a\n * primitive value. Otherwise, the return value is empty (i.e. []).\n *\n * See: https://hl7.org/fhir/fhirpath.html#functions\n * @param {Array<*>} coll - input collection\n * @returns {*|[]}\n */\nengine.getValueFn = function(coll) {\n  if (coll.length === 1) {\n    const node = coll[0];\n    const v = util.valData(node);\n    if (v != null && TypeInfo.isPrimitiveValue(node)) {\n      return v;\n    }\n  }\n  return [];\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL21pc2MuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHVHQUFhO0FBQ2hDLFlBQVksbUJBQU8sQ0FBQywrRkFBUzs7QUFFN0IsUUFBUSx3QkFBd0I7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CLGFBQWEscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL21pc2MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBUaGlzIGZpbGUgaG9sZHMgY29kZSB0byBoYW5kZSB0aGUgRkhJUlBhdGggRXhpc3RlbmNlIGZ1bmN0aW9ucyAoNS4xIGluIHRoZVxuLy8gc3BlY2lmaWNhdGlvbikuXG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmNvbnN0IHsgRlBfUXVhbnRpdHksIFR5cGVJbmZvIH0gPSB0eXBlcztcblxudmFyIGVuZ2luZSA9IHt9O1xuXG5lbmdpbmUuaWlmTWFjcm8gPSBmdW5jdGlvbihkYXRhLCBjb25kLCBvaywgZmFpbCkge1xuICBjb25zdCBjb25kaXRpb24gPSBjb25kKGRhdGEpO1xuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHJldHVybiBjb25kaXRpb24udGhlbihjID0+IGlpZk1hY3JvU3luYyhkYXRhLCBjLCBvaywgZmFpbCkpO1xuICB9XG4gIHJldHVybiBpaWZNYWNyb1N5bmMoZGF0YSwgY29uZGl0aW9uLCBvaywgZmFpbCk7XG59O1xuXG5mdW5jdGlvbiBpaWZNYWNyb1N5bmMoZGF0YSwgY29uZGl0aW9uLCBvaywgZmFpbCkge1xuICBpZih1dGlsLmlzVHJ1ZShjb25kaXRpb24pKSB7XG4gICAgcmV0dXJuIG9rKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWlsID8gZmFpbChkYXRhKSA6IFtdO1xuICB9XG59XG5cbmVuZ2luZS50cmFjZUZuID0gZnVuY3Rpb24gKHgsIGxhYmVsLCBleHByKSB7XG4gIGNvbnN0IGV4cHJSZXMgPSBleHByID8gZXhwcih4KSA6IG51bGw7XG4gIGlmIChleHByUmVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHJldHVybiBleHByUmVzLnRoZW4oKHIpID0+IGVuZ2luZS50cmFjZUZuKHgsIGxhYmVsLCByKSk7XG4gIH1cbiAgaWYgKHRoaXMuY3VzdG9tVHJhY2VGbikge1xuICAgIGlmIChleHByKXtcbiAgICAgIHRoaXMuY3VzdG9tVHJhY2VGbihleHByKHgpLCBsYWJlbCA/PyBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmN1c3RvbVRyYWNlRm4oeCwgbGFiZWwgPz8gXCJcIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChleHByKXtcbiAgICAgIGNvbnNvbGUubG9nKFwiVFJBQ0U6W1wiICsgKGxhYmVsIHx8IFwiXCIpICsgXCJdXCIsIEpTT04uc3RyaW5naWZ5KGV4cHIoeCksIG51bGwsIFwiIFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJUUkFDRTpbXCIgKyAobGFiZWwgfHwgXCJcIikgKyBcIl1cIiwgSlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgXCIgXCIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYSB2YXJpYWJsZSBuYW1lZCBuYW1lIHRoYXQgaXMgYWNjZXNzaWJsZSBpbiBzdWJzZXF1ZW50IGV4cHJlc3Npb25zXG4gKiBhbmQgaGFzIHRoZSB2YWx1ZSBvZiBleHByIGlmIHByZXNlbnQsIG90aGVyd2lzZSB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gKiBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0geCAtIHRoZSBpbnB1dCBjb2xsZWN0aW9uIG9uIHdoaWNoIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGRlZmluZVxuICogQHBhcmFtIHsqfSBbZXhwcl0gLSBhbiBleHByZXNzaW9uIHRvIHJ1biBvbiB0aGUgaW5wdXQgY29sbGVjdGlvblxuICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBjb2xsZWN0aW9uIChUaGUgZnVuY3Rpb24gc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4gKiAgdG8gdGhlIGNhbGxlcilcbiAqL1xuZW5naW5lLmRlZmluZVZhcmlhYmxlID0gZnVuY3Rpb24gKHgsIGxhYmVsLCBleHByKSB7XG4gIGxldCBkYXRhID0geDtcbiAgaWYgKGV4cHIpe1xuICAgIGRhdGEgPSBleHByKHgpO1xuICB9XG4gIC8vIEp1c3QgaW4gdGltZSBpbml0aWFsaXphdGlvbiBvZiBkZWZpbmVkVmFyc1xuICBpZiAoIXRoaXMuZGVmaW5lZFZhcnMpIHRoaXMuZGVmaW5lZFZhcnMgPSB7fTtcblxuICBpZiAobGFiZWwgaW4gdGhpcy52YXJzIHx8IGxhYmVsIGluIHRoaXMucHJvY2Vzc2VkVmFycykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVudmlyb25tZW50IFZhcmlhYmxlICVcIiArIGxhYmVsICsgXCIgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGVmaW5lZFZhcnMpLmluY2x1ZGVzKGxhYmVsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlICVcIiArIGxhYmVsICsgXCIgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgdGhpcy5kZWZpbmVkVmFyc1tsYWJlbF0gPSBkYXRhO1xuICByZXR1cm4geDtcbn07XG5cbnZhciBpbnRSZWdleCA9IC9eWystXT9cXGQrJC87XG5lbmdpbmUudG9JbnRlZ2VyID0gZnVuY3Rpb24oY29sbCl7XG4gIGlmKGNvbGwubGVuZ3RoICE9PSAxKSB7IHJldHVybiBbXTsgfVxuICB2YXIgdiA9IHV0aWwudmFsRGF0YShjb2xsWzBdKTtcbiAgaWYodiA9PT0gZmFsc2UpIHtyZXR1cm4gMDt9XG4gIGlmKHYgPT09IHRydWUpIHtyZXR1cm4gMTt9XG4gIGlmKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYoTnVtYmVyLmlzSW50ZWdlcih2KSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgaWYodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgaW50UmVnZXgudGVzdCh2KSkge1xuICAgIHJldHVybiBwYXJzZUludCh2KTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG5jb25zdCBxdWFudGl0eVJlZ2V4ID0gL14oKFxcK3wtKT9cXGQrKFxcLlxcZCspPylcXHMqKCgnW14nXSsnKXwoW2EtekEtWl0rKSk/JC8sXG4gIHF1YW50aXR5UmVnZXhNYXAgPSB7dmFsdWU6MSx1bml0OjUsdGltZTo2fTtcbmVuZ2luZS50b1F1YW50aXR5ID0gZnVuY3Rpb24gKGNvbGwsIHRvVW5pdCkge1xuICBsZXQgcmVzdWx0O1xuXG4gIGlmIChjb2xsLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCB0byBxdWFudGl0eTogaW5wdXQgY29sbGVjdGlvbiBjb250YWlucyBtdWx0aXBsZSBpdGVtc1wiKTtcbiAgfSBlbHNlIGlmIChjb2xsLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0b1VuaXQpIHtcbiAgICAgIGNvbnN0IHRoaXNVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1t0aGlzLnVuaXRdO1xuICAgICAgY29uc3QgdG9Vbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1t0b1VuaXRdO1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpc1VuaXRJblNlY29uZHMgIT09ICF0b1VuaXRJblNlY29uZHMgJiZcbiAgICAgICAgKHRoaXNVbml0SW5TZWNvbmRzID4gMSB8fCB0b1VuaXRJblNlY29uZHMgPiAxKVxuICAgICAgKSB7XG4gICAgICAgIC8vIENvbnZlcnNpb24gZnJvbSBjYWxlbmRhciBkdXJhdGlvbiBxdWFudGl0aWVzIGdyZWF0ZXIgdGhhbiBzZWNvbmRzIHRvXG4gICAgICAgIC8vIHRpbWUtdmFsdWVkIFVDVU0gcXVhbnRpdGllcyBncmVhdGVyIHRoYW4gc2Vjb25kcyBvciB2aWNlIHZlcnNhIGlzIG5vdFxuICAgICAgICAvLyBhbGxvd2VkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU3Vycm91bmQgVUNVTSB1bml0IGNvZGUgaW4gdGhlIHRvVW5pdCBwYXJhbWV0ZXIgd2l0aCBzaW5nbGUgcXVvdGVzXG4gICAgICBpZiAoIUZQX1F1YW50aXR5Lm1hcFRpbWVVbml0c1RvVUNVTUNvZGVbdG9Vbml0XSkge1xuICAgICAgICB0b1VuaXQgPSBgJyR7dG9Vbml0fSdgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2ID0gdXRpbC52YWxEYXRhQ29udmVydGVkKGNvbGxbMF0pO1xuICAgIGxldCBxdWFudGl0eVJlZ2V4UmVzO1xuXG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXN1bHQgPSBuZXcgRlBfUXVhbnRpdHkodiwgJ1xcJzFcXCcnKTtcbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBGUF9RdWFudGl0eSkge1xuICAgICAgcmVzdWx0ID0gdjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBGUF9RdWFudGl0eSh2ID8gMSA6IDAsICdcXCcxXFwnJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiAocXVhbnRpdHlSZWdleFJlcyA9IHF1YW50aXR5UmVnZXguZXhlYyh2KSkgKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHF1YW50aXR5UmVnZXhSZXNbcXVhbnRpdHlSZWdleE1hcC52YWx1ZV0sXG4gICAgICAgIHVuaXQgPSBxdWFudGl0eVJlZ2V4UmVzW3F1YW50aXR5UmVnZXhNYXAudW5pdF0sXG4gICAgICAgIHRpbWUgPSBxdWFudGl0eVJlZ2V4UmVzW3F1YW50aXR5UmVnZXhNYXAudGltZV07XG5cbiAgICAgIC8vIFVDVU0gdW5pdCBjb2RlIGluIHRoZSBpbnB1dCBzdHJpbmcgbXVzdCBiZSBzdXJyb3VuZGVkIHdpdGggc2luZ2xlIHF1b3Rlc1xuICAgICAgaWYgKCF0aW1lIHx8IEZQX1F1YW50aXR5Lm1hcFRpbWVVbml0c1RvVUNVTUNvZGVbdGltZV0pIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEZQX1F1YW50aXR5KE51bWJlcih2YWx1ZSksIHVuaXQgfHwgdGltZSB8fCAnXFwnMVxcJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQgJiYgdG9Vbml0ICYmIHJlc3VsdC51bml0ICE9PSB0b1VuaXQpIHtcbiAgICAgIHJlc3VsdCA9IEZQX1F1YW50aXR5LmNvbnZVbml0VG8ocmVzdWx0LnVuaXQsIHJlc3VsdC52YWx1ZSwgdG9Vbml0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0IHx8IFtdO1xufTtcblxudmFyIG51bVJlZ2V4ID0gL15bKy1dP1xcZCsoXFwuXFxkKyk/JC87XG5lbmdpbmUudG9EZWNpbWFsID0gZnVuY3Rpb24oY29sbCl7XG4gIGlmKGNvbGwubGVuZ3RoICE9PSAxKSB7IHJldHVybiBbXTsgfVxuICB2YXIgdiA9IHV0aWwudmFsRGF0YShjb2xsWzBdKTtcbiAgaWYodiA9PT0gZmFsc2UpIHtyZXR1cm4gMDt9XG4gIGlmKHYgPT09IHRydWUpIHtyZXR1cm4gMS4wO31cbiAgaWYodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBpZih0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiBudW1SZWdleC50ZXN0KHYpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxuZW5naW5lLnRvU3RyaW5nID0gZnVuY3Rpb24oY29sbCl7XG4gIGlmKGNvbGwubGVuZ3RoICE9PSAxKSB7IHJldHVybiBbXTsgfVxuICB2YXIgdiA9IHV0aWwudmFsRGF0YUNvbnZlcnRlZChjb2xsWzBdKTtcbiAgaWYgKHYgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbn07XG5cblxuLyoqXG4gKiAgRGVmaW5lcyBhIGZ1bmN0aW9uIG9uIGVuZ2luZSBjYWxsZWQgdG8rdGltZVR5cGUgKGUuZy4sIHRvRGF0ZVRpbWUsIGV0Yy4pLlxuICogQHBhcmFtIHRpbWVUeXBlIFRoZSBzdHJpbmcgbmFtZSBvZiBhIGNsYXNzIGZvciBhIHRpbWUgdHlwZSAoZS5nLiBcIkZQX0RhdGVUaW1lXCIpLlxuICovXG5mdW5jdGlvbiBkZWZpbmVUaW1lQ29udmVydGVyKHRpbWVUeXBlKSB7XG4gIGxldCB0aW1lTmFtZSA9IHRpbWVUeXBlLnNsaWNlKDMpOyAvLyBSZW1vdmUgJ0ZQXydcbiAgZW5naW5lWyd0bycrdGltZU5hbWVdID0gZnVuY3Rpb24oY29sbCkge1xuICAgIHZhciBydG4gPSBbXTtcbiAgICBpZiAoY29sbC5sZW5ndGggPiAxKVxuICAgICAgdGhyb3cgRXJyb3IoJ3RvICcrdGltZU5hbWUrJyBjYWxsZWQgZm9yIGEgY29sbGVjdGlvbiBvZiBsZW5ndGggJytjb2xsLmxlbmd0aCk7XG4gICAgaWYgKGNvbGwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgdiA9IHV0aWwudmFsRGF0YShjb2xsWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgdCA9IHR5cGVzW3RpbWVUeXBlXS5jaGVja1N0cmluZyh2KTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICBydG4gPSB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydG47XG4gIH07XG59XG5kZWZpbmVUaW1lQ29udmVydGVyKCdGUF9EYXRlJyk7XG5kZWZpbmVUaW1lQ29udmVydGVyKCdGUF9EYXRlVGltZScpO1xuZGVmaW5lVGltZUNvbnZlcnRlcignRlBfVGltZScpO1xuXG4vLyBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzIGNvbnZlcnRpYmxlIHRvIHRoZSB0cnVlIGJvb2xlYW4gdmFsdWVcbmNvbnN0IHRydWVTdHJpbmdzID0gWyd0cnVlJywgJ3QnLCAneWVzJywgJ3knLCAnMScsICcxLjAnXS5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gIGFjY1t2YWxdID0gdHJ1ZTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcblxuLy8gUG9zc2libGUgc3RyaW5nIHZhbHVlcyBjb252ZXJ0aWJsZSB0byB0aGUgZmFsc2UgYm9vbGVhbiB2YWx1ZVxuY29uc3QgZmFsc2VTdHJpbmdzID0gWydmYWxzZScsICdmJywgJ25vJywgJ24nLCAnMCcsICcwLjAnXS5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gIGFjY1t2YWxdID0gdHJ1ZTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcblxuZW5naW5lLnRvQm9vbGVhbiA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gIGlmKGNvbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgdiA9IHV0aWwudmFsRGF0YShjb2xsWzBdKTtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHY7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmICh2ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgY29uc3QgbG93ZXJDYXNlVmFsdWUgPSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodHJ1ZVN0cmluZ3NbbG93ZXJDYXNlVmFsdWVdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZhbHNlU3RyaW5nc1tsb3dlckNhc2VWYWx1ZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0b0Z1bmN0aW9uIHJldHVybnMgc3BlY2lmaWVkIHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oY29sbDogYXJyYXkpOiA8dHlwZXxbXT59IHRvRnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfGNsYXNzfSB0eXBlIC0gc3BlY2lmaWVzIHR5cGUsIGZvciBleGFtcGxlOiAnc3RyaW5nJyBvciBGUF9RdWFudGl0eVxuICogQHJldHVybiB7ZnVuY3Rpb24oY29sbDogYXJyYXkpfVxuICovXG5lbmdpbmUuY3JlYXRlQ29udmVydHNUb0ZuID0gZnVuY3Rpb24gKHRvRnVuY3Rpb24sIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29sbCkge1xuICAgICAgaWYgKGNvbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGVvZiB0b0Z1bmN0aW9uKGNvbGwpID09PSB0eXBlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbGwpIHtcbiAgICBpZiAoY29sbC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9GdW5jdGlvbihjb2xsKSBpbnN0YW5jZW9mIHR5cGU7XG4gIH07XG59O1xuXG5jb25zdCBzaW5nbGV0b25FdmFsQnlUeXBlID0ge1xuICBcIkludGVnZXJcIjogZnVuY3Rpb24oZCl7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoZCkpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgfSxcbiAgXCJCb29sZWFuXCI6IGZ1bmN0aW9uKGQpe1xuICAgIGlmIChkID09PSB0cnVlIHx8IGQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICBcIk51bWJlclwiOiBmdW5jdGlvbihkKSB7XG4gICAgaWYgKHR5cGVvZiBkID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gIH0sXG4gIFwiU3RyaW5nXCI6IGZ1bmN0aW9uKGQpe1xuICAgIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICB9LFxuICBcIlN0cmluZ09yTnVtYmVyXCI6IGZ1bmN0aW9uKGQpe1xuICAgIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICB9LFxuICBcIkFueVNpbmdsZXRvbkF0Um9vdFwiOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sbGVjdGlvbiB0byBhIHNpbmdsZXRvbiBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKiBUaGUgcmVzdWx0IGNhbiBiZSBhbiBlbXB0eSBhcnJheSBpZiBpbnB1dCBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICogU2VlIGh0dHA6Ly9obDcub3JnL2ZoaXJwYXRoLyNzaW5nbGV0b24tZXZhbHVhdGlvbi1vZi1jb2xsZWN0aW9ucyBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbGwgLSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtICdJbnRlZ2VyJywgJ0Jvb2xlYW4nLCAnTnVtYmVyJyBvciAnU3RyaW5nJ1xuICogQHRocm93cyB7RXJyb3J9ICBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGl0ZW0gaW4gaW5wdXQgY29sbGVjdGlvbixcbiAqICAgb3IgYW4gaXRlbSB0aGF0IGlzIG5vdCBhIHNwZWNpZmllZCB0eXBlXG4gKiBAcmV0dXJuIHsqfFtdfSB0aGUgdmFsdWUgb2Ygc3BlY2lmaWVkIHR5cGUgb3IgZW1wdHkgYXJyYXlcbiAqL1xuZW5naW5lLnNpbmdsZXRvbiA9IGZ1bmN0aW9uIChjb2xsLCB0eXBlKSB7XG4gIGlmKGNvbGwubGVuZ3RoID4gMSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjb2xsZWN0aW9uXCIgKyBKU09OLnN0cmluZ2lmeShjb2xsKSArXG4gICAgICBcIjsgZXhwZWN0ZWQgc2luZ2xldG9uIG9mIHR5cGUgXCIgKyB0eXBlKTtcbiAgfSBlbHNlIGlmIChjb2xsLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB2ID0gdXRpbC52YWxEYXRhKGNvbGxbMF0pO1xuICBpZiAodiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHRvU2luZ2xldG9uID0gc2luZ2xldG9uRXZhbEJ5VHlwZVt0eXBlXTtcbiAgaWYgKHRvU2luZ2xldG9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0b1NpbmdsZXRvbih2KTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dHlwZS50b0xvd2VyQ2FzZSgpfSwgYnV0IGdvdDogJHtKU09OLnN0cmluZ2lmeShjb2xsKX1gKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgdHlwZSAnICsgdHlwZSk7XG59O1xuXG5lbmdpbmUuaGFzVmFsdWVGbiA9IGZ1bmN0aW9uKGNvbGwpIHtcbiAgcmV0dXJuIGNvbGwubGVuZ3RoID09PSAxICYmIHV0aWwudmFsRGF0YShjb2xsWzBdKSAhPSBudWxsXG4gICAgJiYgVHlwZUluZm8uaXNQcmltaXRpdmVWYWx1ZShjb2xsWzBdKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBzeXN0ZW0gdmFsdWUgZm9yIHRoZSBGSElSIHByaW1pdGl2ZSBpZiB0aGUgaW5wdXRcbiAqIGNvbGxlY3Rpb24gY29udGFpbnMgYSBzaW5nbGUgdmFsdWUgd2hpY2ggaXMgYSBGSElSIHByaW1pdGl2ZSwgYW5kIGl0IGhhcyBhXG4gKiBwcmltaXRpdmUgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHJldHVybiB2YWx1ZSBpcyBlbXB0eSAoaS5lLiBbXSkuXG4gKlxuICogU2VlOiBodHRwczovL2hsNy5vcmcvZmhpci9maGlycGF0aC5odG1sI2Z1bmN0aW9uc1xuICogQHBhcmFtIHtBcnJheTwqPn0gY29sbCAtIGlucHV0IGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHsqfFtdfVxuICovXG5lbmdpbmUuZ2V0VmFsdWVGbiA9IGZ1bmN0aW9uKGNvbGwpIHtcbiAgaWYgKGNvbGwubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbGxbMF07XG4gICAgY29uc3QgdiA9IHV0aWwudmFsRGF0YShub2RlKTtcbiAgICBpZiAodiAhPSBudWxsICYmIFR5cGVJbmZvLmlzUHJpbWl0aXZlVmFsdWUobm9kZSkpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/navigation.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/navigation.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n\nvar engine = {};\n\nengine.children = function(coll){\n  let model = this.model; // \"this\" is the context object\n  return coll.reduce(function(acc, x){\n    let d = util.valData(x);\n    if (d == null) {\n      return acc;\n    } else if (typeof d === 'object') {\n      for (var prop of Object.keys(d)) {\n        util.pushFn(acc, util.makeChildResNodes(x, prop, model));\n      }\n      return acc;\n    } else {\n      return acc;\n    }\n  }, []);\n};\n\nengine.descendants = function(coll){\n  var ch = engine.children.call(this, coll); // \"this\" is the context object\n  var res = [];\n  while(ch.length > 0){\n    util.pushFn(res, ch);\n    ch = engine.children.call(this, ch);\n  }\n  return res;\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLHVHQUFhOztBQUVsQzs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9uYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5cbnZhciBlbmdpbmUgPSB7fTtcblxuZW5naW5lLmNoaWxkcmVuID0gZnVuY3Rpb24oY29sbCl7XG4gIGxldCBtb2RlbCA9IHRoaXMubW9kZWw7IC8vIFwidGhpc1wiIGlzIHRoZSBjb250ZXh0IG9iamVjdFxuICByZXR1cm4gY29sbC5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KXtcbiAgICBsZXQgZCA9IHV0aWwudmFsRGF0YSh4KTtcbiAgICBpZiAoZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIG9mIE9iamVjdC5rZXlzKGQpKSB7XG4gICAgICAgIHV0aWwucHVzaEZuKGFjYywgdXRpbC5tYWtlQ2hpbGRSZXNOb2Rlcyh4LCBwcm9wLCBtb2RlbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gIH0sIFtdKTtcbn07XG5cbmVuZ2luZS5kZXNjZW5kYW50cyA9IGZ1bmN0aW9uKGNvbGwpe1xuICB2YXIgY2ggPSBlbmdpbmUuY2hpbGRyZW4uY2FsbCh0aGlzLCBjb2xsKTsgLy8gXCJ0aGlzXCIgaXMgdGhlIGNvbnRleHQgb2JqZWN0XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUoY2gubGVuZ3RoID4gMCl7XG4gICAgdXRpbC5wdXNoRm4ocmVzLCBjaCk7XG4gICAgY2ggPSBlbmdpbmUuY2hpbGRyZW4uY2FsbCh0aGlzLCBjaCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/navigation.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("let numberFns = {};\n\n// Returns the number of digits in the number after the decimal point, ignoring\n// trailing zeros.\nfunction decimalPlaces(x) {\n  // Based on https://stackoverflow.com/a/9539746/360782\n  // Make sure it is a number and use the builtin number -> string.\n  const s = \"\" + (+x),\n    match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n  // NaN or Infinity or integer.\n  // We arbitrarily decide that Infinity is integral.\n  if (!match) { return 0; }\n  // Count the number of digits in the fraction and subtract the\n  // exponent to simulate moving the decimal point left by exponent places.\n  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1\n  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5\n  //var wholeNum = match[1];\n  const fraction = match[2],\n    exponent = match[3];\n  return Math.max(\n    0,  // lower limit.\n    (fraction === '0' ? 0 : (fraction || '').length)  // fraction length\n    - (exponent || 0));  // exponent\n}\n\n/**\n *  Rounds a number to the specified number of decimal places.\n * @param x the decimal number to be rounded\n * @param n the (maximum) number of decimal places to preserve.  (The result\n *  could contain fewer if the decimal digits in x contain zeros).\n */\nfunction roundToDecimalPlaces (x, n) {\n  const scale = Math.pow(10, n);\n  return Math.round(x*scale)/scale;\n}\n\n/**\n *  The smallest representable number in FHIRPath.\n */\nconst PRECISION_STEP = 1e-8;\n\n/**\n *  Rounds a number to the nearest multiple of PRECISION_STEP.\n */\nconst roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {\n  return Math.round(x/PRECISION_STEP)*PRECISION_STEP;\n};\n\n/**\n * Determines numbers equivalence\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEquivalent = function(actual, expected) {\n  if(Number.isInteger(actual) && Number.isInteger(expected)) {\n    return actual === expected;\n  }\n\n  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));\n\n  if(prec === 0){\n    return Math.round(actual) === Math.round(expected);\n  } else {\n    // Note: parseFloat(0.00000011).toPrecision(7) ===  \"1.100000e-7\"\n    // It does # of significant digits, not decimal places.\n    return roundToDecimalPlaces(actual, prec) ===\n      roundToDecimalPlaces(expected, prec);\n  }\n};\n\n/**\n * Determines numbers equality\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEqual = function(actual, expected) {\n  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);\n};\n\nmodule.exports = numberFns;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL251bWJlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL251bWJlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IG51bWJlckZucyA9IHt9O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBudW1iZXIgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGlnbm9yaW5nXG4vLyB0cmFpbGluZyB6ZXJvcy5cbmZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoeCkge1xuICAvLyBCYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTUzOTc0Ni8zNjA3ODJcbiAgLy8gTWFrZSBzdXJlIGl0IGlzIGEgbnVtYmVyIGFuZCB1c2UgdGhlIGJ1aWx0aW4gbnVtYmVyIC0+IHN0cmluZy5cbiAgY29uc3QgcyA9IFwiXCIgKyAoK3gpLFxuICAgIG1hdGNoID0gLyhcXGQrKSg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLy5leGVjKHMpO1xuICAvLyBOYU4gb3IgSW5maW5pdHkgb3IgaW50ZWdlci5cbiAgLy8gV2UgYXJiaXRyYXJpbHkgZGVjaWRlIHRoYXQgSW5maW5pdHkgaXMgaW50ZWdyYWwuXG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIDA7IH1cbiAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGZyYWN0aW9uIGFuZCBzdWJ0cmFjdCB0aGVcbiAgLy8gZXhwb25lbnQgdG8gc2ltdWxhdGUgbW92aW5nIHRoZSBkZWNpbWFsIHBvaW50IGxlZnQgYnkgZXhwb25lbnQgcGxhY2VzLlxuICAvLyAxLjIzNGUrMiBoYXMgMSBmcmFjdGlvbiBkaWdpdCBhbmQgJzIzNCcubGVuZ3RoIC0gIDIgPT0gMVxuICAvLyAxLjIzNGUtMiBoYXMgNSBmcmFjdGlvbiBkaWdpdCBhbmQgJzIzNCcubGVuZ3RoIC0gLTIgPT0gNVxuICAvL3ZhciB3aG9sZU51bSA9IG1hdGNoWzFdO1xuICBjb25zdCBmcmFjdGlvbiA9IG1hdGNoWzJdLFxuICAgIGV4cG9uZW50ID0gbWF0Y2hbM107XG4gIHJldHVybiBNYXRoLm1heChcbiAgICAwLCAgLy8gbG93ZXIgbGltaXQuXG4gICAgKGZyYWN0aW9uID09PSAnMCcgPyAwIDogKGZyYWN0aW9uIHx8ICcnKS5sZW5ndGgpICAvLyBmcmFjdGlvbiBsZW5ndGhcbiAgICAtIChleHBvbmVudCB8fCAwKSk7ICAvLyBleHBvbmVudFxufVxuXG4vKipcbiAqICBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcGFyYW0geCB0aGUgZGVjaW1hbCBudW1iZXIgdG8gYmUgcm91bmRlZFxuICogQHBhcmFtIG4gdGhlIChtYXhpbXVtKSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcHJlc2VydmUuICAoVGhlIHJlc3VsdFxuICogIGNvdWxkIGNvbnRhaW4gZmV3ZXIgaWYgdGhlIGRlY2ltYWwgZGlnaXRzIGluIHggY29udGFpbiB6ZXJvcykuXG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsUGxhY2VzICh4LCBuKSB7XG4gIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMTAsIG4pO1xuICByZXR1cm4gTWF0aC5yb3VuZCh4KnNjYWxlKS9zY2FsZTtcbn1cblxuLyoqXG4gKiAgVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgbnVtYmVyIGluIEZISVJQYXRoLlxuICovXG5jb25zdCBQUkVDSVNJT05fU1RFUCA9IDFlLTg7XG5cbi8qKlxuICogIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiBQUkVDSVNJT05fU1RFUC5cbiAqL1xuY29uc3Qgcm91bmRUb01heFByZWNpc2lvbiA9IG51bWJlckZucy5yb3VuZFRvTWF4UHJlY2lzaW9uID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoeC9QUkVDSVNJT05fU1RFUCkqUFJFQ0lTSU9OX1NURVA7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgbnVtYmVycyBlcXVpdmFsZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbFxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5udW1iZXJGbnMuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZihOdW1iZXIuaXNJbnRlZ2VyKGFjdHVhbCkgJiYgTnVtYmVyLmlzSW50ZWdlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09PSBleHBlY3RlZDtcbiAgfVxuXG4gIGNvbnN0IHByZWMgPSBNYXRoLm1pbihkZWNpbWFsUGxhY2VzKGFjdHVhbCksIGRlY2ltYWxQbGFjZXMoZXhwZWN0ZWQpKTtcblxuICBpZihwcmVjID09PSAwKXtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChhY3R1YWwpID09PSBNYXRoLnJvdW5kKGV4cGVjdGVkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3RlOiBwYXJzZUZsb2F0KDAuMDAwMDAwMTEpLnRvUHJlY2lzaW9uKDcpID09PSAgXCIxLjEwMDAwMGUtN1wiXG4gICAgLy8gSXQgZG9lcyAjIG9mIHNpZ25pZmljYW50IGRpZ2l0cywgbm90IGRlY2ltYWwgcGxhY2VzLlxuICAgIHJldHVybiByb3VuZFRvRGVjaW1hbFBsYWNlcyhhY3R1YWwsIHByZWMpID09PVxuICAgICAgcm91bmRUb0RlY2ltYWxQbGFjZXMoZXhwZWN0ZWQsIHByZWMpO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgbnVtYmVycyBlcXVhbGl0eVxuICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbFxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5udW1iZXJGbnMuaXNFcXVhbCA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgcmV0dXJuIHJvdW5kVG9NYXhQcmVjaXNpb24oYWN0dWFsKSA9PT0gcm91bmRUb01heFByZWNpc2lvbihleHBlY3RlZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG51bWJlckZucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// This is a modified version of antr4's index.js, in which\n// the \"require\" statements of two unused classes are commented out\n// to avoid introducing a dependency on Node.js' \"fs\" package.\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = __webpack_require__(/*! antlr4/src/antlr4/atn/index */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/atn/index.js\");\nexports.codepointat = __webpack_require__(/*! antlr4/src/antlr4/polyfills/codepointat */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/polyfills/codepointat.js\");\nexports.dfa = __webpack_require__(/*! antlr4/src/antlr4/dfa/index */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/dfa/index.js\");\nexports.fromcodepoint = __webpack_require__(/*! antlr4/src/antlr4/polyfills/fromcodepoint */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js\");\nexports.tree = __webpack_require__(/*! antlr4/src/antlr4/tree/index */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/tree/index.js\");\nexports.error = __webpack_require__(/*! antlr4/src/antlr4/error/index */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/error/index.js\");\nexports.Token = __webpack_require__(/*! antlr4/src/antlr4/Token */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/Token.js\").Token;\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');\nexports.CommonToken = __webpack_require__(/*! antlr4/src/antlr4/Token */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/Token.js\").CommonToken;\nexports.InputStream = __webpack_require__(/*! antlr4/src/antlr4/InputStream */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/InputStream.js\");\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.FileStream = require('antlr4/src/antlr4/FileStream');\nexports.CommonTokenStream = __webpack_require__(/*! antlr4/src/antlr4/CommonTokenStream */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/CommonTokenStream.js\");\nexports.Lexer = __webpack_require__(/*! antlr4/src/antlr4/Lexer */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/Lexer.js\");\nexports.Parser = __webpack_require__(/*! antlr4/src/antlr4/Parser */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/Parser.js\");\nvar pc = __webpack_require__(/*! antlr4/src/antlr4/PredictionContext */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/PredictionContext.js\");\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = __webpack_require__(/*! antlr4/src/antlr4/ParserRuleContext */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/ParserRuleContext.js\");\nexports.Interval = __webpack_require__(/*! antlr4/src/antlr4/IntervalSet */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/IntervalSet.js\").Interval;\nexports.IntervalSet = __webpack_require__(/*! antlr4/src/antlr4/IntervalSet */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/IntervalSet.js\").IntervalSet;\nexports.Utils = __webpack_require__(/*! antlr4/src/antlr4/Utils */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/Utils.js\");\nexports.LL1Analyzer = __webpack_require__(/*! antlr4/src/antlr4/LL1Analyzer */ \"(ssr)/../node_modules/.pnpm/antlr4@4.9.3/node_modules/antlr4/src/antlr4/LL1Analyzer.js\").LL1Analyzer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9hbnRscjQtaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEpBQW9EO0FBQ3BELDRMQUF3RTtBQUN4RSw0SkFBb0Q7QUFDcEQsa01BQTRFO0FBQzVFLCtKQUFzRDtBQUN0RCxrS0FBd0Q7QUFDeEQsNEpBQXdEO0FBQ3hEO0FBQ0E7QUFDQSx3S0FBb0U7QUFDcEUsd0tBQThEO0FBQzlEO0FBQ0E7QUFDQSwwTEFBMEU7QUFDMUUsc0pBQWtEO0FBQ2xELHlKQUFvRDtBQUNwRCxTQUFTLG1CQUFPLENBQUMseUlBQXFDO0FBQ3RELDhCQUE4QjtBQUM5QiwwTEFBMEU7QUFDMUUsOEtBQW9FO0FBQ3BFLG9MQUEwRTtBQUMxRSxzSkFBa0Q7QUFDbEQsb0xBQTBFIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9wYXJzZXIvYW50bHI0LWluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGFudHI0J3MgaW5kZXguanMsIGluIHdoaWNoXG4vLyB0aGUgXCJyZXF1aXJlXCIgc3RhdGVtZW50cyBvZiB0d28gdW51c2VkIGNsYXNzZXMgYXJlIGNvbW1lbnRlZCBvdXRcbi8vIHRvIGF2b2lkIGludHJvZHVjaW5nIGEgZGVwZW5kZW5jeSBvbiBOb2RlLmpzJyBcImZzXCIgcGFja2FnZS5cblxuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuZXhwb3J0cy5hdG4gPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9hdG4vaW5kZXgnKTtcbmV4cG9ydHMuY29kZXBvaW50YXQgPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9wb2x5ZmlsbHMvY29kZXBvaW50YXQnKTtcbmV4cG9ydHMuZGZhID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvZGZhL2luZGV4Jyk7XG5leHBvcnRzLmZyb21jb2RlcG9pbnQgPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9wb2x5ZmlsbHMvZnJvbWNvZGVwb2ludCcpO1xuZXhwb3J0cy50cmVlID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvdHJlZS9pbmRleCcpO1xuZXhwb3J0cy5lcnJvciA9IHJlcXVpcmUoJ2FudGxyNC9zcmMvYW50bHI0L2Vycm9yL2luZGV4Jyk7XG5leHBvcnRzLlRva2VuID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvVG9rZW4nKS5Ub2tlbjtcbi8vIENvbW1lbnRlZCBvdXQgdG8gYXZvaWQgdGhlIHByb2JsZW0gd2l0aCAnZnMnIGR1cmluZyB0aGUgd2VicGFjayBidWlsZFxuLy8gZXhwb3J0cy5DaGFyU3RyZWFtcyA9IHJlcXVpcmUoJ2FudGxyNC9zcmMvYW50bHI0L0NoYXJTdHJlYW1zJyk7XG5leHBvcnRzLkNvbW1vblRva2VuID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvVG9rZW4nKS5Db21tb25Ub2tlbjtcbmV4cG9ydHMuSW5wdXRTdHJlYW0gPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9JbnB1dFN0cmVhbScpO1xuLy8gQ29tbWVudGVkIG91dCB0byBhdm9pZCB0aGUgcHJvYmxlbSB3aXRoICdmcycgZHVyaW5nIHRoZSB3ZWJwYWNrIGJ1aWxkXG4vLyBleHBvcnRzLkZpbGVTdHJlYW0gPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9GaWxlU3RyZWFtJyk7XG5leHBvcnRzLkNvbW1vblRva2VuU3RyZWFtID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvQ29tbW9uVG9rZW5TdHJlYW0nKTtcbmV4cG9ydHMuTGV4ZXIgPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9MZXhlcicpO1xuZXhwb3J0cy5QYXJzZXIgPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9QYXJzZXInKTtcbnZhciBwYyA9IHJlcXVpcmUoJ2FudGxyNC9zcmMvYW50bHI0L1ByZWRpY3Rpb25Db250ZXh0Jyk7XG5leHBvcnRzLlByZWRpY3Rpb25Db250ZXh0Q2FjaGUgPSBwYy5QcmVkaWN0aW9uQ29udGV4dENhY2hlO1xuZXhwb3J0cy5QYXJzZXJSdWxlQ29udGV4dCA9IHJlcXVpcmUoJ2FudGxyNC9zcmMvYW50bHI0L1BhcnNlclJ1bGVDb250ZXh0Jyk7XG5leHBvcnRzLkludGVydmFsID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbmV4cG9ydHMuSW50ZXJ2YWxTZXQgPSByZXF1aXJlKCdhbnRscjQvc3JjL2FudGxyNC9JbnRlcnZhbFNldCcpLkludGVydmFsU2V0O1xuZXhwb3J0cy5VdGlscyA9IHJlcXVpcmUoJ2FudGxyNC9zcmMvYW50bHI0L1V0aWxzJyk7XG5leHBvcnRzLkxMMUFuYWx5emVyID0gcmVxdWlyZSgnYW50bHI0L3NyYy9hbnRscjQvTEwxQW5hbHl6ZXInKS5MTDFBbmFseXplcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = __webpack_require__(/*! ../antlr4-index */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js\");\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0002A\\u0203\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\",\n    \"\\u0004\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\",\n    \"\\t\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\",\n    \"\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\",\n    \"\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\",\n    \"\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\",\n    \"\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\",\n    \"\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\",\n    \"\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\",\n    \"\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004\",\n    \"*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u0004\",\n    \"1\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u00047\\t7\\u0004\",\n    \"8\\t8\\u00049\\t9\\u0004:\\t:\\u0004;\\t;\\u0004<\\t<\\u0004=\\t=\\u0004>\\t>\\u0004\",\n    \"?\\t?\\u0004@\\t@\\u0004A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004D\\tD\\u0003\\u0002\\u0003\",\n    \"\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\",\n    \"\\u000b\\u0003\\u000b\\u0003\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\u000e\",\n    \"\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\",\n    \"\\u0003\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\n    \"\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\",\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\",\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\",\n    \"\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001f\\u0003\\u001f\\u0003 \",\n    \"\\u0003 \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\",\n    \"\\u0003$\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003\\'\\u0003\\'\\u0003(\\u0003(\\u0003\",\n    \"(\\u0003(\\u0003(\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003*\\u0003\",\n    \"*\\u0003*\\u0003*\\u0003*\\u0003+\\u0003+\\u0003+\\u0003+\\u0003,\\u0003,\\u0003\",\n    \",\\u0003,\\u0003,\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\n    \".\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003/\\u0003/\\u0003/\\u0003\",\n    \"/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u00030\\u0003\",\n    \"0\\u00030\\u00030\\u00030\\u00030\\u00031\\u00031\\u00031\\u00031\\u00031\\u0003\",\n    \"1\\u00031\\u00032\\u00032\\u00032\\u00032\\u00032\\u00032\\u00033\\u00033\\u0003\",\n    \"3\\u00033\\u00033\\u00034\\u00034\\u00034\\u00034\\u00034\\u00034\\u00035\\u0003\",\n    \"5\\u00035\\u00035\\u00035\\u00035\\u00035\\u00035\\u00036\\u00036\\u00036\\u0003\",\n    \"6\\u00036\\u00036\\u00036\\u00036\\u00037\\u00037\\u00037\\u00037\\u00037\\u0003\",\n    \"7\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00038\\u00038\\u0003\",\n    \"8\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u0003\",\n    \"8\\u00058\\u0183\\n8\\u00058\\u0185\\n8\\u00058\\u0187\\n8\\u00038\\u00058\\u018a\",\n    \"\\n8\\u00039\\u00039\\u00039\\u00039\\u0003:\\u0003:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0003:\\u0006:\\u019a\\n:\\r:\\u000e:\\u019b\\u0005\",\n    \":\\u019e\\n:\\u0005:\\u01a0\\n:\\u0005:\\u01a2\\n:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0005:\\u01ab\\n:\\u0003;\\u0005;\\u01ae\\n;\\u0003\",\n    \";\\u0007;\\u01b1\\n;\\f;\\u000e;\\u01b4\\u000b;\\u0003<\\u0003<\\u0003<\\u0007\",\n    \"<\\u01b9\\n<\\f<\\u000e<\\u01bc\\u000b<\\u0003<\\u0003<\\u0003=\\u0003=\\u0003\",\n    \"=\\u0007=\\u01c3\\n=\\f=\\u000e=\\u01c6\\u000b=\\u0003=\\u0003=\\u0003>\\u0006\",\n    \">\\u01cb\\n>\\r>\\u000e>\\u01cc\\u0003>\\u0003>\\u0006>\\u01d1\\n>\\r>\\u000e>\\u01d2\",\n    \"\\u0005>\\u01d5\\n>\\u0003?\\u0006?\\u01d8\\n?\\r?\\u000e?\\u01d9\\u0003?\\u0003\",\n    \"?\\u0003@\\u0003@\\u0003@\\u0003@\\u0007@\\u01e2\\n@\\f@\\u000e@\\u01e5\\u000b\",\n    \"@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003A\\u0003A\\u0003A\\u0003A\\u0007\",\n    \"A\\u01f0\\nA\\fA\\u000eA\\u01f3\\u000bA\\u0003A\\u0003A\\u0003B\\u0003B\\u0003\",\n    \"B\\u0005B\\u01fa\\nB\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003D\\u0003\",\n    \"D\\u0003\\u01e3\\u0002E\\u0003\\u0003\\u0005\\u0004\\u0007\\u0005\\t\\u0006\\u000b\",\n    \"\\u0007\\r\\b\\u000f\\t\\u0011\\n\\u0013\\u000b\\u0015\\f\\u0017\\r\\u0019\\u000e\\u001b\",\n    \"\\u000f\\u001d\\u0010\\u001f\\u0011!\\u0012#\\u0013%\\u0014\\'\\u0015)\\u0016+\",\n    \"\\u0017-\\u0018/\\u00191\\u001a3\\u001b5\\u001c7\\u001d9\\u001e;\\u001f= ?!A\",\n    \"\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\\u0002u;w<y={>}\",\n    \"?\\u007f@\\u0081A\\u0083\\u0002\\u0085\\u0002\\u0087\\u0002\\u0003\\u0002\\f\\u0003\",\n    \"\\u00022;\\u0004\\u0002--//\\u0005\\u0002C\\\\aac|\\u0006\\u00022;C\\\\aac|\\u0004\",\n    \"\\u0002^^bb\\u0003\\u0002))\\u0005\\u0002\\u000b\\f\\u000f\\u000f\\\"\\\"\\u0004\\u0002\",\n    \"\\f\\f\\u000f\\u000f\\n\\u0002))11^^bbhhppttvv\\u0005\\u00022;CHch\\u0002\\u0214\",\n    \"\\u0002\\u0003\\u0003\\u0002\\u0002\\u0002\\u0002\\u0005\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"\\'\\u0003\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\\u0002\\u0002+\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\\u0002/\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u00023\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00029\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"=\\u0003\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\\u0002\\u0002A\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\\u0002E\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002I\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002O\\u0003\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"S\\u0003\\u0002\\u0002\\u0002\\u0002U\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0002c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002e\\u0003\\u0002\\u0002\\u0002\\u0002g\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"i\\u0003\\u0002\\u0002\\u0002\\u0002k\\u0003\\u0002\\u0002\\u0002\\u0002m\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002o\\u0003\\u0002\\u0002\\u0002\\u0002q\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002u\\u0003\\u0002\\u0002\\u0002\\u0002w\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002y\\u0003\\u0002\\u0002\\u0002\\u0002{\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002}\\u0003\\u0002\\u0002\\u0002\\u0002\\u007f\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0081\\u0003\\u0002\\u0002\\u0002\\u0003\\u0089\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0005\\u008b\\u0003\\u0002\\u0002\\u0002\\u0007\\u008d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\t\\u008f\\u0003\\u0002\\u0002\\u0002\\u000b\\u0091\\u0003\\u0002\\u0002\\u0002\",\n    \"\\r\\u0093\\u0003\\u0002\\u0002\\u0002\\u000f\\u0095\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0011\\u0097\\u0003\\u0002\\u0002\\u0002\\u0013\\u009b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0015\\u009f\\u0003\\u0002\\u0002\\u0002\\u0017\\u00a1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0019\\u00a3\\u0003\\u0002\\u0002\\u0002\\u001b\\u00a6\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u001d\\u00a8\\u0003\\u0002\\u0002\\u0002\\u001f\\u00aa\\u0003\\u0002\\u0002\\u0002\",\n    \"!\\u00ad\\u0003\\u0002\\u0002\\u0002#\\u00b0\\u0003\\u0002\\u0002\\u0002%\\u00b3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\'\\u00b5\\u0003\\u0002\\u0002\\u0002)\\u00b7\\u0003\",\n    \"\\u0002\\u0002\\u0002+\\u00ba\\u0003\\u0002\\u0002\\u0002-\\u00bd\\u0003\\u0002\",\n    \"\\u0002\\u0002/\\u00c0\\u0003\\u0002\\u0002\\u00021\\u00c9\\u0003\\u0002\\u0002\",\n    \"\\u00023\\u00cd\\u0003\\u0002\\u0002\\u00025\\u00d0\\u0003\\u0002\\u0002\\u0002\",\n    \"7\\u00d4\\u0003\\u0002\\u0002\\u00029\\u00dc\\u0003\\u0002\\u0002\\u0002;\\u00de\",\n    \"\\u0003\\u0002\\u0002\\u0002=\\u00e0\\u0003\\u0002\\u0002\\u0002?\\u00e2\\u0003\",\n    \"\\u0002\\u0002\\u0002A\\u00e4\\u0003\\u0002\\u0002\\u0002C\\u00e9\\u0003\\u0002\",\n    \"\\u0002\\u0002E\\u00ef\\u0003\\u0002\\u0002\\u0002G\\u00f1\\u0003\\u0002\\u0002\",\n    \"\\u0002I\\u00f7\\u0003\\u0002\\u0002\\u0002K\\u00fe\\u0003\\u0002\\u0002\\u0002\",\n    \"M\\u0105\\u0003\\u0002\\u0002\\u0002O\\u0107\\u0003\\u0002\\u0002\\u0002Q\\u010c\",\n    \"\\u0003\\u0002\\u0002\\u0002S\\u0112\\u0003\\u0002\\u0002\\u0002U\\u0117\\u0003\",\n    \"\\u0002\\u0002\\u0002W\\u011b\\u0003\\u0002\\u0002\\u0002Y\\u0120\\u0003\\u0002\",\n    \"\\u0002\\u0002[\\u0127\\u0003\\u0002\\u0002\\u0002]\\u012e\\u0003\\u0002\\u0002\",\n    \"\\u0002_\\u013a\\u0003\\u0002\\u0002\\u0002a\\u0140\\u0003\\u0002\\u0002\\u0002\",\n    \"c\\u0147\\u0003\\u0002\\u0002\\u0002e\\u014d\\u0003\\u0002\\u0002\\u0002g\\u0152\",\n    \"\\u0003\\u0002\\u0002\\u0002i\\u0158\\u0003\\u0002\\u0002\\u0002k\\u0160\\u0003\",\n    \"\\u0002\\u0002\\u0002m\\u0168\\u0003\\u0002\\u0002\\u0002o\\u0175\\u0003\\u0002\",\n    \"\\u0002\\u0002q\\u018b\\u0003\\u0002\\u0002\\u0002s\\u018f\\u0003\\u0002\\u0002\",\n    \"\\u0002u\\u01ad\\u0003\\u0002\\u0002\\u0002w\\u01b5\\u0003\\u0002\\u0002\\u0002\",\n    \"y\\u01bf\\u0003\\u0002\\u0002\\u0002{\\u01ca\\u0003\\u0002\\u0002\\u0002}\\u01d7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u007f\\u01dd\\u0003\\u0002\\u0002\\u0002\\u0081\\u01eb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0083\\u01f6\\u0003\\u0002\\u0002\\u0002\\u0085\\u01fb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0087\\u0201\\u0003\\u0002\\u0002\\u0002\\u0089\\u008a\",\n    \"\\u00070\\u0002\\u0002\\u008a\\u0004\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\",\n    \"\\u0007]\\u0002\\u0002\\u008c\\u0006\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\",\n    \"\\u0007_\\u0002\\u0002\\u008e\\b\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0007\",\n    \"-\\u0002\\u0002\\u0090\\n\\u0003\\u0002\\u0002\\u0002\\u0091\\u0092\\u0007/\\u0002\",\n    \"\\u0002\\u0092\\f\\u0003\\u0002\\u0002\\u0002\\u0093\\u0094\\u0007,\\u0002\\u0002\",\n    \"\\u0094\\u000e\\u0003\\u0002\\u0002\\u0002\\u0095\\u0096\\u00071\\u0002\\u0002\",\n    \"\\u0096\\u0010\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0007f\\u0002\\u0002\",\n    \"\\u0098\\u0099\\u0007k\\u0002\\u0002\\u0099\\u009a\\u0007x\\u0002\\u0002\\u009a\",\n    \"\\u0012\\u0003\\u0002\\u0002\\u0002\\u009b\\u009c\\u0007o\\u0002\\u0002\\u009c\",\n    \"\\u009d\\u0007q\\u0002\\u0002\\u009d\\u009e\\u0007f\\u0002\\u0002\\u009e\\u0014\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u009f\\u00a0\\u0007(\\u0002\\u0002\\u00a0\\u0016\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a1\\u00a2\\u0007~\\u0002\\u0002\\u00a2\\u0018\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a4\\u0007>\\u0002\\u0002\\u00a4\\u00a5\",\n    \"\\u0007?\\u0002\\u0002\\u00a5\\u001a\\u0003\\u0002\\u0002\\u0002\\u00a6\\u00a7\",\n    \"\\u0007>\\u0002\\u0002\\u00a7\\u001c\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00a9\",\n    \"\\u0007@\\u0002\\u0002\\u00a9\\u001e\\u0003\\u0002\\u0002\\u0002\\u00aa\\u00ab\",\n    \"\\u0007@\\u0002\\u0002\\u00ab\\u00ac\\u0007?\\u0002\\u0002\\u00ac \\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ad\\u00ae\\u0007k\\u0002\\u0002\\u00ae\\u00af\\u0007u\\u0002\",\n    \"\\u0002\\u00af\\\"\\u0003\\u0002\\u0002\\u0002\\u00b0\\u00b1\\u0007c\\u0002\\u0002\",\n    \"\\u00b1\\u00b2\\u0007u\\u0002\\u0002\\u00b2$\\u0003\\u0002\\u0002\\u0002\\u00b3\",\n    \"\\u00b4\\u0007?\\u0002\\u0002\\u00b4&\\u0003\\u0002\\u0002\\u0002\\u00b5\\u00b6\",\n    \"\\u0007\\u0080\\u0002\\u0002\\u00b6(\\u0003\\u0002\\u0002\\u0002\\u00b7\\u00b8\",\n    \"\\u0007#\\u0002\\u0002\\u00b8\\u00b9\\u0007?\\u0002\\u0002\\u00b9*\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ba\\u00bb\\u0007#\\u0002\\u0002\\u00bb\\u00bc\\u0007\\u0080\",\n    \"\\u0002\\u0002\\u00bc,\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00be\\u0007k\\u0002\",\n    \"\\u0002\\u00be\\u00bf\\u0007p\\u0002\\u0002\\u00bf.\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c0\\u00c1\\u0007e\\u0002\\u0002\\u00c1\\u00c2\\u0007q\\u0002\\u0002\\u00c2\",\n    \"\\u00c3\\u0007p\\u0002\\u0002\\u00c3\\u00c4\\u0007v\\u0002\\u0002\\u00c4\\u00c5\",\n    \"\\u0007c\\u0002\\u0002\\u00c5\\u00c6\\u0007k\\u0002\\u0002\\u00c6\\u00c7\\u0007\",\n    \"p\\u0002\\u0002\\u00c7\\u00c8\\u0007u\\u0002\\u0002\\u00c80\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00c9\\u00ca\\u0007c\\u0002\\u0002\\u00ca\\u00cb\\u0007p\\u0002\\u0002\",\n    \"\\u00cb\\u00cc\\u0007f\\u0002\\u0002\\u00cc2\\u0003\\u0002\\u0002\\u0002\\u00cd\",\n    \"\\u00ce\\u0007q\\u0002\\u0002\\u00ce\\u00cf\\u0007t\\u0002\\u0002\\u00cf4\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00d0\\u00d1\\u0007z\\u0002\\u0002\\u00d1\\u00d2\\u0007\",\n    \"q\\u0002\\u0002\\u00d2\\u00d3\\u0007t\\u0002\\u0002\\u00d36\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00d4\\u00d5\\u0007k\\u0002\\u0002\\u00d5\\u00d6\\u0007o\\u0002\\u0002\",\n    \"\\u00d6\\u00d7\\u0007r\\u0002\\u0002\\u00d7\\u00d8\\u0007n\\u0002\\u0002\\u00d8\",\n    \"\\u00d9\\u0007k\\u0002\\u0002\\u00d9\\u00da\\u0007g\\u0002\\u0002\\u00da\\u00db\",\n    \"\\u0007u\\u0002\\u0002\\u00db8\\u0003\\u0002\\u0002\\u0002\\u00dc\\u00dd\\u0007\",\n    \"*\\u0002\\u0002\\u00dd:\\u0003\\u0002\\u0002\\u0002\\u00de\\u00df\\u0007+\\u0002\",\n    \"\\u0002\\u00df<\\u0003\\u0002\\u0002\\u0002\\u00e0\\u00e1\\u0007}\\u0002\\u0002\",\n    \"\\u00e1>\\u0003\\u0002\\u0002\\u0002\\u00e2\\u00e3\\u0007\\u007f\\u0002\\u0002\",\n    \"\\u00e3@\\u0003\\u0002\\u0002\\u0002\\u00e4\\u00e5\\u0007v\\u0002\\u0002\\u00e5\",\n    \"\\u00e6\\u0007t\\u0002\\u0002\\u00e6\\u00e7\\u0007w\\u0002\\u0002\\u00e7\\u00e8\",\n    \"\\u0007g\\u0002\\u0002\\u00e8B\\u0003\\u0002\\u0002\\u0002\\u00e9\\u00ea\\u0007\",\n    \"h\\u0002\\u0002\\u00ea\\u00eb\\u0007c\\u0002\\u0002\\u00eb\\u00ec\\u0007n\\u0002\",\n    \"\\u0002\\u00ec\\u00ed\\u0007u\\u0002\\u0002\\u00ed\\u00ee\\u0007g\\u0002\\u0002\",\n    \"\\u00eeD\\u0003\\u0002\\u0002\\u0002\\u00ef\\u00f0\\u0007\\'\\u0002\\u0002\\u00f0\",\n    \"F\\u0003\\u0002\\u0002\\u0002\\u00f1\\u00f2\\u0007&\\u0002\\u0002\\u00f2\\u00f3\",\n    \"\\u0007v\\u0002\\u0002\\u00f3\\u00f4\\u0007j\\u0002\\u0002\\u00f4\\u00f5\\u0007\",\n    \"k\\u0002\\u0002\\u00f5\\u00f6\\u0007u\\u0002\\u0002\\u00f6H\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00f7\\u00f8\\u0007&\\u0002\\u0002\\u00f8\\u00f9\\u0007k\\u0002\\u0002\",\n    \"\\u00f9\\u00fa\\u0007p\\u0002\\u0002\\u00fa\\u00fb\\u0007f\\u0002\\u0002\\u00fb\",\n    \"\\u00fc\\u0007g\\u0002\\u0002\\u00fc\\u00fd\\u0007z\\u0002\\u0002\\u00fdJ\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00fe\\u00ff\\u0007&\\u0002\\u0002\\u00ff\\u0100\\u0007\",\n    \"v\\u0002\\u0002\\u0100\\u0101\\u0007q\\u0002\\u0002\\u0101\\u0102\\u0007v\\u0002\",\n    \"\\u0002\\u0102\\u0103\\u0007c\\u0002\\u0002\\u0103\\u0104\\u0007n\\u0002\\u0002\",\n    \"\\u0104L\\u0003\\u0002\\u0002\\u0002\\u0105\\u0106\\u0007.\\u0002\\u0002\\u0106\",\n    \"N\\u0003\\u0002\\u0002\\u0002\\u0107\\u0108\\u0007{\\u0002\\u0002\\u0108\\u0109\",\n    \"\\u0007g\\u0002\\u0002\\u0109\\u010a\\u0007c\\u0002\\u0002\\u010a\\u010b\\u0007\",\n    \"t\\u0002\\u0002\\u010bP\\u0003\\u0002\\u0002\\u0002\\u010c\\u010d\\u0007o\\u0002\",\n    \"\\u0002\\u010d\\u010e\\u0007q\\u0002\\u0002\\u010e\\u010f\\u0007p\\u0002\\u0002\",\n    \"\\u010f\\u0110\\u0007v\\u0002\\u0002\\u0110\\u0111\\u0007j\\u0002\\u0002\\u0111\",\n    \"R\\u0003\\u0002\\u0002\\u0002\\u0112\\u0113\\u0007y\\u0002\\u0002\\u0113\\u0114\",\n    \"\\u0007g\\u0002\\u0002\\u0114\\u0115\\u0007g\\u0002\\u0002\\u0115\\u0116\\u0007\",\n    \"m\\u0002\\u0002\\u0116T\\u0003\\u0002\\u0002\\u0002\\u0117\\u0118\\u0007f\\u0002\",\n    \"\\u0002\\u0118\\u0119\\u0007c\\u0002\\u0002\\u0119\\u011a\\u0007{\\u0002\\u0002\",\n    \"\\u011aV\\u0003\\u0002\\u0002\\u0002\\u011b\\u011c\\u0007j\\u0002\\u0002\\u011c\",\n    \"\\u011d\\u0007q\\u0002\\u0002\\u011d\\u011e\\u0007w\\u0002\\u0002\\u011e\\u011f\",\n    \"\\u0007t\\u0002\\u0002\\u011fX\\u0003\\u0002\\u0002\\u0002\\u0120\\u0121\\u0007\",\n    \"o\\u0002\\u0002\\u0121\\u0122\\u0007k\\u0002\\u0002\\u0122\\u0123\\u0007p\\u0002\",\n    \"\\u0002\\u0123\\u0124\\u0007w\\u0002\\u0002\\u0124\\u0125\\u0007v\\u0002\\u0002\",\n    \"\\u0125\\u0126\\u0007g\\u0002\\u0002\\u0126Z\\u0003\\u0002\\u0002\\u0002\\u0127\",\n    \"\\u0128\\u0007u\\u0002\\u0002\\u0128\\u0129\\u0007g\\u0002\\u0002\\u0129\\u012a\",\n    \"\\u0007e\\u0002\\u0002\\u012a\\u012b\\u0007q\\u0002\\u0002\\u012b\\u012c\\u0007\",\n    \"p\\u0002\\u0002\\u012c\\u012d\\u0007f\\u0002\\u0002\\u012d\\\\\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u012e\\u012f\\u0007o\\u0002\\u0002\\u012f\\u0130\\u0007k\\u0002\\u0002\",\n    \"\\u0130\\u0131\\u0007n\\u0002\\u0002\\u0131\\u0132\\u0007n\\u0002\\u0002\\u0132\",\n    \"\\u0133\\u0007k\\u0002\\u0002\\u0133\\u0134\\u0007u\\u0002\\u0002\\u0134\\u0135\",\n    \"\\u0007g\\u0002\\u0002\\u0135\\u0136\\u0007e\\u0002\\u0002\\u0136\\u0137\\u0007\",\n    \"q\\u0002\\u0002\\u0137\\u0138\\u0007p\\u0002\\u0002\\u0138\\u0139\\u0007f\\u0002\",\n    \"\\u0002\\u0139^\\u0003\\u0002\\u0002\\u0002\\u013a\\u013b\\u0007{\\u0002\\u0002\",\n    \"\\u013b\\u013c\\u0007g\\u0002\\u0002\\u013c\\u013d\\u0007c\\u0002\\u0002\\u013d\",\n    \"\\u013e\\u0007t\\u0002\\u0002\\u013e\\u013f\\u0007u\\u0002\\u0002\\u013f`\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0140\\u0141\\u0007o\\u0002\\u0002\\u0141\\u0142\\u0007\",\n    \"q\\u0002\\u0002\\u0142\\u0143\\u0007p\\u0002\\u0002\\u0143\\u0144\\u0007v\\u0002\",\n    \"\\u0002\\u0144\\u0145\\u0007j\\u0002\\u0002\\u0145\\u0146\\u0007u\\u0002\\u0002\",\n    \"\\u0146b\\u0003\\u0002\\u0002\\u0002\\u0147\\u0148\\u0007y\\u0002\\u0002\\u0148\",\n    \"\\u0149\\u0007g\\u0002\\u0002\\u0149\\u014a\\u0007g\\u0002\\u0002\\u014a\\u014b\",\n    \"\\u0007m\\u0002\\u0002\\u014b\\u014c\\u0007u\\u0002\\u0002\\u014cd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u014d\\u014e\\u0007f\\u0002\\u0002\\u014e\\u014f\\u0007c\\u0002\",\n    \"\\u0002\\u014f\\u0150\\u0007{\\u0002\\u0002\\u0150\\u0151\\u0007u\\u0002\\u0002\",\n    \"\\u0151f\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0007j\\u0002\\u0002\\u0153\",\n    \"\\u0154\\u0007q\\u0002\\u0002\\u0154\\u0155\\u0007w\\u0002\\u0002\\u0155\\u0156\",\n    \"\\u0007t\\u0002\\u0002\\u0156\\u0157\\u0007u\\u0002\\u0002\\u0157h\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0158\\u0159\\u0007o\\u0002\\u0002\\u0159\\u015a\\u0007k\\u0002\",\n    \"\\u0002\\u015a\\u015b\\u0007p\\u0002\\u0002\\u015b\\u015c\\u0007w\\u0002\\u0002\",\n    \"\\u015c\\u015d\\u0007v\\u0002\\u0002\\u015d\\u015e\\u0007g\\u0002\\u0002\\u015e\",\n    \"\\u015f\\u0007u\\u0002\\u0002\\u015fj\\u0003\\u0002\\u0002\\u0002\\u0160\\u0161\",\n    \"\\u0007u\\u0002\\u0002\\u0161\\u0162\\u0007g\\u0002\\u0002\\u0162\\u0163\\u0007\",\n    \"e\\u0002\\u0002\\u0163\\u0164\\u0007q\\u0002\\u0002\\u0164\\u0165\\u0007p\\u0002\",\n    \"\\u0002\\u0165\\u0166\\u0007f\\u0002\\u0002\\u0166\\u0167\\u0007u\\u0002\\u0002\",\n    \"\\u0167l\\u0003\\u0002\\u0002\\u0002\\u0168\\u0169\\u0007o\\u0002\\u0002\\u0169\",\n    \"\\u016a\\u0007k\\u0002\\u0002\\u016a\\u016b\\u0007n\\u0002\\u0002\\u016b\\u016c\",\n    \"\\u0007n\\u0002\\u0002\\u016c\\u016d\\u0007k\\u0002\\u0002\\u016d\\u016e\\u0007\",\n    \"u\\u0002\\u0002\\u016e\\u016f\\u0007g\\u0002\\u0002\\u016f\\u0170\\u0007e\\u0002\",\n    \"\\u0002\\u0170\\u0171\\u0007q\\u0002\\u0002\\u0171\\u0172\\u0007p\\u0002\\u0002\",\n    \"\\u0172\\u0173\\u0007f\\u0002\\u0002\\u0173\\u0174\\u0007u\\u0002\\u0002\\u0174\",\n    \"n\\u0003\\u0002\\u0002\\u0002\\u0175\\u0176\\u0007B\\u0002\\u0002\\u0176\\u0177\",\n    \"\\t\\u0002\\u0002\\u0002\\u0177\\u0178\\t\\u0002\\u0002\\u0002\\u0178\\u0179\\t\\u0002\",\n    \"\\u0002\\u0002\\u0179\\u0186\\t\\u0002\\u0002\\u0002\\u017a\\u017b\\u0007/\\u0002\",\n    \"\\u0002\\u017b\\u017c\\t\\u0002\\u0002\\u0002\\u017c\\u0184\\t\\u0002\\u0002\\u0002\",\n    \"\\u017d\\u017e\\u0007/\\u0002\\u0002\\u017e\\u017f\\t\\u0002\\u0002\\u0002\\u017f\",\n    \"\\u0182\\t\\u0002\\u0002\\u0002\\u0180\\u0181\\u0007V\\u0002\\u0002\\u0181\\u0183\",\n    \"\\u0005s:\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0182\\u0183\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0183\\u0185\\u0003\\u0002\\u0002\\u0002\\u0184\\u017d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0184\\u0185\\u0003\\u0002\\u0002\\u0002\\u0185\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0186\\u017a\\u0003\\u0002\\u0002\\u0002\\u0186\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0187\\u0189\\u0003\\u0002\\u0002\\u0002\\u0188\\u018a\\u0007\",\n    \"\\\\\\u0002\\u0002\\u0189\\u0188\\u0003\\u0002\\u0002\\u0002\\u0189\\u018a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u018ap\\u0003\\u0002\\u0002\\u0002\\u018b\\u018c\\u0007\",\n    \"B\\u0002\\u0002\\u018c\\u018d\\u0007V\\u0002\\u0002\\u018d\\u018e\\u0005s:\\u0002\",\n    \"\\u018er\\u0003\\u0002\\u0002\\u0002\\u018f\\u0190\\t\\u0002\\u0002\\u0002\\u0190\",\n    \"\\u01a1\\t\\u0002\\u0002\\u0002\\u0191\\u0192\\u0007<\\u0002\\u0002\\u0192\\u0193\",\n    \"\\t\\u0002\\u0002\\u0002\\u0193\\u019f\\t\\u0002\\u0002\\u0002\\u0194\\u0195\\u0007\",\n    \"<\\u0002\\u0002\\u0195\\u0196\\t\\u0002\\u0002\\u0002\\u0196\\u019d\\t\\u0002\\u0002\",\n    \"\\u0002\\u0197\\u0199\\u00070\\u0002\\u0002\\u0198\\u019a\\t\\u0002\\u0002\\u0002\",\n    \"\\u0199\\u0198\\u0003\\u0002\\u0002\\u0002\\u019a\\u019b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019b\\u0199\\u0003\\u0002\\u0002\\u0002\\u019b\\u019c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019c\\u019e\\u0003\\u0002\\u0002\\u0002\\u019d\\u0197\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019d\\u019e\\u0003\\u0002\\u0002\\u0002\\u019e\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019f\\u0194\\u0003\\u0002\\u0002\\u0002\\u019f\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a0\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a1\\u0191\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a1\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01aa\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a3\\u01ab\\u0007\\\\\\u0002\\u0002\\u01a4\\u01a5\\t\\u0003\\u0002\\u0002\\u01a5\",\n    \"\\u01a6\\t\\u0002\\u0002\\u0002\\u01a6\\u01a7\\t\\u0002\\u0002\\u0002\\u01a7\\u01a8\",\n    \"\\u0007<\\u0002\\u0002\\u01a8\\u01a9\\t\\u0002\\u0002\\u0002\\u01a9\\u01ab\\t\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01a3\\u0003\\u0002\\u0002\\u0002\\u01aa\\u01a4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01ab\\u0003\\u0002\\u0002\\u0002\\u01abt\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ac\\u01ae\\t\\u0004\\u0002\\u0002\\u01ad\\u01ac\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ae\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01af\\u01b1\\t\\u0005\",\n    \"\\u0002\\u0002\\u01b0\\u01af\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01b4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b2\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b2\\u01b3\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b3v\\u0003\\u0002\\u0002\\u0002\\u01b4\\u01b2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b5\\u01ba\\u0007b\\u0002\\u0002\\u01b6\\u01b9\\u0005\\u0083\",\n    \"B\\u0002\\u01b7\\u01b9\\n\\u0006\\u0002\\u0002\\u01b8\\u01b6\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01b8\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01bc\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ba\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bb\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bb\\u01bd\\u0003\\u0002\\u0002\\u0002\\u01bc\\u01ba\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bd\\u01be\\u0007b\\u0002\\u0002\\u01bex\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01bf\\u01c4\\u0007)\\u0002\\u0002\\u01c0\\u01c3\\u0005\\u0083B\\u0002\\u01c1\",\n    \"\\u01c3\\n\\u0007\\u0002\\u0002\\u01c2\\u01c0\\u0003\\u0002\\u0002\\u0002\\u01c2\",\n    \"\\u01c1\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c6\\u0003\\u0002\\u0002\\u0002\\u01c4\",\n    \"\\u01c2\\u0003\\u0002\\u0002\\u0002\\u01c4\\u01c5\\u0003\\u0002\\u0002\\u0002\\u01c5\",\n    \"\\u01c7\\u0003\\u0002\\u0002\\u0002\\u01c6\\u01c4\\u0003\\u0002\\u0002\\u0002\\u01c7\",\n    \"\\u01c8\\u0007)\\u0002\\u0002\\u01c8z\\u0003\\u0002\\u0002\\u0002\\u01c9\\u01cb\",\n    \"\\t\\u0002\\u0002\\u0002\\u01ca\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01ca\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01cd\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cd\\u01d4\\u0003\\u0002\\u0002\\u0002\\u01ce\\u01d0\",\n    \"\\u00070\\u0002\\u0002\\u01cf\\u01d1\\t\\u0002\\u0002\\u0002\\u01d0\\u01cf\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d1\\u01d2\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d2\\u01d3\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d4\\u01ce\\u0003\\u0002\\u0002\\u0002\\u01d4\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d5|\\u0003\\u0002\\u0002\\u0002\\u01d6\\u01d8\\t\\b\\u0002\",\n    \"\\u0002\\u01d7\\u01d6\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01d9\\u01d7\\u0003\\u0002\\u0002\\u0002\\u01d9\\u01da\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01da\\u01db\\u0003\\u0002\\u0002\\u0002\\u01db\\u01dc\\b?\\u0002\\u0002\",\n    \"\\u01dc~\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01de\\u00071\\u0002\\u0002\\u01de\",\n    \"\\u01df\\u0007,\\u0002\\u0002\\u01df\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e0\",\n    \"\\u01e2\\u000b\\u0002\\u0002\\u0002\\u01e1\\u01e0\\u0003\\u0002\\u0002\\u0002\\u01e2\",\n    \"\\u01e5\\u0003\\u0002\\u0002\\u0002\\u01e3\\u01e4\\u0003\\u0002\\u0002\\u0002\\u01e3\",\n    \"\\u01e1\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e6\\u0003\\u0002\\u0002\\u0002\\u01e5\",\n    \"\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e7\\u0007,\\u0002\\u0002\\u01e7\",\n    \"\\u01e8\\u00071\\u0002\\u0002\\u01e8\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01e9\",\n    \"\\u01ea\\b@\\u0002\\u0002\\u01ea\\u0080\\u0003\\u0002\\u0002\\u0002\\u01eb\\u01ec\",\n    \"\\u00071\\u0002\\u0002\\u01ec\\u01ed\\u00071\\u0002\\u0002\\u01ed\\u01f1\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01ee\\u01f0\\n\\t\\u0002\\u0002\\u01ef\\u01ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f0\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f1\\u01ef\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f1\\u01f2\\u0003\\u0002\\u0002\\u0002\\u01f2\\u01f4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f3\\u01f1\\u0003\\u0002\\u0002\\u0002\\u01f4\\u01f5\\bA\\u0002\",\n    \"\\u0002\\u01f5\\u0082\\u0003\\u0002\\u0002\\u0002\\u01f6\\u01f9\\u0007^\\u0002\",\n    \"\\u0002\\u01f7\\u01fa\\t\\n\\u0002\\u0002\\u01f8\\u01fa\\u0005\\u0085C\\u0002\\u01f9\",\n    \"\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01f9\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fa\",\n    \"\\u0084\\u0003\\u0002\\u0002\\u0002\\u01fb\\u01fc\\u0007w\\u0002\\u0002\\u01fc\",\n    \"\\u01fd\\u0005\\u0087D\\u0002\\u01fd\\u01fe\\u0005\\u0087D\\u0002\\u01fe\\u01ff\",\n    \"\\u0005\\u0087D\\u0002\\u01ff\\u0200\\u0005\\u0087D\\u0002\\u0200\\u0086\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0201\\u0202\\t\\u000b\\u0002\\u0002\\u0202\\u0088\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u001a\\u0002\\u0182\\u0184\\u0186\\u0189\\u019b\\u019d\\u019f\",\n    \"\\u01a1\\u01aa\\u01ad\\u01b0\\u01b2\\u01b8\\u01ba\\u01c2\\u01c4\\u01cc\\u01d2\\u01d4\",\n    \"\\u01d9\\u01e3\\u01f1\\u01f9\\u0003\\u0002\\u0003\\u0002\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nclass FHIRPathLexer extends antlr4.Lexer {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\n\tstatic modeNames = [ \"DEFAULT_MODE\" ];\n\tstatic literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                         \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                         \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \n                         \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \n                         \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \n                         \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \n                         \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \n                         \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \n                         \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \n                         \"'minutes'\", \"'seconds'\", \"'milliseconds'\" ];\n\tstatic symbolicNames = [ null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, \"DATETIME\", \n                          \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \n                          \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n\tstatic ruleNames = [ \"T__0\", \"T__1\", \"T__2\", \"T__3\", \"T__4\", \"T__5\", \"T__6\", \n                      \"T__7\", \"T__8\", \"T__9\", \"T__10\", \"T__11\", \"T__12\", \n                      \"T__13\", \"T__14\", \"T__15\", \"T__16\", \"T__17\", \"T__18\", \n                      \"T__19\", \"T__20\", \"T__21\", \"T__22\", \"T__23\", \"T__24\", \n                      \"T__25\", \"T__26\", \"T__27\", \"T__28\", \"T__29\", \"T__30\", \n                      \"T__31\", \"T__32\", \"T__33\", \"T__34\", \"T__35\", \"T__36\", \n                      \"T__37\", \"T__38\", \"T__39\", \"T__40\", \"T__41\", \"T__42\", \n                      \"T__43\", \"T__44\", \"T__45\", \"T__46\", \"T__47\", \"T__48\", \n                      \"T__49\", \"T__50\", \"T__51\", \"T__52\", \"T__53\", \"DATETIME\", \n                      \"TIME\", \"TIMEFORMAT\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                      \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\", \n                      \"ESC\", \"UNICODE\", \"HEX\" ];\n\n    constructor(input) {\n        super(input)\n        this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());\n    }\n\n    get atn() {\n        return atn;\n    }\n}\n\nFHIRPathLexer.EOF = antlr4.Token.EOF;\nFHIRPathLexer.T__0 = 1;\nFHIRPathLexer.T__1 = 2;\nFHIRPathLexer.T__2 = 3;\nFHIRPathLexer.T__3 = 4;\nFHIRPathLexer.T__4 = 5;\nFHIRPathLexer.T__5 = 6;\nFHIRPathLexer.T__6 = 7;\nFHIRPathLexer.T__7 = 8;\nFHIRPathLexer.T__8 = 9;\nFHIRPathLexer.T__9 = 10;\nFHIRPathLexer.T__10 = 11;\nFHIRPathLexer.T__11 = 12;\nFHIRPathLexer.T__12 = 13;\nFHIRPathLexer.T__13 = 14;\nFHIRPathLexer.T__14 = 15;\nFHIRPathLexer.T__15 = 16;\nFHIRPathLexer.T__16 = 17;\nFHIRPathLexer.T__17 = 18;\nFHIRPathLexer.T__18 = 19;\nFHIRPathLexer.T__19 = 20;\nFHIRPathLexer.T__20 = 21;\nFHIRPathLexer.T__21 = 22;\nFHIRPathLexer.T__22 = 23;\nFHIRPathLexer.T__23 = 24;\nFHIRPathLexer.T__24 = 25;\nFHIRPathLexer.T__25 = 26;\nFHIRPathLexer.T__26 = 27;\nFHIRPathLexer.T__27 = 28;\nFHIRPathLexer.T__28 = 29;\nFHIRPathLexer.T__29 = 30;\nFHIRPathLexer.T__30 = 31;\nFHIRPathLexer.T__31 = 32;\nFHIRPathLexer.T__32 = 33;\nFHIRPathLexer.T__33 = 34;\nFHIRPathLexer.T__34 = 35;\nFHIRPathLexer.T__35 = 36;\nFHIRPathLexer.T__36 = 37;\nFHIRPathLexer.T__37 = 38;\nFHIRPathLexer.T__38 = 39;\nFHIRPathLexer.T__39 = 40;\nFHIRPathLexer.T__40 = 41;\nFHIRPathLexer.T__41 = 42;\nFHIRPathLexer.T__42 = 43;\nFHIRPathLexer.T__43 = 44;\nFHIRPathLexer.T__44 = 45;\nFHIRPathLexer.T__45 = 46;\nFHIRPathLexer.T__46 = 47;\nFHIRPathLexer.T__47 = 48;\nFHIRPathLexer.T__48 = 49;\nFHIRPathLexer.T__49 = 50;\nFHIRPathLexer.T__50 = 51;\nFHIRPathLexer.T__51 = 52;\nFHIRPathLexer.T__52 = 53;\nFHIRPathLexer.T__53 = 54;\nFHIRPathLexer.DATETIME = 55;\nFHIRPathLexer.TIME = 56;\nFHIRPathLexer.IDENTIFIER = 57;\nFHIRPathLexer.DELIMITEDIDENTIFIER = 58;\nFHIRPathLexer.STRING = 59;\nFHIRPathLexer.NUMBER = 60;\nFHIRPathLexer.WS = 61;\nFHIRPathLexer.COMMENT = 62;\nFHIRPathLexer.LINE_COMMENT = 63;\n\n\n\n\nmodule.exports = FHIRPathLexer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9nZW5lcmF0ZWQvRkhJUlBhdGhMZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFIQUFpQjs7OztBQUl4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTyxTQUFTO0FBQ2xFLE1BQU0sT0FBTyxTQUFTLEdBQUcsT0FBTyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsaUVBQWlFLEtBQUssRUFBRTtBQUN4RTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtCQUErQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vZmhpcnBhdGhAMy4xOC4wL25vZGVfbW9kdWxlcy9maGlycGF0aC9zcmMvcGFyc2VyL2dlbmVyYXRlZC9GSElSUGF0aExleGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBmcm9tIEZISVJQYXRoLmc0IGJ5IEFOVExSIDQuOS4zXG4vLyBqc2hpbnQgaWdub3JlOiBzdGFydFxuY29uc3QgYW50bHI0ID0gcmVxdWlyZSgnLi4vYW50bHI0LWluZGV4Jyk7XG5cblxuXG5jb25zdCBzZXJpYWxpemVkQVROID0gW1wiXFx1MDAwM1xcdTYwOGJcXHVhNzJhXFx1ODEzM1xcdWI5ZWRcXHU0MTdjXFx1M2JlN1xcdTc3ODZcIixcbiAgICBcIlxcdTU5NjRcXHUwMDAyQVxcdTAyMDNcXGJcXHUwMDAxXFx1MDAwNFxcdTAwMDJcXHRcXHUwMDAyXFx1MDAwNFxcdTAwMDNcXHRcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDA0XFx1MDAwNFxcdFxcdTAwMDRcXHUwMDA0XFx1MDAwNVxcdFxcdTAwMDVcXHUwMDA0XFx1MDAwNlxcdFxcdTAwMDZcXHUwMDA0XFx1MDAwN1wiLFxuICAgIFwiXFx0XFx1MDAwN1xcdTAwMDRcXGJcXHRcXGJcXHUwMDA0XFx0XFx0XFx0XFx1MDAwNFxcblxcdFxcblxcdTAwMDRcXHUwMDBiXFx0XFx1MDAwYlxcdTAwMDRcIixcbiAgICBcIlxcZlxcdFxcZlxcdTAwMDRcXHJcXHRcXHJcXHUwMDA0XFx1MDAwZVxcdFxcdTAwMGVcXHUwMDA0XFx1MDAwZlxcdFxcdTAwMGZcXHUwMDA0XFx1MDAxMFwiLFxuICAgIFwiXFx0XFx1MDAxMFxcdTAwMDRcXHUwMDExXFx0XFx1MDAxMVxcdTAwMDRcXHUwMDEyXFx0XFx1MDAxMlxcdTAwMDRcXHUwMDEzXFx0XFx1MDAxM1wiLFxuICAgIFwiXFx1MDAwNFxcdTAwMTRcXHRcXHUwMDE0XFx1MDAwNFxcdTAwMTVcXHRcXHUwMDE1XFx1MDAwNFxcdTAwMTZcXHRcXHUwMDE2XFx1MDAwNFxcdTAwMTdcIixcbiAgICBcIlxcdFxcdTAwMTdcXHUwMDA0XFx1MDAxOFxcdFxcdTAwMThcXHUwMDA0XFx1MDAxOVxcdFxcdTAwMTlcXHUwMDA0XFx1MDAxYVxcdFxcdTAwMWFcIixcbiAgICBcIlxcdTAwMDRcXHUwMDFiXFx0XFx1MDAxYlxcdTAwMDRcXHUwMDFjXFx0XFx1MDAxY1xcdTAwMDRcXHUwMDFkXFx0XFx1MDAxZFxcdTAwMDRcXHUwMDFlXCIsXG4gICAgXCJcXHRcXHUwMDFlXFx1MDAwNFxcdTAwMWZcXHRcXHUwMDFmXFx1MDAwNCBcXHQgXFx1MDAwNCFcXHQhXFx1MDAwNFxcXCJcXHRcXFwiXFx1MDAwNCNcIixcbiAgICBcIlxcdCNcXHUwMDA0JFxcdCRcXHUwMDA0JVxcdCVcXHUwMDA0JlxcdCZcXHUwMDA0XFwnXFx0XFwnXFx1MDAwNChcXHQoXFx1MDAwNClcXHQpXFx1MDAwNFwiLFxuICAgIFwiKlxcdCpcXHUwMDA0K1xcdCtcXHUwMDA0LFxcdCxcXHUwMDA0LVxcdC1cXHUwMDA0LlxcdC5cXHUwMDA0L1xcdC9cXHUwMDA0MFxcdDBcXHUwMDA0XCIsXG4gICAgXCIxXFx0MVxcdTAwMDQyXFx0MlxcdTAwMDQzXFx0M1xcdTAwMDQ0XFx0NFxcdTAwMDQ1XFx0NVxcdTAwMDQ2XFx0NlxcdTAwMDQ3XFx0N1xcdTAwMDRcIixcbiAgICBcIjhcXHQ4XFx1MDAwNDlcXHQ5XFx1MDAwNDpcXHQ6XFx1MDAwNDtcXHQ7XFx1MDAwNDxcXHQ8XFx1MDAwND1cXHQ9XFx1MDAwND5cXHQ+XFx1MDAwNFwiLFxuICAgIFwiP1xcdD9cXHUwMDA0QFxcdEBcXHUwMDA0QVxcdEFcXHUwMDA0QlxcdEJcXHUwMDA0Q1xcdENcXHUwMDA0RFxcdERcXHUwMDAzXFx1MDAwMlxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA1XFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwNVxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcYlxcdTAwMDNcIixcbiAgICBcIlxcYlxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXHRcXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFx1MDAwZVwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAxMVxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTJcIixcbiAgICBcIlxcdTAwMDNcXHUwMDEzXFx1MDAwM1xcdTAwMTNcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XCIsXG4gICAgXCJcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcIixcbiAgICBcIlxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMTlcXHUwMDAzXFx1MDAxOVwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMTlcXHUwMDAzXFx1MDAxOVxcdTAwMDNcXHUwMDFhXFx1MDAwM1xcdTAwMWFcXHUwMDAzXFx1MDAxYVxcdTAwMDNcXHUwMDFiXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAxYlxcdTAwMDNcXHUwMDFiXFx1MDAwM1xcdTAwMWJcXHUwMDAzXFx1MDAxY1xcdTAwMDNcXHUwMDFjXFx1MDAwM1xcdTAwMWNcIixcbiAgICBcIlxcdTAwMDNcXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDAzXFx1MDAxY1xcdTAwMDNcXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDAzXFx1MDAxZFwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMWRcXHUwMDAzXFx1MDAxZVxcdTAwMDNcXHUwMDFlXFx1MDAwM1xcdTAwMWZcXHUwMDAzXFx1MDAxZlxcdTAwMDMgXCIsXG4gICAgXCJcXHUwMDAzIFxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzXFxcIlxcdTAwMDNcXFwiXFx1MDAwM1xcXCJcXHUwMDAzXCIsXG4gICAgXCJcXFwiXFx1MDAwM1xcXCJcXHUwMDAzXFxcIlxcdTAwMDMjXFx1MDAwMyNcXHUwMDAzJFxcdTAwMDMkXFx1MDAwMyRcXHUwMDAzJFxcdTAwMDMkXCIsXG4gICAgXCJcXHUwMDAzJFxcdTAwMDMlXFx1MDAwMyVcXHUwMDAzJVxcdTAwMDMlXFx1MDAwMyVcXHUwMDAzJVxcdTAwMDMlXFx1MDAwMyZcXHUwMDAzXCIsXG4gICAgXCImXFx1MDAwMyZcXHUwMDAzJlxcdTAwMDMmXFx1MDAwMyZcXHUwMDAzJlxcdTAwMDNcXCdcXHUwMDAzXFwnXFx1MDAwMyhcXHUwMDAzKFxcdTAwMDNcIixcbiAgICBcIihcXHUwMDAzKFxcdTAwMDMoXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwMypcXHUwMDAzXCIsXG4gICAgXCIqXFx1MDAwMypcXHUwMDAzKlxcdTAwMDMqXFx1MDAwMytcXHUwMDAzK1xcdTAwMDMrXFx1MDAwMytcXHUwMDAzLFxcdTAwMDMsXFx1MDAwM1wiLFxuICAgIFwiLFxcdTAwMDMsXFx1MDAwMyxcXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy1cXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy1cXHUwMDAzLVxcdTAwMDNcIixcbiAgICBcIi5cXHUwMDAzLlxcdTAwMDMuXFx1MDAwMy5cXHUwMDAzLlxcdTAwMDMuXFx1MDAwMy5cXHUwMDAzL1xcdTAwMDMvXFx1MDAwMy9cXHUwMDAzXCIsXG4gICAgXCIvXFx1MDAwMy9cXHUwMDAzL1xcdTAwMDMvXFx1MDAwMy9cXHUwMDAzL1xcdTAwMDMvXFx1MDAwMy9cXHUwMDAzL1xcdTAwMDMwXFx1MDAwM1wiLFxuICAgIFwiMFxcdTAwMDMwXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDMwXFx1MDAwMzFcXHUwMDAzMVxcdTAwMDMxXFx1MDAwMzFcXHUwMDAzMVxcdTAwMDNcIixcbiAgICBcIjFcXHUwMDAzMVxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMzXFx1MDAwMzNcXHUwMDAzXCIsXG4gICAgXCIzXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDM0XFx1MDAwMzRcXHUwMDAzNFxcdTAwMDM0XFx1MDAwMzRcXHUwMDAzNFxcdTAwMDM1XFx1MDAwM1wiLFxuICAgIFwiNVxcdTAwMDM1XFx1MDAwMzVcXHUwMDAzNVxcdTAwMDM1XFx1MDAwMzVcXHUwMDAzNVxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDNcIixcbiAgICBcIjZcXHUwMDAzNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDM3XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwMzdcXHUwMDAzXCIsXG4gICAgXCI3XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwMzdcXHUwMDAzOFxcdTAwMDM4XFx1MDAwM1wiLFxuICAgIFwiOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDNcIixcbiAgICBcIjhcXHUwMDA1OFxcdTAxODNcXG44XFx1MDAwNThcXHUwMTg1XFxuOFxcdTAwMDU4XFx1MDE4N1xcbjhcXHUwMDAzOFxcdTAwMDU4XFx1MDE4YVwiLFxuICAgIFwiXFxuOFxcdTAwMDM5XFx1MDAwMzlcXHUwMDAzOVxcdTAwMDM5XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDNcIixcbiAgICBcIjpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDY6XFx1MDE5YVxcbjpcXHI6XFx1MDAwZTpcXHUwMTliXFx1MDAwNVwiLFxuICAgIFwiOlxcdTAxOWVcXG46XFx1MDAwNTpcXHUwMWEwXFxuOlxcdTAwMDU6XFx1MDFhMlxcbjpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzXCIsXG4gICAgXCI6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwNTpcXHUwMWFiXFxuOlxcdTAwMDM7XFx1MDAwNTtcXHUwMWFlXFxuO1xcdTAwMDNcIixcbiAgICBcIjtcXHUwMDA3O1xcdTAxYjFcXG47XFxmO1xcdTAwMGU7XFx1MDFiNFxcdTAwMGI7XFx1MDAwMzxcXHUwMDAzPFxcdTAwMDM8XFx1MDAwN1wiLFxuICAgIFwiPFxcdTAxYjlcXG48XFxmPFxcdTAwMGU8XFx1MDFiY1xcdTAwMGI8XFx1MDAwMzxcXHUwMDAzPFxcdTAwMDM9XFx1MDAwMz1cXHUwMDAzXCIsXG4gICAgXCI9XFx1MDAwNz1cXHUwMWMzXFxuPVxcZj1cXHUwMDBlPVxcdTAxYzZcXHUwMDBiPVxcdTAwMDM9XFx1MDAwMz1cXHUwMDAzPlxcdTAwMDZcIixcbiAgICBcIj5cXHUwMWNiXFxuPlxccj5cXHUwMDBlPlxcdTAxY2NcXHUwMDAzPlxcdTAwMDM+XFx1MDAwNj5cXHUwMWQxXFxuPlxccj5cXHUwMDBlPlxcdTAxZDJcIixcbiAgICBcIlxcdTAwMDU+XFx1MDFkNVxcbj5cXHUwMDAzP1xcdTAwMDY/XFx1MDFkOFxcbj9cXHI/XFx1MDAwZT9cXHUwMWQ5XFx1MDAwMz9cXHUwMDAzXCIsXG4gICAgXCI/XFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA3QFxcdTAxZTJcXG5AXFxmQFxcdTAwMGVAXFx1MDFlNVxcdTAwMGJcIixcbiAgICBcIkBcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0FcXHUwMDAzQVxcdTAwMDNBXFx1MDAwM0FcXHUwMDA3XCIsXG4gICAgXCJBXFx1MDFmMFxcbkFcXGZBXFx1MDAwZUFcXHUwMWYzXFx1MDAwYkFcXHUwMDAzQVxcdTAwMDNBXFx1MDAwM0JcXHUwMDAzQlxcdTAwMDNcIixcbiAgICBcIkJcXHUwMDA1QlxcdTAxZmFcXG5CXFx1MDAwM0NcXHUwMDAzQ1xcdTAwMDNDXFx1MDAwM0NcXHUwMDAzQ1xcdTAwMDNDXFx1MDAwM0RcXHUwMDAzXCIsXG4gICAgXCJEXFx1MDAwM1xcdTAxZTNcXHUwMDAyRVxcdTAwMDNcXHUwMDAzXFx1MDAwNVxcdTAwMDRcXHUwMDA3XFx1MDAwNVxcdFxcdTAwMDZcXHUwMDBiXCIsXG4gICAgXCJcXHUwMDA3XFxyXFxiXFx1MDAwZlxcdFxcdTAwMTFcXG5cXHUwMDEzXFx1MDAwYlxcdTAwMTVcXGZcXHUwMDE3XFxyXFx1MDAxOVxcdTAwMGVcXHUwMDFiXCIsXG4gICAgXCJcXHUwMDBmXFx1MDAxZFxcdTAwMTBcXHUwMDFmXFx1MDAxMSFcXHUwMDEyI1xcdTAwMTMlXFx1MDAxNFxcJ1xcdTAwMTUpXFx1MDAxNitcIixcbiAgICBcIlxcdTAwMTctXFx1MDAxOC9cXHUwMDE5MVxcdTAwMWEzXFx1MDAxYjVcXHUwMDFjN1xcdTAwMWQ5XFx1MDAxZTtcXHUwMDFmPSA/IUFcIixcbiAgICBcIlxcXCJDI0UkRyVJJktcXCdNKE8pUSpTK1UsVy1ZLlsvXTBfMWEyYzNlNGc1aTZrN204bzlxOnNcXHUwMDAydTt3PHk9ez59XCIsXG4gICAgXCI/XFx1MDA3ZkBcXHUwMDgxQVxcdTAwODNcXHUwMDAyXFx1MDA4NVxcdTAwMDJcXHUwMDg3XFx1MDAwMlxcdTAwMDNcXHUwMDAyXFxmXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMjI7XFx1MDAwNFxcdTAwMDItLS8vXFx1MDAwNVxcdTAwMDJDXFxcXGFhY3xcXHUwMDA2XFx1MDAwMjI7Q1xcXFxhYWN8XFx1MDAwNFwiLFxuICAgIFwiXFx1MDAwMl5eYmJcXHUwMDAzXFx1MDAwMikpXFx1MDAwNVxcdTAwMDJcXHUwMDBiXFxmXFx1MDAwZlxcdTAwMGZcXFwiXFxcIlxcdTAwMDRcXHUwMDAyXCIsXG4gICAgXCJcXGZcXGZcXHUwMDBmXFx1MDAwZlxcblxcdTAwMDIpKTExXl5iYmhocHB0dHZ2XFx1MDAwNVxcdTAwMDIyO0NIY2hcXHUwMDAyXFx1MDIxNFwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcclxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDBmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAxN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDFiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMiFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyI1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyJVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXCdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMilcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMitcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyLVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyL1xcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDIxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMjVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyO1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCI9XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDI/XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJBXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMkNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMkVcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyR1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAySVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJLXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJNXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMk9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiU1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyVVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyV1xcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJZXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJbXFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMl1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMl9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJnXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcImlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMmtcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMm1cXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyb1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAycVxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJ1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJ3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMnlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMntcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyfVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA3ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDgxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDNcXHUwMDg5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwNVxcdTAwOGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwN1xcdTAwOGRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHRcXHUwMDhmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMGJcXHUwMDkxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFxyXFx1MDA5M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDBmXFx1MDA5NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMTFcXHUwMDk3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTNcXHUwMDliXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAxNVxcdTAwOWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxN1xcdTAwYTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDE5XFx1MDBhM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFiXFx1MDBhNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMWRcXHUwMGE4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWZcXHUwMGFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiIVxcdTAwYWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyI1xcdTAwYjBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyJVxcdTAwYjNcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXCdcXHUwMGI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMilcXHUwMGI3XFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyK1xcdTAwYmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyLVxcdTAwYmRcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDIvXFx1MDBjMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIxXFx1MDBjOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMjNcXHUwMGNkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjVcXHUwMGQwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiN1xcdTAwZDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyOVxcdTAwZGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyO1xcdTAwZGVcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI9XFx1MDBlMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI/XFx1MDBlMlxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMkFcXHUwMGU0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkNcXHUwMGU5XFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyRVxcdTAwZWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyR1xcdTAwZjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJJXFx1MDBmN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJLXFx1MDBmZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIk1cXHUwMTA1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk9cXHUwMTA3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlFcXHUwMTBjXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyU1xcdTAxMTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyVVxcdTAxMTdcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJXXFx1MDExYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJZXFx1MDEyMFxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMltcXHUwMTI3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMl1cXHUwMTJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyX1xcdTAxM2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyYVxcdTAxNDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJjXFx1MDE0N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJlXFx1MDE0ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJnXFx1MDE1MlwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmlcXHUwMTU4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmtcXHUwMTYwXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAybVxcdTAxNjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyb1xcdTAxNzVcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJxXFx1MDE4YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJzXFx1MDE4ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMnVcXHUwMWFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMndcXHUwMWI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwieVxcdTAxYmZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAye1xcdTAxY2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyfVxcdTAxZDdcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDdmXFx1MDFkZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDgxXFx1MDFlYlwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODNcXHUwMWY2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODVcXHUwMWZiXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4N1xcdTAyMDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4OVxcdTAwOGFcIixcbiAgICBcIlxcdTAwMDcwXFx1MDAwMlxcdTAwMDJcXHUwMDhhXFx1MDAwNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhiXFx1MDA4Y1wiLFxuICAgIFwiXFx1MDAwN11cXHUwMDAyXFx1MDAwMlxcdTAwOGNcXHUwMDA2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOGRcXHUwMDhlXCIsXG4gICAgXCJcXHUwMDA3X1xcdTAwMDJcXHUwMDAyXFx1MDA4ZVxcYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhmXFx1MDA5MFxcdTAwMDdcIixcbiAgICBcIi1cXHUwMDAyXFx1MDAwMlxcdTAwOTBcXG5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5MVxcdTAwOTJcXHUwMDA3L1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDkyXFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTNcXHUwMDk0XFx1MDAwNyxcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDA5NFxcdTAwMGVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5NVxcdTAwOTZcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDk2XFx1MDAxMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk3XFx1MDA5OFxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwOThcXHUwMDk5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAwOTlcXHUwMDlhXFx1MDAwN3hcXHUwMDAyXFx1MDAwMlxcdTAwOWFcIixcbiAgICBcIlxcdTAwMTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5YlxcdTAwOWNcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXFx1MDA5Y1wiLFxuICAgIFwiXFx1MDA5ZFxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMDlkXFx1MDA5ZVxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMDllXFx1MDAxNFwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOWZcXHUwMGEwXFx1MDAwNyhcXHUwMDAyXFx1MDAwMlxcdTAwYTBcXHUwMDE2XCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhMVxcdTAwYTJcXHUwMDA3flxcdTAwMDJcXHUwMDAyXFx1MDBhMlxcdTAwMThcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGEzXFx1MDBhNFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMGE0XFx1MDBhNVwiLFxuICAgIFwiXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAwYTVcXHUwMDFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYTZcXHUwMGE3XCIsXG4gICAgXCJcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDBhN1xcdTAwMWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhOFxcdTAwYTlcIixcbiAgICBcIlxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwMGE5XFx1MDAxZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGFhXFx1MDBhYlwiLFxuICAgIFwiXFx1MDAwN0BcXHUwMDAyXFx1MDAwMlxcdTAwYWJcXHUwMGFjXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAwYWMgXFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBhZFxcdTAwYWVcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDBhZVxcdTAwYWZcXHUwMDA3dVxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMGFmXFxcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGIwXFx1MDBiMVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwYjFcXHUwMGIyXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAwYjIkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjNcIixcbiAgICBcIlxcdTAwYjRcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDBiNCZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiNVxcdTAwYjZcIixcbiAgICBcIlxcdTAwMDdcXHUwMDgwXFx1MDAwMlxcdTAwMDJcXHUwMGI2KFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGI3XFx1MDBiOFwiLFxuICAgIFwiXFx1MDAwNyNcXHUwMDAyXFx1MDAwMlxcdTAwYjhcXHUwMGI5XFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAwYjkqXFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiYVxcdTAwYmJcXHUwMDA3I1xcdTAwMDJcXHUwMDAyXFx1MDBiYlxcdTAwYmNcXHUwMDA3XFx1MDA4MFwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGJjLFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJkXFx1MDBiZVxcdTAwMDdrXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwYmVcXHUwMGJmXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAwYmYuXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDBjMFxcdTAwYzFcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDBjMVxcdTAwYzJcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDBjMlwiLFxuICAgIFwiXFx1MDBjM1xcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMGMzXFx1MDBjNFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMGM0XFx1MDBjNVwiLFxuICAgIFwiXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAwYzVcXHUwMGM2XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAwYzZcXHUwMGM3XFx1MDAwN1wiLFxuICAgIFwicFxcdTAwMDJcXHUwMDAyXFx1MDBjN1xcdTAwYzhcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDBjODBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMGM5XFx1MDBjYVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMGNhXFx1MDBjYlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwY2JcXHUwMGNjXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAwY2MyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwY2RcIixcbiAgICBcIlxcdTAwY2VcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDBjZVxcdTAwY2ZcXHUwMDA3dFxcdTAwMDJcXHUwMDAyXFx1MDBjZjRcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGQwXFx1MDBkMVxcdTAwMDd6XFx1MDAwMlxcdTAwMDJcXHUwMGQxXFx1MDBkMlxcdTAwMDdcIixcbiAgICBcInFcXHUwMDAyXFx1MDAwMlxcdTAwZDJcXHUwMGQzXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAwZDM2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDBkNFxcdTAwZDVcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDBkNVxcdTAwZDZcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMGQ2XFx1MDBkN1xcdTAwMDdyXFx1MDAwMlxcdTAwMDJcXHUwMGQ3XFx1MDBkOFxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMGQ4XCIsXG4gICAgXCJcXHUwMGQ5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAwZDlcXHUwMGRhXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAwZGFcXHUwMGRiXCIsXG4gICAgXCJcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDBkYjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkY1xcdTAwZGRcXHUwMDA3XCIsXG4gICAgXCIqXFx1MDAwMlxcdTAwMDJcXHUwMGRkOlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGRlXFx1MDBkZlxcdTAwMDcrXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwZGY8XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTBcXHUwMGUxXFx1MDAwN31cXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDBlMT5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlMlxcdTAwZTNcXHUwMDA3XFx1MDA3ZlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMGUzQFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGU0XFx1MDBlNVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMGU1XCIsXG4gICAgXCJcXHUwMGU2XFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAwZTZcXHUwMGU3XFx1MDAwN3dcXHUwMDAyXFx1MDAwMlxcdTAwZTdcXHUwMGU4XCIsXG4gICAgXCJcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDBlOEJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlOVxcdTAwZWFcXHUwMDA3XCIsXG4gICAgXCJoXFx1MDAwMlxcdTAwMDJcXHUwMGVhXFx1MDBlYlxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMGViXFx1MDBlY1xcdTAwMDduXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwZWNcXHUwMGVkXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAwZWRcXHUwMGVlXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDBlZURcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlZlxcdTAwZjBcXHUwMDA3XFwnXFx1MDAwMlxcdTAwMDJcXHUwMGYwXCIsXG4gICAgXCJGXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjFcXHUwMGYyXFx1MDAwNyZcXHUwMDAyXFx1MDAwMlxcdTAwZjJcXHUwMGYzXCIsXG4gICAgXCJcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDBmM1xcdTAwZjRcXHUwMDA3alxcdTAwMDJcXHUwMDAyXFx1MDBmNFxcdTAwZjVcXHUwMDA3XCIsXG4gICAgXCJrXFx1MDAwMlxcdTAwMDJcXHUwMGY1XFx1MDBmNlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMGY2SFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwZjdcXHUwMGY4XFx1MDAwNyZcXHUwMDAyXFx1MDAwMlxcdTAwZjhcXHUwMGY5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDBmOVxcdTAwZmFcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDBmYVxcdTAwZmJcXHUwMDA3ZlxcdTAwMDJcXHUwMDAyXFx1MDBmYlwiLFxuICAgIFwiXFx1MDBmY1xcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMGZjXFx1MDBmZFxcdTAwMDd6XFx1MDAwMlxcdTAwMDJcXHUwMGZkSlxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZmVcXHUwMGZmXFx1MDAwNyZcXHUwMDAyXFx1MDAwMlxcdTAwZmZcXHUwMTAwXFx1MDAwN1wiLFxuICAgIFwidlxcdTAwMDJcXHUwMDAyXFx1MDEwMFxcdTAxMDFcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDEwMVxcdTAxMDJcXHUwMDA3dlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMTAyXFx1MDEwM1xcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMTAzXFx1MDEwNFxcdTAwMDduXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxMDRMXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMDVcXHUwMTA2XFx1MDAwNy5cXHUwMDAyXFx1MDAwMlxcdTAxMDZcIixcbiAgICBcIk5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwN1xcdTAxMDhcXHUwMDA3e1xcdTAwMDJcXHUwMDAyXFx1MDEwOFxcdTAxMDlcIixcbiAgICBcIlxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMTA5XFx1MDEwYVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMTBhXFx1MDEwYlxcdTAwMDdcIixcbiAgICBcInRcXHUwMDAyXFx1MDAwMlxcdTAxMGJQXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMGNcXHUwMTBkXFx1MDAwN29cXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDEwZFxcdTAxMGVcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDEwZVxcdTAxMGZcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTBmXFx1MDExMFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMTEwXFx1MDExMVxcdTAwMDdqXFx1MDAwMlxcdTAwMDJcXHUwMTExXCIsXG4gICAgXCJSXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTJcXHUwMTEzXFx1MDAwN3lcXHUwMDAyXFx1MDAwMlxcdTAxMTNcXHUwMTE0XCIsXG4gICAgXCJcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDExNFxcdTAxMTVcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDExNVxcdTAxMTZcXHUwMDA3XCIsXG4gICAgXCJtXFx1MDAwMlxcdTAwMDJcXHUwMTE2VFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTE3XFx1MDExOFxcdTAwMDdmXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxMThcXHUwMTE5XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxMTlcXHUwMTFhXFx1MDAwN3tcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDExYVZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExYlxcdTAxMWNcXHUwMDA3alxcdTAwMDJcXHUwMDAyXFx1MDExY1wiLFxuICAgIFwiXFx1MDExZFxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMTFkXFx1MDExZVxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMTFlXFx1MDExZlwiLFxuICAgIFwiXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAxMWZYXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjBcXHUwMTIxXFx1MDAwN1wiLFxuICAgIFwib1xcdTAwMDJcXHUwMDAyXFx1MDEyMVxcdTAxMjJcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDEyMlxcdTAxMjNcXHUwMDA3cFxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMTIzXFx1MDEyNFxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMTI0XFx1MDEyNVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxMjVcXHUwMTI2XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxMjZaXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjdcIixcbiAgICBcIlxcdTAxMjhcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDEyOFxcdTAxMjlcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDEyOVxcdTAxMmFcIixcbiAgICBcIlxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMTJhXFx1MDEyYlxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMTJiXFx1MDEyY1xcdTAwMDdcIixcbiAgICBcInBcXHUwMDAyXFx1MDAwMlxcdTAxMmNcXHUwMTJkXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAxMmRcXFxcXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDEyZVxcdTAxMmZcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXFx1MDEyZlxcdTAxMzBcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTMwXFx1MDEzMVxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMTMxXFx1MDEzMlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMTMyXCIsXG4gICAgXCJcXHUwMTMzXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAxMzNcXHUwMTM0XFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAxMzRcXHUwMTM1XCIsXG4gICAgXCJcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDEzNVxcdTAxMzZcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDEzNlxcdTAxMzdcXHUwMDA3XCIsXG4gICAgXCJxXFx1MDAwMlxcdTAwMDJcXHUwMTM3XFx1MDEzOFxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMTM4XFx1MDEzOVxcdTAwMDdmXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxMzleXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxM2FcXHUwMTNiXFx1MDAwN3tcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDEzYlxcdTAxM2NcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDEzY1xcdTAxM2RcXHUwMDA3Y1xcdTAwMDJcXHUwMDAyXFx1MDEzZFwiLFxuICAgIFwiXFx1MDEzZVxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMTNlXFx1MDEzZlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMTNmYFxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDBcXHUwMTQxXFx1MDAwN29cXHUwMDAyXFx1MDAwMlxcdTAxNDFcXHUwMTQyXFx1MDAwN1wiLFxuICAgIFwicVxcdTAwMDJcXHUwMDAyXFx1MDE0MlxcdTAxNDNcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDE0M1xcdTAxNDRcXHUwMDA3dlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMTQ0XFx1MDE0NVxcdTAwMDdqXFx1MDAwMlxcdTAwMDJcXHUwMTQ1XFx1MDE0NlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxNDZiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDdcXHUwMTQ4XFx1MDAwN3lcXHUwMDAyXFx1MDAwMlxcdTAxNDhcIixcbiAgICBcIlxcdTAxNDlcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDE0OVxcdTAxNGFcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDE0YVxcdTAxNGJcIixcbiAgICBcIlxcdTAwMDdtXFx1MDAwMlxcdTAwMDJcXHUwMTRiXFx1MDE0Y1xcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMTRjZFxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxNGRcXHUwMTRlXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAxNGVcXHUwMTRmXFx1MDAwN2NcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDE0ZlxcdTAxNTBcXHUwMDA3e1xcdTAwMDJcXHUwMDAyXFx1MDE1MFxcdTAxNTFcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTUxZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTUyXFx1MDE1M1xcdTAwMDdqXFx1MDAwMlxcdTAwMDJcXHUwMTUzXCIsXG4gICAgXCJcXHUwMTU0XFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAxNTRcXHUwMTU1XFx1MDAwN3dcXHUwMDAyXFx1MDAwMlxcdTAxNTVcXHUwMTU2XCIsXG4gICAgXCJcXHUwMDA3dFxcdTAwMDJcXHUwMDAyXFx1MDE1NlxcdTAxNTdcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDE1N2hcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTU4XFx1MDE1OVxcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMTU5XFx1MDE1YVxcdTAwMDdrXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxNWFcXHUwMTViXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAxNWJcXHUwMTVjXFx1MDAwN3dcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDE1Y1xcdTAxNWRcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDE1ZFxcdTAxNWVcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDE1ZVwiLFxuICAgIFwiXFx1MDE1ZlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMTVmalxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTYwXFx1MDE2MVwiLFxuICAgIFwiXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAxNjFcXHUwMTYyXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxNjJcXHUwMTYzXFx1MDAwN1wiLFxuICAgIFwiZVxcdTAwMDJcXHUwMDAyXFx1MDE2M1xcdTAxNjRcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDE2NFxcdTAxNjVcXHUwMDA3cFxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMTY1XFx1MDE2NlxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMTY2XFx1MDE2N1xcdTAwMDd1XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxNjdsXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNjhcXHUwMTY5XFx1MDAwN29cXHUwMDAyXFx1MDAwMlxcdTAxNjlcIixcbiAgICBcIlxcdTAxNmFcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDE2YVxcdTAxNmJcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDE2YlxcdTAxNmNcIixcbiAgICBcIlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMTZjXFx1MDE2ZFxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMTZkXFx1MDE2ZVxcdTAwMDdcIixcbiAgICBcInVcXHUwMDAyXFx1MDAwMlxcdTAxNmVcXHUwMTZmXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxNmZcXHUwMTcwXFx1MDAwN2VcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDE3MFxcdTAxNzFcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDE3MVxcdTAxNzJcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTcyXFx1MDE3M1xcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMTczXFx1MDE3NFxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMTc0XCIsXG4gICAgXCJuXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNzVcXHUwMTc2XFx1MDAwN0JcXHUwMDAyXFx1MDAwMlxcdTAxNzZcXHUwMTc3XCIsXG4gICAgXCJcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTc3XFx1MDE3OFxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNzhcXHUwMTc5XFx0XFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTc5XFx1MDE4NlxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxN2FcXHUwMTdiXFx1MDAwNy9cXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDE3YlxcdTAxN2NcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTdjXFx1MDE4NFxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDE3ZFxcdTAxN2VcXHUwMDA3L1xcdTAwMDJcXHUwMDAyXFx1MDE3ZVxcdTAxN2ZcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTdmXCIsXG4gICAgXCJcXHUwMTgyXFx0XFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4MFxcdTAxODFcXHUwMDA3VlxcdTAwMDJcXHUwMDAyXFx1MDE4MVxcdTAxODNcIixcbiAgICBcIlxcdTAwMDVzOlxcdTAwMDJcXHUwMTgyXFx1MDE4MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTgyXFx1MDE4M1xcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODNcXHUwMTg1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODRcXHUwMTdkXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4NFxcdTAxODVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4NVxcdTAxODdcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTg2XFx1MDE3YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTg2XFx1MDE4N1xcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODdcXHUwMTg5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODhcXHUwMThhXFx1MDAwN1wiLFxuICAgIFwiXFxcXFxcdTAwMDJcXHUwMDAyXFx1MDE4OVxcdTAxODhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4OVxcdTAxOGFcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMThhcFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMThiXFx1MDE4Y1xcdTAwMDdcIixcbiAgICBcIkJcXHUwMDAyXFx1MDAwMlxcdTAxOGNcXHUwMThkXFx1MDAwN1ZcXHUwMDAyXFx1MDAwMlxcdTAxOGRcXHUwMThlXFx1MDAwNXM6XFx1MDAwMlwiLFxuICAgIFwiXFx1MDE4ZXJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4ZlxcdTAxOTBcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTkwXCIsXG4gICAgXCJcXHUwMWExXFx0XFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5MVxcdTAxOTJcXHUwMDA3PFxcdTAwMDJcXHUwMDAyXFx1MDE5MlxcdTAxOTNcIixcbiAgICBcIlxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOTNcXHUwMTlmXFx0XFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5NFxcdTAxOTVcXHUwMDA3XCIsXG4gICAgXCI8XFx1MDAwMlxcdTAwMDJcXHUwMTk1XFx1MDE5NlxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOTZcXHUwMTlkXFx0XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMTk3XFx1MDE5OVxcdTAwMDcwXFx1MDAwMlxcdTAwMDJcXHUwMTk4XFx1MDE5YVxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDE5OVxcdTAxOThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5YVxcdTAxOWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTliXFx1MDE5OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTliXFx1MDE5Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxOWNcXHUwMTllXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOWRcXHUwMTk3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDE5ZFxcdTAxOWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5ZVxcdTAxYTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMTlmXFx1MDE5NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTlmXFx1MDFhMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAxYTBcXHUwMWEyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYTFcXHUwMTkxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDFhMVxcdTAxYTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhMlxcdTAxYWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMWEzXFx1MDFhYlxcdTAwMDdcXFxcXFx1MDAwMlxcdTAwMDJcXHUwMWE0XFx1MDFhNVxcdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAxYTVcIixcbiAgICBcIlxcdTAxYTZcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWE2XFx1MDFhN1xcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYTdcXHUwMWE4XCIsXG4gICAgXCJcXHUwMDA3PFxcdTAwMDJcXHUwMDAyXFx1MDFhOFxcdTAxYTlcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWE5XFx1MDFhYlxcdFxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDFhYVxcdTAxYTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhYVxcdTAxYTRcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMWFhXFx1MDFhYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWFidFxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxYWNcXHUwMWFlXFx0XFx1MDAwNFxcdTAwMDJcXHUwMDAyXFx1MDFhZFxcdTAxYWNcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMWFlXFx1MDFiMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWFmXFx1MDFiMVxcdFxcdTAwMDVcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDFiMFxcdTAxYWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiMVxcdTAxYjRcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMWIyXFx1MDFiMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWIyXFx1MDFiM1xcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxYjN2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYjRcXHUwMWIyXFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDFiNVxcdTAxYmFcXHUwMDA3YlxcdTAwMDJcXHUwMDAyXFx1MDFiNlxcdTAxYjlcXHUwMDA1XFx1MDA4M1wiLFxuICAgIFwiQlxcdTAwMDJcXHUwMWI3XFx1MDFiOVxcblxcdTAwMDZcXHUwMDAyXFx1MDAwMlxcdTAxYjhcXHUwMWI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDFiOFxcdTAxYjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiOVxcdTAxYmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMWJhXFx1MDFiOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWJhXFx1MDFiYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxYmJcXHUwMWJkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYmNcXHUwMWJhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDFiZFxcdTAxYmVcXHUwMDA3YlxcdTAwMDJcXHUwMDAyXFx1MDFiZXhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMWJmXFx1MDFjNFxcdTAwMDcpXFx1MDAwMlxcdTAwMDJcXHUwMWMwXFx1MDFjM1xcdTAwMDVcXHUwMDgzQlxcdTAwMDJcXHUwMWMxXCIsXG4gICAgXCJcXHUwMWMzXFxuXFx1MDAwN1xcdTAwMDJcXHUwMDAyXFx1MDFjMlxcdTAxYzBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjMlwiLFxuICAgIFwiXFx1MDFjMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWMzXFx1MDFjNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWM0XCIsXG4gICAgXCJcXHUwMWMyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzRcXHUwMWM1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzVcIixcbiAgICBcIlxcdTAxYzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjNlxcdTAxYzRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjN1wiLFxuICAgIFwiXFx1MDFjOFxcdTAwMDcpXFx1MDAwMlxcdTAwMDJcXHUwMWM4elxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWM5XFx1MDFjYlwiLFxuICAgIFwiXFx0XFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjYVxcdTAxYzlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjYlxcdTAxY2NcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWNjXFx1MDFjYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWNjXFx1MDFjZFwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxY2RcXHUwMWQ0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxY2VcXHUwMWQwXCIsXG4gICAgXCJcXHUwMDA3MFxcdTAwMDJcXHUwMDAyXFx1MDFjZlxcdTAxZDFcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWQwXFx1MDFjZlxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDFcXHUwMWQyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDJcXHUwMWQwXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkMlxcdTAxZDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkM1xcdTAxZDVcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWQ0XFx1MDFjZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWQ0XFx1MDFkNVxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDV8XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDZcXHUwMWQ4XFx0XFxiXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxZDdcXHUwMWQ2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDhcXHUwMWQ5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDFkOVxcdTAxZDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkOVxcdTAxZGFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMWRhXFx1MDFkYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWRiXFx1MDFkY1xcYj9cXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDFkY35cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkZFxcdTAxZGVcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDFkZVwiLFxuICAgIFwiXFx1MDFkZlxcdTAwMDcsXFx1MDAwMlxcdTAwMDJcXHUwMWRmXFx1MDFlM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWUwXCIsXG4gICAgXCJcXHUwMWUyXFx1MDAwYlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZTFcXHUwMWUwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZTJcIixcbiAgICBcIlxcdTAxZTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFlM1xcdTAxZTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFlM1wiLFxuICAgIFwiXFx1MDFlMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU0XFx1MDFlNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU1XCIsXG4gICAgXCJcXHUwMWUzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZTZcXHUwMWU3XFx1MDAwNyxcXHUwMDAyXFx1MDAwMlxcdTAxZTdcIixcbiAgICBcIlxcdTAxZThcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDFlOFxcdTAxZTlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFlOVwiLFxuICAgIFwiXFx1MDFlYVxcYkBcXHUwMDAyXFx1MDAwMlxcdTAxZWFcXHUwMDgwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZWJcXHUwMWVjXCIsXG4gICAgXCJcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDFlY1xcdTAxZWRcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDFlZFxcdTAxZjFcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWVlXFx1MDFmMFxcblxcdFxcdTAwMDJcXHUwMDAyXFx1MDFlZlxcdTAxZWVcXHUwMDAzXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMWYwXFx1MDFmM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWYxXFx1MDFlZlxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxZjFcXHUwMWYyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjJcXHUwMWY0XFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDFmM1xcdTAxZjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFmNFxcdTAxZjVcXGJBXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcdTAxZjVcXHUwMDgyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjZcXHUwMWY5XFx1MDAwN15cXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDFmN1xcdTAxZmFcXHRcXG5cXHUwMDAyXFx1MDAwMlxcdTAxZjhcXHUwMWZhXFx1MDAwNVxcdTAwODVDXFx1MDAwMlxcdTAxZjlcIixcbiAgICBcIlxcdTAxZjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFmOVxcdTAxZjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFmYVwiLFxuICAgIFwiXFx1MDA4NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWZiXFx1MDFmY1xcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMWZjXCIsXG4gICAgXCJcXHUwMWZkXFx1MDAwNVxcdTAwODdEXFx1MDAwMlxcdTAxZmRcXHUwMWZlXFx1MDAwNVxcdTAwODdEXFx1MDAwMlxcdTAxZmVcXHUwMWZmXCIsXG4gICAgXCJcXHUwMDA1XFx1MDA4N0RcXHUwMDAyXFx1MDFmZlxcdTAyMDBcXHUwMDA1XFx1MDA4N0RcXHUwMDAyXFx1MDIwMFxcdTAwODZcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjAxXFx1MDIwMlxcdFxcdTAwMGJcXHUwMDAyXFx1MDAwMlxcdTAyMDJcXHUwMDg4XFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxYVxcdTAwMDJcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg5XFx1MDE5YlxcdTAxOWRcXHUwMTlmXCIsXG4gICAgXCJcXHUwMWExXFx1MDFhYVxcdTAxYWRcXHUwMWIwXFx1MDFiMlxcdTAxYjhcXHUwMWJhXFx1MDFjMlxcdTAxYzRcXHUwMWNjXFx1MDFkMlxcdTAxZDRcIixcbiAgICBcIlxcdTAxZDlcXHUwMWUzXFx1MDFmMVxcdTAxZjlcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXCJdLmpvaW4oXCJcIik7XG5cblxuY29uc3QgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XG5cbmNvbnN0IGRlY2lzaW9uc1RvREZBID0gYXRuLmRlY2lzaW9uVG9TdGF0ZS5tYXAoIChkcywgaW5kZXgpID0+IG5ldyBhbnRscjQuZGZhLkRGQShkcywgaW5kZXgpICk7XG5cbmNsYXNzIEZISVJQYXRoTGV4ZXIgZXh0ZW5kcyBhbnRscjQuTGV4ZXIge1xuXG4gICAgc3RhdGljIGdyYW1tYXJGaWxlTmFtZSA9IFwiRkhJUlBhdGguZzRcIjtcbiAgICBzdGF0aWMgY2hhbm5lbE5hbWVzID0gWyBcIkRFRkFVTFRfVE9LRU5fQ0hBTk5FTFwiLCBcIkhJRERFTlwiIF07XG5cdHN0YXRpYyBtb2RlTmFtZXMgPSBbIFwiREVGQVVMVF9NT0RFXCIgXTtcblx0c3RhdGljIGxpdGVyYWxOYW1lcyA9IFsgbnVsbCwgXCInLidcIiwgXCInWydcIiwgXCInXSdcIiwgXCInKydcIiwgXCInLSdcIiwgXCInKidcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCInLydcIiwgXCInZGl2J1wiLCBcIidtb2QnXCIsIFwiJyYnXCIsIFwiJ3wnXCIsIFwiJzw9J1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIic8J1wiLCBcIic+J1wiLCBcIic+PSdcIiwgXCInaXMnXCIsIFwiJ2FzJ1wiLCBcIic9J1wiLCBcIid+J1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIichPSdcIiwgXCInIX4nXCIsIFwiJ2luJ1wiLCBcIidjb250YWlucydcIiwgXCInYW5kJ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIidvcidcIiwgXCIneG9yJ1wiLCBcIidpbXBsaWVzJ1wiLCBcIicoJ1wiLCBcIicpJ1wiLCBcIid7J1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIid9J1wiLCBcIid0cnVlJ1wiLCBcIidmYWxzZSdcIiwgXCInJSdcIiwgXCInJHRoaXMnXCIsIFwiJyRpbmRleCdcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCInJHRvdGFsJ1wiLCBcIicsJ1wiLCBcIid5ZWFyJ1wiLCBcIidtb250aCdcIiwgXCInd2VlaydcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCInZGF5J1wiLCBcIidob3VyJ1wiLCBcIidtaW51dGUnXCIsIFwiJ3NlY29uZCdcIiwgXCInbWlsbGlzZWNvbmQnXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3llYXJzJ1wiLCBcIidtb250aHMnXCIsIFwiJ3dlZWtzJ1wiLCBcIidkYXlzJ1wiLCBcIidob3VycydcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCInbWludXRlcydcIiwgXCInc2Vjb25kcydcIiwgXCInbWlsbGlzZWNvbmRzJ1wiIF07XG5cdHN0YXRpYyBzeW1ib2xpY05hbWVzID0gWyBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcIkRBVEVUSU1FXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRJTUVcIiwgXCJJREVOVElGSUVSXCIsIFwiREVMSU1JVEVESURFTlRJRklFUlwiLCBcIlNUUklOR1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJOVU1CRVJcIiwgXCJXU1wiLCBcIkNPTU1FTlRcIiwgXCJMSU5FX0NPTU1FTlRcIiBdO1xuXHRzdGF0aWMgcnVsZU5hbWVzID0gWyBcIlRfXzBcIiwgXCJUX18xXCIsIFwiVF9fMlwiLCBcIlRfXzNcIiwgXCJUX180XCIsIFwiVF9fNVwiLCBcIlRfXzZcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX183XCIsIFwiVF9fOFwiLCBcIlRfXzlcIiwgXCJUX18xMFwiLCBcIlRfXzExXCIsIFwiVF9fMTJcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX18xM1wiLCBcIlRfXzE0XCIsIFwiVF9fMTVcIiwgXCJUX18xNlwiLCBcIlRfXzE3XCIsIFwiVF9fMThcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX18xOVwiLCBcIlRfXzIwXCIsIFwiVF9fMjFcIiwgXCJUX18yMlwiLCBcIlRfXzIzXCIsIFwiVF9fMjRcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX18yNVwiLCBcIlRfXzI2XCIsIFwiVF9fMjdcIiwgXCJUX18yOFwiLCBcIlRfXzI5XCIsIFwiVF9fMzBcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX18zMVwiLCBcIlRfXzMyXCIsIFwiVF9fMzNcIiwgXCJUX18zNFwiLCBcIlRfXzM1XCIsIFwiVF9fMzZcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX18zN1wiLCBcIlRfXzM4XCIsIFwiVF9fMzlcIiwgXCJUX180MFwiLCBcIlRfXzQxXCIsIFwiVF9fNDJcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX180M1wiLCBcIlRfXzQ0XCIsIFwiVF9fNDVcIiwgXCJUX180NlwiLCBcIlRfXzQ3XCIsIFwiVF9fNDhcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUX180OVwiLCBcIlRfXzUwXCIsIFwiVF9fNTFcIiwgXCJUX181MlwiLCBcIlRfXzUzXCIsIFwiREFURVRJTUVcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgXCJUSU1FXCIsIFwiVElNRUZPUk1BVFwiLCBcIklERU5USUZJRVJcIiwgXCJERUxJTUlURURJREVOVElGSUVSXCIsIFxuICAgICAgICAgICAgICAgICAgICAgIFwiU1RSSU5HXCIsIFwiTlVNQkVSXCIsIFwiV1NcIiwgXCJDT01NRU5UXCIsIFwiTElORV9DT01NRU5UXCIsIFxuICAgICAgICAgICAgICAgICAgICAgIFwiRVNDXCIsIFwiVU5JQ09ERVwiLCBcIkhFWFwiIF07XG5cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcihpbnB1dClcbiAgICAgICAgdGhpcy5faW50ZXJwID0gbmV3IGFudGxyNC5hdG4uTGV4ZXJBVE5TaW11bGF0b3IodGhpcywgYXRuLCBkZWNpc2lvbnNUb0RGQSwgbmV3IGFudGxyNC5QcmVkaWN0aW9uQ29udGV4dENhY2hlKCkpO1xuICAgIH1cblxuICAgIGdldCBhdG4oKSB7XG4gICAgICAgIHJldHVybiBhdG47XG4gICAgfVxufVxuXG5GSElSUGF0aExleGVyLkVPRiA9IGFudGxyNC5Ub2tlbi5FT0Y7XG5GSElSUGF0aExleGVyLlRfXzAgPSAxO1xuRkhJUlBhdGhMZXhlci5UX18xID0gMjtcbkZISVJQYXRoTGV4ZXIuVF9fMiA9IDM7XG5GSElSUGF0aExleGVyLlRfXzMgPSA0O1xuRkhJUlBhdGhMZXhlci5UX180ID0gNTtcbkZISVJQYXRoTGV4ZXIuVF9fNSA9IDY7XG5GSElSUGF0aExleGVyLlRfXzYgPSA3O1xuRkhJUlBhdGhMZXhlci5UX183ID0gODtcbkZISVJQYXRoTGV4ZXIuVF9fOCA9IDk7XG5GSElSUGF0aExleGVyLlRfXzkgPSAxMDtcbkZISVJQYXRoTGV4ZXIuVF9fMTAgPSAxMTtcbkZISVJQYXRoTGV4ZXIuVF9fMTEgPSAxMjtcbkZISVJQYXRoTGV4ZXIuVF9fMTIgPSAxMztcbkZISVJQYXRoTGV4ZXIuVF9fMTMgPSAxNDtcbkZISVJQYXRoTGV4ZXIuVF9fMTQgPSAxNTtcbkZISVJQYXRoTGV4ZXIuVF9fMTUgPSAxNjtcbkZISVJQYXRoTGV4ZXIuVF9fMTYgPSAxNztcbkZISVJQYXRoTGV4ZXIuVF9fMTcgPSAxODtcbkZISVJQYXRoTGV4ZXIuVF9fMTggPSAxOTtcbkZISVJQYXRoTGV4ZXIuVF9fMTkgPSAyMDtcbkZISVJQYXRoTGV4ZXIuVF9fMjAgPSAyMTtcbkZISVJQYXRoTGV4ZXIuVF9fMjEgPSAyMjtcbkZISVJQYXRoTGV4ZXIuVF9fMjIgPSAyMztcbkZISVJQYXRoTGV4ZXIuVF9fMjMgPSAyNDtcbkZISVJQYXRoTGV4ZXIuVF9fMjQgPSAyNTtcbkZISVJQYXRoTGV4ZXIuVF9fMjUgPSAyNjtcbkZISVJQYXRoTGV4ZXIuVF9fMjYgPSAyNztcbkZISVJQYXRoTGV4ZXIuVF9fMjcgPSAyODtcbkZISVJQYXRoTGV4ZXIuVF9fMjggPSAyOTtcbkZISVJQYXRoTGV4ZXIuVF9fMjkgPSAzMDtcbkZISVJQYXRoTGV4ZXIuVF9fMzAgPSAzMTtcbkZISVJQYXRoTGV4ZXIuVF9fMzEgPSAzMjtcbkZISVJQYXRoTGV4ZXIuVF9fMzIgPSAzMztcbkZISVJQYXRoTGV4ZXIuVF9fMzMgPSAzNDtcbkZISVJQYXRoTGV4ZXIuVF9fMzQgPSAzNTtcbkZISVJQYXRoTGV4ZXIuVF9fMzUgPSAzNjtcbkZISVJQYXRoTGV4ZXIuVF9fMzYgPSAzNztcbkZISVJQYXRoTGV4ZXIuVF9fMzcgPSAzODtcbkZISVJQYXRoTGV4ZXIuVF9fMzggPSAzOTtcbkZISVJQYXRoTGV4ZXIuVF9fMzkgPSA0MDtcbkZISVJQYXRoTGV4ZXIuVF9fNDAgPSA0MTtcbkZISVJQYXRoTGV4ZXIuVF9fNDEgPSA0MjtcbkZISVJQYXRoTGV4ZXIuVF9fNDIgPSA0MztcbkZISVJQYXRoTGV4ZXIuVF9fNDMgPSA0NDtcbkZISVJQYXRoTGV4ZXIuVF9fNDQgPSA0NTtcbkZISVJQYXRoTGV4ZXIuVF9fNDUgPSA0NjtcbkZISVJQYXRoTGV4ZXIuVF9fNDYgPSA0NztcbkZISVJQYXRoTGV4ZXIuVF9fNDcgPSA0ODtcbkZISVJQYXRoTGV4ZXIuVF9fNDggPSA0OTtcbkZISVJQYXRoTGV4ZXIuVF9fNDkgPSA1MDtcbkZISVJQYXRoTGV4ZXIuVF9fNTAgPSA1MTtcbkZISVJQYXRoTGV4ZXIuVF9fNTEgPSA1MjtcbkZISVJQYXRoTGV4ZXIuVF9fNTIgPSA1MztcbkZISVJQYXRoTGV4ZXIuVF9fNTMgPSA1NDtcbkZISVJQYXRoTGV4ZXIuREFURVRJTUUgPSA1NTtcbkZISVJQYXRoTGV4ZXIuVElNRSA9IDU2O1xuRkhJUlBhdGhMZXhlci5JREVOVElGSUVSID0gNTc7XG5GSElSUGF0aExleGVyLkRFTElNSVRFRElERU5USUZJRVIgPSA1ODtcbkZISVJQYXRoTGV4ZXIuU1RSSU5HID0gNTk7XG5GSElSUGF0aExleGVyLk5VTUJFUiA9IDYwO1xuRkhJUlBhdGhMZXhlci5XUyA9IDYxO1xuRkhJUlBhdGhMZXhlci5DT01NRU5UID0gNjI7XG5GSElSUGF0aExleGVyLkxJTkVfQ09NTUVOVCA9IDYzO1xuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZISVJQYXRoTGV4ZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathListener.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathListener.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = __webpack_require__(/*! ../antlr4-index */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js\");\n\n// This class defines a complete listener for a parse tree produced by FHIRPathParser.\nclass FHIRPathListener extends antlr4.tree.ParseTreeListener {\n\n\t// Enter a parse tree produced by FHIRPathParser#entireExpression.\n\tenterEntireExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#entireExpression.\n\texitEntireExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexerExpression.\n\tenterIndexerExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexerExpression.\n\texitIndexerExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#polarityExpression.\n\tenterPolarityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#polarityExpression.\n\texitPolarityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#additiveExpression.\n\tenterAdditiveExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#additiveExpression.\n\texitAdditiveExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\tenterMultiplicativeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\texitMultiplicativeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unionExpression.\n\tenterUnionExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unionExpression.\n\texitUnionExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#orExpression.\n\tenterOrExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#orExpression.\n\texitOrExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#andExpression.\n\tenterAndExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#andExpression.\n\texitAndExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#membershipExpression.\n\tenterMembershipExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#membershipExpression.\n\texitMembershipExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#inequalityExpression.\n\tenterInequalityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#inequalityExpression.\n\texitInequalityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationExpression.\n\tenterInvocationExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationExpression.\n\texitInvocationExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#equalityExpression.\n\tenterEqualityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#equalityExpression.\n\texitEqualityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#impliesExpression.\n\tenterImpliesExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#impliesExpression.\n\texitImpliesExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#termExpression.\n\tenterTermExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#termExpression.\n\texitTermExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeExpression.\n\tenterTypeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeExpression.\n\texitTypeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationTerm.\n\tenterInvocationTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationTerm.\n\texitInvocationTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#literalTerm.\n\tenterLiteralTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#literalTerm.\n\texitLiteralTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstantTerm.\n\tenterExternalConstantTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstantTerm.\n\texitExternalConstantTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\tenterParenthesizedTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\texitParenthesizedTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#nullLiteral.\n\tenterNullLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#nullLiteral.\n\texitNullLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#booleanLiteral.\n\tenterBooleanLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#booleanLiteral.\n\texitBooleanLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#stringLiteral.\n\tenterStringLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#stringLiteral.\n\texitStringLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#numberLiteral.\n\tenterNumberLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#numberLiteral.\n\texitNumberLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\tenterDateTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\texitDateTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#timeLiteral.\n\tenterTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#timeLiteral.\n\texitTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantityLiteral.\n\tenterQuantityLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantityLiteral.\n\texitQuantityLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstant.\n\tenterExternalConstant(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstant.\n\texitExternalConstant(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#memberInvocation.\n\tenterMemberInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#memberInvocation.\n\texitMemberInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functionInvocation.\n\tenterFunctionInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functionInvocation.\n\texitFunctionInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#thisInvocation.\n\tenterThisInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#thisInvocation.\n\texitThisInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexInvocation.\n\tenterIndexInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexInvocation.\n\texitIndexInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#totalInvocation.\n\tenterTotalInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#totalInvocation.\n\texitTotalInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functn.\n\tenterFunctn(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functn.\n\texitFunctn(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#paramList.\n\tenterParamList(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#paramList.\n\texitParamList(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantity.\n\tenterQuantity(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantity.\n\texitQuantity(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unit.\n\tenterUnit(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unit.\n\texitUnit(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimePrecision.\n\tenterDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimePrecision.\n\texitDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\tenterPluralDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\texitPluralDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeSpecifier.\n\tenterTypeSpecifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeSpecifier.\n\texitTypeSpecifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\tenterQualifiedIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\texitQualifiedIdentifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#identifier.\n\tenterIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#identifier.\n\texitIdentifier(ctx) {\n\t}\n\n\n\n}\nmodule.exports = FHIRPathListener;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9nZW5lcmF0ZWQvRkhJUlBhdGhMaXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFIQUFpQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vZmhpcnBhdGhAMy4xOC4wL25vZGVfbW9kdWxlcy9maGlycGF0aC9zcmMvcGFyc2VyL2dlbmVyYXRlZC9GSElSUGF0aExpc3RlbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBmcm9tIEZISVJQYXRoLmc0IGJ5IEFOVExSIDQuOS4zXG4vLyBqc2hpbnQgaWdub3JlOiBzdGFydFxuY29uc3QgYW50bHI0ID0gcmVxdWlyZSgnLi4vYW50bHI0LWluZGV4Jyk7XG5cbi8vIFRoaXMgY2xhc3MgZGVmaW5lcyBhIGNvbXBsZXRlIGxpc3RlbmVyIGZvciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIuXG5jbGFzcyBGSElSUGF0aExpc3RlbmVyIGV4dGVuZHMgYW50bHI0LnRyZWUuUGFyc2VUcmVlTGlzdGVuZXIge1xuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNlbnRpcmVFeHByZXNzaW9uLlxuXHRlbnRlckVudGlyZUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNlbnRpcmVFeHByZXNzaW9uLlxuXHRleGl0RW50aXJlRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2luZGV4ZXJFeHByZXNzaW9uLlxuXHRlbnRlckluZGV4ZXJFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaW5kZXhlckV4cHJlc3Npb24uXG5cdGV4aXRJbmRleGVyRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3BvbGFyaXR5RXhwcmVzc2lvbi5cblx0ZW50ZXJQb2xhcml0eUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNwb2xhcml0eUV4cHJlc3Npb24uXG5cdGV4aXRQb2xhcml0eUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNhZGRpdGl2ZUV4cHJlc3Npb24uXG5cdGVudGVyQWRkaXRpdmVFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjYWRkaXRpdmVFeHByZXNzaW9uLlxuXHRleGl0QWRkaXRpdmVFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjbXVsdGlwbGljYXRpdmVFeHByZXNzaW9uLlxuXHRlbnRlck11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI211bHRpcGxpY2F0aXZlRXhwcmVzc2lvbi5cblx0ZXhpdE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3VuaW9uRXhwcmVzc2lvbi5cblx0ZW50ZXJVbmlvbkV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN1bmlvbkV4cHJlc3Npb24uXG5cdGV4aXRVbmlvbkV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNvckV4cHJlc3Npb24uXG5cdGVudGVyT3JFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjb3JFeHByZXNzaW9uLlxuXHRleGl0T3JFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjYW5kRXhwcmVzc2lvbi5cblx0ZW50ZXJBbmRFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjYW5kRXhwcmVzc2lvbi5cblx0ZXhpdEFuZEV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNtZW1iZXJzaGlwRXhwcmVzc2lvbi5cblx0ZW50ZXJNZW1iZXJzaGlwRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI21lbWJlcnNoaXBFeHByZXNzaW9uLlxuXHRleGl0TWVtYmVyc2hpcEV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNpbmVxdWFsaXR5RXhwcmVzc2lvbi5cblx0ZW50ZXJJbmVxdWFsaXR5RXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2luZXF1YWxpdHlFeHByZXNzaW9uLlxuXHRleGl0SW5lcXVhbGl0eUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNpbnZvY2F0aW9uRXhwcmVzc2lvbi5cblx0ZW50ZXJJbnZvY2F0aW9uRXhwcmVzc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2ludm9jYXRpb25FeHByZXNzaW9uLlxuXHRleGl0SW52b2NhdGlvbkV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNlcXVhbGl0eUV4cHJlc3Npb24uXG5cdGVudGVyRXF1YWxpdHlFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjZXF1YWxpdHlFeHByZXNzaW9uLlxuXHRleGl0RXF1YWxpdHlFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaW1wbGllc0V4cHJlc3Npb24uXG5cdGVudGVySW1wbGllc0V4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNpbXBsaWVzRXhwcmVzc2lvbi5cblx0ZXhpdEltcGxpZXNFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjdGVybUV4cHJlc3Npb24uXG5cdGVudGVyVGVybUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0ZXJtRXhwcmVzc2lvbi5cblx0ZXhpdFRlcm1FeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjdHlwZUV4cHJlc3Npb24uXG5cdGVudGVyVHlwZUV4cHJlc3Npb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0eXBlRXhwcmVzc2lvbi5cblx0ZXhpdFR5cGVFeHByZXNzaW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaW52b2NhdGlvblRlcm0uXG5cdGVudGVySW52b2NhdGlvblRlcm0oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNpbnZvY2F0aW9uVGVybS5cblx0ZXhpdEludm9jYXRpb25UZXJtKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjbGl0ZXJhbFRlcm0uXG5cdGVudGVyTGl0ZXJhbFRlcm0oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNsaXRlcmFsVGVybS5cblx0ZXhpdExpdGVyYWxUZXJtKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjZXh0ZXJuYWxDb25zdGFudFRlcm0uXG5cdGVudGVyRXh0ZXJuYWxDb25zdGFudFRlcm0oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNleHRlcm5hbENvbnN0YW50VGVybS5cblx0ZXhpdEV4dGVybmFsQ29uc3RhbnRUZXJtKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjcGFyZW50aGVzaXplZFRlcm0uXG5cdGVudGVyUGFyZW50aGVzaXplZFRlcm0oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNwYXJlbnRoZXNpemVkVGVybS5cblx0ZXhpdFBhcmVudGhlc2l6ZWRUZXJtKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjbnVsbExpdGVyYWwuXG5cdGVudGVyTnVsbExpdGVyYWwoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNudWxsTGl0ZXJhbC5cblx0ZXhpdE51bGxMaXRlcmFsKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjYm9vbGVhbkxpdGVyYWwuXG5cdGVudGVyQm9vbGVhbkxpdGVyYWwoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNib29sZWFuTGl0ZXJhbC5cblx0ZXhpdEJvb2xlYW5MaXRlcmFsKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjc3RyaW5nTGl0ZXJhbC5cblx0ZW50ZXJTdHJpbmdMaXRlcmFsKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjc3RyaW5nTGl0ZXJhbC5cblx0ZXhpdFN0cmluZ0xpdGVyYWwoY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNudW1iZXJMaXRlcmFsLlxuXHRlbnRlck51bWJlckxpdGVyYWwoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNudW1iZXJMaXRlcmFsLlxuXHRleGl0TnVtYmVyTGl0ZXJhbChjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2RhdGVUaW1lTGl0ZXJhbC5cblx0ZW50ZXJEYXRlVGltZUxpdGVyYWwoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNkYXRlVGltZUxpdGVyYWwuXG5cdGV4aXREYXRlVGltZUxpdGVyYWwoY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0aW1lTGl0ZXJhbC5cblx0ZW50ZXJUaW1lTGl0ZXJhbChjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3RpbWVMaXRlcmFsLlxuXHRleGl0VGltZUxpdGVyYWwoY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNxdWFudGl0eUxpdGVyYWwuXG5cdGVudGVyUXVhbnRpdHlMaXRlcmFsKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjcXVhbnRpdHlMaXRlcmFsLlxuXHRleGl0UXVhbnRpdHlMaXRlcmFsKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjZXh0ZXJuYWxDb25zdGFudC5cblx0ZW50ZXJFeHRlcm5hbENvbnN0YW50KGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjZXh0ZXJuYWxDb25zdGFudC5cblx0ZXhpdEV4dGVybmFsQ29uc3RhbnQoY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNtZW1iZXJJbnZvY2F0aW9uLlxuXHRlbnRlck1lbWJlckludm9jYXRpb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNtZW1iZXJJbnZvY2F0aW9uLlxuXHRleGl0TWVtYmVySW52b2NhdGlvbihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2Z1bmN0aW9uSW52b2NhdGlvbi5cblx0ZW50ZXJGdW5jdGlvbkludm9jYXRpb24oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNmdW5jdGlvbkludm9jYXRpb24uXG5cdGV4aXRGdW5jdGlvbkludm9jYXRpb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0aGlzSW52b2NhdGlvbi5cblx0ZW50ZXJUaGlzSW52b2NhdGlvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3RoaXNJbnZvY2F0aW9uLlxuXHRleGl0VGhpc0ludm9jYXRpb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNpbmRleEludm9jYXRpb24uXG5cdGVudGVySW5kZXhJbnZvY2F0aW9uKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaW5kZXhJbnZvY2F0aW9uLlxuXHRleGl0SW5kZXhJbnZvY2F0aW9uKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjdG90YWxJbnZvY2F0aW9uLlxuXHRlbnRlclRvdGFsSW52b2NhdGlvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3RvdGFsSW52b2NhdGlvbi5cblx0ZXhpdFRvdGFsSW52b2NhdGlvbihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2Z1bmN0bi5cblx0ZW50ZXJGdW5jdG4oY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNmdW5jdG4uXG5cdGV4aXRGdW5jdG4oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNwYXJhbUxpc3QuXG5cdGVudGVyUGFyYW1MaXN0KGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjcGFyYW1MaXN0LlxuXHRleGl0UGFyYW1MaXN0KGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjcXVhbnRpdHkuXG5cdGVudGVyUXVhbnRpdHkoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNxdWFudGl0eS5cblx0ZXhpdFF1YW50aXR5KGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjdW5pdC5cblx0ZW50ZXJVbml0KGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjdW5pdC5cblx0ZXhpdFVuaXQoY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNkYXRlVGltZVByZWNpc2lvbi5cblx0ZW50ZXJEYXRlVGltZVByZWNpc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI2RhdGVUaW1lUHJlY2lzaW9uLlxuXHRleGl0RGF0ZVRpbWVQcmVjaXNpb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciNwbHVyYWxEYXRlVGltZVByZWNpc2lvbi5cblx0ZW50ZXJQbHVyYWxEYXRlVGltZVByZWNpc2lvbihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3BsdXJhbERhdGVUaW1lUHJlY2lzaW9uLlxuXHRleGl0UGx1cmFsRGF0ZVRpbWVQcmVjaXNpb24oY3R4KSB7XG5cdH1cblxuXG5cdC8vIEVudGVyIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0eXBlU3BlY2lmaWVyLlxuXHRlbnRlclR5cGVTcGVjaWZpZXIoY3R4KSB7XG5cdH1cblxuXHQvLyBFeGl0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBGSElSUGF0aFBhcnNlciN0eXBlU3BlY2lmaWVyLlxuXHRleGl0VHlwZVNwZWNpZmllcihjdHgpIHtcblx0fVxuXG5cblx0Ly8gRW50ZXIgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3F1YWxpZmllZElkZW50aWZpZXIuXG5cdGVudGVyUXVhbGlmaWVkSWRlbnRpZmllcihjdHgpIHtcblx0fVxuXG5cdC8vIEV4aXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IEZISVJQYXRoUGFyc2VyI3F1YWxpZmllZElkZW50aWZpZXIuXG5cdGV4aXRRdWFsaWZpZWRJZGVudGlmaWVyKGN0eCkge1xuXHR9XG5cblxuXHQvLyBFbnRlciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaWRlbnRpZmllci5cblx0ZW50ZXJJZGVudGlmaWVyKGN0eCkge1xuXHR9XG5cblx0Ly8gRXhpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgRkhJUlBhdGhQYXJzZXIjaWRlbnRpZmllci5cblx0ZXhpdElkZW50aWZpZXIoY3R4KSB7XG5cdH1cblxuXG5cbn1cbm1vZHVsZS5leHBvcnRzID0gRkhJUlBhdGhMaXN0ZW5lcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathListener.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathParser.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathParser.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = __webpack_require__(/*! ../antlr4-index */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js\");\nconst FHIRPathListener = __webpack_require__(/*! ./FHIRPathListener */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathListener.js\");\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0003A\\u009c\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\",\n    \"\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\",\n    \"\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\",\n    \"\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\",\n    \"\\u0003\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0005\\u0003(\\n\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003\",\n    \"P\\n\\u0003\\f\\u0003\\u000e\\u0003S\\u000b\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\\\\",\n    \"\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\",\n    \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005f\\n\\u0005\\u0003\\u0006\",\n    \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006k\\n\\u0006\\u0003\\u0007\\u0003\\u0007\",\n    \"\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0005\\u0007r\\n\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0005\\bw\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0007\",\n    \"\\t~\\n\\t\\f\\t\\u000e\\t\\u0081\\u000b\\t\\u0003\\n\\u0003\\n\\u0005\\n\\u0085\\n\\n\",\n    \"\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0005\\u000b\\u008a\\n\\u000b\\u0003\",\n    \"\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\",\n    \"\\u000f\\u0003\\u000f\\u0007\\u000f\\u0095\\n\\u000f\\f\\u000f\\u000e\\u000f\\u0098\",\n    \"\\u000b\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0002\\u0003\\u0004\\u0011\",\n    \"\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\",\n    \"\\u001e\\u0002\\u000e\\u0003\\u0002\\u0006\\u0007\\u0003\\u0002\\b\\u000b\\u0004\",\n    \"\\u0002\\u0006\\u0007\\f\\f\\u0003\\u0002\\u000e\\u0011\\u0003\\u0002\\u0014\\u0017\",\n    \"\\u0003\\u0002\\u0018\\u0019\\u0003\\u0002\\u001b\\u001c\\u0003\\u0002\\u0012\\u0013\",\n    \"\\u0003\\u0002\\\"#\\u0003\\u0002)0\\u0003\\u000218\\u0005\\u0002\\u0012\\u0013\",\n    \"\\u0018\\u0019;<\\u0002\\u00ad\\u0002 \\u0003\\u0002\\u0002\\u0002\\u0004\\'\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0006[\\u0003\\u0002\\u0002\\u0002\\be\\u0003\\u0002\\u0002\",\n    \"\\u0002\\ng\\u0003\\u0002\\u0002\\u0002\\fq\\u0003\\u0002\\u0002\\u0002\\u000es\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0010z\\u0003\\u0002\\u0002\\u0002\\u0012\\u0082\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0014\\u0089\\u0003\\u0002\\u0002\\u0002\\u0016\\u008b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0018\\u008d\\u0003\\u0002\\u0002\\u0002\\u001a\\u008f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u001c\\u0091\\u0003\\u0002\\u0002\\u0002\\u001e\\u0099\",\n    \"\\u0003\\u0002\\u0002\\u0002 !\\u0005\\u0004\\u0003\\u0002!\\\"\\u0007\\u0002\\u0002\",\n    \"\\u0003\\\"\\u0003\\u0003\\u0002\\u0002\\u0002#$\\b\\u0003\\u0001\\u0002$(\\u0005\",\n    \"\\u0006\\u0004\\u0002%&\\t\\u0002\\u0002\\u0002&(\\u0005\\u0004\\u0003\\r\\'#\\u0003\",\n    \"\\u0002\\u0002\\u0002\\'%\\u0003\\u0002\\u0002\\u0002(Q\\u0003\\u0002\\u0002\\u0002\",\n    \")*\\f\\f\\u0002\\u0002*+\\t\\u0003\\u0002\\u0002+P\\u0005\\u0004\\u0003\\r,-\\f\\u000b\",\n    \"\\u0002\\u0002-.\\t\\u0004\\u0002\\u0002.P\\u0005\\u0004\\u0003\\f/0\\f\\n\\u0002\",\n    \"\\u000201\\u0007\\r\\u0002\\u00021P\\u0005\\u0004\\u0003\\u000b23\\f\\t\\u0002\\u0002\",\n    \"34\\t\\u0005\\u0002\\u00024P\\u0005\\u0004\\u0003\\n56\\f\\u0007\\u0002\\u00026\",\n    \"7\\t\\u0006\\u0002\\u00027P\\u0005\\u0004\\u0003\\b89\\f\\u0006\\u0002\\u00029:\",\n    \"\\t\\u0007\\u0002\\u0002:P\\u0005\\u0004\\u0003\\u0007;<\\f\\u0005\\u0002\\u0002\",\n    \"<=\\u0007\\u001a\\u0002\\u0002=P\\u0005\\u0004\\u0003\\u0006>?\\f\\u0004\\u0002\",\n    \"\\u0002?@\\t\\b\\u0002\\u0002@P\\u0005\\u0004\\u0003\\u0005AB\\f\\u0003\\u0002\\u0002\",\n    \"BC\\u0007\\u001d\\u0002\\u0002CP\\u0005\\u0004\\u0003\\u0004DE\\f\\u000f\\u0002\",\n    \"\\u0002EF\\u0007\\u0003\\u0002\\u0002FP\\u0005\\f\\u0007\\u0002GH\\f\\u000e\\u0002\",\n    \"\\u0002HI\\u0007\\u0004\\u0002\\u0002IJ\\u0005\\u0004\\u0003\\u0002JK\\u0007\\u0005\",\n    \"\\u0002\\u0002KP\\u0003\\u0002\\u0002\\u0002LM\\f\\b\\u0002\\u0002MN\\t\\t\\u0002\",\n    \"\\u0002NP\\u0005\\u001a\\u000e\\u0002O)\\u0003\\u0002\\u0002\\u0002O,\\u0003\\u0002\",\n    \"\\u0002\\u0002O/\\u0003\\u0002\\u0002\\u0002O2\\u0003\\u0002\\u0002\\u0002O5\\u0003\",\n    \"\\u0002\\u0002\\u0002O8\\u0003\\u0002\\u0002\\u0002O;\\u0003\\u0002\\u0002\\u0002\",\n    \"O>\\u0003\\u0002\\u0002\\u0002OA\\u0003\\u0002\\u0002\\u0002OD\\u0003\\u0002\\u0002\",\n    \"\\u0002OG\\u0003\\u0002\\u0002\\u0002OL\\u0003\\u0002\\u0002\\u0002PS\\u0003\\u0002\",\n    \"\\u0002\\u0002QO\\u0003\\u0002\\u0002\\u0002QR\\u0003\\u0002\\u0002\\u0002R\\u0005\",\n    \"\\u0003\\u0002\\u0002\\u0002SQ\\u0003\\u0002\\u0002\\u0002T\\\\\\u0005\\f\\u0007\",\n    \"\\u0002U\\\\\\u0005\\b\\u0005\\u0002V\\\\\\u0005\\n\\u0006\\u0002WX\\u0007\\u001e\\u0002\",\n    \"\\u0002XY\\u0005\\u0004\\u0003\\u0002YZ\\u0007\\u001f\\u0002\\u0002Z\\\\\\u0003\",\n    \"\\u0002\\u0002\\u0002[T\\u0003\\u0002\\u0002\\u0002[U\\u0003\\u0002\\u0002\\u0002\",\n    \"[V\\u0003\\u0002\\u0002\\u0002[W\\u0003\\u0002\\u0002\\u0002\\\\\\u0007\\u0003\\u0002\",\n    \"\\u0002\\u0002]^\\u0007 \\u0002\\u0002^f\\u0007!\\u0002\\u0002_f\\t\\n\\u0002\\u0002\",\n    \"`f\\u0007=\\u0002\\u0002af\\u0007>\\u0002\\u0002bf\\u00079\\u0002\\u0002cf\\u0007\",\n    \":\\u0002\\u0002df\\u0005\\u0012\\n\\u0002e]\\u0003\\u0002\\u0002\\u0002e_\\u0003\",\n    \"\\u0002\\u0002\\u0002e`\\u0003\\u0002\\u0002\\u0002ea\\u0003\\u0002\\u0002\\u0002\",\n    \"eb\\u0003\\u0002\\u0002\\u0002ec\\u0003\\u0002\\u0002\\u0002ed\\u0003\\u0002\\u0002\",\n    \"\\u0002f\\t\\u0003\\u0002\\u0002\\u0002gj\\u0007$\\u0002\\u0002hk\\u0005\\u001e\",\n    \"\\u0010\\u0002ik\\u0007=\\u0002\\u0002jh\\u0003\\u0002\\u0002\\u0002ji\\u0003\",\n    \"\\u0002\\u0002\\u0002k\\u000b\\u0003\\u0002\\u0002\\u0002lr\\u0005\\u001e\\u0010\",\n    \"\\u0002mr\\u0005\\u000e\\b\\u0002nr\\u0007%\\u0002\\u0002or\\u0007&\\u0002\\u0002\",\n    \"pr\\u0007\\'\\u0002\\u0002ql\\u0003\\u0002\\u0002\\u0002qm\\u0003\\u0002\\u0002\",\n    \"\\u0002qn\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002qp\\u0003\\u0002\",\n    \"\\u0002\\u0002r\\r\\u0003\\u0002\\u0002\\u0002st\\u0005\\u001e\\u0010\\u0002tv\",\n    \"\\u0007\\u001e\\u0002\\u0002uw\\u0005\\u0010\\t\\u0002vu\\u0003\\u0002\\u0002\\u0002\",\n    \"vw\\u0003\\u0002\\u0002\\u0002wx\\u0003\\u0002\\u0002\\u0002xy\\u0007\\u001f\\u0002\",\n    \"\\u0002y\\u000f\\u0003\\u0002\\u0002\\u0002z\\u007f\\u0005\\u0004\\u0003\\u0002\",\n    \"{|\\u0007(\\u0002\\u0002|~\\u0005\\u0004\\u0003\\u0002}{\\u0003\\u0002\\u0002\",\n    \"\\u0002~\\u0081\\u0003\\u0002\\u0002\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u007f\\u0080\\u0003\\u0002\\u0002\\u0002\\u0080\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0081\\u007f\\u0003\\u0002\\u0002\\u0002\\u0082\\u0084\\u0007>\\u0002\\u0002\",\n    \"\\u0083\\u0085\\u0005\\u0014\\u000b\\u0002\\u0084\\u0083\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0084\\u0085\\u0003\\u0002\\u0002\\u0002\\u0085\\u0013\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0086\\u008a\\u0005\\u0016\\f\\u0002\\u0087\\u008a\\u0005\\u0018\\r\\u0002\\u0088\",\n    \"\\u008a\\u0007=\\u0002\\u0002\\u0089\\u0086\\u0003\\u0002\\u0002\\u0002\\u0089\",\n    \"\\u0087\\u0003\\u0002\\u0002\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u008a\",\n    \"\\u0015\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\\t\\u000b\\u0002\\u0002\\u008c\",\n    \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\\t\\f\\u0002\\u0002\\u008e\\u0019\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0005\\u001c\\u000f\\u0002\\u0090\\u001b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0091\\u0096\\u0005\\u001e\\u0010\\u0002\\u0092\\u0093\",\n    \"\\u0007\\u0003\\u0002\\u0002\\u0093\\u0095\\u0005\\u001e\\u0010\\u0002\\u0094\\u0092\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0095\\u0098\\u0003\\u0002\\u0002\\u0002\\u0096\\u0094\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\\u0002\\u0002\\u0002\\u0097\\u001d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0098\\u0096\\u0003\\u0002\\u0002\\u0002\\u0099\\u009a\",\n    \"\\t\\r\\u0002\\u0002\\u009a\\u001f\\u0003\\u0002\\u0002\\u0002\\u000e\\'OQ[ejqv\",\n    \"\\u007f\\u0084\\u0089\\u0096\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nconst sharedContextCache = new antlr4.PredictionContextCache();\n\nclass FHIRPathParser extends antlr4.Parser {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                            \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                            \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \n                            \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \n                            \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \n                            \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \n                            \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \n                            \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \n                            \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \n                            \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \n                            \"'seconds'\", \"'milliseconds'\" ];\n    static symbolicNames = [ null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, \"DATETIME\", \n                             \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                             \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n    static ruleNames = [ \"entireExpression\", \"expression\", \"term\", \"literal\", \n                         \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \n                         \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \n                         \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\" ];\n\n    constructor(input) {\n        super(input);\n        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n        this.ruleNames = FHIRPathParser.ruleNames;\n        this.literalNames = FHIRPathParser.literalNames;\n        this.symbolicNames = FHIRPathParser.symbolicNames;\n    }\n\n    get atn() {\n        return atn;\n    }\n\n    sempred(localctx, ruleIndex, predIndex) {\n    \tswitch(ruleIndex) {\n    \tcase 1:\n    \t    \t\treturn this.expression_sempred(localctx, predIndex);\n        default:\n            throw \"No predicate with index:\" + ruleIndex;\n       }\n    }\n\n    expression_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 0:\n    \t\t\treturn this.precpred(this._ctx, 10);\n    \t\tcase 1:\n    \t\t\treturn this.precpred(this._ctx, 9);\n    \t\tcase 2:\n    \t\t\treturn this.precpred(this._ctx, 8);\n    \t\tcase 3:\n    \t\t\treturn this.precpred(this._ctx, 7);\n    \t\tcase 4:\n    \t\t\treturn this.precpred(this._ctx, 5);\n    \t\tcase 5:\n    \t\t\treturn this.precpred(this._ctx, 4);\n    \t\tcase 6:\n    \t\t\treturn this.precpred(this._ctx, 3);\n    \t\tcase 7:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 8:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tcase 9:\n    \t\t\treturn this.precpred(this._ctx, 13);\n    \t\tcase 10:\n    \t\t\treturn this.precpred(this._ctx, 12);\n    \t\tcase 11:\n    \t\t\treturn this.precpred(this._ctx, 6);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n\n\n\n\tentireExpression() {\n\t    let localctx = new EntireExpressionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 30;\n\t        this.expression(0);\n\t        this.state = 31;\n\t        this.match(FHIRPathParser.EOF);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\texpression(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new ExpressionContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 2;\n\t    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 37;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__27:\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.T__33:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new TermExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\n\t            this.state = 34;\n\t            this.term();\n\t            break;\n\t        case FHIRPathParser.T__3:\n\t        case FHIRPathParser.T__4:\n\t            localctx = new PolarityExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\t            this.state = 35;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__3 || _la===FHIRPathParser.T__4)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            this.state = 36;\n\t            this.expression(11);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 79;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,2,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 77;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 39;\n\t                    if (!( this.precpred(this._ctx, 10))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n\t                    }\n\t                    this.state = 40;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__5) | (1 << FHIRPathParser.T__6) | (1 << FHIRPathParser.T__7) | (1 << FHIRPathParser.T__8))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 41;\n\t                    this.expression(11);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 42;\n\t                    if (!( this.precpred(this._ctx, 9))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n\t                    }\n\t                    this.state = 43;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__9))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 44;\n\t                    this.expression(10);\n\t                    break;\n\n\t                case 3:\n\t                    localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 45;\n\t                    if (!( this.precpred(this._ctx, 8))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n\t                    }\n\t                    this.state = 46;\n\t                    this.match(FHIRPathParser.T__10);\n\t                    this.state = 47;\n\t                    this.expression(9);\n\t                    break;\n\n\t                case 4:\n\t                    localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 48;\n\t                    if (!( this.precpred(this._ctx, 7))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n\t                    }\n\t                    this.state = 49;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__11) | (1 << FHIRPathParser.T__12) | (1 << FHIRPathParser.T__13) | (1 << FHIRPathParser.T__14))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 50;\n\t                    this.expression(8);\n\t                    break;\n\n\t                case 5:\n\t                    localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 51;\n\t                    if (!( this.precpred(this._ctx, 5))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n\t                    }\n\t                    this.state = 52;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__17) | (1 << FHIRPathParser.T__18) | (1 << FHIRPathParser.T__19) | (1 << FHIRPathParser.T__20))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 53;\n\t                    this.expression(6);\n\t                    break;\n\n\t                case 6:\n\t                    localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 54;\n\t                    if (!( this.precpred(this._ctx, 4))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n\t                    }\n\t                    this.state = 55;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__21 || _la===FHIRPathParser.T__22)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 56;\n\t                    this.expression(5);\n\t                    break;\n\n\t                case 7:\n\t                    localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 57;\n\t                    if (!( this.precpred(this._ctx, 3))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n\t                    }\n\t                    this.state = 58;\n\t                    this.match(FHIRPathParser.T__23);\n\t                    this.state = 59;\n\t                    this.expression(4);\n\t                    break;\n\n\t                case 8:\n\t                    localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 60;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 61;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__24 || _la===FHIRPathParser.T__25)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 62;\n\t                    this.expression(3);\n\t                    break;\n\n\t                case 9:\n\t                    localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 63;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 64;\n\t                    this.match(FHIRPathParser.T__26);\n\t                    this.state = 65;\n\t                    this.expression(2);\n\t                    break;\n\n\t                case 10:\n\t                    localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 66;\n\t                    if (!( this.precpred(this._ctx, 13))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n\t                    }\n\t                    this.state = 67;\n\t                    this.match(FHIRPathParser.T__0);\n\t                    this.state = 68;\n\t                    this.invocation();\n\t                    break;\n\n\t                case 11:\n\t                    localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 69;\n\t                    if (!( this.precpred(this._ctx, 12))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n\t                    }\n\t                    this.state = 70;\n\t                    this.match(FHIRPathParser.T__1);\n\t                    this.state = 71;\n\t                    this.expression(0);\n\t                    this.state = 72;\n\t                    this.match(FHIRPathParser.T__2);\n\t                    break;\n\n\t                case 12:\n\t                    localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 74;\n\t                    if (!( this.precpred(this._ctx, 6))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n\t                    }\n\t                    this.state = 75;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__15 || _la===FHIRPathParser.T__16)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 76;\n\t                    this.typeSpecifier();\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 81;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,2,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tterm() {\n\t    let localctx = new TermContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\t    try {\n\t        this.state = 89;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            localctx = new InvocationTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 82;\n\t            this.invocation();\n\t            break;\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new LiteralTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 83;\n\t            this.literal();\n\t            break;\n\t        case FHIRPathParser.T__33:\n\t            localctx = new ExternalConstantTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 84;\n\t            this.externalConstant();\n\t            break;\n\t        case FHIRPathParser.T__27:\n\t            localctx = new ParenthesizedTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 85;\n\t            this.match(FHIRPathParser.T__27);\n\t            this.state = 86;\n\t            this.expression(0);\n\t            this.state = 87;\n\t            this.match(FHIRPathParser.T__28);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tliteral() {\n\t    let localctx = new LiteralContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 99;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,4,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new NullLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 91;\n\t            this.match(FHIRPathParser.T__29);\n\t            this.state = 92;\n\t            this.match(FHIRPathParser.T__30);\n\t            break;\n\n\t        case 2:\n\t            localctx = new BooleanLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 93;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__31 || _la===FHIRPathParser.T__32)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            break;\n\n\t        case 3:\n\t            localctx = new StringLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 94;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\n\t        case 4:\n\t            localctx = new NumberLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 95;\n\t            this.match(FHIRPathParser.NUMBER);\n\t            break;\n\n\t        case 5:\n\t            localctx = new DateTimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 96;\n\t            this.match(FHIRPathParser.DATETIME);\n\t            break;\n\n\t        case 6:\n\t            localctx = new TimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 97;\n\t            this.match(FHIRPathParser.TIME);\n\t            break;\n\n\t        case 7:\n\t            localctx = new QuantityLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 98;\n\t            this.quantity();\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\texternalConstant() {\n\t    let localctx = new ExternalConstantContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 101;\n\t        this.match(FHIRPathParser.T__33);\n\t        this.state = 104;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            this.state = 102;\n\t            this.identifier();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.state = 103;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tinvocation() {\n\t    let localctx = new InvocationContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\t    try {\n\t        this.state = 111;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new MemberInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 106;\n\t            this.identifier();\n\t            break;\n\n\t        case 2:\n\t            localctx = new FunctionInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 107;\n\t            this.functn();\n\t            break;\n\n\t        case 3:\n\t            localctx = new ThisInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 108;\n\t            this.match(FHIRPathParser.T__34);\n\t            break;\n\n\t        case 4:\n\t            localctx = new IndexInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 109;\n\t            this.match(FHIRPathParser.T__35);\n\t            break;\n\n\t        case 5:\n\t            localctx = new TotalInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 110;\n\t            this.match(FHIRPathParser.T__36);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfunctn() {\n\t    let localctx = new FunctnContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 113;\n\t        this.identifier();\n\t        this.state = 114;\n\t        this.match(FHIRPathParser.T__27);\n\t        this.state = 116;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22) | (1 << FHIRPathParser.T__27) | (1 << FHIRPathParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (FHIRPathParser.T__31 - 32)) | (1 << (FHIRPathParser.T__32 - 32)) | (1 << (FHIRPathParser.T__33 - 32)) | (1 << (FHIRPathParser.T__34 - 32)) | (1 << (FHIRPathParser.T__35 - 32)) | (1 << (FHIRPathParser.T__36 - 32)) | (1 << (FHIRPathParser.DATETIME - 32)) | (1 << (FHIRPathParser.TIME - 32)) | (1 << (FHIRPathParser.IDENTIFIER - 32)) | (1 << (FHIRPathParser.DELIMITEDIDENTIFIER - 32)) | (1 << (FHIRPathParser.STRING - 32)) | (1 << (FHIRPathParser.NUMBER - 32)))) !== 0)) {\n\t            this.state = 115;\n\t            this.paramList();\n\t        }\n\n\t        this.state = 118;\n\t        this.match(FHIRPathParser.T__28);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tparamList() {\n\t    let localctx = new ParamListContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 120;\n\t        this.expression(0);\n\t        this.state = 125;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===FHIRPathParser.T__37) {\n\t            this.state = 121;\n\t            this.match(FHIRPathParser.T__37);\n\t            this.state = 122;\n\t            this.expression(0);\n\t            this.state = 127;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tquantity() {\n\t    let localctx = new QuantityContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 128;\n\t        this.match(FHIRPathParser.NUMBER);\n\t        this.state = 130;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);\n\t        if(la_===1) {\n\t            this.state = 129;\n\t            this.unit();\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tunit() {\n\t    let localctx = new UnitContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\t    try {\n\t        this.state = 135;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__38:\n\t        case FHIRPathParser.T__39:\n\t        case FHIRPathParser.T__40:\n\t        case FHIRPathParser.T__41:\n\t        case FHIRPathParser.T__42:\n\t        case FHIRPathParser.T__43:\n\t        case FHIRPathParser.T__44:\n\t        case FHIRPathParser.T__45:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 132;\n\t            this.dateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.T__46:\n\t        case FHIRPathParser.T__47:\n\t        case FHIRPathParser.T__48:\n\t        case FHIRPathParser.T__49:\n\t        case FHIRPathParser.T__50:\n\t        case FHIRPathParser.T__51:\n\t        case FHIRPathParser.T__52:\n\t        case FHIRPathParser.T__53:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 133;\n\t            this.pluralDateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 134;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdateTimePrecision() {\n\t    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 137;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (FHIRPathParser.T__38 - 39)) | (1 << (FHIRPathParser.T__39 - 39)) | (1 << (FHIRPathParser.T__40 - 39)) | (1 << (FHIRPathParser.T__41 - 39)) | (1 << (FHIRPathParser.T__42 - 39)) | (1 << (FHIRPathParser.T__43 - 39)) | (1 << (FHIRPathParser.T__44 - 39)) | (1 << (FHIRPathParser.T__45 - 39)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tpluralDateTimePrecision() {\n\t    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 139;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (FHIRPathParser.T__46 - 47)) | (1 << (FHIRPathParser.T__47 - 47)) | (1 << (FHIRPathParser.T__48 - 47)) | (1 << (FHIRPathParser.T__49 - 47)) | (1 << (FHIRPathParser.T__50 - 47)) | (1 << (FHIRPathParser.T__51 - 47)) | (1 << (FHIRPathParser.T__52 - 47)) | (1 << (FHIRPathParser.T__53 - 47)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeSpecifier() {\n\t    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 141;\n\t        this.qualifiedIdentifier();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tqualifiedIdentifier() {\n\t    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 143;\n\t        this.identifier();\n\t        this.state = 148;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,11,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 144;\n\t                this.match(FHIRPathParser.T__0);\n\t                this.state = 145;\n\t                this.identifier(); \n\t            }\n\t            this.state = 150;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,11,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tidentifier() {\n\t    let localctx = new IdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 151;\n\t        _la = this._input.LA(1);\n\t        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22))) !== 0) || _la===FHIRPathParser.IDENTIFIER || _la===FHIRPathParser.DELIMITEDIDENTIFIER)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n}\n\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\n\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nclass EntireExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tEOF() {\n\t    return this.getToken(FHIRPathParser.EOF, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEntireExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEntireExpression(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_expression;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass IndexerExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexerExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexerExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nclass PolarityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPolarityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPolarityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nclass AdditiveExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAdditiveExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAdditiveExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nclass MultiplicativeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nclass UnionExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnionExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnionExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nclass OrExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterOrExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitOrExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nclass AndExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAndExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAndExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nclass MembershipExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMembershipExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMembershipExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nclass InequalityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInequalityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInequalityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nclass InvocationExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nclass EqualityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEqualityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEqualityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nclass ImpliesExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterImpliesExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitImpliesExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nclass TermExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tterm() {\n\t    return this.getTypedRuleContext(TermContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTermExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTermExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nclass TypeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttypeSpecifier() {\n\t    return this.getTypedRuleContext(TypeSpecifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nclass TermContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_term;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass ExternalConstantTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texternalConstant() {\n\t    return this.getTypedRuleContext(ExternalConstantContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstantTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstantTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nclass LiteralTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tliteral() {\n\t    return this.getTypedRuleContext(LiteralContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterLiteralTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitLiteralTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nclass ParenthesizedTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParenthesizedTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParenthesizedTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nclass InvocationTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nclass LiteralContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_literal;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tTIME() {\n\t    return this.getToken(FHIRPathParser.TIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nclass NullLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNullLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNullLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nclass DateTimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tDATETIME() {\n\t    return this.getToken(FHIRPathParser.DATETIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nclass StringLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterStringLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitStringLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nclass BooleanLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterBooleanLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitBooleanLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nclass NumberLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNumberLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNumberLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nclass QuantityLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tquantity() {\n\t    return this.getTypedRuleContext(QuantityContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantityLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantityLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nclass ExternalConstantContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstant(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstant(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass InvocationContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_invocation;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TotalInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTotalInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTotalInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nclass ThisInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterThisInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitThisInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nclass IndexInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nclass FunctionInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tfunctn() {\n\t    return this.getTypedRuleContext(FunctnContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctionInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctionInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nclass MemberInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMemberInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMemberInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nclass FunctnContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_functn;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tparamList() {\n\t    return this.getTypedRuleContext(ParamListContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctn(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctn(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ParamListContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_paramList;\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParamList(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParamList(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QuantityContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_quantity;\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tunit() {\n\t    return this.getTypedRuleContext(UnitContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantity(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantity(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass UnitContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_unit;\n    }\n\n\tdateTimePrecision() {\n\t    return this.getTypedRuleContext(DateTimePrecisionContext,0);\n\t};\n\n\tpluralDateTimePrecision() {\n\t    return this.getTypedRuleContext(PluralDateTimePrecisionContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnit(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnit(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass DateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass TypeSpecifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n    }\n\n\tqualifiedIdentifier() {\n\t    return this.getTypedRuleContext(QualifiedIdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeSpecifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeSpecifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QualifiedIdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n    }\n\n\tidentifier = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(IdentifierContext);\n\t    } else {\n\t        return this.getTypedRuleContext(IdentifierContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass IdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_identifier;\n    }\n\n\tIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n\t};\n\n\tDELIMITEDIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext; \nFHIRPathParser.ExpressionContext = ExpressionContext; \nFHIRPathParser.TermContext = TermContext; \nFHIRPathParser.LiteralContext = LiteralContext; \nFHIRPathParser.ExternalConstantContext = ExternalConstantContext; \nFHIRPathParser.InvocationContext = InvocationContext; \nFHIRPathParser.FunctnContext = FunctnContext; \nFHIRPathParser.ParamListContext = ParamListContext; \nFHIRPathParser.QuantityContext = QuantityContext; \nFHIRPathParser.UnitContext = UnitContext; \nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext; \nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext; \nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext; \nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext; \nFHIRPathParser.IdentifierContext = IdentifierContext; \n\nmodule.exports = FHIRPathParser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9nZW5lcmF0ZWQvRkhJUlBhdGhQYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxxSEFBaUI7QUFDeEMseUJBQXlCLG1CQUFPLENBQUMsc0lBQW9COztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQWdEO0FBQ3RELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9nZW5lcmF0ZWQvRkhJUlBhdGhQYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGZyb20gRkhJUlBhdGguZzQgYnkgQU5UTFIgNC45LjNcbi8vIGpzaGludCBpZ25vcmU6IHN0YXJ0XG5jb25zdCBhbnRscjQgPSByZXF1aXJlKCcuLi9hbnRscjQtaW5kZXgnKTtcbmNvbnN0IEZISVJQYXRoTGlzdGVuZXIgPSByZXF1aXJlKCcuL0ZISVJQYXRoTGlzdGVuZXInKTtcblxuY29uc3Qgc2VyaWFsaXplZEFUTiA9IFtcIlxcdTAwMDNcXHU2MDhiXFx1YTcyYVxcdTgxMzNcXHViOWVkXFx1NDE3Y1xcdTNiZTdcXHU3Nzg2XCIsXG4gICAgXCJcXHU1OTY0XFx1MDAwM0FcXHUwMDljXFx1MDAwNFxcdTAwMDJcXHRcXHUwMDAyXFx1MDAwNFxcdTAwMDNcXHRcXHUwMDAzXFx1MDAwNFxcdTAwMDRcIixcbiAgICBcIlxcdFxcdTAwMDRcXHUwMDA0XFx1MDAwNVxcdFxcdTAwMDVcXHUwMDA0XFx1MDAwNlxcdFxcdTAwMDZcXHUwMDA0XFx1MDAwN1xcdFxcdTAwMDdcIixcbiAgICBcIlxcdTAwMDRcXGJcXHRcXGJcXHUwMDA0XFx0XFx0XFx0XFx1MDAwNFxcblxcdFxcblxcdTAwMDRcXHUwMDBiXFx0XFx1MDAwYlxcdTAwMDRcXGZcXHRcXGZcIixcbiAgICBcIlxcdTAwMDRcXHJcXHRcXHJcXHUwMDA0XFx1MDAwZVxcdFxcdTAwMGVcXHUwMDA0XFx1MDAwZlxcdFxcdTAwMGZcXHUwMDA0XFx1MDAxMFxcdFxcdTAwMTBcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDNcXHUwMDA1XFx1MDAwMyhcXG5cXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDdcXHUwMDAzXCIsXG4gICAgXCJQXFxuXFx1MDAwM1xcZlxcdTAwMDNcXHUwMDBlXFx1MDAwM1NcXHUwMDBiXFx1MDAwM1xcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDA1XFx1MDAwNFxcXFxcIixcbiAgICBcIlxcblxcdTAwMDRcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcXHUwMDA1XFx1MDAwNWZcXG5cXHUwMDA1XFx1MDAwM1xcdTAwMDZcIixcbiAgICBcIlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDA1XFx1MDAwNmtcXG5cXHUwMDA2XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwNVxcdTAwMDdyXFxuXFx1MDAwN1xcdTAwMDNcXGJcXHUwMDAzXCIsXG4gICAgXCJcXGJcXHUwMDAzXFxiXFx1MDAwNVxcYndcXG5cXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDdcIixcbiAgICBcIlxcdH5cXG5cXHRcXGZcXHRcXHUwMDBlXFx0XFx1MDA4MVxcdTAwMGJcXHRcXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDVcXG5cXHUwMDg1XFxuXFxuXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDA1XFx1MDAwYlxcdTAwOGFcXG5cXHUwMDBiXFx1MDAwM1wiLFxuICAgIFwiXFxmXFx1MDAwM1xcZlxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBmXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwN1xcdTAwMGZcXHUwMDk1XFxuXFx1MDAwZlxcZlxcdTAwMGZcXHUwMDBlXFx1MDAwZlxcdTAwOThcIixcbiAgICBcIlxcdTAwMGJcXHUwMDBmXFx1MDAwM1xcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAxMVwiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDRcXHUwMDA2XFxiXFxuXFxmXFx1MDAwZVxcdTAwMTBcXHUwMDEyXFx1MDAxNFxcdTAwMTZcXHUwMDE4XFx1MDAxYVxcdTAwMWNcIixcbiAgICBcIlxcdTAwMWVcXHUwMDAyXFx1MDAwZVxcdTAwMDNcXHUwMDAyXFx1MDAwNlxcdTAwMDdcXHUwMDAzXFx1MDAwMlxcYlxcdTAwMGJcXHUwMDA0XCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwNlxcdTAwMDdcXGZcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMGVcXHUwMDExXFx1MDAwM1xcdTAwMDJcXHUwMDE0XFx1MDAxN1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDE4XFx1MDAxOVxcdTAwMDNcXHUwMDAyXFx1MDAxYlxcdTAwMWNcXHUwMDAzXFx1MDAwMlxcdTAwMTJcXHUwMDEzXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcXCIjXFx1MDAwM1xcdTAwMDIpMFxcdTAwMDNcXHUwMDAyMThcXHUwMDA1XFx1MDAwMlxcdTAwMTJcXHUwMDEzXCIsXG4gICAgXCJcXHUwMDE4XFx1MDAxOTs8XFx1MDAwMlxcdTAwYWRcXHUwMDAyIFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDA0XFwnXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwNltcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFxiZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMlxcbmdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFxmcVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDBlc1wiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTB6XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTJcXHUwMDgyXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxNFxcdTAwODlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxNlxcdTAwOGJcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE4XFx1MDA4ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFhXFx1MDA4ZlwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWNcXHUwMDkxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWVcXHUwMDk5XCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyICFcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDAyIVxcXCJcXHUwMDA3XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDNcXFwiXFx1MDAwM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIjJFxcYlxcdTAwMDNcXHUwMDAxXFx1MDAwMiQoXFx1MDAwNVwiLFxuICAgIFwiXFx1MDAwNlxcdTAwMDRcXHUwMDAyJSZcXHRcXHUwMDAyXFx1MDAwMlxcdTAwMDImKFxcdTAwMDVcXHUwMDA0XFx1MDAwM1xcclxcJyNcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXCclXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMihRXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiKSpcXGZcXGZcXHUwMDAyXFx1MDAwMiorXFx0XFx1MDAwM1xcdTAwMDJcXHUwMDAyK1BcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHIsLVxcZlxcdTAwMGJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyLS5cXHRcXHUwMDA0XFx1MDAwMlxcdTAwMDIuUFxcdTAwMDVcXHUwMDA0XFx1MDAwM1xcZi8wXFxmXFxuXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMjAxXFx1MDAwN1xcclxcdTAwMDJcXHUwMDAyMVBcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDBiMjNcXGZcXHRcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiMzRcXHRcXHUwMDA1XFx1MDAwMlxcdTAwMDI0UFxcdTAwMDVcXHUwMDA0XFx1MDAwM1xcbjU2XFxmXFx1MDAwN1xcdTAwMDJcXHUwMDAyNlwiLFxuICAgIFwiN1xcdFxcdTAwMDZcXHUwMDAyXFx1MDAwMjdQXFx1MDAwNVxcdTAwMDRcXHUwMDAzXFxiODlcXGZcXHUwMDA2XFx1MDAwMlxcdTAwMDI5OlwiLFxuICAgIFwiXFx0XFx1MDAwN1xcdTAwMDJcXHUwMDAyOlBcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDA3OzxcXGZcXHUwMDA1XFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIjw9XFx1MDAwN1xcdTAwMWFcXHUwMDAyXFx1MDAwMj1QXFx1MDAwNVxcdTAwMDRcXHUwMDAzXFx1MDAwNj4/XFxmXFx1MDAwNFxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDI/QFxcdFxcYlxcdTAwMDJcXHUwMDAyQFBcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDA1QUJcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIkJDXFx1MDAwN1xcdTAwMWRcXHUwMDAyXFx1MDAwMkNQXFx1MDAwNVxcdTAwMDRcXHUwMDAzXFx1MDAwNERFXFxmXFx1MDAwZlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJFRlxcdTAwMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJGUFxcdTAwMDVcXGZcXHUwMDA3XFx1MDAwMkdIXFxmXFx1MDAwZVxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJISVxcdTAwMDdcXHUwMDA0XFx1MDAwMlxcdTAwMDJJSlxcdTAwMDVcXHUwMDA0XFx1MDAwM1xcdTAwMDJKS1xcdTAwMDdcXHUwMDA1XCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMktQXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkxNXFxmXFxiXFx1MDAwMlxcdTAwMDJNTlxcdFxcdFxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJOUFxcdTAwMDVcXHUwMDFhXFx1MDAwZVxcdTAwMDJPKVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJPLFxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMk8vXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk8yXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk81XFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyTzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyTztcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJPPlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJPQVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJPRFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMk9HXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk9MXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlBTXFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyUU9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyUVJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyUlxcdTAwMDVcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJTUVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJUXFxcXFxcdTAwMDVcXGZcXHUwMDA3XCIsXG4gICAgXCJcXHUwMDAyVVxcXFxcXHUwMDA1XFxiXFx1MDAwNVxcdTAwMDJWXFxcXFxcdTAwMDVcXG5cXHUwMDA2XFx1MDAwMldYXFx1MDAwN1xcdTAwMWVcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyWFlcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDAyWVpcXHUwMDA3XFx1MDAxZlxcdTAwMDJcXHUwMDAyWlxcXFxcXHUwMDAzXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJbVFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJbVVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIltWXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMltXXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcXFxcXHUwMDA3XFx1MDAwM1xcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXV5cXHUwMDA3IFxcdTAwMDJcXHUwMDAyXmZcXHUwMDA3IVxcdTAwMDJcXHUwMDAyX2ZcXHRcXG5cXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiYGZcXHUwMDA3PVxcdTAwMDJcXHUwMDAyYWZcXHUwMDA3PlxcdTAwMDJcXHUwMDAyYmZcXHUwMDA3OVxcdTAwMDJcXHUwMDAyY2ZcXHUwMDA3XCIsXG4gICAgXCI6XFx1MDAwMlxcdTAwMDJkZlxcdTAwMDVcXHUwMDEyXFxuXFx1MDAwMmVdXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmVfXFx1MDAwM1wiLFxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyZWBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyZWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJlYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJlY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJlZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDAwMmZcXHRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyZ2pcXHUwMDA3JFxcdTAwMDJcXHUwMDAyaGtcXHUwMDA1XFx1MDAxZVwiLFxuICAgIFwiXFx1MDAxMFxcdTAwMDJpa1xcdTAwMDc9XFx1MDAwMlxcdTAwMDJqaFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJqaVxcdTAwMDNcIixcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMmtcXHUwMDBiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmxyXFx1MDAwNVxcdTAwMWVcXHUwMDEwXCIsXG4gICAgXCJcXHUwMDAybXJcXHUwMDA1XFx1MDAwZVxcYlxcdTAwMDJuclxcdTAwMDclXFx1MDAwMlxcdTAwMDJvclxcdTAwMDcmXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcInByXFx1MDAwN1xcJ1xcdTAwMDJcXHUwMDAycWxcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAycW1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJxblxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJxb1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJxcFxcdTAwMDNcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyXFx1MDAwMnJcXHJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyc3RcXHUwMDA1XFx1MDAxZVxcdTAwMTBcXHUwMDAydHZcIixcbiAgICBcIlxcdTAwMDdcXHUwMDFlXFx1MDAwMlxcdTAwMDJ1d1xcdTAwMDVcXHUwMDEwXFx0XFx1MDAwMnZ1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwidndcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyd3hcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyeHlcXHUwMDA3XFx1MDAxZlxcdTAwMDJcIixcbiAgICBcIlxcdTAwMDJ5XFx1MDAwZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJ6XFx1MDA3ZlxcdTAwMDVcXHUwMDA0XFx1MDAwM1xcdTAwMDJcIixcbiAgICBcInt8XFx1MDAwNyhcXHUwMDAyXFx1MDAwMnx+XFx1MDAwNVxcdTAwMDRcXHUwMDAzXFx1MDAwMn17XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDAyflxcdTAwODFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA3Zn1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDdmXFx1MDA4MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDgwXFx1MDAxMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwODFcXHUwMDdmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODJcXHUwMDg0XFx1MDAwNz5cXHUwMDAyXFx1MDAwMlwiLFxuICAgIFwiXFx1MDA4M1xcdTAwODVcXHUwMDA1XFx1MDAxNFxcdTAwMGJcXHUwMDAyXFx1MDA4NFxcdTAwODNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXG4gICAgXCJcXHUwMDg0XFx1MDA4NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDg1XFx1MDAxM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcbiAgICBcIlxcdTAwODZcXHUwMDhhXFx1MDAwNVxcdTAwMTZcXGZcXHUwMDAyXFx1MDA4N1xcdTAwOGFcXHUwMDA1XFx1MDAxOFxcclxcdTAwMDJcXHUwMDg4XCIsXG4gICAgXCJcXHUwMDhhXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAwODlcXHUwMDg2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODlcIixcbiAgICBcIlxcdTAwODdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4OVxcdTAwODhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4YVwiLFxuICAgIFwiXFx1MDAxNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhiXFx1MDA4Y1xcdFxcdTAwMGJcXHUwMDAyXFx1MDAwMlxcdTAwOGNcIixcbiAgICBcIlxcdTAwMTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4ZFxcdTAwOGVcXHRcXGZcXHUwMDAyXFx1MDAwMlxcdTAwOGVcXHUwMDE5XCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4ZlxcdTAwOTBcXHUwMDA1XFx1MDAxY1xcdTAwMGZcXHUwMDAyXFx1MDA5MFxcdTAwMWJcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDkxXFx1MDA5NlxcdTAwMDVcXHUwMDFlXFx1MDAxMFxcdTAwMDJcXHUwMDkyXFx1MDA5M1wiLFxuICAgIFwiXFx1MDAwN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwOTNcXHUwMDk1XFx1MDAwNVxcdTAwMWVcXHUwMDEwXFx1MDAwMlxcdTAwOTRcXHUwMDkyXCIsXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5NVxcdTAwOThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5NlxcdTAwOTRcIixcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk2XFx1MDA5N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk3XFx1MDAxZFwiLFxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOThcXHUwMDk2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTlcXHUwMDlhXCIsXG4gICAgXCJcXHRcXHJcXHUwMDAyXFx1MDAwMlxcdTAwOWFcXHUwMDFmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMGVcXCdPUVtlanF2XCIsXG4gICAgXCJcXHUwMDdmXFx1MDA4NFxcdTAwODlcXHUwMDk2XCJdLmpvaW4oXCJcIik7XG5cblxuY29uc3QgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XG5cbmNvbnN0IGRlY2lzaW9uc1RvREZBID0gYXRuLmRlY2lzaW9uVG9TdGF0ZS5tYXAoIChkcywgaW5kZXgpID0+IG5ldyBhbnRscjQuZGZhLkRGQShkcywgaW5kZXgpICk7XG5cbmNvbnN0IHNoYXJlZENvbnRleHRDYWNoZSA9IG5ldyBhbnRscjQuUHJlZGljdGlvbkNvbnRleHRDYWNoZSgpO1xuXG5jbGFzcyBGSElSUGF0aFBhcnNlciBleHRlbmRzIGFudGxyNC5QYXJzZXIge1xuXG4gICAgc3RhdGljIGdyYW1tYXJGaWxlTmFtZSA9IFwiRkhJUlBhdGguZzRcIjtcbiAgICBzdGF0aWMgbGl0ZXJhbE5hbWVzID0gWyBudWxsLCBcIicuJ1wiLCBcIidbJ1wiLCBcIiddJ1wiLCBcIicrJ1wiLCBcIictJ1wiLCBcIicqJ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicvJ1wiLCBcIidkaXYnXCIsIFwiJ21vZCdcIiwgXCInJidcIiwgXCInfCdcIiwgXCInPD0nXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJzwnXCIsIFwiJz4nXCIsIFwiJz49J1wiLCBcIidpcydcIiwgXCInYXMnXCIsIFwiJz0nXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ34nXCIsIFwiJyE9J1wiLCBcIichfidcIiwgXCInaW4nXCIsIFwiJ2NvbnRhaW5zJ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidhbmQnXCIsIFwiJ29yJ1wiLCBcIid4b3InXCIsIFwiJ2ltcGxpZXMnXCIsIFwiJygnXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJyknXCIsIFwiJ3snXCIsIFwiJ30nXCIsIFwiJ3RydWUnXCIsIFwiJ2ZhbHNlJ1wiLCBcIiclJ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIickdGhpcydcIiwgXCInJGluZGV4J1wiLCBcIickdG90YWwnXCIsIFwiJywnXCIsIFwiJ3llYXInXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ21vbnRoJ1wiLCBcIid3ZWVrJ1wiLCBcIidkYXknXCIsIFwiJ2hvdXInXCIsIFwiJ21pbnV0ZSdcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInc2Vjb25kJ1wiLCBcIidtaWxsaXNlY29uZCdcIiwgXCIneWVhcnMnXCIsIFwiJ21vbnRocydcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInd2Vla3MnXCIsIFwiJ2RheXMnXCIsIFwiJ2hvdXJzJ1wiLCBcIidtaW51dGVzJ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidzZWNvbmRzJ1wiLCBcIidtaWxsaXNlY29uZHMnXCIgXTtcbiAgICBzdGF0aWMgc3ltYm9saWNOYW1lcyA9IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXCJEQVRFVElNRVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUSU1FXCIsIFwiSURFTlRJRklFUlwiLCBcIkRFTElNSVRFRElERU5USUZJRVJcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU1RSSU5HXCIsIFwiTlVNQkVSXCIsIFwiV1NcIiwgXCJDT01NRU5UXCIsIFwiTElORV9DT01NRU5UXCIgXTtcbiAgICBzdGF0aWMgcnVsZU5hbWVzID0gWyBcImVudGlyZUV4cHJlc3Npb25cIiwgXCJleHByZXNzaW9uXCIsIFwidGVybVwiLCBcImxpdGVyYWxcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJleHRlcm5hbENvbnN0YW50XCIsIFwiaW52b2NhdGlvblwiLCBcImZ1bmN0blwiLCBcInBhcmFtTGlzdFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcInF1YW50aXR5XCIsIFwidW5pdFwiLCBcImRhdGVUaW1lUHJlY2lzaW9uXCIsIFwicGx1cmFsRGF0ZVRpbWVQcmVjaXNpb25cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlU3BlY2lmaWVyXCIsIFwicXVhbGlmaWVkSWRlbnRpZmllclwiLCBcImlkZW50aWZpZXJcIiBdO1xuXG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgICB0aGlzLl9pbnRlcnAgPSBuZXcgYW50bHI0LmF0bi5QYXJzZXJBVE5TaW11bGF0b3IodGhpcywgYXRuLCBkZWNpc2lvbnNUb0RGQSwgc2hhcmVkQ29udGV4dENhY2hlKTtcbiAgICAgICAgdGhpcy5ydWxlTmFtZXMgPSBGSElSUGF0aFBhcnNlci5ydWxlTmFtZXM7XG4gICAgICAgIHRoaXMubGl0ZXJhbE5hbWVzID0gRkhJUlBhdGhQYXJzZXIubGl0ZXJhbE5hbWVzO1xuICAgICAgICB0aGlzLnN5bWJvbGljTmFtZXMgPSBGSElSUGF0aFBhcnNlci5zeW1ib2xpY05hbWVzO1xuICAgIH1cblxuICAgIGdldCBhdG4oKSB7XG4gICAgICAgIHJldHVybiBhdG47XG4gICAgfVxuXG4gICAgc2VtcHJlZChsb2NhbGN0eCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpIHtcbiAgICBcdHN3aXRjaChydWxlSW5kZXgpIHtcbiAgICBcdGNhc2UgMTpcbiAgICBcdCAgICBcdFx0cmV0dXJuIHRoaXMuZXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHJ1bGVJbmRleDtcbiAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcbiAgICBcdHN3aXRjaChwcmVkSW5kZXgpIHtcbiAgICBcdFx0Y2FzZSAwOlxuICAgIFx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTApO1xuICAgIFx0XHRjYXNlIDE6XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA5KTtcbiAgICBcdFx0Y2FzZSAyOlxuICAgIFx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOCk7XG4gICAgXHRcdGNhc2UgMzpcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpO1xuICAgIFx0XHRjYXNlIDQ6XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KTtcbiAgICBcdFx0Y2FzZSA1OlxuICAgIFx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNCk7XG4gICAgXHRcdGNhc2UgNjpcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpO1xuICAgIFx0XHRjYXNlIDc6XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKTtcbiAgICBcdFx0Y2FzZSA4OlxuICAgIFx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XG4gICAgXHRcdGNhc2UgOTpcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEzKTtcbiAgICBcdFx0Y2FzZSAxMDpcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEyKTtcbiAgICBcdFx0Y2FzZSAxMTpcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDYpO1xuICAgIFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XG4gICAgXHR9XG4gICAgfTtcblxuXG5cblxuXHRlbnRpcmVFeHByZXNzaW9uKCkge1xuXHQgICAgbGV0IGxvY2FsY3R4ID0gbmV3IEVudGlyZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdCAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMCwgRkhJUlBhdGhQYXJzZXIuUlVMRV9lbnRpcmVFeHByZXNzaW9uKTtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMzA7XG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAzMTtcblx0ICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLkVPRik7XG5cdCAgICB9IGNhdGNoIChyZSkge1xuXHQgICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuXHRcdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgIFx0dGhyb3cgcmU7XG5cdFx0ICAgIH1cblx0ICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvY2FsY3R4O1xuXHR9XG5cblxuXHRleHByZXNzaW9uKF9wKSB7XG5cdFx0aWYoX3A9PT11bmRlZmluZWQpIHtcblx0XHQgICAgX3AgPSAwO1xuXHRcdH1cblx0ICAgIGNvbnN0IF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XG5cdCAgICBjb25zdCBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xuXHQgICAgbGV0IGxvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcblx0ICAgIGxldCBfcHJldmN0eCA9IGxvY2FsY3R4O1xuXHQgICAgY29uc3QgX3N0YXJ0U3RhdGUgPSAyO1xuXHQgICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDIsIEZISVJQYXRoUGFyc2VyLlJVTEVfZXhwcmVzc2lvbiwgX3ApO1xuXHQgICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMzc7XG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHQgICAgICAgIHN3aXRjaCh0aGlzLl9pbnB1dC5MQSgxKSkge1xuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMTU6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18xNjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzIxOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMjI6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18yNzpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzI5OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzE6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18zMjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzMzOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzQ6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18zNTpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzM2OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuREFURVRJTUU6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5USU1FOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuSURFTlRJRklFUjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLkRFTElNSVRFRElERU5USUZJRVI6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5TVFJJTkc6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5OVU1CRVI6XG5cdCAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFRlcm1FeHByZXNzaW9uQ29udGV4dCh0aGlzLCBsb2NhbGN0eCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuXHQgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xuXG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDtcblx0ICAgICAgICAgICAgdGhpcy50ZXJtKCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzQ6XG5cdCAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFBvbGFyaXR5RXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcblx0ICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM1O1xuXHQgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICAgICAgaWYoIShfbGE9PT1GSElSUGF0aFBhcnNlci5UX18zIHx8IF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzQpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM2O1xuXHQgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMTEpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gNzk7XG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHQgICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyLHRoaXMuX2N0eClcblx0ICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuXHQgICAgICAgICAgICBpZihfYWx0PT09MSkge1xuXHQgICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3Nztcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEsdGhpcy5fY3R4KTtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaChsYV8pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEwKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwO1xuXHQgICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmKCEoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzUpIHwgKDEgPDwgRkhJUlBhdGhQYXJzZXIuVF9fNikgfCAoMSA8PCBGSElSUGF0aFBhcnNlci5UX183KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzgpKSkgIT09IDApKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQxO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBBZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDI7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA5KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOSlcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Mztcblx0ICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZighKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBGSElSUGF0aFBhcnNlci5UX18zKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzQpIHwgKDEgPDwgRkhJUlBhdGhQYXJzZXIuVF9fOSkpKSAhPT0gMCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDEwKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFVuaW9uRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBGSElSUGF0aFBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDgpKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA4KVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuVF9fMTApO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Nztcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oOSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBJbmVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQodGhpcywgbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBGSElSUGF0aFBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0ODtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA3KVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5O1xuXHQgICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmKCEoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzExKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzEyKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzEzKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzE0KSkpICE9PSAwKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oOCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBFcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNSlcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1Mjtcblx0ICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZighKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBGSElSUGF0aFBhcnNlci5UX18xNykgfCAoMSA8PCBGSElSUGF0aFBhcnNlci5UX18xOCkgfCAoMSA8PCBGSElSUGF0aFBhcnNlci5UX18xOSkgfCAoMSA8PCBGSElSUGF0aFBhcnNlci5UX18yMCkpKSAhPT0gMCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTM7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDYpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTWVtYmVyc2hpcEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNClcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NTtcblx0ICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZighKF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzIxIHx8IF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzIyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbig1KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEFuZEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTc7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMylcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1ODtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRfXzIzKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgT3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIEZISVJQYXRoUGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYwO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMikpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjE7XG5cdCAgICAgICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYoIShfbGE9PT1GSElSUGF0aFBhcnNlci5UX18yNCB8fCBfbGE9PT1GSElSUGF0aFBhcnNlci5UX18yNSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Mjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBJbXBsaWVzRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBGSElSUGF0aFBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Mztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuVF9fMjYpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMik7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgSW52b2NhdGlvbkV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjY7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMykpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEzKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY3O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuVF9fMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY4O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2NhdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOlxuXHQgICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEluZGV4ZXJFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIEZISVJQYXRoUGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTIpKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMilcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRfXzEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcyO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuVF9fMik7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMTI6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgVHlwZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA2KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNilcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NTtcblx0ICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZighKF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzE1IHx8IF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzE2KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc2O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZVNwZWNpZmllcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICB9IFxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MTtcblx0ICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHQgICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyLHRoaXMuX2N0eCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICB9IGNhdGNoKCBlcnJvcikge1xuXHQgICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyBlcnJvcjtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0dGVybSgpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBUZXJtQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDQsIEZISVJQYXRoUGFyc2VyLlJVTEVfdGVybSk7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSA4OTtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdCAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18xNTpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzE2OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMjE6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18yMjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzM0OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzU6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18zNjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLklERU5USUZJRVI6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5ERUxJTUlURURJREVOVElGSUVSOlxuXHQgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBJbnZvY2F0aW9uVGVybUNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gODI7XG5cdCAgICAgICAgICAgIHRoaXMuaW52b2NhdGlvbigpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzI5OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzE6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18zMjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLkRBVEVUSU1FOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVElNRTpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlNUUklORzpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLk5VTUJFUjpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTGl0ZXJhbFRlcm1Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzO1xuXHQgICAgICAgICAgICB0aGlzLmxpdGVyYWwoKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18zMzpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRXh0ZXJuYWxDb25zdGFudFRlcm1Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0O1xuXHQgICAgICAgICAgICB0aGlzLmV4dGVybmFsQ29uc3RhbnQoKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18yNzpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUGFyZW50aGVzaXplZFRlcm1Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1O1xuXHQgICAgICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRfXzI3KTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2O1xuXHQgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Nztcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18yOCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAocmUpIHtcblx0ICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICBcdHRocm93IHJlO1xuXHRcdCAgICB9XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2NhbGN0eDtcblx0fVxuXG5cblxuXHRsaXRlcmFsKCkge1xuXHQgICAgbGV0IGxvY2FsY3R4ID0gbmV3IExpdGVyYWxDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdCAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNiwgRkhJUlBhdGhQYXJzZXIuUlVMRV9saXRlcmFsKTtcblx0ICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXG5cdCAgICB0cnkge1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSA5OTtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdCAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNCx0aGlzLl9jdHgpO1xuXHQgICAgICAgIHN3aXRjaChsYV8pIHtcblx0ICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IE51bGxMaXRlcmFsQ29udGV4dCh0aGlzLCBsb2NhbGN0eCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MTtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18yOSk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Mjtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18zMCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBCb29sZWFuTGl0ZXJhbENvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTM7XG5cdCAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHQgICAgICAgICAgICBpZighKF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzMxIHx8IF9sYT09PUZISVJQYXRoUGFyc2VyLlRfXzMyKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBTdHJpbmdMaXRlcmFsQ29udGV4dCh0aGlzLCBsb2NhbGN0eCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NDtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5TVFJJTkcpO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTnVtYmVyTGl0ZXJhbENvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDQpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTU7XG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuTlVNQkVSKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IERhdGVUaW1lTGl0ZXJhbENvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTY7XG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuREFURVRJTUUpO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgVGltZUxpdGVyYWxDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA2KTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk3O1xuXHQgICAgICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRJTUUpO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUXVhbnRpdHlMaXRlcmFsQ29udGV4dCh0aGlzLCBsb2NhbGN0eCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNyk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODtcblx0ICAgICAgICAgICAgdGhpcy5xdWFudGl0eSgpO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0ZXh0ZXJuYWxDb25zdGFudCgpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBFeHRlcm5hbENvbnN0YW50Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDgsIEZISVJQYXRoUGFyc2VyLlJVTEVfZXh0ZXJuYWxDb25zdGFudCk7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTtcblx0ICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRfXzMzKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTA0O1xuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzE1OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMTY6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX18yMTpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzIyOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuSURFTlRJRklFUjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLkRFTElNSVRFRElERU5USUZJRVI6XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDI7XG5cdCAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlNUUklORzpcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMztcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5TVFJJTkcpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0aW52b2NhdGlvbigpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBJbnZvY2F0aW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEwLCBGSElSUGF0aFBhcnNlci5SVUxFX2ludm9jYXRpb24pO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTExO1xuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw2LHRoaXMuX2N0eCk7XG5cdCAgICAgICAgc3dpdGNoKGxhXykge1xuXHQgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTWVtYmVySW52b2NhdGlvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA2O1xuXHQgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEZ1bmN0aW9uSW52b2NhdGlvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA3O1xuXHQgICAgICAgICAgICB0aGlzLmZ1bmN0bigpO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgVGhpc0ludm9jYXRpb25Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18zNCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBJbmRleEludm9jYXRpb25Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18zNSk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBUb3RhbEludm9jYXRpb25Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcblx0ICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA1KTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMDtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18zNik7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAocmUpIHtcblx0ICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICBcdHRocm93IHJlO1xuXHRcdCAgICB9XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2NhbGN0eDtcblx0fVxuXG5cblxuXHRmdW5jdG4oKSB7XG5cdCAgICBsZXQgbG9jYWxjdHggPSBuZXcgRnVuY3RuQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEyLCBGSElSUGF0aFBhcnNlci5SVUxFX2Z1bmN0bik7XG5cdCAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAxMTM7XG5cdCAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDtcblx0ICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlRfXzI3KTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTE2O1xuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgRkhJUlBhdGhQYXJzZXIuVF9fMykgfCAoMSA8PCBGSElSUGF0aFBhcnNlci5UX180KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzE1KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzE2KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzIxKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzIyKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzI3KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzI5KSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fMzEgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzMyIC0gMzIpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX18zMyAtIDMyKSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fMzQgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzM1IC0gMzIpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX18zNiAtIDMyKSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuREFURVRJTUUgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRJTUUgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLklERU5USUZJRVIgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLkRFTElNSVRFRElERU5USUZJRVIgLSAzMikpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlNUUklORyAtIDMyKSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuTlVNQkVSIC0gMzIpKSkpICE9PSAwKSkge1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE1O1xuXHQgICAgICAgICAgICB0aGlzLnBhcmFtTGlzdCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAxMTg7XG5cdCAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18yOCk7XG5cdCAgICB9IGNhdGNoIChyZSkge1xuXHQgICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuXHRcdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgIFx0dGhyb3cgcmU7XG5cdFx0ICAgIH1cblx0ICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvY2FsY3R4O1xuXHR9XG5cblxuXG5cdHBhcmFtTGlzdCgpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBQYXJhbUxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdCAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTQsIEZISVJQYXRoUGFyc2VyLlJVTEVfcGFyYW1MaXN0KTtcblx0ICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXG5cdCAgICB0cnkge1xuXHQgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMDtcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNTtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdCAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdCAgICAgICAgd2hpbGUoX2xhPT09RkhJUlBhdGhQYXJzZXIuVF9fMzcpIHtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTtcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaChGSElSUGF0aFBhcnNlci5UX18zNyk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjI7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNztcblx0ICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHQgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGNhdGNoIChyZSkge1xuXHQgICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuXHRcdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgIFx0dGhyb3cgcmU7XG5cdFx0ICAgIH1cblx0ICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvY2FsY3R4O1xuXHR9XG5cblxuXG5cdHF1YW50aXR5KCkge1xuXHQgICAgbGV0IGxvY2FsY3R4ID0gbmV3IFF1YW50aXR5Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDE2LCBGSElSUGF0aFBhcnNlci5SVUxFX3F1YW50aXR5KTtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTI4O1xuXHQgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuTlVNQkVSKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTMwO1xuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw5LHRoaXMuX2N0eCk7XG5cdCAgICAgICAgaWYobGFfPT09MSkge1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI5O1xuXHQgICAgICAgICAgICB0aGlzLnVuaXQoKTtcblxuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0dW5pdCgpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBVbml0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDE4LCBGSElSUGF0aFBhcnNlci5SVUxFX3VuaXQpO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTM1O1xuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzM4OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fMzk6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX180MDpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzQxOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fNDI6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX180Mzpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzQ0OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fNDU6XG5cdCAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMzI7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0ZVRpbWVQcmVjaXNpb24oKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX180Njpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzQ3OlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fNDg6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX180OTpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzUwOlxuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuVF9fNTE6XG5cdCAgICAgICAgY2FzZSBGSElSUGF0aFBhcnNlci5UX181Mjpcblx0ICAgICAgICBjYXNlIEZISVJQYXRoUGFyc2VyLlRfXzUzOlxuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTMzO1xuXHQgICAgICAgICAgICB0aGlzLnBsdXJhbERhdGVUaW1lUHJlY2lzaW9uKCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgRkhJUlBhdGhQYXJzZXIuU1RSSU5HOlxuXHQgICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTM0O1xuXHQgICAgICAgICAgICB0aGlzLm1hdGNoKEZISVJQYXRoUGFyc2VyLlNUUklORyk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAocmUpIHtcblx0ICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICBcdHRocm93IHJlO1xuXHRcdCAgICB9XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2NhbGN0eDtcblx0fVxuXG5cblxuXHRkYXRlVGltZVByZWNpc2lvbigpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBEYXRlVGltZVByZWNpc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0ICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAyMCwgRkhJUlBhdGhQYXJzZXIuUlVMRV9kYXRlVGltZVByZWNpc2lvbik7XG5cdCAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAxMzc7XG5cdCAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdCAgICAgICAgaWYoISgoKCgoX2xhIC0gMzkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzkpKSAmICgoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fMzggLSAzOSkpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzM5IC0gMzkpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX180MCAtIDM5KSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fNDEgLSAzOSkpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzQyIC0gMzkpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX180MyAtIDM5KSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fNDQgLSAzOSkpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzQ1IC0gMzkpKSkpICE9PSAwKSkpIHtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAocmUpIHtcblx0ICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICBcdHRocm93IHJlO1xuXHRcdCAgICB9XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2NhbGN0eDtcblx0fVxuXG5cblxuXHRwbHVyYWxEYXRlVGltZVByZWNpc2lvbigpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBQbHVyYWxEYXRlVGltZVByZWNpc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0ICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAyMiwgRkhJUlBhdGhQYXJzZXIuUlVMRV9wbHVyYWxEYXRlVGltZVByZWNpc2lvbik7XG5cdCAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAxMzk7XG5cdCAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdCAgICAgICAgaWYoISgoKCgoX2xhIC0gNDcpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNDcpKSAmICgoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fNDYgLSA0NykpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzQ3IC0gNDcpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX180OCAtIDQ3KSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fNDkgLSA0NykpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzUwIC0gNDcpKSB8ICgxIDw8IChGSElSUGF0aFBhcnNlci5UX181MSAtIDQ3KSkgfCAoMSA8PCAoRkhJUlBhdGhQYXJzZXIuVF9fNTIgLSA0NykpIHwgKDEgPDwgKEZISVJQYXRoUGFyc2VyLlRfXzUzIC0gNDcpKSkpICE9PSAwKSkpIHtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAocmUpIHtcblx0ICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICBcdHRocm93IHJlO1xuXHRcdCAgICB9XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2NhbGN0eDtcblx0fVxuXG5cblxuXHR0eXBlU3BlY2lmaWVyKCkge1xuXHQgICAgbGV0IGxvY2FsY3R4ID0gbmV3IFR5cGVTcGVjaWZpZXJDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdCAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMjQsIEZISVJQYXRoUGFyc2VyLlJVTEVfdHlwZVNwZWNpZmllcik7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDE0MTtcblx0ICAgICAgICB0aGlzLnF1YWxpZmllZElkZW50aWZpZXIoKTtcblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0cXVhbGlmaWVkSWRlbnRpZmllcigpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBRdWFsaWZpZWRJZGVudGlmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDI2LCBGSElSUGF0aFBhcnNlci5SVUxFX3F1YWxpZmllZElkZW50aWZpZXIpO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSAxNDM7XG5cdCAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IDE0ODtcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdCAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDExLHRoaXMuX2N0eClcblx0ICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuXHQgICAgICAgICAgICBpZihfYWx0PT09MSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE0NDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goRkhJUlBhdGhQYXJzZXIuVF9fMCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTQ1O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7IFxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNTA7XG5cdCAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0ICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTEsdGhpcy5fY3R4KTtcblx0ICAgICAgICB9XG5cblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG5cblx0aWRlbnRpZmllcigpIHtcblx0ICAgIGxldCBsb2NhbGN0eCA9IG5ldyBJZGVudGlmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHQgICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDI4LCBGSElSUGF0aFBhcnNlci5SVUxFX2lkZW50aWZpZXIpO1xuXHQgICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gMTUxO1xuXHQgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHQgICAgICAgIGlmKCEoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzE1KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzE2KSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzIxKSB8ICgxIDw8IEZISVJQYXRoUGFyc2VyLlRfXzIyKSkpICE9PSAwKSB8fCBfbGE9PT1GSElSUGF0aFBhcnNlci5JREVOVElGSUVSIHx8IF9sYT09PUZISVJQYXRoUGFyc2VyLkRFTElNSVRFRElERU5USUZJRVIpKSB7XG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKHJlKSB7XG5cdCAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgXHR0aHJvdyByZTtcblx0XHQgICAgfVxuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9jYWxjdHg7XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLkVPRiA9IGFudGxyNC5Ub2tlbi5FT0Y7XG5GSElSUGF0aFBhcnNlci5UX18wID0gMTtcbkZISVJQYXRoUGFyc2VyLlRfXzEgPSAyO1xuRkhJUlBhdGhQYXJzZXIuVF9fMiA9IDM7XG5GSElSUGF0aFBhcnNlci5UX18zID0gNDtcbkZISVJQYXRoUGFyc2VyLlRfXzQgPSA1O1xuRkhJUlBhdGhQYXJzZXIuVF9fNSA9IDY7XG5GSElSUGF0aFBhcnNlci5UX182ID0gNztcbkZISVJQYXRoUGFyc2VyLlRfXzcgPSA4O1xuRkhJUlBhdGhQYXJzZXIuVF9fOCA9IDk7XG5GSElSUGF0aFBhcnNlci5UX185ID0gMTA7XG5GSElSUGF0aFBhcnNlci5UX18xMCA9IDExO1xuRkhJUlBhdGhQYXJzZXIuVF9fMTEgPSAxMjtcbkZISVJQYXRoUGFyc2VyLlRfXzEyID0gMTM7XG5GSElSUGF0aFBhcnNlci5UX18xMyA9IDE0O1xuRkhJUlBhdGhQYXJzZXIuVF9fMTQgPSAxNTtcbkZISVJQYXRoUGFyc2VyLlRfXzE1ID0gMTY7XG5GSElSUGF0aFBhcnNlci5UX18xNiA9IDE3O1xuRkhJUlBhdGhQYXJzZXIuVF9fMTcgPSAxODtcbkZISVJQYXRoUGFyc2VyLlRfXzE4ID0gMTk7XG5GSElSUGF0aFBhcnNlci5UX18xOSA9IDIwO1xuRkhJUlBhdGhQYXJzZXIuVF9fMjAgPSAyMTtcbkZISVJQYXRoUGFyc2VyLlRfXzIxID0gMjI7XG5GSElSUGF0aFBhcnNlci5UX18yMiA9IDIzO1xuRkhJUlBhdGhQYXJzZXIuVF9fMjMgPSAyNDtcbkZISVJQYXRoUGFyc2VyLlRfXzI0ID0gMjU7XG5GSElSUGF0aFBhcnNlci5UX18yNSA9IDI2O1xuRkhJUlBhdGhQYXJzZXIuVF9fMjYgPSAyNztcbkZISVJQYXRoUGFyc2VyLlRfXzI3ID0gMjg7XG5GSElSUGF0aFBhcnNlci5UX18yOCA9IDI5O1xuRkhJUlBhdGhQYXJzZXIuVF9fMjkgPSAzMDtcbkZISVJQYXRoUGFyc2VyLlRfXzMwID0gMzE7XG5GSElSUGF0aFBhcnNlci5UX18zMSA9IDMyO1xuRkhJUlBhdGhQYXJzZXIuVF9fMzIgPSAzMztcbkZISVJQYXRoUGFyc2VyLlRfXzMzID0gMzQ7XG5GSElSUGF0aFBhcnNlci5UX18zNCA9IDM1O1xuRkhJUlBhdGhQYXJzZXIuVF9fMzUgPSAzNjtcbkZISVJQYXRoUGFyc2VyLlRfXzM2ID0gMzc7XG5GSElSUGF0aFBhcnNlci5UX18zNyA9IDM4O1xuRkhJUlBhdGhQYXJzZXIuVF9fMzggPSAzOTtcbkZISVJQYXRoUGFyc2VyLlRfXzM5ID0gNDA7XG5GSElSUGF0aFBhcnNlci5UX180MCA9IDQxO1xuRkhJUlBhdGhQYXJzZXIuVF9fNDEgPSA0MjtcbkZISVJQYXRoUGFyc2VyLlRfXzQyID0gNDM7XG5GSElSUGF0aFBhcnNlci5UX180MyA9IDQ0O1xuRkhJUlBhdGhQYXJzZXIuVF9fNDQgPSA0NTtcbkZISVJQYXRoUGFyc2VyLlRfXzQ1ID0gNDY7XG5GSElSUGF0aFBhcnNlci5UX180NiA9IDQ3O1xuRkhJUlBhdGhQYXJzZXIuVF9fNDcgPSA0ODtcbkZISVJQYXRoUGFyc2VyLlRfXzQ4ID0gNDk7XG5GSElSUGF0aFBhcnNlci5UX180OSA9IDUwO1xuRkhJUlBhdGhQYXJzZXIuVF9fNTAgPSA1MTtcbkZISVJQYXRoUGFyc2VyLlRfXzUxID0gNTI7XG5GSElSUGF0aFBhcnNlci5UX181MiA9IDUzO1xuRkhJUlBhdGhQYXJzZXIuVF9fNTMgPSA1NDtcbkZISVJQYXRoUGFyc2VyLkRBVEVUSU1FID0gNTU7XG5GSElSUGF0aFBhcnNlci5USU1FID0gNTY7XG5GSElSUGF0aFBhcnNlci5JREVOVElGSUVSID0gNTc7XG5GSElSUGF0aFBhcnNlci5ERUxJTUlURURJREVOVElGSUVSID0gNTg7XG5GSElSUGF0aFBhcnNlci5TVFJJTkcgPSA1OTtcbkZISVJQYXRoUGFyc2VyLk5VTUJFUiA9IDYwO1xuRkhJUlBhdGhQYXJzZXIuV1MgPSA2MTtcbkZISVJQYXRoUGFyc2VyLkNPTU1FTlQgPSA2MjtcbkZISVJQYXRoUGFyc2VyLkxJTkVfQ09NTUVOVCA9IDYzO1xuXG5GSElSUGF0aFBhcnNlci5SVUxFX2VudGlyZUV4cHJlc3Npb24gPSAwO1xuRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uID0gMTtcbkZISVJQYXRoUGFyc2VyLlJVTEVfdGVybSA9IDI7XG5GSElSUGF0aFBhcnNlci5SVUxFX2xpdGVyYWwgPSAzO1xuRkhJUlBhdGhQYXJzZXIuUlVMRV9leHRlcm5hbENvbnN0YW50ID0gNDtcbkZISVJQYXRoUGFyc2VyLlJVTEVfaW52b2NhdGlvbiA9IDU7XG5GSElSUGF0aFBhcnNlci5SVUxFX2Z1bmN0biA9IDY7XG5GSElSUGF0aFBhcnNlci5SVUxFX3BhcmFtTGlzdCA9IDc7XG5GSElSUGF0aFBhcnNlci5SVUxFX3F1YW50aXR5ID0gODtcbkZISVJQYXRoUGFyc2VyLlJVTEVfdW5pdCA9IDk7XG5GSElSUGF0aFBhcnNlci5SVUxFX2RhdGVUaW1lUHJlY2lzaW9uID0gMTA7XG5GSElSUGF0aFBhcnNlci5SVUxFX3BsdXJhbERhdGVUaW1lUHJlY2lzaW9uID0gMTE7XG5GSElSUGF0aFBhcnNlci5SVUxFX3R5cGVTcGVjaWZpZXIgPSAxMjtcbkZISVJQYXRoUGFyc2VyLlJVTEVfcXVhbGlmaWVkSWRlbnRpZmllciA9IDEzO1xuRkhJUlBhdGhQYXJzZXIuUlVMRV9pZGVudGlmaWVyID0gMTQ7XG5cbmNsYXNzIEVudGlyZUV4cHJlc3Npb25Db250ZXh0IGV4dGVuZHMgYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgICAgIGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XG4gICAgICAgICAgICBpbnZva2luZ1N0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucnVsZUluZGV4ID0gRkhJUlBhdGhQYXJzZXIuUlVMRV9lbnRpcmVFeHByZXNzaW9uO1xuICAgIH1cblxuXHRleHByZXNzaW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcblx0fTtcblxuXHRFT0YoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihGSElSUGF0aFBhcnNlci5FT0YsIDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyRW50aXJlRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRFbnRpcmVFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuXG5cbmNsYXNzIEV4cHJlc3Npb25Db250ZXh0IGV4dGVuZHMgYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgICAgIGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XG4gICAgICAgICAgICBpbnZva2luZ1N0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucnVsZUluZGV4ID0gRkhJUlBhdGhQYXJzZXIuUlVMRV9leHByZXNzaW9uO1xuICAgIH1cblxuXG5cdCBcblx0XHRjb3B5RnJvbShjdHgpIHtcblx0XHRcdHN1cGVyLmNvcHlGcm9tKGN0eCk7XG5cdFx0fVxuXG59XG5cblxuY2xhc3MgSW5kZXhlckV4cHJlc3Npb25Db250ZXh0IGV4dGVuZHMgRXhwcmVzc2lvbkNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBjdHgpIHtcbiAgICAgICAgc3VwZXIocGFyc2VyKTtcbiAgICAgICAgc3VwZXIuY29weUZyb20oY3R4KTtcbiAgICB9XG5cblx0ZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcblx0ICAgIGlmKGk9PT11bmRlZmluZWQpIHtcblx0ICAgICAgICBpID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmKGk9PT1udWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LGkpO1xuXHQgICAgfVxuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVySW5kZXhlckV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0SW5kZXhlckV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5JbmRleGVyRXhwcmVzc2lvbkNvbnRleHQgPSBJbmRleGVyRXhwcmVzc2lvbkNvbnRleHQ7XG5cbmNsYXNzIFBvbGFyaXR5RXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRleHByZXNzaW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlclBvbGFyaXR5RXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRQb2xhcml0eUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5Qb2xhcml0eUV4cHJlc3Npb25Db250ZXh0ID0gUG9sYXJpdHlFeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XG5cdCAgICBpZihpPT09dW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZihpPT09bnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcblx0ICAgIH1cblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlckFkZGl0aXZlRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRBZGRpdGl2ZUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5BZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0ID0gQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XG5cdCAgICBpZihpPT09dW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZihpPT09bnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcblx0ICAgIH1cblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlck11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5NdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0ID0gTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgVW5pb25FeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XG5cdCAgICBpZihpPT09dW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZihpPT09bnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcblx0ICAgIH1cblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlclVuaW9uRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRVbmlvbkV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5VbmlvbkV4cHJlc3Npb25Db250ZXh0ID0gVW5pb25FeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgT3JFeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XG5cdCAgICBpZihpPT09dW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZihpPT09bnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcblx0ICAgIH1cblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlck9yRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRPckV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5PckV4cHJlc3Npb25Db250ZXh0ID0gT3JFeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgQW5kRXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRleHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xuXHQgICAgaWYoaT09PXVuZGVmaW5lZCkge1xuXHQgICAgICAgIGkgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYoaT09PW51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XG5cdCAgICB9XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJBbmRFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdEFuZEV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5BbmRFeHByZXNzaW9uQ29udGV4dCA9IEFuZEV4cHJlc3Npb25Db250ZXh0O1xuXG5jbGFzcyBNZW1iZXJzaGlwRXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRleHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xuXHQgICAgaWYoaT09PXVuZGVmaW5lZCkge1xuXHQgICAgICAgIGkgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYoaT09PW51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XG5cdCAgICB9XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJNZW1iZXJzaGlwRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRNZW1iZXJzaGlwRXhwcmVzc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLk1lbWJlcnNoaXBFeHByZXNzaW9uQ29udGV4dCA9IE1lbWJlcnNoaXBFeHByZXNzaW9uQ29udGV4dDtcblxuY2xhc3MgSW5lcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0IGV4dGVuZHMgRXhwcmVzc2lvbkNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBjdHgpIHtcbiAgICAgICAgc3VwZXIocGFyc2VyKTtcbiAgICAgICAgc3VwZXIuY29weUZyb20oY3R4KTtcbiAgICB9XG5cblx0ZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcblx0ICAgIGlmKGk9PT11bmRlZmluZWQpIHtcblx0ICAgICAgICBpID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmKGk9PT1udWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LGkpO1xuXHQgICAgfVxuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVySW5lcXVhbGl0eUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0SW5lcXVhbGl0eUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5JbmVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQgPSBJbmVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQ7XG5cbmNsYXNzIEludm9jYXRpb25FeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xuXHR9O1xuXG5cdGludm9jYXRpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEludm9jYXRpb25Db250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVySW52b2NhdGlvbkV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0SW52b2NhdGlvbkV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5JbnZvY2F0aW9uRXhwcmVzc2lvbkNvbnRleHQgPSBJbnZvY2F0aW9uRXhwcmVzc2lvbkNvbnRleHQ7XG5cbmNsYXNzIEVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRleHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xuXHQgICAgaWYoaT09PXVuZGVmaW5lZCkge1xuXHQgICAgICAgIGkgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYoaT09PW51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XG5cdCAgICB9XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJFcXVhbGl0eUV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0RXF1YWxpdHlFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuRkhJUlBhdGhQYXJzZXIuRXF1YWxpdHlFeHByZXNzaW9uQ29udGV4dCA9IEVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQ7XG5cbmNsYXNzIEltcGxpZXNFeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIEV4cHJlc3Npb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XG5cdCAgICBpZihpPT09dW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZihpPT09bnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcblx0ICAgIH1cblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlckltcGxpZXNFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdEltcGxpZXNFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuRkhJUlBhdGhQYXJzZXIuSW1wbGllc0V4cHJlc3Npb25Db250ZXh0ID0gSW1wbGllc0V4cHJlc3Npb25Db250ZXh0O1xuXG5jbGFzcyBUZXJtRXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHR0ZXJtKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUZXJtQ29udGV4dCwwKTtcblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlclRlcm1FeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFRlcm1FeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuRkhJUlBhdGhQYXJzZXIuVGVybUV4cHJlc3Npb25Db250ZXh0ID0gVGVybUV4cHJlc3Npb25Db250ZXh0O1xuXG5jbGFzcyBUeXBlRXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBFeHByZXNzaW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRleHByZXNzaW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcblx0fTtcblxuXHR0eXBlU3BlY2lmaWVyKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUeXBlU3BlY2lmaWVyQ29udGV4dCwwKTtcblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlclR5cGVFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFR5cGVFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuRkhJUlBhdGhQYXJzZXIuVHlwZUV4cHJlc3Npb25Db250ZXh0ID0gVHlwZUV4cHJlc3Npb25Db250ZXh0O1xuXG5jbGFzcyBUZXJtQ29udGV4dCBleHRlbmRzIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgICBpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xuICAgICAgICAgICAgaW52b2tpbmdTdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IEZISVJQYXRoUGFyc2VyLlJVTEVfdGVybTtcbiAgICB9XG5cblxuXHQgXG5cdFx0Y29weUZyb20oY3R4KSB7XG5cdFx0XHRzdXBlci5jb3B5RnJvbShjdHgpO1xuXHRcdH1cblxufVxuXG5cbmNsYXNzIEV4dGVybmFsQ29uc3RhbnRUZXJtQ29udGV4dCBleHRlbmRzIFRlcm1Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4dGVybmFsQ29uc3RhbnQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4dGVybmFsQ29uc3RhbnRDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyRXh0ZXJuYWxDb25zdGFudFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0RXh0ZXJuYWxDb25zdGFudFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5FeHRlcm5hbENvbnN0YW50VGVybUNvbnRleHQgPSBFeHRlcm5hbENvbnN0YW50VGVybUNvbnRleHQ7XG5cbmNsYXNzIExpdGVyYWxUZXJtQ29udGV4dCBleHRlbmRzIFRlcm1Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGxpdGVyYWwoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KExpdGVyYWxDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyTGl0ZXJhbFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0TGl0ZXJhbFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5MaXRlcmFsVGVybUNvbnRleHQgPSBMaXRlcmFsVGVybUNvbnRleHQ7XG5cbmNsYXNzIFBhcmVudGhlc2l6ZWRUZXJtQ29udGV4dCBleHRlbmRzIFRlcm1Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGV4cHJlc3Npb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyUGFyZW50aGVzaXplZFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0UGFyZW50aGVzaXplZFRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5QYXJlbnRoZXNpemVkVGVybUNvbnRleHQgPSBQYXJlbnRoZXNpemVkVGVybUNvbnRleHQ7XG5cbmNsYXNzIEludm9jYXRpb25UZXJtQ29udGV4dCBleHRlbmRzIFRlcm1Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGludm9jYXRpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEludm9jYXRpb25Db250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVySW52b2NhdGlvblRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0SW52b2NhdGlvblRlcm0odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5JbnZvY2F0aW9uVGVybUNvbnRleHQgPSBJbnZvY2F0aW9uVGVybUNvbnRleHQ7XG5cbmNsYXNzIExpdGVyYWxDb250ZXh0IGV4dGVuZHMgYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgICAgIGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XG4gICAgICAgICAgICBpbnZva2luZ1N0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucnVsZUluZGV4ID0gRkhJUlBhdGhQYXJzZXIuUlVMRV9saXRlcmFsO1xuICAgIH1cblxuXG5cdCBcblx0XHRjb3B5RnJvbShjdHgpIHtcblx0XHRcdHN1cGVyLmNvcHlGcm9tKGN0eCk7XG5cdFx0fVxuXG59XG5cblxuY2xhc3MgVGltZUxpdGVyYWxDb250ZXh0IGV4dGVuZHMgTGl0ZXJhbENvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBjdHgpIHtcbiAgICAgICAgc3VwZXIocGFyc2VyKTtcbiAgICAgICAgc3VwZXIuY29weUZyb20oY3R4KTtcbiAgICB9XG5cblx0VElNRSgpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldFRva2VuKEZISVJQYXRoUGFyc2VyLlRJTUUsIDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyVGltZUxpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0VGltZUxpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5UaW1lTGl0ZXJhbENvbnRleHQgPSBUaW1lTGl0ZXJhbENvbnRleHQ7XG5cbmNsYXNzIE51bGxMaXRlcmFsQ29udGV4dCBleHRlbmRzIExpdGVyYWxDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJOdWxsTGl0ZXJhbCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXROdWxsTGl0ZXJhbCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLk51bGxMaXRlcmFsQ29udGV4dCA9IE51bGxMaXRlcmFsQ29udGV4dDtcblxuY2xhc3MgRGF0ZVRpbWVMaXRlcmFsQ29udGV4dCBleHRlbmRzIExpdGVyYWxDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdERBVEVUSU1FKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oRkhJUlBhdGhQYXJzZXIuREFURVRJTUUsIDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyRGF0ZVRpbWVMaXRlcmFsKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdERhdGVUaW1lTGl0ZXJhbCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLkRhdGVUaW1lTGl0ZXJhbENvbnRleHQgPSBEYXRlVGltZUxpdGVyYWxDb250ZXh0O1xuXG5jbGFzcyBTdHJpbmdMaXRlcmFsQ29udGV4dCBleHRlbmRzIExpdGVyYWxDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdFNUUklORygpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldFRva2VuKEZISVJQYXRoUGFyc2VyLlNUUklORywgMCk7XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJTdHJpbmdMaXRlcmFsKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFN0cmluZ0xpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5TdHJpbmdMaXRlcmFsQ29udGV4dCA9IFN0cmluZ0xpdGVyYWxDb250ZXh0O1xuXG5jbGFzcyBCb29sZWFuTGl0ZXJhbENvbnRleHQgZXh0ZW5kcyBMaXRlcmFsQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyQm9vbGVhbkxpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0Qm9vbGVhbkxpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5Cb29sZWFuTGl0ZXJhbENvbnRleHQgPSBCb29sZWFuTGl0ZXJhbENvbnRleHQ7XG5cbmNsYXNzIE51bWJlckxpdGVyYWxDb250ZXh0IGV4dGVuZHMgTGl0ZXJhbENvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBjdHgpIHtcbiAgICAgICAgc3VwZXIocGFyc2VyKTtcbiAgICAgICAgc3VwZXIuY29weUZyb20oY3R4KTtcbiAgICB9XG5cblx0TlVNQkVSKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oRkhJUlBhdGhQYXJzZXIuTlVNQkVSLCAwKTtcblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlck51bWJlckxpdGVyYWwodGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0TnVtYmVyTGl0ZXJhbCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLk51bWJlckxpdGVyYWxDb250ZXh0ID0gTnVtYmVyTGl0ZXJhbENvbnRleHQ7XG5cbmNsYXNzIFF1YW50aXR5TGl0ZXJhbENvbnRleHQgZXh0ZW5kcyBMaXRlcmFsQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXHRxdWFudGl0eSgpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUXVhbnRpdHlDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyUXVhbnRpdHlMaXRlcmFsKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFF1YW50aXR5TGl0ZXJhbCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLlF1YW50aXR5TGl0ZXJhbENvbnRleHQgPSBRdWFudGl0eUxpdGVyYWxDb250ZXh0O1xuXG5jbGFzcyBFeHRlcm5hbENvbnN0YW50Q29udGV4dCBleHRlbmRzIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgICBpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xuICAgICAgICAgICAgaW52b2tpbmdTdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IEZISVJQYXRoUGFyc2VyLlJVTEVfZXh0ZXJuYWxDb25zdGFudDtcbiAgICB9XG5cblx0aWRlbnRpZmllcigpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSWRlbnRpZmllckNvbnRleHQsMCk7XG5cdH07XG5cblx0U1RSSU5HKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oRkhJUlBhdGhQYXJzZXIuU1RSSU5HLCAwKTtcblx0fTtcblxuXHRlbnRlclJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5lbnRlckV4dGVybmFsQ29uc3RhbnQodGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0RXh0ZXJuYWxDb25zdGFudCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cblxuXG5jbGFzcyBJbnZvY2F0aW9uQ29udGV4dCBleHRlbmRzIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgICBpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xuICAgICAgICAgICAgaW52b2tpbmdTdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IEZISVJQYXRoUGFyc2VyLlJVTEVfaW52b2NhdGlvbjtcbiAgICB9XG5cblxuXHQgXG5cdFx0Y29weUZyb20oY3R4KSB7XG5cdFx0XHRzdXBlci5jb3B5RnJvbShjdHgpO1xuXHRcdH1cblxufVxuXG5cbmNsYXNzIFRvdGFsSW52b2NhdGlvbkNvbnRleHQgZXh0ZW5kcyBJbnZvY2F0aW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyVG90YWxJbnZvY2F0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFRvdGFsSW52b2NhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLlRvdGFsSW52b2NhdGlvbkNvbnRleHQgPSBUb3RhbEludm9jYXRpb25Db250ZXh0O1xuXG5jbGFzcyBUaGlzSW52b2NhdGlvbkNvbnRleHQgZXh0ZW5kcyBJbnZvY2F0aW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyVGhpc0ludm9jYXRpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0VGhpc0ludm9jYXRpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5GSElSUGF0aFBhcnNlci5UaGlzSW52b2NhdGlvbkNvbnRleHQgPSBUaGlzSW52b2NhdGlvbkNvbnRleHQ7XG5cbmNsYXNzIEluZGV4SW52b2NhdGlvbkNvbnRleHQgZXh0ZW5kcyBJbnZvY2F0aW9uQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGN0eCkge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICBzdXBlci5jb3B5RnJvbShjdHgpO1xuICAgIH1cblxuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVySW5kZXhJbnZvY2F0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdEluZGV4SW52b2NhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLkluZGV4SW52b2NhdGlvbkNvbnRleHQgPSBJbmRleEludm9jYXRpb25Db250ZXh0O1xuXG5jbGFzcyBGdW5jdGlvbkludm9jYXRpb25Db250ZXh0IGV4dGVuZHMgSW52b2NhdGlvbkNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBjdHgpIHtcbiAgICAgICAgc3VwZXIocGFyc2VyKTtcbiAgICAgICAgc3VwZXIuY29weUZyb20oY3R4KTtcbiAgICB9XG5cblx0ZnVuY3RuKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChGdW5jdG5Db250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyRnVuY3Rpb25JbnZvY2F0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdEZ1bmN0aW9uSW52b2NhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cbkZISVJQYXRoUGFyc2VyLkZ1bmN0aW9uSW52b2NhdGlvbkNvbnRleHQgPSBGdW5jdGlvbkludm9jYXRpb25Db250ZXh0O1xuXG5jbGFzcyBNZW1iZXJJbnZvY2F0aW9uQ29udGV4dCBleHRlbmRzIEludm9jYXRpb25Db250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgY3R4KSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHN1cGVyLmNvcHlGcm9tKGN0eCk7XG4gICAgfVxuXG5cdGlkZW50aWZpZXIoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KElkZW50aWZpZXJDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyTWVtYmVySW52b2NhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRNZW1iZXJJbnZvY2F0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuRkhJUlBhdGhQYXJzZXIuTWVtYmVySW52b2NhdGlvbkNvbnRleHQgPSBNZW1iZXJJbnZvY2F0aW9uQ29udGV4dDtcblxuY2xhc3MgRnVuY3RuQ29udGV4dCBleHRlbmRzIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgICBpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xuICAgICAgICAgICAgaW52b2tpbmdTdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IEZISVJQYXRoUGFyc2VyLlJVTEVfZnVuY3RuO1xuICAgIH1cblxuXHRpZGVudGlmaWVyKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJZGVudGlmaWVyQ29udGV4dCwwKTtcblx0fTtcblxuXHRwYXJhbUxpc3QoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFBhcmFtTGlzdENvbnRleHQsMCk7XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJGdW5jdG4odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0RnVuY3RuKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuXG5cbmNsYXNzIFBhcmFtTGlzdENvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX3BhcmFtTGlzdDtcbiAgICB9XG5cblx0ZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcblx0ICAgIGlmKGk9PT11bmRlZmluZWQpIHtcblx0ICAgICAgICBpID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmKGk9PT1udWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LGkpO1xuXHQgICAgfVxuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyUGFyYW1MaXN0KHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFBhcmFtTGlzdCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cblxuXG5jbGFzcyBRdWFudGl0eUNvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX3F1YW50aXR5O1xuICAgIH1cblxuXHROVU1CRVIoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihGSElSUGF0aFBhcnNlci5OVU1CRVIsIDApO1xuXHR9O1xuXG5cdHVuaXQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFVuaXRDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyUXVhbnRpdHkodGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0UXVhbnRpdHkodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5cblxuY2xhc3MgVW5pdENvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX3VuaXQ7XG4gICAgfVxuXG5cdGRhdGVUaW1lUHJlY2lzaW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEYXRlVGltZVByZWNpc2lvbkNvbnRleHQsMCk7XG5cdH07XG5cblx0cGx1cmFsRGF0ZVRpbWVQcmVjaXNpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFBsdXJhbERhdGVUaW1lUHJlY2lzaW9uQ29udGV4dCwwKTtcblx0fTtcblxuXHRTVFJJTkcoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihGSElSUGF0aFBhcnNlci5TVFJJTkcsIDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyVW5pdCh0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRVbml0KHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuXG5cbmNsYXNzIERhdGVUaW1lUHJlY2lzaW9uQ29udGV4dCBleHRlbmRzIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgICBpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xuICAgICAgICAgICAgaW52b2tpbmdTdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IEZISVJQYXRoUGFyc2VyLlJVTEVfZGF0ZVRpbWVQcmVjaXNpb247XG4gICAgfVxuXG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJEYXRlVGltZVByZWNpc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXREYXRlVGltZVByZWNpc2lvbih0aGlzKTtcblx0XHR9XG5cdH1cblxuXG59XG5cblxuXG5jbGFzcyBQbHVyYWxEYXRlVGltZVByZWNpc2lvbkNvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX3BsdXJhbERhdGVUaW1lUHJlY2lzaW9uO1xuICAgIH1cblxuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyUGx1cmFsRGF0ZVRpbWVQcmVjaXNpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZXhpdFJ1bGUobGlzdGVuZXIpIHtcblx0ICAgIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgRkhJUlBhdGhMaXN0ZW5lciApIHtcblx0ICAgICAgICBsaXN0ZW5lci5leGl0UGx1cmFsRGF0ZVRpbWVQcmVjaXNpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5cblxuY2xhc3MgVHlwZVNwZWNpZmllckNvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX3R5cGVTcGVjaWZpZXI7XG4gICAgfVxuXG5cdHF1YWxpZmllZElkZW50aWZpZXIoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFF1YWxpZmllZElkZW50aWZpZXJDb250ZXh0LDApO1xuXHR9O1xuXG5cdGVudGVyUnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmVudGVyVHlwZVNwZWNpZmllcih0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRleGl0UnVsZShsaXN0ZW5lcikge1xuXHQgICAgaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBGSElSUGF0aExpc3RlbmVyICkge1xuXHQgICAgICAgIGxpc3RlbmVyLmV4aXRUeXBlU3BlY2lmaWVyKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cbn1cblxuXG5cbmNsYXNzIFF1YWxpZmllZElkZW50aWZpZXJDb250ZXh0IGV4dGVuZHMgYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgICAgIGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XG4gICAgICAgICAgICBpbnZva2luZ1N0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucnVsZUluZGV4ID0gRkhJUlBhdGhQYXJzZXIuUlVMRV9xdWFsaWZpZWRJZGVudGlmaWVyO1xuICAgIH1cblxuXHRpZGVudGlmaWVyID0gZnVuY3Rpb24oaSkge1xuXHQgICAgaWYoaT09PXVuZGVmaW5lZCkge1xuXHQgICAgICAgIGkgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYoaT09PW51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhJZGVudGlmaWVyQ29udGV4dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSWRlbnRpZmllckNvbnRleHQsaSk7XG5cdCAgICB9XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJRdWFsaWZpZWRJZGVudGlmaWVyKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdFF1YWxpZmllZElkZW50aWZpZXIodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5cblxuY2xhc3MgSWRlbnRpZmllckNvbnRleHQgZXh0ZW5kcyBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgICAgaWYocGFyZW50PT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcbiAgICAgICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBGSElSUGF0aFBhcnNlci5SVUxFX2lkZW50aWZpZXI7XG4gICAgfVxuXG5cdElERU5USUZJRVIoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihGSElSUGF0aFBhcnNlci5JREVOVElGSUVSLCAwKTtcblx0fTtcblxuXHRERUxJTUlURURJREVOVElGSUVSKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oRkhJUlBhdGhQYXJzZXIuREVMSU1JVEVESURFTlRJRklFUiwgMCk7XG5cdH07XG5cblx0ZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZW50ZXJJZGVudGlmaWVyKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGV4aXRSdWxlKGxpc3RlbmVyKSB7XG5cdCAgICBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEZISVJQYXRoTGlzdGVuZXIgKSB7XG5cdCAgICAgICAgbGlzdGVuZXIuZXhpdElkZW50aWZpZXIodGhpcyk7XG5cdFx0fVxuXHR9XG5cblxufVxuXG5cblxuXG5GSElSUGF0aFBhcnNlci5FbnRpcmVFeHByZXNzaW9uQ29udGV4dCA9IEVudGlyZUV4cHJlc3Npb25Db250ZXh0OyBcbkZISVJQYXRoUGFyc2VyLkV4cHJlc3Npb25Db250ZXh0ID0gRXhwcmVzc2lvbkNvbnRleHQ7IFxuRkhJUlBhdGhQYXJzZXIuVGVybUNvbnRleHQgPSBUZXJtQ29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5MaXRlcmFsQ29udGV4dCA9IExpdGVyYWxDb250ZXh0OyBcbkZISVJQYXRoUGFyc2VyLkV4dGVybmFsQ29uc3RhbnRDb250ZXh0ID0gRXh0ZXJuYWxDb25zdGFudENvbnRleHQ7IFxuRkhJUlBhdGhQYXJzZXIuSW52b2NhdGlvbkNvbnRleHQgPSBJbnZvY2F0aW9uQ29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5GdW5jdG5Db250ZXh0ID0gRnVuY3RuQ29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5QYXJhbUxpc3RDb250ZXh0ID0gUGFyYW1MaXN0Q29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5RdWFudGl0eUNvbnRleHQgPSBRdWFudGl0eUNvbnRleHQ7IFxuRkhJUlBhdGhQYXJzZXIuVW5pdENvbnRleHQgPSBVbml0Q29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5EYXRlVGltZVByZWNpc2lvbkNvbnRleHQgPSBEYXRlVGltZVByZWNpc2lvbkNvbnRleHQ7IFxuRkhJUlBhdGhQYXJzZXIuUGx1cmFsRGF0ZVRpbWVQcmVjaXNpb25Db250ZXh0ID0gUGx1cmFsRGF0ZVRpbWVQcmVjaXNpb25Db250ZXh0OyBcbkZISVJQYXRoUGFyc2VyLlR5cGVTcGVjaWZpZXJDb250ZXh0ID0gVHlwZVNwZWNpZmllckNvbnRleHQ7IFxuRkhJUlBhdGhQYXJzZXIuUXVhbGlmaWVkSWRlbnRpZmllckNvbnRleHQgPSBRdWFsaWZpZWRJZGVudGlmaWVyQ29udGV4dDsgXG5GSElSUGF0aFBhcnNlci5JZGVudGlmaWVyQ29udGV4dCA9IElkZW50aWZpZXJDb250ZXh0OyBcblxubW9kdWxlLmV4cG9ydHMgPSBGSElSUGF0aFBhcnNlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathParser.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/index.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const antlr4 = __webpack_require__(/*! ./antlr4-index */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/antlr4-index.js\");\nconst Lexer = __webpack_require__(/*! ./generated/FHIRPathLexer */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js\");\nconst Parser = __webpack_require__(/*! ./generated/FHIRPathParser */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathParser.js\");\nconst Listener = __webpack_require__(/*! ./generated/FHIRPathListener */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/generated/FHIRPathListener.js\");\n\n\nclass ErrorListener extends antlr4.error.ErrorListener {\n  constructor(errors) {\n    super();\n    this.errors = errors;\n  }\n  syntaxError(rec, sym, line, col, msg, e) {\n    this.errors.push([rec, sym, line, col, msg, e]);\n  }\n}\n\nvar parse = function(path){\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n\n  var tokens  = new antlr4.CommonTokenStream(lexer);\n\n\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n\n  var tree = parser.entireExpression();\n\n  class PathListener extends Listener{\n    constructor() {\n      super();\n    }\n  }\n\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function(ctx) {\n        let parentNode = parentStack[parentStack.length - 1];\n        let nodeType = p.slice(5); // remove \"enter\"\n        node = {type: nodeType};\n        node.text = ctx.getText();\n        if (!parentNode.children)\n          parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node);\n        // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n        node.terminalNodeText = [];\n        for (let c of ctx.children) {\n          // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n          // has the original function names, so we can't rely on\n          // c.constructor.name.  It appears the TerminalNodeImpl is the only\n          // node with a \"symbol\" property, so test for that.\n          if (c.symbol)\n            node.terminalNodeText.push(c.getText());\n        }\n      };\n    }\n    else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function() {\n        parentStack.pop();\n      };\n    }\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    let errMsgs = [];\n    for (let i=0, len=errors.length; i<len; ++i) {\n      let err = errors[i];\n      let msg = \"line: \"+err[2]+\"; column: \"+ err[3]+\"; message: \"+err[4];\n      errMsgs.push(msg);\n    }\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n  return ast;\n};\n\n\nmodule.exports = {\n  parse: parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsb0hBQWdCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQywwSUFBMkI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLDRJQUE0QjtBQUNuRCxpQkFBaUIsbUJBQU8sQ0FBQyxnSkFBOEI7OztBQUd2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9wYXJzZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYW50bHI0ID0gcmVxdWlyZShcIi4vYW50bHI0LWluZGV4XCIpO1xuY29uc3QgTGV4ZXIgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvRkhJUlBhdGhMZXhlclwiKTtcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9GSElSUGF0aFBhcnNlclwiKTtcbmNvbnN0IExpc3RlbmVyID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL0ZISVJQYXRoTGlzdGVuZXJcIik7XG5cblxuY2xhc3MgRXJyb3JMaXN0ZW5lciBleHRlbmRzIGFudGxyNC5lcnJvci5FcnJvckxpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgfVxuICBzeW50YXhFcnJvcihyZWMsIHN5bSwgbGluZSwgY29sLCBtc2csIGUpIHtcbiAgICB0aGlzLmVycm9ycy5wdXNoKFtyZWMsIHN5bSwgbGluZSwgY29sLCBtc2csIGVdKTtcbiAgfVxufVxuXG52YXIgcGFyc2UgPSBmdW5jdGlvbihwYXRoKXtcbiAgdmFyIGNoYXJzID0gbmV3IGFudGxyNC5JbnB1dFN0cmVhbShwYXRoKTtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKGNoYXJzKTtcblxuICB2YXIgdG9rZW5zICA9IG5ldyBhbnRscjQuQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIpO1xuXG5cbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIodG9rZW5zKTtcbiAgcGFyc2VyLmJ1aWxkUGFyc2VUcmVlcyA9IHRydWU7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVycm9yTGlzdGVuZXIoZXJyb3JzKTtcblxuICBsZXhlci5yZW1vdmVFcnJvckxpc3RlbmVycygpO1xuICBsZXhlci5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgcGFyc2VyLnJlbW92ZUVycm9yTGlzdGVuZXJzKCk7XG4gIHBhcnNlci5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICB2YXIgdHJlZSA9IHBhcnNlci5lbnRpcmVFeHByZXNzaW9uKCk7XG5cbiAgY2xhc3MgUGF0aExpc3RlbmVyIGV4dGVuZHMgTGlzdGVuZXJ7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc3QgPSB7fTtcbiAgdmFyIG5vZGU7XG4gIHZhciBwYXJlbnRTdGFjayA9IFthc3RdO1xuICBmb3IgKGxldCBwIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKExpc3RlbmVyLnByb3RvdHlwZSkpIHtcbiAgICBpZiAocC5zdGFydHNXaXRoKFwiZW50ZXJcIikpIHtcbiAgICAgIFBhdGhMaXN0ZW5lci5wcm90b3R5cGVbcF0gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBwYXJlbnRTdGFja1twYXJlbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IG5vZGVUeXBlID0gcC5zbGljZSg1KTsgLy8gcmVtb3ZlIFwiZW50ZXJcIlxuICAgICAgICBub2RlID0ge3R5cGU6IG5vZGVUeXBlfTtcbiAgICAgICAgbm9kZS50ZXh0ID0gY3R4LmdldFRleHQoKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlLmNoaWxkcmVuKVxuICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwYXJlbnRTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAvLyBBbHNvIGNvbGxlY3QgdGhpcyBub2RlJ3MgdGVybWluYWwgbm9kZXMsIGlmIGFueS4gIFRlcm1pbmFsIG5vZGVzIGFyZVxuICAgICAgICAvLyBub3Qgd2Fsa2VkIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHRyZWUsIGJ1dCBpbmNsdWRlIHRoaW5ncyBsaWtlIFwiK1wiIGFuZFxuICAgICAgICAvLyBcIi1cIiwgd2hpY2ggd2UgbmVlZC5cbiAgICAgICAgbm9kZS50ZXJtaW5hbE5vZGVUZXh0ID0gW107XG4gICAgICAgIGZvciAobGV0IGMgb2YgY3R4LmNoaWxkcmVuKSB7XG4gICAgICAgICAgLy8gVGVzdCBmb3Igbm9kZSB0eXBlIFwiVGVybWluYWxOb2RlSW1wbFwiLiAgTWluaW1pemVkIGNvZGUgbm8gbG9uZ2VyXG4gICAgICAgICAgLy8gaGFzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBuYW1lcywgc28gd2UgY2FuJ3QgcmVseSBvblxuICAgICAgICAgIC8vIGMuY29uc3RydWN0b3IubmFtZS4gIEl0IGFwcGVhcnMgdGhlIFRlcm1pbmFsTm9kZUltcGwgaXMgdGhlIG9ubHlcbiAgICAgICAgICAvLyBub2RlIHdpdGggYSBcInN5bWJvbFwiIHByb3BlcnR5LCBzbyB0ZXN0IGZvciB0aGF0LlxuICAgICAgICAgIGlmIChjLnN5bWJvbClcbiAgICAgICAgICAgIG5vZGUudGVybWluYWxOb2RlVGV4dC5wdXNoKGMuZ2V0VGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocC5zdGFydHNXaXRoKFwiZXhpdFwiKSkge1xuICAgICAgUGF0aExpc3RlbmVyLnByb3RvdHlwZVtwXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXJlbnRTdGFjay5wb3AoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50ZXIgPSBuZXcgUGF0aExpc3RlbmVyKCk7XG4gIGFudGxyNC50cmVlLlBhcnNlVHJlZVdhbGtlci5ERUZBVUxULndhbGsocHJpbnRlciwgdHJlZSk7XG5cbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGVyck1zZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGxlbj1lcnJvcnMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBsZXQgZXJyID0gZXJyb3JzW2ldO1xuICAgICAgbGV0IG1zZyA9IFwibGluZTogXCIrZXJyWzJdK1wiOyBjb2x1bW46IFwiKyBlcnJbM10rXCI7IG1lc3NhZ2U6IFwiK2Vycls0XTtcbiAgICAgIGVyck1zZ3MucHVzaChtc2cpO1xuICAgIH1cbiAgICB2YXIgZSA9IG5ldyBFcnJvcihlcnJNc2dzLmpvaW4oXCJcXG5cIikpO1xuICAgIGUuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIGFzdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBwYXJzZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/parser/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/polyfill.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/polyfill.js ***!
  \***********************************************************************************/
/***/ (() => {

eval("// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\n\n// isInteger (not in IE)\n// From Mozilla docs\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\nif (!String.prototype.startsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function(searchString, position) {\n      position = position || 0;\n      return this.indexOf(searchString, position) === position;\n    }\n  });\n}\n\nif (!String.prototype.endsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'endsWith', {\n    value: function(searchString, position) {\n      var subjectString = this.toString();\n      if (position === undefined || position > subjectString.length) {\n        position = subjectString.length;\n      }\n      position -= searchString.length;\n      var lastIndex = subjectString.indexOf(searchString, position);\n      return lastIndex !== -1 && lastIndex === position;\n    }\n  });\n}\n\nif (!String.prototype.includes) {\n  Object.defineProperty(String.prototype, 'includes', {\n    value: function() {\n      return this.indexOf.apply(this, arguments) !== -1;\n    }\n  });\n}\n\nif (!Object.assign) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(Object, 'assign', {\n    value: function(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      return slice(arguments, 1).reduce(function (to, nextSource) {\n        Object.keys(Object(nextSource)).forEach(function (nextKey) {\n          to[nextKey] = nextSource[nextKey];\n        });\n        return to;\n      },  Object(target));\n    }\n  });\n}\n\n// Define btoa for NodeJS\nif (typeof btoa === 'undefined') {\n  global.btoa = function (str) {\n    return new Buffer.from(str, 'binary').toString('base64');\n  };\n}\n\n// Define atob for NodeJS\nif (typeof atob === 'undefined') {\n  global.atob = function (b64Encoded) {\n    return new Buffer.from(b64Encoded, 'base64').toString('binary');\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3BvbHlmaWxsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9wb2x5ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCaW5kaW5nIHRoZSBmdW5jdGlvbiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCBmb3IgY29udmVydCBBcnJheS1saWtlIG9iamVjdHMvY29sbGVjdGlvbnMgdG8gYSBuZXcgQXJyYXkuXG5jb25zdCBzbGljZSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxuLy8gaXNJbnRlZ2VyIChub3QgaW4gSUUpXG4vLyBGcm9tIE1vemlsbGEgZG9jc1xuTnVtYmVyLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICBpc0Zpbml0ZSh2YWx1ZSkgJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG5cbmlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gIC8vIEZyb20gTW96aWxsYSBkb2NzIHdpdGggbGl0dGxlIGNoYW5nZXNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pID09PSBwb3NpdGlvbjtcbiAgICB9XG4gIH0pO1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgLy8gRnJvbSBNb3ppbGxhIGRvY3Mgd2l0aCBsaXR0bGUgY2hhbmdlc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ2VuZHNXaXRoJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgc3ViamVjdFN0cmluZyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbiAgICB9XG4gIH0pO1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdpbmNsdWRlcycsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgIT09IC0xO1xuICAgIH1cbiAgfSk7XG59XG5cbmlmICghT2JqZWN0LmFzc2lnbikge1xuICAvLyBGcm9tIE1vemlsbGEgZG9jcyB3aXRoIGxpdHRsZSBjaGFuZ2VzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsaWNlKGFyZ3VtZW50cywgMSkucmVkdWNlKGZ1bmN0aW9uICh0bywgbmV4dFNvdXJjZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKG5leHRLZXkpIHtcbiAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgICB9LCAgT2JqZWN0KHRhcmdldCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIERlZmluZSBidG9hIGZvciBOb2RlSlNcbmlmICh0eXBlb2YgYnRvYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsLmJ0b2EgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIuZnJvbShzdHIsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH07XG59XG5cbi8vIERlZmluZSBhdG9iIGZvciBOb2RlSlNcbmlmICh0eXBlb2YgYXRvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsLmF0b2IgPSBmdW5jdGlvbiAoYjY0RW5jb2RlZCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyLmZyb20oYjY0RW5jb2RlZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/polyfill.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/sdc-ig-supplements.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/sdc-ig-supplements.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Contains the supplementary FHIRPath functions defined in the Structured Data\n// Capture IG, https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements.\n\nlet engine = {};\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n\n\n/**\n * Returns numeric values from the score extension associated with the input\n * collection of resource nodes (e.g. QuestionnaireResponse item answers).\n *\n * Currently, when searching for a score extension, we respect the \"Context of\n * Use\" for each possible extension used to store a score. See:\n *   * https://www.hl7.org/fhir/extensions/StructureDefinition-itemWeight.html\n *   * https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-itemWeight.html\n *   * https://hl7.org/fhir/R5/codesystem.html#defined-props\n *   * https://www.hl7.org/fhir/codesystem-concept-properties.html\n *   * https://www.hl7.org/fhir/R4/extension-ordinalvalue.html\n *\n * Since the first mention of the ordinal() (a.k.a. weight()) function was in\n * SDC 3 (https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements),\n * we don't support this function in STU3 and DSTU2 for extensions described in\n * these links:\n *   * https://www.hl7.org/fhir/stu3/extension-questionnaire-ordinalvalue.html\n *   * https://www.hl7.org/fhir/stu3/extension-valueset-ordinalvalue.html\n *   * https://hl7.org/fhir/STU3/extension-iso21090-co-value.html\n *   * https://hl7.org/fhir/DSTU2/questionnaire.html#4.26.5.9\n *   * https://hl7.org/fhir/DSTU2/extension-iso21090-co-value.html\n *   * https://hl7.org/fhir/DSTU2/extension-valueset-ordinalvalue.html\n *\n * Also, according to the resolution of this JIRA issue\n * https://jira.hl7.org/browse/FHIR-49329, we support\n * a score extension for all possible [x] in value[x] in QuestionnaireResponse\n * answers.\n *\n * We search for the first score extension for each source node to add its value\n * to the result in the following order:\n * 1. Check the source node for a score extension.\n * 2. If the source node is an answer from a `QuestionnaireResponse` or its\n *    `value[x]`:\n *     - Check the `value[x]` element for a score extension.\n *     - Check the corresponding answer option (if any) of the corresponding\n *       `Questionnaire` item for a score extension.\n *     - Otherwise, if the `Questionnaire` item references a contained `ValueSet`,\n *       check the corresponding element there for a score extension.\n * 4. If the source resource (to which the source node belongs, e.g.\n *    `QuestionnaireResponse`) or `Questionnaire` contains a corresponding\n *    `CodeSystem`, check for a score extension (for R4) or property (for R5)\n *    there.\n * 5. Look for a score extension (for R4) or property (for R5) in the\n *    corresponding `CodeSystem` loaded from the terminology server.\n * @param {Array} coll - resource nodes\n * @return {(number|Promise<number>)[]}\n */\nengine.weight = function (coll) {\n  const ctx = this;\n  if(!ctx.model?.score) {\n    throw new Error(\"The weight()/ordinal() function is not supported for the current model.\");\n  }\n  if(coll !== false && ! coll) { return []; }\n\n  const res = [];\n\n  const questionnaire = this.vars.questionnaire || this.processedVars.questionnaire?.data;\n  let hasPromise = false;\n\n  coll.forEach((elem) => {\n    if (elem?.data) {\n      const {score: embeddedScore, isQuestionnaireResponse, value, valueType} =\n        getResourceNodeInfo(ctx, elem);\n      if (embeddedScore !== undefined) {\n        // if we have a score extension in the source item, use it.\n        res.push(embeddedScore);\n      } else if (isQuestionnaireResponse && value != null && valueType) {\n        const linkIds = getLinkIds(elem);\n        if (questionnaire) {\n          const qItem = getQItemByLinkIds(ctx.model?.version,questionnaire, linkIds);\n          if (qItem) {\n            const qItemInfo = getQuestionnaireItemInfo(ctx, qItem, value, valueType);\n            if (qItemInfo.score !== undefined) {\n              // if we have a score extension for the answerOption, use it.\n              res.push(qItemInfo.score);\n            } else if (qItemInfo.answerOption && value.system || qItemInfo.answerValueSet) {\n              // Otherwise, check corresponding value set and code system\n              hasPromise = addWeightFromCorrespondingResourcesToResult(res, ctx,\n                questionnaire, qItemInfo.answerValueSet, value.code,\n                value.system, elem) || hasPromise;\n            }\n          } else {\n            throw new Error(\n              'Questionnaire item with this linkId were not found: ' +\n              elem.parentResNode.data.linkId + '.');\n          }\n        } else {\n          throw new Error('%questionnaire is needed but not specified.');\n        }\n      } else if (valueType === 'Coding' && value?.system) {\n        // If there are no questionnaire (no linkId) check corresponding code system\n        hasPromise = addWeightFromCorrespondingResourcesToResult(res, ctx, null,\n          null, value.code, value.system, elem) || hasPromise;\n      }\n    }\n  });\n\n  return hasPromise ? Promise.all(res) : res;\n};\n\n\n/**\n * Returns the score extension value for the specified ResourceNode, a flag\n * indicating that the ResourceNode belongs to an answer in the\n * QuestionnaireResponse, a node value and its capitalized data type name that\n * can be used to further search for the score if the score extension is not\n * embedded in the node.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @param {ResourceNode} rNode - resource node.\n * @returns {{\n *   score: (number|undefined),\n *   isQuestionnaireResponse: (true|false|undefined),\n *   value: (any)\n *   valueType: (string)\n *   }}\n */\nfunction getResourceNodeInfo(ctx, rNode) {\n  const scorePropertyUri = ctx.model.score.propertyURI;\n  const scoreExtensionUri =  ctx.model.score.extensionURI;\n  let score;\n  let isQuestionnaireResponse;\n  let value;\n  let valueType;\n  let valueProp;\n\n  switch(rNode.path) {\n    case 'Coding':\n      isQuestionnaireResponse =\n        rNode.parentResNode?.path === 'QuestionnaireResponse.item.answer';\n      score = getScoreExtensionValue(rNode.data, scoreExtensionUri);\n      value = rNode.data;\n      valueType = 'Coding';\n      break;\n    case 'Questionnaire.item.answerOption':\n      score = getScoreExtensionValue(rNode.data, scoreExtensionUri);\n      value = rNode.data;\n      // No need to return value and valueType, because there is no further search;\n      break;\n    case 'QuestionnaireResponse.item.answer':\n      isQuestionnaireResponse = true;\n      // eslint-disable-next-line no-fallthrough\n      valueProp = rNode.data && Object.keys(rNode.data).find(\n        p => p.length > 5 && p.startsWith('value')\n      );\n      if (valueProp) {\n        valueType = valueProp.substring(5);\n        value = rNode.data[valueProp];\n        score = getScoreExtensionValue(rNode.data['_'+valueProp] || value, scoreExtensionUri);\n      }\n      break;\n    case 'ValueSet.compose.include.concept':\n      if (!ctx.model.score.propertyURI) {\n        score = getScoreExtensionValue(rNode.data, scoreExtensionUri);\n      }\n      // Create a fake node value to allow further search in CodeSystem\n      value = {\n        code: rNode.data.code,\n        system: rNode.parentResNode?.data.system\n      };\n      valueType = 'Coding';\n      break;\n    case 'ValueSet.expansion.contains':\n      if (scorePropertyUri) {\n        const scorePropertyCode = getPropertyCode(\n          rNode.parentResNode?.data.property, scorePropertyUri\n        );\n        score = getDecimalPropertyValue(rNode.data, scorePropertyCode);\n        value = rNode.data;\n        valueType = 'Coding';\n      }\n      break;\n    case 'CodeSystem.concept':\n      if (scorePropertyUri) {\n        const scorePropertyCode = getPropertyCode(\n          rNode.parentResNode?.data.property, scorePropertyUri\n        );\n        score = getDecimalPropertyValue(rNode.data, scorePropertyCode);\n      } else {\n        score = getScoreExtensionValue(rNode.data, scoreExtensionUri);\n      }\n      // No need to return value and valueType, because there is no further search\n      break;\n    default:\n      isQuestionnaireResponse = rNode.parentResNode?.path === 'QuestionnaireResponse.item.answer';\n      if (isQuestionnaireResponse) {\n        score = getScoreExtensionValue(rNode._data || rNode.data, scoreExtensionUri);\n        value = rNode.data;\n        valueType = util.capitalize(rNode.fhirNodeDataType);\n      }\n  }\n  return {score, isQuestionnaireResponse, value, valueType};\n}\n\n\n/**\n * Returns the value of the score extension from the specified node data.\n * @param {Object|undefined} nodeData - node data.\n * @param {string[]|undefined} extensionURI - score extension URI.\n * @returns {number|undefined}\n */\nfunction getScoreExtensionValue(nodeData, extensionURI) {\n  return extensionURI && nodeData?.extension?.find(\n    (i) => extensionURI.indexOf(i.url) !== -1\n  )?.valueDecimal;\n}\n\n\n/**\n * Returns the score extension value for the specified questionnaire item,\n * the answer option that matches specified value and valueType,\n * and a value set URL specified in the Questionnaire item.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @param {Object} qItem - questionnaire item.\n * @param {any} value - item value.\n * @param {string} valueType - item value type.\n * @returns {{\n *   score: number | undefined,\n *   answerOption: Object | undefined,\n *   answerValueSet: string\n *   }}\n */\nfunction getQuestionnaireItemInfo(ctx, qItem, value, valueType) {\n  let compareFn;\n  const valuePropName = 'value'+valueType;\n\n  switch (valueType) {\n    case 'Attachment':\n    case 'Quantity':\n    case 'Reference':\n      compareFn = o => Object.keys(value).find(\n        (propKey) => propKey !== 'extension' && o[valuePropName][propKey] !== value[propKey]\n      ) === undefined;\n      break;\n    case 'Coding':\n      compareFn = o => o.valueCoding?.code === value.code &&\n        o.valueCoding?.system === value.system;\n      break;\n    default:\n      compareFn = o => o[valuePropName] === value;\n  }\n  const answerOption = qItem?.answerOption?.find(compareFn);\n  const score =\n    getScoreExtensionValue(answerOption, ctx.model.score.extensionURI);\n  const answerValueSet = qItem?.answerValueSet;\n  return {score, answerOption, answerValueSet};\n}\n\n\n// Object for storing received scores\nconst weightCache = {};\n// Duration of data storage in cache.\nconst cacheStorageTime = 3600000; // 1 hour = 60 * 60 * 1000\n\n\n/**\n * Caches score.\n * @param {string} key - key to store score in cache.\n * @param {number|Promise} value - value of score or promise of value.\n */\nfunction putScoreToCache(key, value) {\n  weightCache[key] = {\n    timestamp: Date.now(),\n    value\n  };\n}\n\n\n/**\n * Checks if there is an unexpired score in the cache.\n * @param {string} key - key to store score in cache.\n * @return {boolean|undefined}\n */\nfunction hasScoreInCache(key) {\n  return weightCache[key] && Date.now() - weightCache[key].timestamp < cacheStorageTime;\n}\n\n\n/**\n * Returns a score or promise of score from the cache. Does not check the\n * expiration time. {@link hasScoreInCache} should be called before this\n * function.\n * @param {string} key - key to store score in cache.\n * @return {number | Promise}\n */\nfunction getScoreFromCache(key) {\n  return weightCache[key].value;\n}\n\n\n/**\n * Adds the value of score or its promise received from a corresponding value\n * set or code system to the result array.\n * @param {Array} res - result array.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @param {Object} questionnaire - object containing questionnaire resource data\n * @param {string} vsURL - value set URL specified in the Questionnaire item.\n * @param {string} code - symbol in syntax defined by the system.\n * @param {string} system - code system.\n * @param {ResourceNode|any} elem - source collection item for which we obtain\n *  the score value.\n * @return {boolean} a flag indicating that a promise has been added to the\n *  resulting array.\n */\nfunction addWeightFromCorrespondingResourcesToResult(res, ctx, questionnaire,\n  vsURL, code, system, elem) {\n  let score;\n  const modelVersion = ctx.model?.version;\n  const cacheKey = [\n    modelVersion,\n    questionnaire?.url || questionnaire?.id,\n    ctx.processedVars.terminologies?.terminologyUrl,\n    vsURL, code, system\n  ].join('|');\n\n  if (hasScoreInCache(cacheKey)) {\n    score =  getScoreFromCache(cacheKey);\n  } else {\n    if (code) {\n      if (vsURL) {\n        const vsId = /^#(.*)/.test(vsURL) ? RegExp.$1 : null;\n        const isAnswerValueSet = vsId\n          ? (r) => r.id === vsId && r.resourceType === 'ValueSet'\n          : (r) => r.url === vsURL && r.resourceType === 'ValueSet';\n\n        const containedVS = questionnaire?.contained?.find(isAnswerValueSet);\n\n        if (containedVS) {\n          score = getWeightFromVS(ctx, containedVS, code, system);\n        } else if (vsId) {\n          throw new Error(\n            `Cannot find a contained value set with id: ` + vsId + '.');\n        }\n      } // end if (vsURL)\n\n      if (system) {\n        if (score === undefined || score === null) {\n          score = getWeightFromCS(ctx, questionnaire, elem, code, system);\n        } else if (score instanceof Promise) {\n          score = score.then(weightFromVS => {\n            if (weightFromVS !== undefined && weightFromVS !== null) {\n              return weightFromVS;\n            }\n            return getWeightFromCS(ctx, questionnaire, elem, code, system);\n          });\n        }\n      }\n    }\n\n    putScoreToCache(cacheKey, score);\n  }\n\n  if (score !== undefined) {\n    res.push(score);\n  }\n\n  return score instanceof Promise;\n}\n\n\n/**\n * Returns the value (or its promise) of the itemWeight property or score\n * extension for the specified system and code from a CodeSystem.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function). * @param ctx\n * @param {Object} questionnaire - object containing questionnaire resource data\n * @param {ResourceNode|any} elem - source collection item for which we obtain\n *  the score value.\n * @param {string} code - symbol in syntax defined by the system.\n * @param {string} system - code system.\n * @return {number|undefined|Promise<number|undefined>}\n */\nfunction getWeightFromCS(ctx, questionnaire, elem, code, system) {\n  const isCodeSystem = (r) => r.url === system && r.resourceType === 'CodeSystem';\n  const containedCS = getContainedResources(elem)?.find(isCodeSystem)\n    || questionnaire?.contained?.find(isCodeSystem);\n  let score;\n\n  if (containedCS) {\n    const scorePropertyUri = ctx.model?.score.propertyURI;\n    if (scorePropertyUri) {\n      const scorePropertyCode = getPropertyCode(containedCS?.property, scorePropertyUri);\n      if (scorePropertyCode) {\n        const item = getCodeSystemItem(containedCS?.concept, code);\n        score = getDecimalPropertyValue(item, scorePropertyCode);\n      }\n    } else {\n      const codeSystemExt = ctx.model?.score.extensionURI;\n      if (codeSystemExt) {\n        const item = getCodeSystemItem(containedCS?.concept, code);\n        score = getScoreExtensionValue(item, codeSystemExt);\n      }\n    }\n  } else {\n    score = getWeightFromTerminologyCodeSet(ctx, code, system);\n  }\n\n  return score;\n}\n\n\n/**\n * Returns a promise to return a score value from the code system obtained from\n * the terminology server.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @param {string} code - symbol in syntax defined by the system.\n * @param {string} system - code system.\n * @return {Promise<number|undefined>}\n */\nfunction getWeightFromTerminologyCodeSet(ctx, code, system) {\n  const scorePropertyUri = ctx.model?.score.propertyURI;\n  const codeSystemExt = ctx.model?.score.extensionURI;\n\n  const terminologyUrl = getTerminologyUrl(ctx);\n  const fetchOptions = {\n    headers: {\n      'Accept': 'application/fhir+json'\n    },\n    ...(ctx.signal ? {signal: ctx.signal} : {})\n  };\n  return util.fetchWithCache(`${terminologyUrl}/CodeSystem?` + new URLSearchParams({\n    url: system,\n    ...(scorePropertyUri ? {_elements: 'property'}: {})\n  }).toString(), fetchOptions)\n    .then(bundle => {\n      if (scorePropertyUri) {\n        const scorePropertyCode = getPropertyCode(bundle?.entry?.[0]?.resource?.property, scorePropertyUri);\n        if (scorePropertyCode) {\n          return util.fetchWithCache(`${terminologyUrl}/CodeSystem/$lookup?` + new URLSearchParams({\n            code, system, property: scorePropertyCode\n          }).toString(), fetchOptions)\n            .then((parameters) => {\n              return parameters.parameter\n                .find(p => p.name === 'property' && p.part\n                  .find(part => part.name === 'code' && part.valueCode === scorePropertyCode))\n                ?.part?.find(p => p.name === 'value')?.valueDecimal;\n            });\n        }\n      } else {\n        const item = getCodeSystemItem(bundle?.entry?.[0]?.resource.concept, code);\n        return getScoreExtensionValue(item, codeSystemExt);\n      }\n    });\n}\n\n\n/**\n * Returns the URL of the terminology server.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @return {string}\n */\nfunction getTerminologyUrl(ctx) {\n  if (!ctx.async) {\n    throw new Error('The asynchronous function \"weight\"/\"ordinal\" is not allowed. ' +\n      'To enable asynchronous functions, use the async=true or async=\"always\"' +\n      ' option.');\n  }\n\n  const terminologyUrl = ctx.processedVars.terminologies?.terminologyUrl;\n  if (!terminologyUrl) {\n    throw new Error('Option \"terminologyUrl\" is not specified.');\n  }\n\n  return terminologyUrl;\n}\n\n\n/**\n * Returns an item from \"ValueSet.expansion.contains\" that has the specified\n * code and system.\n * @param {Array<Object>} contains - value of \"ValueSet.expansion.contains\".\n * @param {string} code - symbol in syntax defined by the system.\n * @param {string} system - code system.\n * @return {Object| undefined}\n */\nfunction getValueSetItem(contains, code, system) {\n  let result;\n  if (contains) {\n    for(let i = 0; i < contains.length && !result; i++) {\n      const item = contains[i];\n      if (item.code === code && item.system === system) {\n        result = item;\n      } else {\n        result = getValueSetItem(item.contains, code, system);\n      }\n    }\n  }\n  return result;\n}\n\n\n/**\n * Returns an item from \"CodeSystem.concept\" that has the specified code.\n * @param {Array<Object>} concept - value of \"CodeSystem.concept\".\n * @param {string} code - symbol in syntax defined by the system.\n * @return {Object| undefined}\n */\nfunction getCodeSystemItem(concept, code) {\n  let result;\n  if (concept) {\n    for(let i = 0; i < concept.length && !result; i++) {\n      const item = concept[i];\n      if (item.code === code) {\n        result = item;\n      } else if (item.concept) {\n        result = getCodeSystemItem(item.concept, code);\n      }\n    }\n  }\n  return result;\n}\n\n\n/**\n * Returns  a property code from the array with additional information\n * supplied about each concept by its URI.\n * @param {Object} properties - ValueSet.expansion.property or\n *  CodeSystem.property.\n *  @param {string} uri - property URI.\n * @return {boolean}\n */\nfunction getPropertyCode(properties, uri) {\n  return properties?.find(p => p.uri === uri)?.code;\n}\n\n\n/**\n * Returns the decimal value of a property from a value set item or code\n * system concept item by its code.\n * @param {Object} item - an item from a ValueSet.expansion.contains or\n *  CodeSystem.concept.\n * @param {Object} code - property code.\n * @return {number | undefined}\n */\nfunction getDecimalPropertyValue(item, code) {\n  return item?.property?.find(p => p.code === code)?.valueDecimal;\n}\n\n\n/**\n * Returns the value of the itemWeight property or score extension for the\n * specified system and code from a value set. If the item in the value set has\n * no score, undefined is returned. If the item does not exist, null is returned.\n * The difference between null and undefined values may be used in paging.\n * @param {Object} ctx - object describing the context of expression\n *  evaluation (see the \"applyParsedPath\" function).\n * @param {Object} vs - ValueSet.\n * @param {string} code - symbol in syntax defined by the system.\n * @param {string} system - code system.\n * @return {number|null|undefined}\n */\nfunction getWeightFromVS(ctx, vs, code, system) {\n  let score;\n  let item;\n  const scorePropertyUri = ctx.model?.score.propertyURI;\n  if (scorePropertyUri) {\n    // \"ValueSet.expansion.contains\" for R5\n    const scorePropertyCode = getPropertyCode(\n      vs.expansion?.property, scorePropertyUri\n    );\n    if (scorePropertyCode) {\n      item = getValueSetItem(vs.expansion?.contains, code, system);\n      score = getDecimalPropertyValue(item, scorePropertyCode);\n    }\n  } else {\n    // \"ValueSet.compose.include.concept\" for R4\n    const includeExt = ctx.model?.score.extensionURI;\n    const include = vs.compose?.include;\n    const len = include?.length;\n    for (let i = 0; i < len && !item; ++i) {\n      if (include[i].system === system) {\n        item = getCodeSystemItem(include[i].concept, code);\n      }\n    }\n    score = getScoreExtensionValue(item, includeExt);\n  }\n\n  return item ? score : null;\n}\n\n\n/**\n * Returns array of linkIds of ancestor ResourceNodes and source ResourceNode\n * starting with the linkId of the given node and ending with the topmost item's\n * linkId.\n * @param {ResourceNode} node - source ResourceNode.\n * @return {String[]}\n */\nfunction getLinkIds(node) {\n  const res = [];\n\n  while (!node.data?.linkId && node?.parentResNode) {\n    node = node.parentResNode;\n  }\n\n  while (node?.data?.linkId) {\n    res.push(node.data.linkId);\n    node = node.parentResNode;\n  }\n\n  return res;\n}\n\n\n/**\n * Returns the \"contained\" property of the resource to which the ResourceNode\n * belongs, or an undefined value if not a ResourceNode was passed or if there\n * is no contained property.\n * @param {ResourceNode|any} node - source ResourceNode or something else.\n * @return {Object[]|undefined}\n */\nfunction getContainedResources(node) {\n  while (node) {\n    if (node.data?.resourceType && node.data?.contained) {\n      return node.data?.contained;\n    }\n    node = node.parentResNode;\n  }\n}\n\n\n/**\n * Mapping questionnaires to \"linkIds\" keys mapped to questionnaire items.\n * It is used to cache the result in the getQItemByLinkIds function.\n * @type {WeakMap<WeakKey, Object>}\n */\nconst questionnaire2linkIds = new WeakMap();\n\n\n/**\n * Returns a questionnaire item based on the linkIds array of the ancestor\n * ResourceNodes and the target ResourceNode. If the questionnaire item is not\n * found, it returns null.\n * @param {string} modelVersion - model version: 'r5', 'r4', 'stu3', or 'dstu2'.\n * @param {Object} questionnaire - object with a Questionnaire resource.\n * @param {string[]} linkIds - array of linkIds starting with the linkId of the\n * target node and ending with the topmost known item's linkId.\n * @return {Object | null}\n */\nfunction getQItemByLinkIds(modelVersion, questionnaire, linkIds) {\n  let currentNode;\n  // Mapping \"linkIds\" keys to questionnaire items.\n  let linkIds2items;\n  // \"linkIds\" key.\n  const linkIdsKey = linkIds.join('|');\n\n  // Get the mapping of \"linkIds\" keys to questionnaire items for the current\n  // questionnaire, or create it if it doesn't exist.\n  if (questionnaire2linkIds.has(questionnaire)) {\n    linkIds2items = questionnaire2linkIds.get(questionnaire);\n    currentNode =  linkIds2items[linkIdsKey];\n  } else {\n    linkIds2items = {};\n    questionnaire2linkIds.set(questionnaire, linkIds2items);\n  }\n\n  // We use \"hasOwnProperty\" because we also cache undefined results for scores.\n  if (!Object.prototype.hasOwnProperty.call(linkIds2items, linkIdsKey)) {\n    // If the result is not cached yet, we search for the questionnaire item.\n    const topLinkId = linkIds[linkIds.length - 1];\n\n    if (modelVersion === 'dstu2') {\n      // Search for an item in a questionnaire specified in DSTU2 format.\n      let collection = questionnaire.group;\n\n      // Find the questionnaire item that matches the linkId of the topmost\n      // known item.\n      while (collection?.length > 0) {\n        currentNode = collection.find(o => o.linkId === topLinkId);\n        if (currentNode) {\n          break;\n        } else {\n          collection = [].concat(...collection.map(i => [].concat(i.question || [], i.group || [])));\n        }\n      }\n\n      // Getting a questionnaire item relative to the topmost known item using\n      // subsequent linkIds.\n      for (let i = linkIds.length - 2; i >= 0 && currentNode; --i) {\n        currentNode = currentNode.question?.find(o => o.linkId === linkIds[i]) ||\n          currentNode.group?.find(o => o.linkId === linkIds[i]);\n      }\n\n    } else {\n      // Search for an item in a questionnaire specified in STU3, R4 or R5\n      // format.\n      let collection = questionnaire.item;\n\n      // Find the questionnaire item that matches the linkId of the topmost\n      // known item.\n      while (collection?.length > 0) {\n        currentNode = collection.find(o => o.linkId === topLinkId);\n        if (currentNode) {\n          break;\n        } else {\n          collection = [].concat(...collection.map(i => i.item || []));\n        }\n      }\n\n      // Getting a questionnaire item relative to the topmost known item using\n      // subsequent linkIds.\n      for (let i = linkIds.length - 2; i >= 0 && currentNode; --i) {\n        currentNode = currentNode.item?.find(o => o.linkId === linkIds[i]);\n      }\n    }\n\n    linkIds2items[linkIdsKey] = currentNode;\n  }\n\n  return currentNode;\n}\n\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3NkYy1pZy1zdXBwbGVtZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHVHQUFhOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7OztBQUdsQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixvQkFBb0IsSUFBSTtBQUM5QztBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsNEJBQTRCLHNCQUFzQixJQUFJO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3NkYy1pZy1zdXBwbGVtZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250YWlucyB0aGUgc3VwcGxlbWVudGFyeSBGSElSUGF0aCBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGUgU3RydWN0dXJlZCBEYXRhXG4vLyBDYXB0dXJlIElHLCBodHRwczovL2hsNy5vcmcvZmhpci91di9zZGMvZXhwcmVzc2lvbnMuaHRtbCNmaGlycGF0aC1zdXBwbGVtZW50cy5cblxubGV0IGVuZ2luZSA9IHt9O1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxpdGllc1wiKTtcblxuXG4vKipcbiAqIFJldHVybnMgbnVtZXJpYyB2YWx1ZXMgZnJvbSB0aGUgc2NvcmUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5wdXRcbiAqIGNvbGxlY3Rpb24gb2YgcmVzb3VyY2Ugbm9kZXMgKGUuZy4gUXVlc3Rpb25uYWlyZVJlc3BvbnNlIGl0ZW0gYW5zd2VycykuXG4gKlxuICogQ3VycmVudGx5LCB3aGVuIHNlYXJjaGluZyBmb3IgYSBzY29yZSBleHRlbnNpb24sIHdlIHJlc3BlY3QgdGhlIFwiQ29udGV4dCBvZlxuICogVXNlXCIgZm9yIGVhY2ggcG9zc2libGUgZXh0ZW5zaW9uIHVzZWQgdG8gc3RvcmUgYSBzY29yZS4gU2VlOlxuICogICAqIGh0dHBzOi8vd3d3LmhsNy5vcmcvZmhpci9leHRlbnNpb25zL1N0cnVjdHVyZURlZmluaXRpb24taXRlbVdlaWdodC5odG1sXG4gKiAgICogaHR0cHM6Ly9idWlsZC5maGlyLm9yZy9pZy9ITDcvZmhpci1leHRlbnNpb25zL1N0cnVjdHVyZURlZmluaXRpb24taXRlbVdlaWdodC5odG1sXG4gKiAgICogaHR0cHM6Ly9obDcub3JnL2ZoaXIvUjUvY29kZXN5c3RlbS5odG1sI2RlZmluZWQtcHJvcHNcbiAqICAgKiBodHRwczovL3d3dy5obDcub3JnL2ZoaXIvY29kZXN5c3RlbS1jb25jZXB0LXByb3BlcnRpZXMuaHRtbFxuICogICAqIGh0dHBzOi8vd3d3LmhsNy5vcmcvZmhpci9SNC9leHRlbnNpb24tb3JkaW5hbHZhbHVlLmh0bWxcbiAqXG4gKiBTaW5jZSB0aGUgZmlyc3QgbWVudGlvbiBvZiB0aGUgb3JkaW5hbCgpIChhLmsuYS4gd2VpZ2h0KCkpIGZ1bmN0aW9uIHdhcyBpblxuICogU0RDIDMgKGh0dHBzOi8vaGw3Lm9yZy9maGlyL3V2L3NkYy9leHByZXNzaW9ucy5odG1sI2ZoaXJwYXRoLXN1cHBsZW1lbnRzKSxcbiAqIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBmdW5jdGlvbiBpbiBTVFUzIGFuZCBEU1RVMiBmb3IgZXh0ZW5zaW9ucyBkZXNjcmliZWQgaW5cbiAqIHRoZXNlIGxpbmtzOlxuICogICAqIGh0dHBzOi8vd3d3LmhsNy5vcmcvZmhpci9zdHUzL2V4dGVuc2lvbi1xdWVzdGlvbm5haXJlLW9yZGluYWx2YWx1ZS5odG1sXG4gKiAgICogaHR0cHM6Ly93d3cuaGw3Lm9yZy9maGlyL3N0dTMvZXh0ZW5zaW9uLXZhbHVlc2V0LW9yZGluYWx2YWx1ZS5odG1sXG4gKiAgICogaHR0cHM6Ly9obDcub3JnL2ZoaXIvU1RVMy9leHRlbnNpb24taXNvMjEwOTAtY28tdmFsdWUuaHRtbFxuICogICAqIGh0dHBzOi8vaGw3Lm9yZy9maGlyL0RTVFUyL3F1ZXN0aW9ubmFpcmUuaHRtbCM0LjI2LjUuOVxuICogICAqIGh0dHBzOi8vaGw3Lm9yZy9maGlyL0RTVFUyL2V4dGVuc2lvbi1pc28yMTA5MC1jby12YWx1ZS5odG1sXG4gKiAgICogaHR0cHM6Ly9obDcub3JnL2ZoaXIvRFNUVTIvZXh0ZW5zaW9uLXZhbHVlc2V0LW9yZGluYWx2YWx1ZS5odG1sXG4gKlxuICogQWxzbywgYWNjb3JkaW5nIHRvIHRoZSByZXNvbHV0aW9uIG9mIHRoaXMgSklSQSBpc3N1ZVxuICogaHR0cHM6Ly9qaXJhLmhsNy5vcmcvYnJvd3NlL0ZISVItNDkzMjksIHdlIHN1cHBvcnRcbiAqIGEgc2NvcmUgZXh0ZW5zaW9uIGZvciBhbGwgcG9zc2libGUgW3hdIGluIHZhbHVlW3hdIGluIFF1ZXN0aW9ubmFpcmVSZXNwb25zZVxuICogYW5zd2Vycy5cbiAqXG4gKiBXZSBzZWFyY2ggZm9yIHRoZSBmaXJzdCBzY29yZSBleHRlbnNpb24gZm9yIGVhY2ggc291cmNlIG5vZGUgdG8gYWRkIGl0cyB2YWx1ZVxuICogdG8gdGhlIHJlc3VsdCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICogMS4gQ2hlY2sgdGhlIHNvdXJjZSBub2RlIGZvciBhIHNjb3JlIGV4dGVuc2lvbi5cbiAqIDIuIElmIHRoZSBzb3VyY2Ugbm9kZSBpcyBhbiBhbnN3ZXIgZnJvbSBhIGBRdWVzdGlvbm5haXJlUmVzcG9uc2VgIG9yIGl0c1xuICogICAgYHZhbHVlW3hdYDpcbiAqICAgICAtIENoZWNrIHRoZSBgdmFsdWVbeF1gIGVsZW1lbnQgZm9yIGEgc2NvcmUgZXh0ZW5zaW9uLlxuICogICAgIC0gQ2hlY2sgdGhlIGNvcnJlc3BvbmRpbmcgYW5zd2VyIG9wdGlvbiAoaWYgYW55KSBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgYFF1ZXN0aW9ubmFpcmVgIGl0ZW0gZm9yIGEgc2NvcmUgZXh0ZW5zaW9uLlxuICogICAgIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYFF1ZXN0aW9ubmFpcmVgIGl0ZW0gcmVmZXJlbmNlcyBhIGNvbnRhaW5lZCBgVmFsdWVTZXRgLFxuICogICAgICAgY2hlY2sgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCB0aGVyZSBmb3IgYSBzY29yZSBleHRlbnNpb24uXG4gKiA0LiBJZiB0aGUgc291cmNlIHJlc291cmNlICh0byB3aGljaCB0aGUgc291cmNlIG5vZGUgYmVsb25ncywgZS5nLlxuICogICAgYFF1ZXN0aW9ubmFpcmVSZXNwb25zZWApIG9yIGBRdWVzdGlvbm5haXJlYCBjb250YWlucyBhIGNvcnJlc3BvbmRpbmdcbiAqICAgIGBDb2RlU3lzdGVtYCwgY2hlY2sgZm9yIGEgc2NvcmUgZXh0ZW5zaW9uIChmb3IgUjQpIG9yIHByb3BlcnR5IChmb3IgUjUpXG4gKiAgICB0aGVyZS5cbiAqIDUuIExvb2sgZm9yIGEgc2NvcmUgZXh0ZW5zaW9uIChmb3IgUjQpIG9yIHByb3BlcnR5IChmb3IgUjUpIGluIHRoZVxuICogICAgY29ycmVzcG9uZGluZyBgQ29kZVN5c3RlbWAgbG9hZGVkIGZyb20gdGhlIHRlcm1pbm9sb2d5IHNlcnZlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbGwgLSByZXNvdXJjZSBub2Rlc1xuICogQHJldHVybiB7KG51bWJlcnxQcm9taXNlPG51bWJlcj4pW119XG4gKi9cbmVuZ2luZS53ZWlnaHQgPSBmdW5jdGlvbiAoY29sbCkge1xuICBjb25zdCBjdHggPSB0aGlzO1xuICBpZighY3R4Lm1vZGVsPy5zY29yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB3ZWlnaHQoKS9vcmRpbmFsKCkgZnVuY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIGN1cnJlbnQgbW9kZWwuXCIpO1xuICB9XG4gIGlmKGNvbGwgIT09IGZhbHNlICYmICEgY29sbCkgeyByZXR1cm4gW107IH1cblxuICBjb25zdCByZXMgPSBbXTtcblxuICBjb25zdCBxdWVzdGlvbm5haXJlID0gdGhpcy52YXJzLnF1ZXN0aW9ubmFpcmUgfHwgdGhpcy5wcm9jZXNzZWRWYXJzLnF1ZXN0aW9ubmFpcmU/LmRhdGE7XG4gIGxldCBoYXNQcm9taXNlID0gZmFsc2U7XG5cbiAgY29sbC5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgaWYgKGVsZW0/LmRhdGEpIHtcbiAgICAgIGNvbnN0IHtzY29yZTogZW1iZWRkZWRTY29yZSwgaXNRdWVzdGlvbm5haXJlUmVzcG9uc2UsIHZhbHVlLCB2YWx1ZVR5cGV9ID1cbiAgICAgICAgZ2V0UmVzb3VyY2VOb2RlSW5mbyhjdHgsIGVsZW0pO1xuICAgICAgaWYgKGVtYmVkZGVkU2NvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgc2NvcmUgZXh0ZW5zaW9uIGluIHRoZSBzb3VyY2UgaXRlbSwgdXNlIGl0LlxuICAgICAgICByZXMucHVzaChlbWJlZGRlZFNjb3JlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNRdWVzdGlvbm5haXJlUmVzcG9uc2UgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgbGlua0lkcyA9IGdldExpbmtJZHMoZWxlbSk7XG4gICAgICAgIGlmIChxdWVzdGlvbm5haXJlKSB7XG4gICAgICAgICAgY29uc3QgcUl0ZW0gPSBnZXRRSXRlbUJ5TGlua0lkcyhjdHgubW9kZWw/LnZlcnNpb24scXVlc3Rpb25uYWlyZSwgbGlua0lkcyk7XG4gICAgICAgICAgaWYgKHFJdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBxSXRlbUluZm8gPSBnZXRRdWVzdGlvbm5haXJlSXRlbUluZm8oY3R4LCBxSXRlbSwgdmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAocUl0ZW1JbmZvLnNjb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHNjb3JlIGV4dGVuc2lvbiBmb3IgdGhlIGFuc3dlck9wdGlvbiwgdXNlIGl0LlxuICAgICAgICAgICAgICByZXMucHVzaChxSXRlbUluZm8uc2NvcmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxSXRlbUluZm8uYW5zd2VyT3B0aW9uICYmIHZhbHVlLnN5c3RlbSB8fCBxSXRlbUluZm8uYW5zd2VyVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb3JyZXNwb25kaW5nIHZhbHVlIHNldCBhbmQgY29kZSBzeXN0ZW1cbiAgICAgICAgICAgICAgaGFzUHJvbWlzZSA9IGFkZFdlaWdodEZyb21Db3JyZXNwb25kaW5nUmVzb3VyY2VzVG9SZXN1bHQocmVzLCBjdHgsXG4gICAgICAgICAgICAgICAgcXVlc3Rpb25uYWlyZSwgcUl0ZW1JbmZvLmFuc3dlclZhbHVlU2V0LCB2YWx1ZS5jb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLnN5c3RlbSwgZWxlbSkgfHwgaGFzUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnUXVlc3Rpb25uYWlyZSBpdGVtIHdpdGggdGhpcyBsaW5rSWQgd2VyZSBub3QgZm91bmQ6ICcgK1xuICAgICAgICAgICAgICBlbGVtLnBhcmVudFJlc05vZGUuZGF0YS5saW5rSWQgKyAnLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyVxdWVzdGlvbm5haXJlIGlzIG5lZWRlZCBidXQgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdDb2RpbmcnICYmIHZhbHVlPy5zeXN0ZW0pIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHF1ZXN0aW9ubmFpcmUgKG5vIGxpbmtJZCkgY2hlY2sgY29ycmVzcG9uZGluZyBjb2RlIHN5c3RlbVxuICAgICAgICBoYXNQcm9taXNlID0gYWRkV2VpZ2h0RnJvbUNvcnJlc3BvbmRpbmdSZXNvdXJjZXNUb1Jlc3VsdChyZXMsIGN0eCwgbnVsbCxcbiAgICAgICAgICBudWxsLCB2YWx1ZS5jb2RlLCB2YWx1ZS5zeXN0ZW0sIGVsZW0pIHx8IGhhc1Byb21pc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaGFzUHJvbWlzZSA/IFByb21pc2UuYWxsKHJlcykgOiByZXM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NvcmUgZXh0ZW5zaW9uIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIFJlc291cmNlTm9kZSwgYSBmbGFnXG4gKiBpbmRpY2F0aW5nIHRoYXQgdGhlIFJlc291cmNlTm9kZSBiZWxvbmdzIHRvIGFuIGFuc3dlciBpbiB0aGVcbiAqIFF1ZXN0aW9ubmFpcmVSZXNwb25zZSwgYSBub2RlIHZhbHVlIGFuZCBpdHMgY2FwaXRhbGl6ZWQgZGF0YSB0eXBlIG5hbWUgdGhhdFxuICogY2FuIGJlIHVzZWQgdG8gZnVydGhlciBzZWFyY2ggZm9yIHRoZSBzY29yZSBpZiB0aGUgc2NvcmUgZXh0ZW5zaW9uIGlzIG5vdFxuICogZW1iZWRkZWQgaW4gdGhlIG5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgb2YgZXhwcmVzc2lvblxuICogIGV2YWx1YXRpb24gKHNlZSB0aGUgXCJhcHBseVBhcnNlZFBhdGhcIiBmdW5jdGlvbikuXG4gKiBAcGFyYW0ge1Jlc291cmNlTm9kZX0gck5vZGUgLSByZXNvdXJjZSBub2RlLlxuICogQHJldHVybnMge3tcbiAqICAgc2NvcmU6IChudW1iZXJ8dW5kZWZpbmVkKSxcbiAqICAgaXNRdWVzdGlvbm5haXJlUmVzcG9uc2U6ICh0cnVlfGZhbHNlfHVuZGVmaW5lZCksXG4gKiAgIHZhbHVlOiAoYW55KVxuICogICB2YWx1ZVR5cGU6IChzdHJpbmcpXG4gKiAgIH19XG4gKi9cbmZ1bmN0aW9uIGdldFJlc291cmNlTm9kZUluZm8oY3R4LCByTm9kZSkge1xuICBjb25zdCBzY29yZVByb3BlcnR5VXJpID0gY3R4Lm1vZGVsLnNjb3JlLnByb3BlcnR5VVJJO1xuICBjb25zdCBzY29yZUV4dGVuc2lvblVyaSA9ICBjdHgubW9kZWwuc2NvcmUuZXh0ZW5zaW9uVVJJO1xuICBsZXQgc2NvcmU7XG4gIGxldCBpc1F1ZXN0aW9ubmFpcmVSZXNwb25zZTtcbiAgbGV0IHZhbHVlO1xuICBsZXQgdmFsdWVUeXBlO1xuICBsZXQgdmFsdWVQcm9wO1xuXG4gIHN3aXRjaChyTm9kZS5wYXRoKSB7XG4gICAgY2FzZSAnQ29kaW5nJzpcbiAgICAgIGlzUXVlc3Rpb25uYWlyZVJlc3BvbnNlID1cbiAgICAgICAgck5vZGUucGFyZW50UmVzTm9kZT8ucGF0aCA9PT0gJ1F1ZXN0aW9ubmFpcmVSZXNwb25zZS5pdGVtLmFuc3dlcic7XG4gICAgICBzY29yZSA9IGdldFNjb3JlRXh0ZW5zaW9uVmFsdWUock5vZGUuZGF0YSwgc2NvcmVFeHRlbnNpb25VcmkpO1xuICAgICAgdmFsdWUgPSByTm9kZS5kYXRhO1xuICAgICAgdmFsdWVUeXBlID0gJ0NvZGluZyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdRdWVzdGlvbm5haXJlLml0ZW0uYW5zd2VyT3B0aW9uJzpcbiAgICAgIHNjb3JlID0gZ2V0U2NvcmVFeHRlbnNpb25WYWx1ZShyTm9kZS5kYXRhLCBzY29yZUV4dGVuc2lvblVyaSk7XG4gICAgICB2YWx1ZSA9IHJOb2RlLmRhdGE7XG4gICAgICAvLyBObyBuZWVkIHRvIHJldHVybiB2YWx1ZSBhbmQgdmFsdWVUeXBlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIGZ1cnRoZXIgc2VhcmNoO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUXVlc3Rpb25uYWlyZVJlc3BvbnNlLml0ZW0uYW5zd2VyJzpcbiAgICAgIGlzUXVlc3Rpb25uYWlyZVJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgdmFsdWVQcm9wID0gck5vZGUuZGF0YSAmJiBPYmplY3Qua2V5cyhyTm9kZS5kYXRhKS5maW5kKFxuICAgICAgICBwID0+IHAubGVuZ3RoID4gNSAmJiBwLnN0YXJ0c1dpdGgoJ3ZhbHVlJylcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWVQcm9wKSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IHZhbHVlUHJvcC5zdWJzdHJpbmcoNSk7XG4gICAgICAgIHZhbHVlID0gck5vZGUuZGF0YVt2YWx1ZVByb3BdO1xuICAgICAgICBzY29yZSA9IGdldFNjb3JlRXh0ZW5zaW9uVmFsdWUock5vZGUuZGF0YVsnXycrdmFsdWVQcm9wXSB8fCB2YWx1ZSwgc2NvcmVFeHRlbnNpb25VcmkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVmFsdWVTZXQuY29tcG9zZS5pbmNsdWRlLmNvbmNlcHQnOlxuICAgICAgaWYgKCFjdHgubW9kZWwuc2NvcmUucHJvcGVydHlVUkkpIHtcbiAgICAgICAgc2NvcmUgPSBnZXRTY29yZUV4dGVuc2lvblZhbHVlKHJOb2RlLmRhdGEsIHNjb3JlRXh0ZW5zaW9uVXJpKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBhIGZha2Ugbm9kZSB2YWx1ZSB0byBhbGxvdyBmdXJ0aGVyIHNlYXJjaCBpbiBDb2RlU3lzdGVtXG4gICAgICB2YWx1ZSA9IHtcbiAgICAgICAgY29kZTogck5vZGUuZGF0YS5jb2RlLFxuICAgICAgICBzeXN0ZW06IHJOb2RlLnBhcmVudFJlc05vZGU/LmRhdGEuc3lzdGVtXG4gICAgICB9O1xuICAgICAgdmFsdWVUeXBlID0gJ0NvZGluZyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdWYWx1ZVNldC5leHBhbnNpb24uY29udGFpbnMnOlxuICAgICAgaWYgKHNjb3JlUHJvcGVydHlVcmkpIHtcbiAgICAgICAgY29uc3Qgc2NvcmVQcm9wZXJ0eUNvZGUgPSBnZXRQcm9wZXJ0eUNvZGUoXG4gICAgICAgICAgck5vZGUucGFyZW50UmVzTm9kZT8uZGF0YS5wcm9wZXJ0eSwgc2NvcmVQcm9wZXJ0eVVyaVxuICAgICAgICApO1xuICAgICAgICBzY29yZSA9IGdldERlY2ltYWxQcm9wZXJ0eVZhbHVlKHJOb2RlLmRhdGEsIHNjb3JlUHJvcGVydHlDb2RlKTtcbiAgICAgICAgdmFsdWUgPSByTm9kZS5kYXRhO1xuICAgICAgICB2YWx1ZVR5cGUgPSAnQ29kaW5nJztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NvZGVTeXN0ZW0uY29uY2VwdCc6XG4gICAgICBpZiAoc2NvcmVQcm9wZXJ0eVVyaSkge1xuICAgICAgICBjb25zdCBzY29yZVByb3BlcnR5Q29kZSA9IGdldFByb3BlcnR5Q29kZShcbiAgICAgICAgICByTm9kZS5wYXJlbnRSZXNOb2RlPy5kYXRhLnByb3BlcnR5LCBzY29yZVByb3BlcnR5VXJpXG4gICAgICAgICk7XG4gICAgICAgIHNjb3JlID0gZ2V0RGVjaW1hbFByb3BlcnR5VmFsdWUock5vZGUuZGF0YSwgc2NvcmVQcm9wZXJ0eUNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcmUgPSBnZXRTY29yZUV4dGVuc2lvblZhbHVlKHJOb2RlLmRhdGEsIHNjb3JlRXh0ZW5zaW9uVXJpKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vIG5lZWQgdG8gcmV0dXJuIHZhbHVlIGFuZCB2YWx1ZVR5cGUsIGJlY2F1c2UgdGhlcmUgaXMgbm8gZnVydGhlciBzZWFyY2hcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpc1F1ZXN0aW9ubmFpcmVSZXNwb25zZSA9IHJOb2RlLnBhcmVudFJlc05vZGU/LnBhdGggPT09ICdRdWVzdGlvbm5haXJlUmVzcG9uc2UuaXRlbS5hbnN3ZXInO1xuICAgICAgaWYgKGlzUXVlc3Rpb25uYWlyZVJlc3BvbnNlKSB7XG4gICAgICAgIHNjb3JlID0gZ2V0U2NvcmVFeHRlbnNpb25WYWx1ZShyTm9kZS5fZGF0YSB8fCByTm9kZS5kYXRhLCBzY29yZUV4dGVuc2lvblVyaSk7XG4gICAgICAgIHZhbHVlID0gck5vZGUuZGF0YTtcbiAgICAgICAgdmFsdWVUeXBlID0gdXRpbC5jYXBpdGFsaXplKHJOb2RlLmZoaXJOb2RlRGF0YVR5cGUpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7c2NvcmUsIGlzUXVlc3Rpb25uYWlyZVJlc3BvbnNlLCB2YWx1ZSwgdmFsdWVUeXBlfTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzY29yZSBleHRlbnNpb24gZnJvbSB0aGUgc3BlY2lmaWVkIG5vZGUgZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gbm9kZURhdGEgLSBub2RlIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfHVuZGVmaW5lZH0gZXh0ZW5zaW9uVVJJIC0gc2NvcmUgZXh0ZW5zaW9uIFVSSS5cbiAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXRTY29yZUV4dGVuc2lvblZhbHVlKG5vZGVEYXRhLCBleHRlbnNpb25VUkkpIHtcbiAgcmV0dXJuIGV4dGVuc2lvblVSSSAmJiBub2RlRGF0YT8uZXh0ZW5zaW9uPy5maW5kKFxuICAgIChpKSA9PiBleHRlbnNpb25VUkkuaW5kZXhPZihpLnVybCkgIT09IC0xXG4gICk/LnZhbHVlRGVjaW1hbDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjb3JlIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBxdWVzdGlvbm5haXJlIGl0ZW0sXG4gKiB0aGUgYW5zd2VyIG9wdGlvbiB0aGF0IG1hdGNoZXMgc3BlY2lmaWVkIHZhbHVlIGFuZCB2YWx1ZVR5cGUsXG4gKiBhbmQgYSB2YWx1ZSBzZXQgVVJMIHNwZWNpZmllZCBpbiB0aGUgUXVlc3Rpb25uYWlyZSBpdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCAtIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb250ZXh0IG9mIGV4cHJlc3Npb25cbiAqICBldmFsdWF0aW9uIChzZWUgdGhlIFwiYXBwbHlQYXJzZWRQYXRoXCIgZnVuY3Rpb24pLlxuICogQHBhcmFtIHtPYmplY3R9IHFJdGVtIC0gcXVlc3Rpb25uYWlyZSBpdGVtLlxuICogQHBhcmFtIHthbnl9IHZhbHVlIC0gaXRlbSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSBpdGVtIHZhbHVlIHR5cGUuXG4gKiBAcmV0dXJucyB7e1xuICogICBzY29yZTogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICogICBhbnN3ZXJPcHRpb246IE9iamVjdCB8IHVuZGVmaW5lZCxcbiAqICAgYW5zd2VyVmFsdWVTZXQ6IHN0cmluZ1xuICogICB9fVxuICovXG5mdW5jdGlvbiBnZXRRdWVzdGlvbm5haXJlSXRlbUluZm8oY3R4LCBxSXRlbSwgdmFsdWUsIHZhbHVlVHlwZSkge1xuICBsZXQgY29tcGFyZUZuO1xuICBjb25zdCB2YWx1ZVByb3BOYW1lID0gJ3ZhbHVlJyt2YWx1ZVR5cGU7XG5cbiAgc3dpdGNoICh2YWx1ZVR5cGUpIHtcbiAgICBjYXNlICdBdHRhY2htZW50JzpcbiAgICBjYXNlICdRdWFudGl0eSc6XG4gICAgY2FzZSAnUmVmZXJlbmNlJzpcbiAgICAgIGNvbXBhcmVGbiA9IG8gPT4gT2JqZWN0LmtleXModmFsdWUpLmZpbmQoXG4gICAgICAgIChwcm9wS2V5KSA9PiBwcm9wS2V5ICE9PSAnZXh0ZW5zaW9uJyAmJiBvW3ZhbHVlUHJvcE5hbWVdW3Byb3BLZXldICE9PSB2YWx1ZVtwcm9wS2V5XVxuICAgICAgKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQ29kaW5nJzpcbiAgICAgIGNvbXBhcmVGbiA9IG8gPT4gby52YWx1ZUNvZGluZz8uY29kZSA9PT0gdmFsdWUuY29kZSAmJlxuICAgICAgICBvLnZhbHVlQ29kaW5nPy5zeXN0ZW0gPT09IHZhbHVlLnN5c3RlbTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21wYXJlRm4gPSBvID0+IG9bdmFsdWVQcm9wTmFtZV0gPT09IHZhbHVlO1xuICB9XG4gIGNvbnN0IGFuc3dlck9wdGlvbiA9IHFJdGVtPy5hbnN3ZXJPcHRpb24/LmZpbmQoY29tcGFyZUZuKTtcbiAgY29uc3Qgc2NvcmUgPVxuICAgIGdldFNjb3JlRXh0ZW5zaW9uVmFsdWUoYW5zd2VyT3B0aW9uLCBjdHgubW9kZWwuc2NvcmUuZXh0ZW5zaW9uVVJJKTtcbiAgY29uc3QgYW5zd2VyVmFsdWVTZXQgPSBxSXRlbT8uYW5zd2VyVmFsdWVTZXQ7XG4gIHJldHVybiB7c2NvcmUsIGFuc3dlck9wdGlvbiwgYW5zd2VyVmFsdWVTZXR9O1xufVxuXG5cbi8vIE9iamVjdCBmb3Igc3RvcmluZyByZWNlaXZlZCBzY29yZXNcbmNvbnN0IHdlaWdodENhY2hlID0ge307XG4vLyBEdXJhdGlvbiBvZiBkYXRhIHN0b3JhZ2UgaW4gY2FjaGUuXG5jb25zdCBjYWNoZVN0b3JhZ2VUaW1lID0gMzYwMDAwMDsgLy8gMSBob3VyID0gNjAgKiA2MCAqIDEwMDBcblxuXG4vKipcbiAqIENhY2hlcyBzY29yZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXkgdG8gc3RvcmUgc2NvcmUgaW4gY2FjaGUuXG4gKiBAcGFyYW0ge251bWJlcnxQcm9taXNlfSB2YWx1ZSAtIHZhbHVlIG9mIHNjb3JlIG9yIHByb21pc2Ugb2YgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHB1dFNjb3JlVG9DYWNoZShrZXksIHZhbHVlKSB7XG4gIHdlaWdodENhY2hlW2tleV0gPSB7XG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIHZhbHVlXG4gIH07XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlcmUgaXMgYW4gdW5leHBpcmVkIHNjb3JlIGluIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXkgdG8gc3RvcmUgc2NvcmUgaW4gY2FjaGUuXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gaGFzU2NvcmVJbkNhY2hlKGtleSkge1xuICByZXR1cm4gd2VpZ2h0Q2FjaGVba2V5XSAmJiBEYXRlLm5vdygpIC0gd2VpZ2h0Q2FjaGVba2V5XS50aW1lc3RhbXAgPCBjYWNoZVN0b3JhZ2VUaW1lO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHNjb3JlIG9yIHByb21pc2Ugb2Ygc2NvcmUgZnJvbSB0aGUgY2FjaGUuIERvZXMgbm90IGNoZWNrIHRoZVxuICogZXhwaXJhdGlvbiB0aW1lLiB7QGxpbmsgaGFzU2NvcmVJbkNhY2hlfSBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGlzXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXkgdG8gc3RvcmUgc2NvcmUgaW4gY2FjaGUuXG4gKiBAcmV0dXJuIHtudW1iZXIgfCBQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXRTY29yZUZyb21DYWNoZShrZXkpIHtcbiAgcmV0dXJuIHdlaWdodENhY2hlW2tleV0udmFsdWU7XG59XG5cblxuLyoqXG4gKiBBZGRzIHRoZSB2YWx1ZSBvZiBzY29yZSBvciBpdHMgcHJvbWlzZSByZWNlaXZlZCBmcm9tIGEgY29ycmVzcG9uZGluZyB2YWx1ZVxuICogc2V0IG9yIGNvZGUgc3lzdGVtIHRvIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSByZXMgLSByZXN1bHQgYXJyYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgb2YgZXhwcmVzc2lvblxuICogIGV2YWx1YXRpb24gKHNlZSB0aGUgXCJhcHBseVBhcnNlZFBhdGhcIiBmdW5jdGlvbikuXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlc3Rpb25uYWlyZSAtIG9iamVjdCBjb250YWluaW5nIHF1ZXN0aW9ubmFpcmUgcmVzb3VyY2UgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHZzVVJMIC0gdmFsdWUgc2V0IFVSTCBzcGVjaWZpZWQgaW4gdGhlIFF1ZXN0aW9ubmFpcmUgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gc3ltYm9sIGluIHN5bnRheCBkZWZpbmVkIGJ5IHRoZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gY29kZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge1Jlc291cmNlTm9kZXxhbnl9IGVsZW0gLSBzb3VyY2UgY29sbGVjdGlvbiBpdGVtIGZvciB3aGljaCB3ZSBvYnRhaW5cbiAqICB0aGUgc2NvcmUgdmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBhIGZsYWcgaW5kaWNhdGluZyB0aGF0IGEgcHJvbWlzZSBoYXMgYmVlbiBhZGRlZCB0byB0aGVcbiAqICByZXN1bHRpbmcgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFkZFdlaWdodEZyb21Db3JyZXNwb25kaW5nUmVzb3VyY2VzVG9SZXN1bHQocmVzLCBjdHgsIHF1ZXN0aW9ubmFpcmUsXG4gIHZzVVJMLCBjb2RlLCBzeXN0ZW0sIGVsZW0pIHtcbiAgbGV0IHNjb3JlO1xuICBjb25zdCBtb2RlbFZlcnNpb24gPSBjdHgubW9kZWw/LnZlcnNpb247XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIG1vZGVsVmVyc2lvbixcbiAgICBxdWVzdGlvbm5haXJlPy51cmwgfHwgcXVlc3Rpb25uYWlyZT8uaWQsXG4gICAgY3R4LnByb2Nlc3NlZFZhcnMudGVybWlub2xvZ2llcz8udGVybWlub2xvZ3lVcmwsXG4gICAgdnNVUkwsIGNvZGUsIHN5c3RlbVxuICBdLmpvaW4oJ3wnKTtcblxuICBpZiAoaGFzU2NvcmVJbkNhY2hlKGNhY2hlS2V5KSkge1xuICAgIHNjb3JlID0gIGdldFNjb3JlRnJvbUNhY2hlKGNhY2hlS2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29kZSkge1xuICAgICAgaWYgKHZzVVJMKSB7XG4gICAgICAgIGNvbnN0IHZzSWQgPSAvXiMoLiopLy50ZXN0KHZzVVJMKSA/IFJlZ0V4cC4kMSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGlzQW5zd2VyVmFsdWVTZXQgPSB2c0lkXG4gICAgICAgICAgPyAocikgPT4gci5pZCA9PT0gdnNJZCAmJiByLnJlc291cmNlVHlwZSA9PT0gJ1ZhbHVlU2V0J1xuICAgICAgICAgIDogKHIpID0+IHIudXJsID09PSB2c1VSTCAmJiByLnJlc291cmNlVHlwZSA9PT0gJ1ZhbHVlU2V0JztcblxuICAgICAgICBjb25zdCBjb250YWluZWRWUyA9IHF1ZXN0aW9ubmFpcmU/LmNvbnRhaW5lZD8uZmluZChpc0Fuc3dlclZhbHVlU2V0KTtcblxuICAgICAgICBpZiAoY29udGFpbmVkVlMpIHtcbiAgICAgICAgICBzY29yZSA9IGdldFdlaWdodEZyb21WUyhjdHgsIGNvbnRhaW5lZFZTLCBjb2RlLCBzeXN0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZzSWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGZpbmQgYSBjb250YWluZWQgdmFsdWUgc2V0IHdpdGggaWQ6IGAgKyB2c0lkICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgaWYgKHZzVVJMKVxuXG4gICAgICBpZiAoc3lzdGVtKSB7XG4gICAgICAgIGlmIChzY29yZSA9PT0gdW5kZWZpbmVkIHx8IHNjb3JlID09PSBudWxsKSB7XG4gICAgICAgICAgc2NvcmUgPSBnZXRXZWlnaHRGcm9tQ1MoY3R4LCBxdWVzdGlvbm5haXJlLCBlbGVtLCBjb2RlLCBzeXN0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjb3JlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHNjb3JlID0gc2NvcmUudGhlbih3ZWlnaHRGcm9tVlMgPT4ge1xuICAgICAgICAgICAgaWYgKHdlaWdodEZyb21WUyAhPT0gdW5kZWZpbmVkICYmIHdlaWdodEZyb21WUyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0RnJvbVZTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFdlaWdodEZyb21DUyhjdHgsIHF1ZXN0aW9ubmFpcmUsIGVsZW0sIGNvZGUsIHN5c3RlbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXRTY29yZVRvQ2FjaGUoY2FjaGVLZXksIHNjb3JlKTtcbiAgfVxuXG4gIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzLnB1c2goc2NvcmUpO1xuICB9XG5cbiAgcmV0dXJuIHNjb3JlIGluc3RhbmNlb2YgUHJvbWlzZTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIChvciBpdHMgcHJvbWlzZSkgb2YgdGhlIGl0ZW1XZWlnaHQgcHJvcGVydHkgb3Igc2NvcmVcbiAqIGV4dGVuc2lvbiBmb3IgdGhlIHNwZWNpZmllZCBzeXN0ZW0gYW5kIGNvZGUgZnJvbSBhIENvZGVTeXN0ZW0uXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgb2YgZXhwcmVzc2lvblxuICogIGV2YWx1YXRpb24gKHNlZSB0aGUgXCJhcHBseVBhcnNlZFBhdGhcIiBmdW5jdGlvbikuICogQHBhcmFtIGN0eFxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXN0aW9ubmFpcmUgLSBvYmplY3QgY29udGFpbmluZyBxdWVzdGlvbm5haXJlIHJlc291cmNlIGRhdGFcbiAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlfGFueX0gZWxlbSAtIHNvdXJjZSBjb2xsZWN0aW9uIGl0ZW0gZm9yIHdoaWNoIHdlIG9idGFpblxuICogIHRoZSBzY29yZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gc3ltYm9sIGluIHN5bnRheCBkZWZpbmVkIGJ5IHRoZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gY29kZSBzeXN0ZW0uXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfFByb21pc2U8bnVtYmVyfHVuZGVmaW5lZD59XG4gKi9cbmZ1bmN0aW9uIGdldFdlaWdodEZyb21DUyhjdHgsIHF1ZXN0aW9ubmFpcmUsIGVsZW0sIGNvZGUsIHN5c3RlbSkge1xuICBjb25zdCBpc0NvZGVTeXN0ZW0gPSAocikgPT4gci51cmwgPT09IHN5c3RlbSAmJiByLnJlc291cmNlVHlwZSA9PT0gJ0NvZGVTeXN0ZW0nO1xuICBjb25zdCBjb250YWluZWRDUyA9IGdldENvbnRhaW5lZFJlc291cmNlcyhlbGVtKT8uZmluZChpc0NvZGVTeXN0ZW0pXG4gICAgfHwgcXVlc3Rpb25uYWlyZT8uY29udGFpbmVkPy5maW5kKGlzQ29kZVN5c3RlbSk7XG4gIGxldCBzY29yZTtcblxuICBpZiAoY29udGFpbmVkQ1MpIHtcbiAgICBjb25zdCBzY29yZVByb3BlcnR5VXJpID0gY3R4Lm1vZGVsPy5zY29yZS5wcm9wZXJ0eVVSSTtcbiAgICBpZiAoc2NvcmVQcm9wZXJ0eVVyaSkge1xuICAgICAgY29uc3Qgc2NvcmVQcm9wZXJ0eUNvZGUgPSBnZXRQcm9wZXJ0eUNvZGUoY29udGFpbmVkQ1M/LnByb3BlcnR5LCBzY29yZVByb3BlcnR5VXJpKTtcbiAgICAgIGlmIChzY29yZVByb3BlcnR5Q29kZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gZ2V0Q29kZVN5c3RlbUl0ZW0oY29udGFpbmVkQ1M/LmNvbmNlcHQsIGNvZGUpO1xuICAgICAgICBzY29yZSA9IGdldERlY2ltYWxQcm9wZXJ0eVZhbHVlKGl0ZW0sIHNjb3JlUHJvcGVydHlDb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29kZVN5c3RlbUV4dCA9IGN0eC5tb2RlbD8uc2NvcmUuZXh0ZW5zaW9uVVJJO1xuICAgICAgaWYgKGNvZGVTeXN0ZW1FeHQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldENvZGVTeXN0ZW1JdGVtKGNvbnRhaW5lZENTPy5jb25jZXB0LCBjb2RlKTtcbiAgICAgICAgc2NvcmUgPSBnZXRTY29yZUV4dGVuc2lvblZhbHVlKGl0ZW0sIGNvZGVTeXN0ZW1FeHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzY29yZSA9IGdldFdlaWdodEZyb21UZXJtaW5vbG9neUNvZGVTZXQoY3R4LCBjb2RlLCBzeXN0ZW0pO1xuICB9XG5cbiAgcmV0dXJuIHNjb3JlO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdG8gcmV0dXJuIGEgc2NvcmUgdmFsdWUgZnJvbSB0aGUgY29kZSBzeXN0ZW0gb2J0YWluZWQgZnJvbVxuICogdGhlIHRlcm1pbm9sb2d5IHNlcnZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggLSBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29udGV4dCBvZiBleHByZXNzaW9uXG4gKiAgZXZhbHVhdGlvbiAoc2VlIHRoZSBcImFwcGx5UGFyc2VkUGF0aFwiIGZ1bmN0aW9uKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gc3ltYm9sIGluIHN5bnRheCBkZWZpbmVkIGJ5IHRoZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gY29kZSBzeXN0ZW0uXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcnx1bmRlZmluZWQ+fVxuICovXG5mdW5jdGlvbiBnZXRXZWlnaHRGcm9tVGVybWlub2xvZ3lDb2RlU2V0KGN0eCwgY29kZSwgc3lzdGVtKSB7XG4gIGNvbnN0IHNjb3JlUHJvcGVydHlVcmkgPSBjdHgubW9kZWw/LnNjb3JlLnByb3BlcnR5VVJJO1xuICBjb25zdCBjb2RlU3lzdGVtRXh0ID0gY3R4Lm1vZGVsPy5zY29yZS5leHRlbnNpb25VUkk7XG5cbiAgY29uc3QgdGVybWlub2xvZ3lVcmwgPSBnZXRUZXJtaW5vbG9neVVybChjdHgpO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9maGlyK2pzb24nXG4gICAgfSxcbiAgICAuLi4oY3R4LnNpZ25hbCA/IHtzaWduYWw6IGN0eC5zaWduYWx9IDoge30pXG4gIH07XG4gIHJldHVybiB1dGlsLmZldGNoV2l0aENhY2hlKGAke3Rlcm1pbm9sb2d5VXJsfS9Db2RlU3lzdGVtP2AgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICB1cmw6IHN5c3RlbSxcbiAgICAuLi4oc2NvcmVQcm9wZXJ0eVVyaSA/IHtfZWxlbWVudHM6ICdwcm9wZXJ0eSd9OiB7fSlcbiAgfSkudG9TdHJpbmcoKSwgZmV0Y2hPcHRpb25zKVxuICAgIC50aGVuKGJ1bmRsZSA9PiB7XG4gICAgICBpZiAoc2NvcmVQcm9wZXJ0eVVyaSkge1xuICAgICAgICBjb25zdCBzY29yZVByb3BlcnR5Q29kZSA9IGdldFByb3BlcnR5Q29kZShidW5kbGU/LmVudHJ5Py5bMF0/LnJlc291cmNlPy5wcm9wZXJ0eSwgc2NvcmVQcm9wZXJ0eVVyaSk7XG4gICAgICAgIGlmIChzY29yZVByb3BlcnR5Q29kZSkge1xuICAgICAgICAgIHJldHVybiB1dGlsLmZldGNoV2l0aENhY2hlKGAke3Rlcm1pbm9sb2d5VXJsfS9Db2RlU3lzdGVtLyRsb29rdXA/YCArIG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgY29kZSwgc3lzdGVtLCBwcm9wZXJ0eTogc2NvcmVQcm9wZXJ0eUNvZGVcbiAgICAgICAgICB9KS50b1N0cmluZygpLCBmZXRjaE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbigocGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5wYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAuZmluZChwID0+IHAubmFtZSA9PT0gJ3Byb3BlcnR5JyAmJiBwLnBhcnRcbiAgICAgICAgICAgICAgICAgIC5maW5kKHBhcnQgPT4gcGFydC5uYW1lID09PSAnY29kZScgJiYgcGFydC52YWx1ZUNvZGUgPT09IHNjb3JlUHJvcGVydHlDb2RlKSlcbiAgICAgICAgICAgICAgICA/LnBhcnQ/LmZpbmQocCA9PiBwLm5hbWUgPT09ICd2YWx1ZScpPy52YWx1ZURlY2ltYWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldENvZGVTeXN0ZW1JdGVtKGJ1bmRsZT8uZW50cnk/LlswXT8ucmVzb3VyY2UuY29uY2VwdCwgY29kZSk7XG4gICAgICAgIHJldHVybiBnZXRTY29yZUV4dGVuc2lvblZhbHVlKGl0ZW0sIGNvZGVTeXN0ZW1FeHQpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB0ZXJtaW5vbG9neSBzZXJ2ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgb2YgZXhwcmVzc2lvblxuICogIGV2YWx1YXRpb24gKHNlZSB0aGUgXCJhcHBseVBhcnNlZFBhdGhcIiBmdW5jdGlvbikuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRlcm1pbm9sb2d5VXJsKGN0eCkge1xuICBpZiAoIWN0eC5hc3luYykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBcIndlaWdodFwiL1wib3JkaW5hbFwiIGlzIG5vdCBhbGxvd2VkLiAnICtcbiAgICAgICdUbyBlbmFibGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucywgdXNlIHRoZSBhc3luYz10cnVlIG9yIGFzeW5jPVwiYWx3YXlzXCInICtcbiAgICAgICcgb3B0aW9uLicpO1xuICB9XG5cbiAgY29uc3QgdGVybWlub2xvZ3lVcmwgPSBjdHgucHJvY2Vzc2VkVmFycy50ZXJtaW5vbG9naWVzPy50ZXJtaW5vbG9neVVybDtcbiAgaWYgKCF0ZXJtaW5vbG9neVVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIFwidGVybWlub2xvZ3lVcmxcIiBpcyBub3Qgc3BlY2lmaWVkLicpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm1pbm9sb2d5VXJsO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBpdGVtIGZyb20gXCJWYWx1ZVNldC5leHBhbnNpb24uY29udGFpbnNcIiB0aGF0IGhhcyB0aGUgc3BlY2lmaWVkXG4gKiBjb2RlIGFuZCBzeXN0ZW0uXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNvbnRhaW5zIC0gdmFsdWUgb2YgXCJWYWx1ZVNldC5leHBhbnNpb24uY29udGFpbnNcIi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gc3ltYm9sIGluIHN5bnRheCBkZWZpbmVkIGJ5IHRoZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gY29kZSBzeXN0ZW0uXG4gKiBAcmV0dXJuIHtPYmplY3R8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVTZXRJdGVtKGNvbnRhaW5zLCBjb2RlLCBzeXN0ZW0pIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGNvbnRhaW5zKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbnRhaW5zLmxlbmd0aCAmJiAhcmVzdWx0OyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBjb250YWluc1tpXTtcbiAgICAgIGlmIChpdGVtLmNvZGUgPT09IGNvZGUgJiYgaXRlbS5zeXN0ZW0gPT09IHN5c3RlbSkge1xuICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZ2V0VmFsdWVTZXRJdGVtKGl0ZW0uY29udGFpbnMsIGNvZGUsIHN5c3RlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZW0gZnJvbSBcIkNvZGVTeXN0ZW0uY29uY2VwdFwiIHRoYXQgaGFzIHRoZSBzcGVjaWZpZWQgY29kZS5cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29uY2VwdCAtIHZhbHVlIG9mIFwiQ29kZVN5c3RlbS5jb25jZXB0XCIuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIHN5bWJvbCBpbiBzeW50YXggZGVmaW5lZCBieSB0aGUgc3lzdGVtLlxuICogQHJldHVybiB7T2JqZWN0fCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVTeXN0ZW1JdGVtKGNvbmNlcHQsIGNvZGUpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGNvbmNlcHQpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29uY2VwdC5sZW5ndGggJiYgIXJlc3VsdDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gY29uY2VwdFtpXTtcbiAgICAgIGlmIChpdGVtLmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5jb25jZXB0KSB7XG4gICAgICAgIHJlc3VsdCA9IGdldENvZGVTeXN0ZW1JdGVtKGl0ZW0uY29uY2VwdCwgY29kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zICBhIHByb3BlcnR5IGNvZGUgZnJvbSB0aGUgYXJyYXkgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiBzdXBwbGllZCBhYm91dCBlYWNoIGNvbmNlcHQgYnkgaXRzIFVSSS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gVmFsdWVTZXQuZXhwYW5zaW9uLnByb3BlcnR5IG9yXG4gKiAgQ29kZVN5c3RlbS5wcm9wZXJ0eS5cbiAqICBAcGFyYW0ge3N0cmluZ30gdXJpIC0gcHJvcGVydHkgVVJJLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlDb2RlKHByb3BlcnRpZXMsIHVyaSkge1xuICByZXR1cm4gcHJvcGVydGllcz8uZmluZChwID0+IHAudXJpID09PSB1cmkpPy5jb2RlO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVjaW1hbCB2YWx1ZSBvZiBhIHByb3BlcnR5IGZyb20gYSB2YWx1ZSBzZXQgaXRlbSBvciBjb2RlXG4gKiBzeXN0ZW0gY29uY2VwdCBpdGVtIGJ5IGl0cyBjb2RlLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBhbiBpdGVtIGZyb20gYSBWYWx1ZVNldC5leHBhbnNpb24uY29udGFpbnMgb3JcbiAqICBDb2RlU3lzdGVtLmNvbmNlcHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29kZSAtIHByb3BlcnR5IGNvZGUuXG4gKiBAcmV0dXJuIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldERlY2ltYWxQcm9wZXJ0eVZhbHVlKGl0ZW0sIGNvZGUpIHtcbiAgcmV0dXJuIGl0ZW0/LnByb3BlcnR5Py5maW5kKHAgPT4gcC5jb2RlID09PSBjb2RlKT8udmFsdWVEZWNpbWFsO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGl0ZW1XZWlnaHQgcHJvcGVydHkgb3Igc2NvcmUgZXh0ZW5zaW9uIGZvciB0aGVcbiAqIHNwZWNpZmllZCBzeXN0ZW0gYW5kIGNvZGUgZnJvbSBhIHZhbHVlIHNldC4gSWYgdGhlIGl0ZW0gaW4gdGhlIHZhbHVlIHNldCBoYXNcbiAqIG5vIHNjb3JlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuIElmIHRoZSBpdGVtIGRvZXMgbm90IGV4aXN0LCBudWxsIGlzIHJldHVybmVkLlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIG1heSBiZSB1c2VkIGluIHBhZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggLSBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29udGV4dCBvZiBleHByZXNzaW9uXG4gKiAgZXZhbHVhdGlvbiAoc2VlIHRoZSBcImFwcGx5UGFyc2VkUGF0aFwiIGZ1bmN0aW9uKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2cyAtIFZhbHVlU2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBzeW1ib2wgaW4gc3ludGF4IGRlZmluZWQgYnkgdGhlIHN5c3RlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzeXN0ZW0gLSBjb2RlIHN5c3RlbS5cbiAqIEByZXR1cm4ge251bWJlcnxudWxsfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0V2VpZ2h0RnJvbVZTKGN0eCwgdnMsIGNvZGUsIHN5c3RlbSkge1xuICBsZXQgc2NvcmU7XG4gIGxldCBpdGVtO1xuICBjb25zdCBzY29yZVByb3BlcnR5VXJpID0gY3R4Lm1vZGVsPy5zY29yZS5wcm9wZXJ0eVVSSTtcbiAgaWYgKHNjb3JlUHJvcGVydHlVcmkpIHtcbiAgICAvLyBcIlZhbHVlU2V0LmV4cGFuc2lvbi5jb250YWluc1wiIGZvciBSNVxuICAgIGNvbnN0IHNjb3JlUHJvcGVydHlDb2RlID0gZ2V0UHJvcGVydHlDb2RlKFxuICAgICAgdnMuZXhwYW5zaW9uPy5wcm9wZXJ0eSwgc2NvcmVQcm9wZXJ0eVVyaVxuICAgICk7XG4gICAgaWYgKHNjb3JlUHJvcGVydHlDb2RlKSB7XG4gICAgICBpdGVtID0gZ2V0VmFsdWVTZXRJdGVtKHZzLmV4cGFuc2lvbj8uY29udGFpbnMsIGNvZGUsIHN5c3RlbSk7XG4gICAgICBzY29yZSA9IGdldERlY2ltYWxQcm9wZXJ0eVZhbHVlKGl0ZW0sIHNjb3JlUHJvcGVydHlDb2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJWYWx1ZVNldC5jb21wb3NlLmluY2x1ZGUuY29uY2VwdFwiIGZvciBSNFxuICAgIGNvbnN0IGluY2x1ZGVFeHQgPSBjdHgubW9kZWw/LnNjb3JlLmV4dGVuc2lvblVSSTtcbiAgICBjb25zdCBpbmNsdWRlID0gdnMuY29tcG9zZT8uaW5jbHVkZTtcbiAgICBjb25zdCBsZW4gPSBpbmNsdWRlPy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gJiYgIWl0ZW07ICsraSkge1xuICAgICAgaWYgKGluY2x1ZGVbaV0uc3lzdGVtID09PSBzeXN0ZW0pIHtcbiAgICAgICAgaXRlbSA9IGdldENvZGVTeXN0ZW1JdGVtKGluY2x1ZGVbaV0uY29uY2VwdCwgY29kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNjb3JlID0gZ2V0U2NvcmVFeHRlbnNpb25WYWx1ZShpdGVtLCBpbmNsdWRlRXh0KTtcbiAgfVxuXG4gIHJldHVybiBpdGVtID8gc2NvcmUgOiBudWxsO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBsaW5rSWRzIG9mIGFuY2VzdG9yIFJlc291cmNlTm9kZXMgYW5kIHNvdXJjZSBSZXNvdXJjZU5vZGVcbiAqIHN0YXJ0aW5nIHdpdGggdGhlIGxpbmtJZCBvZiB0aGUgZ2l2ZW4gbm9kZSBhbmQgZW5kaW5nIHdpdGggdGhlIHRvcG1vc3QgaXRlbSdzXG4gKiBsaW5rSWQuXG4gKiBAcGFyYW0ge1Jlc291cmNlTm9kZX0gbm9kZSAtIHNvdXJjZSBSZXNvdXJjZU5vZGUuXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGlua0lkcyhub2RlKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuXG4gIHdoaWxlICghbm9kZS5kYXRhPy5saW5rSWQgJiYgbm9kZT8ucGFyZW50UmVzTm9kZSkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudFJlc05vZGU7XG4gIH1cblxuICB3aGlsZSAobm9kZT8uZGF0YT8ubGlua0lkKSB7XG4gICAgcmVzLnB1c2gobm9kZS5kYXRhLmxpbmtJZCk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50UmVzTm9kZTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcImNvbnRhaW5lZFwiIHByb3BlcnR5IG9mIHRoZSByZXNvdXJjZSB0byB3aGljaCB0aGUgUmVzb3VyY2VOb2RlXG4gKiBiZWxvbmdzLCBvciBhbiB1bmRlZmluZWQgdmFsdWUgaWYgbm90IGEgUmVzb3VyY2VOb2RlIHdhcyBwYXNzZWQgb3IgaWYgdGhlcmVcbiAqIGlzIG5vIGNvbnRhaW5lZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlfGFueX0gbm9kZSAtIHNvdXJjZSBSZXNvdXJjZU5vZGUgb3Igc29tZXRoaW5nIGVsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3RbXXx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRhaW5lZFJlc291cmNlcyhub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUuZGF0YT8ucmVzb3VyY2VUeXBlICYmIG5vZGUuZGF0YT8uY29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gbm9kZS5kYXRhPy5jb250YWluZWQ7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudFJlc05vZGU7XG4gIH1cbn1cblxuXG4vKipcbiAqIE1hcHBpbmcgcXVlc3Rpb25uYWlyZXMgdG8gXCJsaW5rSWRzXCIga2V5cyBtYXBwZWQgdG8gcXVlc3Rpb25uYWlyZSBpdGVtcy5cbiAqIEl0IGlzIHVzZWQgdG8gY2FjaGUgdGhlIHJlc3VsdCBpbiB0aGUgZ2V0UUl0ZW1CeUxpbmtJZHMgZnVuY3Rpb24uXG4gKiBAdHlwZSB7V2Vha01hcDxXZWFrS2V5LCBPYmplY3Q+fVxuICovXG5jb25zdCBxdWVzdGlvbm5haXJlMmxpbmtJZHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHF1ZXN0aW9ubmFpcmUgaXRlbSBiYXNlZCBvbiB0aGUgbGlua0lkcyBhcnJheSBvZiB0aGUgYW5jZXN0b3JcbiAqIFJlc291cmNlTm9kZXMgYW5kIHRoZSB0YXJnZXQgUmVzb3VyY2VOb2RlLiBJZiB0aGUgcXVlc3Rpb25uYWlyZSBpdGVtIGlzIG5vdFxuICogZm91bmQsIGl0IHJldHVybnMgbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbFZlcnNpb24gLSBtb2RlbCB2ZXJzaW9uOiAncjUnLCAncjQnLCAnc3R1MycsIG9yICdkc3R1MicuXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlc3Rpb25uYWlyZSAtIG9iamVjdCB3aXRoIGEgUXVlc3Rpb25uYWlyZSByZXNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGxpbmtJZHMgLSBhcnJheSBvZiBsaW5rSWRzIHN0YXJ0aW5nIHdpdGggdGhlIGxpbmtJZCBvZiB0aGVcbiAqIHRhcmdldCBub2RlIGFuZCBlbmRpbmcgd2l0aCB0aGUgdG9wbW9zdCBrbm93biBpdGVtJ3MgbGlua0lkLlxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0UUl0ZW1CeUxpbmtJZHMobW9kZWxWZXJzaW9uLCBxdWVzdGlvbm5haXJlLCBsaW5rSWRzKSB7XG4gIGxldCBjdXJyZW50Tm9kZTtcbiAgLy8gTWFwcGluZyBcImxpbmtJZHNcIiBrZXlzIHRvIHF1ZXN0aW9ubmFpcmUgaXRlbXMuXG4gIGxldCBsaW5rSWRzMml0ZW1zO1xuICAvLyBcImxpbmtJZHNcIiBrZXkuXG4gIGNvbnN0IGxpbmtJZHNLZXkgPSBsaW5rSWRzLmpvaW4oJ3wnKTtcblxuICAvLyBHZXQgdGhlIG1hcHBpbmcgb2YgXCJsaW5rSWRzXCIga2V5cyB0byBxdWVzdGlvbm5haXJlIGl0ZW1zIGZvciB0aGUgY3VycmVudFxuICAvLyBxdWVzdGlvbm5haXJlLCBvciBjcmVhdGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgaWYgKHF1ZXN0aW9ubmFpcmUybGlua0lkcy5oYXMocXVlc3Rpb25uYWlyZSkpIHtcbiAgICBsaW5rSWRzMml0ZW1zID0gcXVlc3Rpb25uYWlyZTJsaW5rSWRzLmdldChxdWVzdGlvbm5haXJlKTtcbiAgICBjdXJyZW50Tm9kZSA9ICBsaW5rSWRzMml0ZW1zW2xpbmtJZHNLZXldO1xuICB9IGVsc2Uge1xuICAgIGxpbmtJZHMyaXRlbXMgPSB7fTtcbiAgICBxdWVzdGlvbm5haXJlMmxpbmtJZHMuc2V0KHF1ZXN0aW9ubmFpcmUsIGxpbmtJZHMyaXRlbXMpO1xuICB9XG5cbiAgLy8gV2UgdXNlIFwiaGFzT3duUHJvcGVydHlcIiBiZWNhdXNlIHdlIGFsc28gY2FjaGUgdW5kZWZpbmVkIHJlc3VsdHMgZm9yIHNjb3Jlcy5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlua0lkczJpdGVtcywgbGlua0lkc0tleSkpIHtcbiAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIG5vdCBjYWNoZWQgeWV0LCB3ZSBzZWFyY2ggZm9yIHRoZSBxdWVzdGlvbm5haXJlIGl0ZW0uXG4gICAgY29uc3QgdG9wTGlua0lkID0gbGlua0lkc1tsaW5rSWRzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG1vZGVsVmVyc2lvbiA9PT0gJ2RzdHUyJykge1xuICAgICAgLy8gU2VhcmNoIGZvciBhbiBpdGVtIGluIGEgcXVlc3Rpb25uYWlyZSBzcGVjaWZpZWQgaW4gRFNUVTIgZm9ybWF0LlxuICAgICAgbGV0IGNvbGxlY3Rpb24gPSBxdWVzdGlvbm5haXJlLmdyb3VwO1xuXG4gICAgICAvLyBGaW5kIHRoZSBxdWVzdGlvbm5haXJlIGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBsaW5rSWQgb2YgdGhlIHRvcG1vc3RcbiAgICAgIC8vIGtub3duIGl0ZW0uXG4gICAgICB3aGlsZSAoY29sbGVjdGlvbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNvbGxlY3Rpb24uZmluZChvID0+IG8ubGlua0lkID09PSB0b3BMaW5rSWQpO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gW10uY29uY2F0KC4uLmNvbGxlY3Rpb24ubWFwKGkgPT4gW10uY29uY2F0KGkucXVlc3Rpb24gfHwgW10sIGkuZ3JvdXAgfHwgW10pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0dGluZyBhIHF1ZXN0aW9ubmFpcmUgaXRlbSByZWxhdGl2ZSB0byB0aGUgdG9wbW9zdCBrbm93biBpdGVtIHVzaW5nXG4gICAgICAvLyBzdWJzZXF1ZW50IGxpbmtJZHMuXG4gICAgICBmb3IgKGxldCBpID0gbGlua0lkcy5sZW5ndGggLSAyOyBpID49IDAgJiYgY3VycmVudE5vZGU7IC0taSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnF1ZXN0aW9uPy5maW5kKG8gPT4gby5saW5rSWQgPT09IGxpbmtJZHNbaV0pIHx8XG4gICAgICAgICAgY3VycmVudE5vZGUuZ3JvdXA/LmZpbmQobyA9PiBvLmxpbmtJZCA9PT0gbGlua0lkc1tpXSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VhcmNoIGZvciBhbiBpdGVtIGluIGEgcXVlc3Rpb25uYWlyZSBzcGVjaWZpZWQgaW4gU1RVMywgUjQgb3IgUjVcbiAgICAgIC8vIGZvcm1hdC5cbiAgICAgIGxldCBjb2xsZWN0aW9uID0gcXVlc3Rpb25uYWlyZS5pdGVtO1xuXG4gICAgICAvLyBGaW5kIHRoZSBxdWVzdGlvbm5haXJlIGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBsaW5rSWQgb2YgdGhlIHRvcG1vc3RcbiAgICAgIC8vIGtub3duIGl0ZW0uXG4gICAgICB3aGlsZSAoY29sbGVjdGlvbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNvbGxlY3Rpb24uZmluZChvID0+IG8ubGlua0lkID09PSB0b3BMaW5rSWQpO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gW10uY29uY2F0KC4uLmNvbGxlY3Rpb24ubWFwKGkgPT4gaS5pdGVtIHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0dGluZyBhIHF1ZXN0aW9ubmFpcmUgaXRlbSByZWxhdGl2ZSB0byB0aGUgdG9wbW9zdCBrbm93biBpdGVtIHVzaW5nXG4gICAgICAvLyBzdWJzZXF1ZW50IGxpbmtJZHMuXG4gICAgICBmb3IgKGxldCBpID0gbGlua0lkcy5sZW5ndGggLSAyOyBpID49IDAgJiYgY3VycmVudE5vZGU7IC0taSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLml0ZW0/LmZpbmQobyA9PiBvLmxpbmtJZCA9PT0gbGlua0lkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlua0lkczJpdGVtc1tsaW5rSWRzS2V5XSA9IGN1cnJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnROb2RlO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/sdc-ig-supplements.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/strings.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/strings.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\nconst misc = __webpack_require__(/*! ./misc */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/misc.js\");\n\nconst engine = {};\n\n// Cache for rewritten RegExp patterns\nconst cachedRegExp = {};\n\n/**\n * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:\n * To do that we replace \".\" with \"[^]\" in source RegExp pattern,\n * except where \".\" is escaped or is inside unescaped [].\n * Another way to do the same is using package regexpu-core\n * or packages regjsparser/regjsgen.\n * @param {string} pattern - source RegExp pattern\n * @return {string}\n */\nfunction rewritePatternForDotAll(pattern) {\n  if (!cachedRegExp[pattern]) {\n    cachedRegExp[pattern] = pattern.replace(/\\./g, (_, offset, entirePattern) => {\n      // The preceding part of the string\n      const precedingPart = entirePattern.substr(0, offset);\n      // The preceding part of the string without escaped characters: '\\', '[' or ']'\n      const cleanPrecedingPart = precedingPart\n        .replace(/\\\\\\\\/g, '')\n        .replace(/\\\\[\\][]/g, '');\n      // Check if '.' is escaped\n      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\\\';\n      // The last index of unescaped '['\n      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('[');\n      // The last index of unescaped ']'\n      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');\n      return escaped ||\n        (lastIndexOfOpenBracket > lastIndexOfCloseBracket)\n        ? '.'\n        : '[^]';\n    });\n  }\n\n  return cachedRegExp[pattern];\n}\n\nengine.indexOf = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);\n};\n\nengine.substring = function (coll, start, length) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {\n    return [];\n  }\n  if (length === undefined || util.isEmpty(length)) {\n    return str.substring(start);\n  }\n  return str.substring(start, start + length);\n};\n\nengine.startsWith = function (coll, prefix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);\n};\n\nengine.endsWith = function (coll, postfix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);\n};\n\nengine.containsFn = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);\n};\n\nengine.upper = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toUpperCase();\n};\n\nengine.lower = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toLowerCase();\n};\n\n// See https://build.fhir.org/ig/HL7/FHIRPath/#joinseparator-string-string\nengine.joinFn = function (coll, separator) {\n  const stringValues = [];\n  coll.forEach((n) => {\n    const d = util.valData(n);\n    if (typeof d === \"string\") {\n      stringValues.push(d);\n    } else if (d != null) {\n      throw new Error('Join requires a collection of strings.');\n    }\n  });\n  if (util.isEmpty(stringValues)) {\n    return [];\n  }\n  if (separator === undefined) {\n    separator = \"\";\n  }\n  return stringValues.join(separator);\n};\n\nengine.splitFn = function (coll, separator) {\n  const strToSplit = misc.singleton(coll, 'String');\n  return util.isEmpty(strToSplit) ? [] : strToSplit.split(separator);\n};\n\nengine.trimFn = function (coll) {\n  const strToTrim = misc.singleton(coll, 'String');\n  return util.isEmpty(strToTrim) ? [] : strToTrim.trim();\n};\n\n// encoding/decoding\nengine.encodeFn = function (coll, format) {\n  const strToEncode = misc.singleton(coll, 'String');\n  if (util.isEmpty(strToEncode)){\n    return [];\n  }\n  if (format === 'urlbase64' || format === 'base64url'){\n    return btoa(strToEncode).replace(/\\+/g, '-').replace(/\\//g, '_');\n  }\n  if (format === 'base64'){\n    return btoa(strToEncode);\n  }\n  if (format === 'hex'){\n    return  Array.from(strToEncode).map(c => \n      c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : \n        encodeURIComponent(c).replace(/%/g,'')\n    ).join('');\n  }\n  return [];\n};\n\nengine.decodeFn = function (coll, format) {\n  const strDecode = misc.singleton(coll, 'String');\n  if (util.isEmpty(strDecode)){\n    return [];\n  }\n  if (format === 'urlbase64' || format === 'base64url'){\n    return atob(strDecode.replace(/-/g, '+').replace(/_/g, '/'));\n  }\n  if (format === 'base64'){\n    return atob(strDecode);\n  }\n  if (format === 'hex'){\n    if (strDecode.length % 2 !== 0){\n      throw new Error('Decode \\'hex\\' requires an even number of characters.');\n    }\n    return decodeURIComponent('%' + strDecode.match(/.{2}/g).join('%'));\n  }\n  return [];\n};\n\n// Check if dotAll is supported.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.\nconst dotAllIsSupported = (new RegExp('')).dotAll === false;\n\nif (dotAllIsSupported) {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(regex, 'su');\n    return reg.test(str);\n  };\n} else {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(rewritePatternForDotAll(regex), 'u');\n    return reg.test(str);\n  };\n}\n\nengine.replace = function (coll, pattern, repl) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');\n  return str.replace(reg, repl);\n};\n\nengine.replaceMatches = function (coll, regex, repl) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(regex, 'gu');\n  return str.replace(reg, repl);\n};\n\nengine.length = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.length;\n};\n\nengine.toChars = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.split('');\n};\n\nmodule.exports = engine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLHVHQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw2RkFBUTs7QUFFN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy9zdHJpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5jb25zdCBtaXNjID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcblxuY29uc3QgZW5naW5lID0ge307XG5cbi8vIENhY2hlIGZvciByZXdyaXR0ZW4gUmVnRXhwIHBhdHRlcm5zXG5jb25zdCBjYWNoZWRSZWdFeHAgPSB7fTtcblxuLyoqXG4gKiBSZXdyaXRlcyBSZWdFeHAgcGF0dGVybiB0byBzdXBwb3J0IHNpbmdsZS1saW5lIG1vZGUgKGRvdEFsbCkgaW4gSUUxMTpcbiAqIFRvIGRvIHRoYXQgd2UgcmVwbGFjZSBcIi5cIiB3aXRoIFwiW15dXCIgaW4gc291cmNlIFJlZ0V4cCBwYXR0ZXJuLFxuICogZXhjZXB0IHdoZXJlIFwiLlwiIGlzIGVzY2FwZWQgb3IgaXMgaW5zaWRlIHVuZXNjYXBlZCBbXS5cbiAqIEFub3RoZXIgd2F5IHRvIGRvIHRoZSBzYW1lIGlzIHVzaW5nIHBhY2thZ2UgcmVnZXhwdS1jb3JlXG4gKiBvciBwYWNrYWdlcyByZWdqc3BhcnNlci9yZWdqc2dlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIC0gc291cmNlIFJlZ0V4cCBwYXR0ZXJuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVQYXR0ZXJuRm9yRG90QWxsKHBhdHRlcm4pIHtcbiAgaWYgKCFjYWNoZWRSZWdFeHBbcGF0dGVybl0pIHtcbiAgICBjYWNoZWRSZWdFeHBbcGF0dGVybl0gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLi9nLCAoXywgb2Zmc2V0LCBlbnRpcmVQYXR0ZXJuKSA9PiB7XG4gICAgICAvLyBUaGUgcHJlY2VkaW5nIHBhcnQgb2YgdGhlIHN0cmluZ1xuICAgICAgY29uc3QgcHJlY2VkaW5nUGFydCA9IGVudGlyZVBhdHRlcm4uc3Vic3RyKDAsIG9mZnNldCk7XG4gICAgICAvLyBUaGUgcHJlY2VkaW5nIHBhcnQgb2YgdGhlIHN0cmluZyB3aXRob3V0IGVzY2FwZWQgY2hhcmFjdGVyczogJ1xcJywgJ1snIG9yICddJ1xuICAgICAgY29uc3QgY2xlYW5QcmVjZWRpbmdQYXJ0ID0gcHJlY2VkaW5nUGFydFxuICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcW1xcXVtdL2csICcnKTtcbiAgICAgIC8vIENoZWNrIGlmICcuJyBpcyBlc2NhcGVkXG4gICAgICBjb25zdCBlc2NhcGVkID0gY2xlYW5QcmVjZWRpbmdQYXJ0W2NsZWFuUHJlY2VkaW5nUGFydC5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnO1xuICAgICAgLy8gVGhlIGxhc3QgaW5kZXggb2YgdW5lc2NhcGVkICdbJ1xuICAgICAgY29uc3QgbGFzdEluZGV4T2ZPcGVuQnJhY2tldCA9IGNsZWFuUHJlY2VkaW5nUGFydC5sYXN0SW5kZXhPZignWycpO1xuICAgICAgLy8gVGhlIGxhc3QgaW5kZXggb2YgdW5lc2NhcGVkICddJ1xuICAgICAgY29uc3QgbGFzdEluZGV4T2ZDbG9zZUJyYWNrZXQgPSBjbGVhblByZWNlZGluZ1BhcnQubGFzdEluZGV4T2YoJ10nKTtcbiAgICAgIHJldHVybiBlc2NhcGVkIHx8XG4gICAgICAgIChsYXN0SW5kZXhPZk9wZW5CcmFja2V0ID4gbGFzdEluZGV4T2ZDbG9zZUJyYWNrZXQpXG4gICAgICAgID8gJy4nXG4gICAgICAgIDogJ1teXSc7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkUmVnRXhwW3BhdHRlcm5dO1xufVxuXG5lbmdpbmUuaW5kZXhPZiA9IGZ1bmN0aW9uIChjb2xsLCBzdWJzdHIpIHtcbiAgY29uc3Qgc3RyID0gbWlzYy5zaW5nbGV0b24oY29sbCwgJ1N0cmluZycpO1xuICByZXR1cm4gdXRpbC5pc0VtcHR5KHN1YnN0cikgfHwgdXRpbC5pc0VtcHR5KHN0cikgPyBbXSA6IHN0ci5pbmRleE9mKHN1YnN0cik7XG59O1xuXG5lbmdpbmUuc3Vic3RyaW5nID0gZnVuY3Rpb24gKGNvbGwsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgY29uc3Qgc3RyID0gbWlzYy5zaW5nbGV0b24oY29sbCwgJ1N0cmluZycpO1xuICBpZiAodXRpbC5pc0VtcHR5KHN0cikgfHwgdXRpbC5pc0VtcHR5KHN0YXJ0KSB8fCBzdGFydCA8IDAgfHwgc3RhcnQgPj0gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdXRpbC5pc0VtcHR5KGxlbmd0aCkpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCk7XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKTtcbn07XG5cbmVuZ2luZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKGNvbGwsIHByZWZpeCkge1xuICBjb25zdCBzdHIgPSBtaXNjLnNpbmdsZXRvbihjb2xsLCAnU3RyaW5nJyk7XG4gIHJldHVybiB1dGlsLmlzRW1wdHkocHJlZml4KSB8fCB1dGlsLmlzRW1wdHkoc3RyKSA/IFtdIDogc3RyLnN0YXJ0c1dpdGgocHJlZml4KTtcbn07XG5cbmVuZ2luZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChjb2xsLCBwb3N0Zml4KSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShwb3N0Zml4KSB8fCB1dGlsLmlzRW1wdHkoc3RyKSA/IFtdIDogc3RyLmVuZHNXaXRoKHBvc3RmaXgpO1xufTtcblxuZW5naW5lLmNvbnRhaW5zRm4gPSBmdW5jdGlvbiAoY29sbCwgc3Vic3RyKSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdWJzdHIpIHx8IHV0aWwuaXNFbXB0eShzdHIpID8gW10gOiBzdHIuaW5jbHVkZXMoc3Vic3RyKTtcbn07XG5cbmVuZ2luZS51cHBlciA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdHIpID8gW10gOiBzdHIudG9VcHBlckNhc2UoKTtcbn07XG5cbmVuZ2luZS5sb3dlciA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdHIpID8gW10gOiBzdHIudG9Mb3dlckNhc2UoKTtcbn07XG5cbi8vIFNlZSBodHRwczovL2J1aWxkLmZoaXIub3JnL2lnL0hMNy9GSElSUGF0aC8jam9pbnNlcGFyYXRvci1zdHJpbmctc3RyaW5nXG5lbmdpbmUuam9pbkZuID0gZnVuY3Rpb24gKGNvbGwsIHNlcGFyYXRvcikge1xuICBjb25zdCBzdHJpbmdWYWx1ZXMgPSBbXTtcbiAgY29sbC5mb3JFYWNoKChuKSA9PiB7XG4gICAgY29uc3QgZCA9IHV0aWwudmFsRGF0YShuKTtcbiAgICBpZiAodHlwZW9mIGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0cmluZ1ZhbHVlcy5wdXNoKGQpO1xuICAgIH0gZWxzZSBpZiAoZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pvaW4gcmVxdWlyZXMgYSBjb2xsZWN0aW9uIG9mIHN0cmluZ3MuJyk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHV0aWwuaXNFbXB0eShzdHJpbmdWYWx1ZXMpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHNlcGFyYXRvciA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1ZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG59O1xuXG5lbmdpbmUuc3BsaXRGbiA9IGZ1bmN0aW9uIChjb2xsLCBzZXBhcmF0b3IpIHtcbiAgY29uc3Qgc3RyVG9TcGxpdCA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdHJUb1NwbGl0KSA/IFtdIDogc3RyVG9TcGxpdC5zcGxpdChzZXBhcmF0b3IpO1xufTtcblxuZW5naW5lLnRyaW1GbiA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gIGNvbnN0IHN0clRvVHJpbSA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdHJUb1RyaW0pID8gW10gOiBzdHJUb1RyaW0udHJpbSgpO1xufTtcblxuLy8gZW5jb2RpbmcvZGVjb2RpbmdcbmVuZ2luZS5lbmNvZGVGbiA9IGZ1bmN0aW9uIChjb2xsLCBmb3JtYXQpIHtcbiAgY29uc3Qgc3RyVG9FbmNvZGUgPSBtaXNjLnNpbmdsZXRvbihjb2xsLCAnU3RyaW5nJyk7XG4gIGlmICh1dGlsLmlzRW1wdHkoc3RyVG9FbmNvZGUpKXtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gJ3VybGJhc2U2NCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0dXJsJyl7XG4gICAgcmV0dXJuIGJ0b2Eoc3RyVG9FbmNvZGUpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICB9XG4gIGlmIChmb3JtYXQgPT09ICdiYXNlNjQnKXtcbiAgICByZXR1cm4gYnRvYShzdHJUb0VuY29kZSk7XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gJ2hleCcpe1xuICAgIHJldHVybiAgQXJyYXkuZnJvbShzdHJUb0VuY29kZSkubWFwKGMgPT4gXG4gICAgICBjLmNoYXJDb2RlQXQoMCkgPCAxMjggPyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpIDogXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChjKS5yZXBsYWNlKC8lL2csJycpXG4gICAgKS5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG5lbmdpbmUuZGVjb2RlRm4gPSBmdW5jdGlvbiAoY29sbCwgZm9ybWF0KSB7XG4gIGNvbnN0IHN0ckRlY29kZSA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgaWYgKHV0aWwuaXNFbXB0eShzdHJEZWNvZGUpKXtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gJ3VybGJhc2U2NCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0dXJsJyl7XG4gICAgcmV0dXJuIGF0b2Ioc3RyRGVjb2RlLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJykpO1xuICB9XG4gIGlmIChmb3JtYXQgPT09ICdiYXNlNjQnKXtcbiAgICByZXR1cm4gYXRvYihzdHJEZWNvZGUpO1xuICB9XG4gIGlmIChmb3JtYXQgPT09ICdoZXgnKXtcbiAgICBpZiAoc3RyRGVjb2RlLmxlbmd0aCAlIDIgIT09IDApe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgXFwnaGV4XFwnIHJlcXVpcmVzIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoJyUnICsgc3RyRGVjb2RlLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyUnKSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxuLy8gQ2hlY2sgaWYgZG90QWxsIGlzIHN1cHBvcnRlZC5cbi8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZG90QWxsIGZvciBkZXRhaWxzLlxuY29uc3QgZG90QWxsSXNTdXBwb3J0ZWQgPSAobmV3IFJlZ0V4cCgnJykpLmRvdEFsbCA9PT0gZmFsc2U7XG5cbmlmIChkb3RBbGxJc1N1cHBvcnRlZCkge1xuICBlbmdpbmUubWF0Y2hlcyA9IGZ1bmN0aW9uIChjb2xsLCByZWdleCkge1xuICAgIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgICBpZiAodXRpbC5pc0VtcHR5KHJlZ2V4KSB8fCB1dGlsLmlzRW1wdHkoc3RyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKHJlZ2V4LCAnc3UnKTtcbiAgICByZXR1cm4gcmVnLnRlc3Qoc3RyKTtcbiAgfTtcbn0gZWxzZSB7XG4gIGVuZ2luZS5tYXRjaGVzID0gZnVuY3Rpb24gKGNvbGwsIHJlZ2V4KSB7XG4gICAgY29uc3Qgc3RyID0gbWlzYy5zaW5nbGV0b24oY29sbCwgJ1N0cmluZycpO1xuICAgIGlmICh1dGlsLmlzRW1wdHkocmVnZXgpIHx8IHV0aWwuaXNFbXB0eShzdHIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAocmV3cml0ZVBhdHRlcm5Gb3JEb3RBbGwocmVnZXgpLCAndScpO1xuICAgIHJldHVybiByZWcudGVzdChzdHIpO1xuICB9O1xufVxuXG5lbmdpbmUucmVwbGFjZSA9IGZ1bmN0aW9uIChjb2xsLCBwYXR0ZXJuLCByZXBsKSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgaWYgKHV0aWwuaXNFbXB0eShwYXR0ZXJuKSB8fCB1dGlsLmlzRW1wdHkocmVwbCkgfHwgdXRpbC5pc0VtcHR5KHN0cikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cCh1dGlsLmVzY2FwZVN0cmluZ0ZvclJlZ0V4cChwYXR0ZXJuKSwgJ2cnKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZywgcmVwbCk7XG59O1xuXG5lbmdpbmUucmVwbGFjZU1hdGNoZXMgPSBmdW5jdGlvbiAoY29sbCwgcmVnZXgsIHJlcGwpIHtcbiAgY29uc3Qgc3RyID0gbWlzYy5zaW5nbGV0b24oY29sbCwgJ1N0cmluZycpO1xuICBpZiAodXRpbC5pc0VtcHR5KHJlZ2V4KSB8fCB1dGlsLmlzRW1wdHkocmVwbCkgfHwgdXRpbC5pc0VtcHR5KHN0cikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChyZWdleCwgJ2d1Jyk7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWcsIHJlcGwpO1xufTtcblxuZW5naW5lLmxlbmd0aCA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gIGNvbnN0IHN0ciA9IG1pc2Muc2luZ2xldG9uKGNvbGwsICdTdHJpbmcnKTtcbiAgcmV0dXJuIHV0aWwuaXNFbXB0eShzdHIpID8gW10gOiBzdHIubGVuZ3RoO1xufTtcblxuZW5naW5lLnRvQ2hhcnMgPSBmdW5jdGlvbiAoY29sbCkge1xuICBjb25zdCBzdHIgPSBtaXNjLnNpbmdsZXRvbihjb2xsLCAnU3RyaW5nJyk7XG4gIHJldHVybiB1dGlsLmlzRW1wdHkoc3RyKSA/IFtdIDogc3RyLnNwbGl0KCcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/strings.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/terminologies.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/terminologies.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file contains a class that implements the Terminology Service API.\n// See https://build.fhir.org/fhirpath.html#txapi for details.\n\n\nconst util = __webpack_require__(/*! ./utilities */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\");\n\n\nclass Terminologies {\n  constructor(terminologyUrl) {\n    this.terminologyUrl = terminologyUrl;\n    this.invocationTable = Terminologies.invocationTable;\n  }\n\n  // Same as fhirpath.invocationTable, but for %terminologies methods\n  static invocationTable = {\n    validateVS: {fn: Terminologies.validateVS,  arity: { 2: ['String', 'AnySingletonAtRoot'], 3: ['String', 'AnySingletonAtRoot', 'String']} }\n  };\n\n  /**\n   * This example function calls the Terminology Service $validate-code operation\n   * on a value set. See Terminology Service API: https://build.fhir.org/fhirpath.html#txapi\n   * The source code of this function is based on this script:\n   * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts\n   * @param {Terminologies[]} self - an array with one element that refers to\n   *  the current Terminology instance.\n   * @param {string} valueset - a canonical URL reference to a value set. In the original\n   *  specification this could also be an actual ValueSet, but I don't want to\n   *  complicate this example.\n   * @param {string|Object} coded - either a Coding, a CodeableConcept,\n   *  or a resource element that is a code.\n   * @param {string} [params] - a URL encoded string with other parameters for the\n   *  validate-code operation (e.g. 'date=2011-03-04&displayLanguage=en').\n   * @return {Promise<Parameters>} - a Parameters resource\n   *  (https://build.fhir.org/parameters.html) with the results of the validation\n   *  operation.\n   */\n  static validateVS(self, valueset, coded, params = '') {\n    const ctx = this;\n    if (!ctx.async) {\n      throw new Error('The asynchronous function \"validateVS\" is not allowed. ' +\n        'To enable asynchronous functions, use the async=true or async=\"always\"' +\n        ' option.');\n    }\n    checkParams(params);\n    const httpHeaders = {\n      \"Accept\": \"application/fhir+json; charset=utf-8\",\n    };\n    const httpPostHeaders = {\n      \"Accept\": \"application/fhir+json; charset=utf-8\",\n      \"Content-Type\": \"application/fhir+json; charset=utf-8\",\n    };\n    let myHeaders = new Headers(httpHeaders);\n\n    const requestUrl = `${self[0].terminologyUrl}/ValueSet/$validate-code`;\n\n    let response;\n    if (coded.coding) {\n      const parameters = {\n        \"resourceType\": \"Parameters\",\n        \"parameter\": [\n          {\n            \"name\": \"url\",\n            \"valueUri\": valueset\n          },\n          {\n            \"name\": \"codeableConcept\",\n            \"valueCodeableConcept\": coded\n          }\n        ]\n      };\n      myHeaders = new Headers(httpPostHeaders);\n      response = util.fetchWithCache(\n        requestUrl + (params ? '?' + params : ''), {\n          method: \"POST\", headers: myHeaders, body: JSON.stringify(parameters),\n          ...(ctx.signal ? {signal: ctx.signal} : {})\n        }\n      );\n    } else if (typeof coded === \"string\") {\n      const queryParams1 = new URLSearchParams({\n        url: valueset,\n      });\n      //  Workaround for the case where we don't have a system. See discussion here:\n      //  https://chat.fhir.org/#narrow/stream/179266-fhirpath/topic/Problem.20with.20the.20.22memberOf.22.20function.20and.20R4.20servers\n      response = util.fetchWithCache(\n        `${self[0].terminologyUrl}/ValueSet?${queryParams1.toString() + (params ? '&' + params : '')}`,\n        {headers: myHeaders, ...(ctx.signal ? {signal: ctx.signal} : {})}\n      )\n        .then((bundle) => {\n          const system = bundle?.entry?.length === 1 && (\n            getSystemFromArrayItems(bundle.entry[0].resource.expansion?.contains)\n            || getSystemFromArrayItems(bundle.entry[0].resource.compose?.include)\n          );\n          if (system) {\n            const queryParams2 = new URLSearchParams({\n              url: valueset,\n              code: coded,\n              system\n            });\n            return util.fetchWithCache(\n              `${requestUrl}?${queryParams2.toString() + (params ? '&' + params : '')}`,\n              { headers: myHeaders, ...(ctx.signal ? {signal: ctx.signal} : {}) }\n            );\n          } else {\n            throw new Error('The valueset does not have a single code system.');\n          }\n        });\n    } else {\n      if (coded.code) {\n        const queryParams = new URLSearchParams({\n          url: valueset ?? '',\n          system: coded.system ?? '',\n          code: coded.code\n        });\n        response = util.fetchWithCache(\n          `${requestUrl}?${queryParams.toString() + (params ? '&' + params : '')}`,\n          { headers: myHeaders, ...(ctx.signal ? {signal: ctx.signal} : {}) }\n        );\n      }\n    }\n\n    return response\n      .then(params => {\n        if (params?.parameter) {\n          return params;\n        }\n        throw new Error(params);\n      })\n      .catch(() => {\n        const key = createIndexKeyMemberOf(coded, valueset);\n        throw new Error(\"Failed to check membership: \" + key);\n      });\n  }\n}\n\n/**\n * Create and returns an Index Key for the validateVS function\n * The source code of this function was borrowed from this script:\n * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts\n * @param {Object|string} value - either a Coding, a CodeableConcept, or\n *  a resource element that is a code.\n * @param {string} valueset - a canonical URL reference to a value set.\n * @returns {string|undefined}\n */\nfunction createIndexKeyMemberOf(value, valueset) {\n  if (typeof value === \"string\") {\n    return value + \" - \" + valueset;\n  }\n  if (value.code) {\n    return value.system + \"|\" + value.code + \" - \" + valueset;\n  }\n  if (value.coding) {\n    // return the same as for coding by joining each of the codings with a comma\n    return value.coding.map((c) => c.system + \"|\" + c.code).join(\",\") + \" - \" + valueset;\n  }\n  return undefined;\n}\n\n/**\n * Throws an exception if the params parameter is not empty and is not a valid\n * URL-encoded string.\n * @param {string|undefined} params - a URL encoded string with parameters\n *  (e.g. 'date=2011-03-04&displayLanguage=en').\n */\nfunction checkParams(params) {\n  if (params?.split('&').find(\n    p => {\n      const v = p.split('=');\n      return v.length <= 2 && v.find(x => encodeURIComponent(decodeURIComponent(x)) !== x);\n    }\n  )) {\n    throw new Error(`\"${params}\" should be a valid URL-encoded string`);\n  }\n}\n\n/**\n * Returns the \"system\" property from an array of items if it is the same for all\n * items and equal to the initial value if the initial value is defined.\n * @param {Object[]|undefined} arr - array of items\n * @param {string|undefined} [system] - optional initial value\n * @return {string|undefined}\n */\nfunction getSystemFromArrayItems(arr, system = undefined) {\n  if (arr) {\n    for (let i = 0; i < arr.length; ++i) {\n      if (!system) {\n        system = arr[i].system;\n      } else if (system !== arr[i].system) {\n        system = undefined;\n        break;\n      }\n    }\n  }\n\n  return system;\n}\n\nmodule.exports = Terminologies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3Rlcm1pbm9sb2dpZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0EsYUFBYSxtQkFBTyxDQUFDLHVHQUFhOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDBCQUEwQix1QkFBdUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CLElBQUk7QUFDcEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCLFlBQVksdURBQXVEO0FBQ3JHLFNBQVMsc0NBQXNDLG9CQUFvQixJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUIsV0FBVyxHQUFHLHVEQUF1RDtBQUN0RixnQkFBZ0Isc0NBQXNDLG9CQUFvQixJQUFJO0FBQzlFO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLFdBQVcsR0FBRyxzREFBc0Q7QUFDakYsWUFBWSxzQ0FBc0Msb0JBQW9CLElBQUk7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy90ZXJtaW5vbG9naWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBjb250YWlucyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgVGVybWlub2xvZ3kgU2VydmljZSBBUEkuXG4vLyBTZWUgaHR0cHM6Ly9idWlsZC5maGlyLm9yZy9maGlycGF0aC5odG1sI3R4YXBpIGZvciBkZXRhaWxzLlxuXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5cblxuY2xhc3MgVGVybWlub2xvZ2llcyB7XG4gIGNvbnN0cnVjdG9yKHRlcm1pbm9sb2d5VXJsKSB7XG4gICAgdGhpcy50ZXJtaW5vbG9neVVybCA9IHRlcm1pbm9sb2d5VXJsO1xuICAgIHRoaXMuaW52b2NhdGlvblRhYmxlID0gVGVybWlub2xvZ2llcy5pbnZvY2F0aW9uVGFibGU7XG4gIH1cblxuICAvLyBTYW1lIGFzIGZoaXJwYXRoLmludm9jYXRpb25UYWJsZSwgYnV0IGZvciAldGVybWlub2xvZ2llcyBtZXRob2RzXG4gIHN0YXRpYyBpbnZvY2F0aW9uVGFibGUgPSB7XG4gICAgdmFsaWRhdGVWUzoge2ZuOiBUZXJtaW5vbG9naWVzLnZhbGlkYXRlVlMsICBhcml0eTogeyAyOiBbJ1N0cmluZycsICdBbnlTaW5nbGV0b25BdFJvb3QnXSwgMzogWydTdHJpbmcnLCAnQW55U2luZ2xldG9uQXRSb290JywgJ1N0cmluZyddfSB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZXhhbXBsZSBmdW5jdGlvbiBjYWxscyB0aGUgVGVybWlub2xvZ3kgU2VydmljZSAkdmFsaWRhdGUtY29kZSBvcGVyYXRpb25cbiAgICogb24gYSB2YWx1ZSBzZXQuIFNlZSBUZXJtaW5vbG9neSBTZXJ2aWNlIEFQSTogaHR0cHM6Ly9idWlsZC5maGlyLm9yZy9maGlycGF0aC5odG1sI3R4YXBpXG4gICAqIFRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIHRoaXMgc2NyaXB0OlxuICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9icmlhbnBvcy85N2UxMjM3NDcwZDc2ODM1ZWE5YTM1YmY4ZTAyMWNhNiNmaWxlLWZoaXJwYXRoLWFzeW5jLXRzXG4gICAqIEBwYXJhbSB7VGVybWlub2xvZ2llc1tdfSBzZWxmIC0gYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCB0aGF0IHJlZmVycyB0b1xuICAgKiAgdGhlIGN1cnJlbnQgVGVybWlub2xvZ3kgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZXNldCAtIGEgY2Fub25pY2FsIFVSTCByZWZlcmVuY2UgdG8gYSB2YWx1ZSBzZXQuIEluIHRoZSBvcmlnaW5hbFxuICAgKiAgc3BlY2lmaWNhdGlvbiB0aGlzIGNvdWxkIGFsc28gYmUgYW4gYWN0dWFsIFZhbHVlU2V0LCBidXQgSSBkb24ndCB3YW50IHRvXG4gICAqICBjb21wbGljYXRlIHRoaXMgZXhhbXBsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBjb2RlZCAtIGVpdGhlciBhIENvZGluZywgYSBDb2RlYWJsZUNvbmNlcHQsXG4gICAqICBvciBhIHJlc291cmNlIGVsZW1lbnQgdGhhdCBpcyBhIGNvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zXSAtIGEgVVJMIGVuY29kZWQgc3RyaW5nIHdpdGggb3RoZXIgcGFyYW1ldGVycyBmb3IgdGhlXG4gICAqICB2YWxpZGF0ZS1jb2RlIG9wZXJhdGlvbiAoZS5nLiAnZGF0ZT0yMDExLTAzLTA0JmRpc3BsYXlMYW5ndWFnZT1lbicpLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFBhcmFtZXRlcnM+fSAtIGEgUGFyYW1ldGVycyByZXNvdXJjZVxuICAgKiAgKGh0dHBzOi8vYnVpbGQuZmhpci5vcmcvcGFyYW1ldGVycy5odG1sKSB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSB2YWxpZGF0aW9uXG4gICAqICBvcGVyYXRpb24uXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVWUyhzZWxmLCB2YWx1ZXNldCwgY29kZWQsIHBhcmFtcyA9ICcnKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcztcbiAgICBpZiAoIWN0eC5hc3luYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIFwidmFsaWRhdGVWU1wiIGlzIG5vdCBhbGxvd2VkLiAnICtcbiAgICAgICAgJ1RvIGVuYWJsZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zLCB1c2UgdGhlIGFzeW5jPXRydWUgb3IgYXN5bmM9XCJhbHdheXNcIicgK1xuICAgICAgICAnIG9wdGlvbi4nKTtcbiAgICB9XG4gICAgY2hlY2tQYXJhbXMocGFyYW1zKTtcbiAgICBjb25zdCBodHRwSGVhZGVycyA9IHtcbiAgICAgIFwiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vZmhpcitqc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgfTtcbiAgICBjb25zdCBodHRwUG9zdEhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2ZoaXIranNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9maGlyK2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICB9O1xuICAgIGxldCBteUhlYWRlcnMgPSBuZXcgSGVhZGVycyhodHRwSGVhZGVycyk7XG5cbiAgICBjb25zdCByZXF1ZXN0VXJsID0gYCR7c2VsZlswXS50ZXJtaW5vbG9neVVybH0vVmFsdWVTZXQvJHZhbGlkYXRlLWNvZGVgO1xuXG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGlmIChjb2RlZC5jb2RpbmcpIHtcbiAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7XG4gICAgICAgIFwicmVzb3VyY2VUeXBlXCI6IFwiUGFyYW1ldGVyc1wiLFxuICAgICAgICBcInBhcmFtZXRlclwiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidXJsXCIsXG4gICAgICAgICAgICBcInZhbHVlVXJpXCI6IHZhbHVlc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb2RlYWJsZUNvbmNlcHRcIixcbiAgICAgICAgICAgIFwidmFsdWVDb2RlYWJsZUNvbmNlcHRcIjogY29kZWRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgICBteUhlYWRlcnMgPSBuZXcgSGVhZGVycyhodHRwUG9zdEhlYWRlcnMpO1xuICAgICAgcmVzcG9uc2UgPSB1dGlsLmZldGNoV2l0aENhY2hlKFxuICAgICAgICByZXF1ZXN0VXJsICsgKHBhcmFtcyA/ICc/JyArIHBhcmFtcyA6ICcnKSwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsIGhlYWRlcnM6IG15SGVhZGVycywgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycyksXG4gICAgICAgICAgLi4uKGN0eC5zaWduYWwgPyB7c2lnbmFsOiBjdHguc2lnbmFsfSA6IHt9KVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBxdWVyeVBhcmFtczEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgdXJsOiB2YWx1ZXNldCxcbiAgICAgIH0pO1xuICAgICAgLy8gIFdvcmthcm91bmQgZm9yIHRoZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmUgYSBzeXN0ZW0uIFNlZSBkaXNjdXNzaW9uIGhlcmU6XG4gICAgICAvLyAgaHR0cHM6Ly9jaGF0LmZoaXIub3JnLyNuYXJyb3cvc3RyZWFtLzE3OTI2Ni1maGlycGF0aC90b3BpYy9Qcm9ibGVtLjIwd2l0aC4yMHRoZS4yMC4yMm1lbWJlck9mLjIyLjIwZnVuY3Rpb24uMjBhbmQuMjBSNC4yMHNlcnZlcnNcbiAgICAgIHJlc3BvbnNlID0gdXRpbC5mZXRjaFdpdGhDYWNoZShcbiAgICAgICAgYCR7c2VsZlswXS50ZXJtaW5vbG9neVVybH0vVmFsdWVTZXQ/JHtxdWVyeVBhcmFtczEudG9TdHJpbmcoKSArIChwYXJhbXMgPyAnJicgKyBwYXJhbXMgOiAnJyl9YCxcbiAgICAgICAge2hlYWRlcnM6IG15SGVhZGVycywgLi4uKGN0eC5zaWduYWwgPyB7c2lnbmFsOiBjdHguc2lnbmFsfSA6IHt9KX1cbiAgICAgIClcbiAgICAgICAgLnRoZW4oKGJ1bmRsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN5c3RlbSA9IGJ1bmRsZT8uZW50cnk/Lmxlbmd0aCA9PT0gMSAmJiAoXG4gICAgICAgICAgICBnZXRTeXN0ZW1Gcm9tQXJyYXlJdGVtcyhidW5kbGUuZW50cnlbMF0ucmVzb3VyY2UuZXhwYW5zaW9uPy5jb250YWlucylcbiAgICAgICAgICAgIHx8IGdldFN5c3RlbUZyb21BcnJheUl0ZW1zKGJ1bmRsZS5lbnRyeVswXS5yZXNvdXJjZS5jb21wb3NlPy5pbmNsdWRlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN5c3RlbSkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMyID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgIHVybDogdmFsdWVzZXQsXG4gICAgICAgICAgICAgIGNvZGU6IGNvZGVkLFxuICAgICAgICAgICAgICBzeXN0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWwuZmV0Y2hXaXRoQ2FjaGUoXG4gICAgICAgICAgICAgIGAke3JlcXVlc3RVcmx9PyR7cXVlcnlQYXJhbXMyLnRvU3RyaW5nKCkgKyAocGFyYW1zID8gJyYnICsgcGFyYW1zIDogJycpfWAsXG4gICAgICAgICAgICAgIHsgaGVhZGVyczogbXlIZWFkZXJzLCAuLi4oY3R4LnNpZ25hbCA/IHtzaWduYWw6IGN0eC5zaWduYWx9IDoge30pIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlc2V0IGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgY29kZSBzeXN0ZW0uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGVkLmNvZGUpIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICB1cmw6IHZhbHVlc2V0ID8/ICcnLFxuICAgICAgICAgIHN5c3RlbTogY29kZWQuc3lzdGVtID8/ICcnLFxuICAgICAgICAgIGNvZGU6IGNvZGVkLmNvZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlID0gdXRpbC5mZXRjaFdpdGhDYWNoZShcbiAgICAgICAgICBgJHtyZXF1ZXN0VXJsfT8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCkgKyAocGFyYW1zID8gJyYnICsgcGFyYW1zIDogJycpfWAsXG4gICAgICAgICAgeyBoZWFkZXJzOiBteUhlYWRlcnMsIC4uLihjdHguc2lnbmFsID8ge3NpZ25hbDogY3R4LnNpZ25hbH0gOiB7fSkgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICAgICAgLnRoZW4ocGFyYW1zID0+IHtcbiAgICAgICAgaWYgKHBhcmFtcz8ucGFyYW1ldGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyYW1zKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVJbmRleEtleU1lbWJlck9mKGNvZGVkLCB2YWx1ZXNldCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjaGVjayBtZW1iZXJzaGlwOiBcIiArIGtleSk7XG4gICAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJucyBhbiBJbmRleCBLZXkgZm9yIHRoZSB2YWxpZGF0ZVZTIGZ1bmN0aW9uXG4gKiBUaGUgc291cmNlIGNvZGUgb2YgdGhpcyBmdW5jdGlvbiB3YXMgYm9ycm93ZWQgZnJvbSB0aGlzIHNjcmlwdDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JyaWFucG9zLzk3ZTEyMzc0NzBkNzY4MzVlYTlhMzViZjhlMDIxY2E2I2ZpbGUtZmhpcnBhdGgtYXN5bmMtdHNcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gdmFsdWUgLSBlaXRoZXIgYSBDb2RpbmcsIGEgQ29kZWFibGVDb25jZXB0LCBvclxuICogIGEgcmVzb3VyY2UgZWxlbWVudCB0aGF0IGlzIGEgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZXNldCAtIGEgY2Fub25pY2FsIFVSTCByZWZlcmVuY2UgdG8gYSB2YWx1ZSBzZXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhLZXlNZW1iZXJPZih2YWx1ZSwgdmFsdWVzZXQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2YWx1ZSArIFwiIC0gXCIgKyB2YWx1ZXNldDtcbiAgfVxuICBpZiAodmFsdWUuY29kZSkge1xuICAgIHJldHVybiB2YWx1ZS5zeXN0ZW0gKyBcInxcIiArIHZhbHVlLmNvZGUgKyBcIiAtIFwiICsgdmFsdWVzZXQ7XG4gIH1cbiAgaWYgKHZhbHVlLmNvZGluZykge1xuICAgIC8vIHJldHVybiB0aGUgc2FtZSBhcyBmb3IgY29kaW5nIGJ5IGpvaW5pbmcgZWFjaCBvZiB0aGUgY29kaW5ncyB3aXRoIGEgY29tbWFcbiAgICByZXR1cm4gdmFsdWUuY29kaW5nLm1hcCgoYykgPT4gYy5zeXN0ZW0gKyBcInxcIiArIGMuY29kZSkuam9pbihcIixcIikgKyBcIiAtIFwiICsgdmFsdWVzZXQ7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBwYXJhbXMgcGFyYW1ldGVyIGlzIG5vdCBlbXB0eSBhbmQgaXMgbm90IGEgdmFsaWRcbiAqIFVSTC1lbmNvZGVkIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcGFyYW1zIC0gYSBVUkwgZW5jb2RlZCBzdHJpbmcgd2l0aCBwYXJhbWV0ZXJzXG4gKiAgKGUuZy4gJ2RhdGU9MjAxMS0wMy0wNCZkaXNwbGF5TGFuZ3VhZ2U9ZW4nKS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tQYXJhbXMocGFyYW1zKSB7XG4gIGlmIChwYXJhbXM/LnNwbGl0KCcmJykuZmluZChcbiAgICBwID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwLnNwbGl0KCc9Jyk7XG4gICAgICByZXR1cm4gdi5sZW5ndGggPD0gMiAmJiB2LmZpbmQoeCA9PiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHgpKSAhPT0geCk7XG4gICAgfVxuICApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7cGFyYW1zfVwiIHNob3VsZCBiZSBhIHZhbGlkIFVSTC1lbmNvZGVkIHN0cmluZ2ApO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgXCJzeXN0ZW1cIiBwcm9wZXJ0eSBmcm9tIGFuIGFycmF5IG9mIGl0ZW1zIGlmIGl0IGlzIHRoZSBzYW1lIGZvciBhbGxcbiAqIGl0ZW1zIGFuZCBlcXVhbCB0byB0aGUgaW5pdGlhbCB2YWx1ZSBpZiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBkZWZpbmVkLlxuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IGFyciAtIGFycmF5IG9mIGl0ZW1zXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtzeXN0ZW1dIC0gb3B0aW9uYWwgaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U3lzdGVtRnJvbUFycmF5SXRlbXMoYXJyLCBzeXN0ZW0gPSB1bmRlZmluZWQpIHtcbiAgaWYgKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIXN5c3RlbSkge1xuICAgICAgICBzeXN0ZW0gPSBhcnJbaV0uc3lzdGVtO1xuICAgICAgfSBlbHNlIGlmIChzeXN0ZW0gIT09IGFycltpXS5zeXN0ZW0pIHtcbiAgICAgICAgc3lzdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3lzdGVtO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlcm1pbm9sb2dpZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/terminologies.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js":
/*!********************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const addMinutes = __webpack_require__(/*! date-fns/add_minutes */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_minutes/index.js\");\nconst ucumUtils = (__webpack_require__(/*! @lhncbc/ucum-lhc */ \"(ssr)/../node_modules/.pnpm/@lhncbc+ucum-lhc@5.0.4/node_modules/@lhncbc/ucum-lhc/source-cjs/ucumPkg.js\").UcumLhcUtils).getInstance();\nconst numbers = __webpack_require__(/*! ./numbers */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/numbers.js\");\n\nconst ucumSystemUrl = 'http://unitsofmeasure.org';\nlet timeFormat =\n  '[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?)?)?(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9])?';\nlet timeRE = new RegExp('^T?'+timeFormat+'$');\nlet dateTimeRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T'+timeFormat+')?)?)?Z?$');\nlet dateRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9])?)?$');\nlet instantRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?))(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9]))))$');\n// FHIR date/time regular expressions are slightly different.  For now, we will\n// stick with the FHIRPath regular expressions.\n//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?/;\n//let fhirDateTimeRE =\n///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;\n\n/**\n *   Class FP_Type is the superclass for FHIRPath types that required special\n *   handling.\n */\nclass FP_Type {\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   */\n  equals(/* otherObj */) {\n    return false;\n  }\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).\n   */\n  equivalentTo(/* otherObj */) {\n    return false;\n  }\n\n  toString() {\n    return this.asStr ? this.asStr : super.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  /**\n   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater\n   *  than otherObj.\n   */\n  compare(/* otherObj */) {\n    throw 'Comparison not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   *  Adds other value to this value.\n   */\n  plus(/* otherObj */) {\n    throw 'Addition not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   * Multiplies this value by another value.\n   */\n  mul(/* otherObj */) {\n    throw 'Multiplication not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   * Divides this value by another value.\n   */\n  div(/* otherObj */) {\n    throw 'Division not implemented for ' + this.constructor.name;\n  }\n}\n\n\n/**\n *  A class for Quantities.\n */\nclass FP_Quantity extends FP_Type {\n  constructor(value, unit) {\n    super();\n    this.asStr = value + ' ' + unit;\n    this.value = value;\n    this.unit = unit;\n  }\n\n  equals(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      return null;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEqual(this.value, otherQuantity.value);\n    }\n\n    // Special year/month comparison case: 1 year = 12 month\n    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);\n    if (compareYearsAndMonths) {\n      return compareYearsAndMonths.isEqual;\n    }\n\n    // General comparison case\n    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),\n      normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEqual(thisQuantity.value, convResult.toVal);\n  }\n\n  equivalentTo(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEquivalent(this.value, otherQuantity.value);\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEquivalent(this.value, convResult.toVal);\n  }\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this quantity is less than, equal to, or greater than otherQuantity.\n   *  If the quantities could not be compared, returns null, which will be\n   *  converted to an empty collection in the \"doInvoke\" function\n   *  See https://hl7.org/fhirpath/#comparison\n   *  @param {FP_Quantity} otherQuantity\n   *  @return {number|null}\n   */\n  compare(otherQuantity) {\n    if (this.unit === otherQuantity.unit) {\n      return this.value - otherQuantity.value;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      // For example, 1 year > 1 'a' should return []\n      return null;\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return null;\n    }\n\n    return this.value - convResult.toVal;\n  }\n\n  /**\n   *  Adds a quantity to this quantity.\n   * @param {FP_Quantity} otherQuantity a quantity to be added to this quantity.\n   * @return {FP_Quantity|null}\n   */\n  plus(otherQuantity) {\n    const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];\n    const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n    if (thisConvFactor && otherConvFactor) {\n      // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months\n      return new FP_Quantity(this.value + otherQuantity.value * otherConvFactor / thisConvFactor, this.unit);\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      return null;\n    }\n\n    const thisUcumUnitCode = thisUnitInSeconds ? 's' : this.unit.replace(surroundingApostrophesRegex, '');\n    const thisValue = (thisUnitInSeconds || 1) * this.value;\n\n    const otherUcumUnitCode = otherUnitInSeconds ? 's' : otherQuantity.unit.replace(surroundingApostrophesRegex, '');\n    const otherValue = (otherUnitInSeconds || 1) * otherQuantity.value;\n\n    const convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherValue, thisUcumUnitCode);\n\n    if (convResult.status !== 'succeeded'\n      || convResult.fromUnit.isSpecial_\n      || convResult.toUnit.isSpecial_) {\n      return null;\n    }\n\n    return new FP_Quantity(thisValue + convResult.toVal, thisUcumUnitCode);\n  }\n\n  /**\n   * Multiplies this quantity to another quantity.\n   * @param {FP_Quantity} otherQuantity a quantity by which to multiply this quantity.\n   * @return {FP_Quantity}\n   */\n  mul(otherQuantity) {\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      (thisUnitInSeconds > 1 && otherQuantity.unit !== \"'1'\") ||\n      (otherUnitInSeconds > 1 && this.unit !== \"'1'\")\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a number, return empty result\n      return null;\n    }\n\n    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);\n    if (!thisQ) {\n      // If the first operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);\n    if (!otherQ) {\n      // If the second operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    // Do not use UCUM unit codes for durations in simple cases\n    if (this.unit === \"'1'\") {\n      return new FP_Quantity(this.value * otherQuantity.value, otherQuantity.unit);\n    } else if (otherQuantity.unit === \"'1'\") {\n      return new FP_Quantity(this.value * otherQuantity.value, this.unit);\n    }\n\n    return new FP_Quantity(\n      thisQ.value * otherQ.value,\n      `'(${thisQ.unit}).(${otherQ.unit})'`\n    );\n  }\n\n  /**\n   * Divides this quantity by another quantity.\n   * @param {FP_Quantity} otherQuantity a quantity by which to divide this quantity.\n   * @return {FP_Quantity}\n   */\n  div(otherQuantity) {\n    // Division by zero always gives an empty result\n    if (otherQuantity.value === 0) {\n      return null;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (thisUnitInSeconds) {\n      if (otherUnitInSeconds) {\n        // If both operands are calendar duration quantities\n        const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];\n        const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n        if (thisConvFactor && otherConvFactor) {\n          // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months\n          return new FP_Quantity(this.value * thisConvFactor / (otherQuantity.value * otherConvFactor), \"'1'\");\n        }\n      } else if (otherQuantity.unit === \"'1'\") {\n        // If the second operand is a number\n        return new FP_Quantity(this.value / otherQuantity.value, this.unit);\n      } else if (thisUnitInSeconds > 1) {\n        // If the first operand is a calendar duration greater than seconds\n        // and the other is not a calendar duration or number, return an empty result.\n        return null;\n      }\n    } else if (otherUnitInSeconds > 1) {\n      // If the first operands is not a calendar duration and the other is a\n      // calendar duration greater than seconds, return an empty result.\n      return null;\n    }\n\n    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);\n    if (!thisQ) {\n      // If the first operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);\n    if (!otherQ) {\n      // If the second operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const resultUnit = otherQ.unit === '1'\n      ? thisQ.unit\n      : `(${thisQ.unit})/(${otherQ.unit})`;\n\n    const convResult = ucumUtils.convertToBaseUnits(resultUnit, thisQ.value / otherQ.value);\n    if (convResult.status !== 'succeeded') {\n      // If the result units are unclear\n      return null;\n    }\n    return new FP_Quantity(\n      convResult.magnitude,\n      `'${Object.keys(convResult.unitToExp).map(key => key+convResult.unitToExp[key]).join('.') || \"1\"}'`\n    );\n  }\n\n  /**\n   * Converts a quantity to UCUM unit if possible, otherwise returns null.\n   * @param {FP_Quantity} quantity - source quantity.\n   * @param {number|undefined} unitInSeconds - if the source quantity is a\n   *  calendar duration then the value of the quantity unit in seconds,\n   *  otherwise undefined.\n   * @return {{unit: string, value: number} | null}\n   */\n  convToUcumUnits(quantity, unitInSeconds) {\n    if (unitInSeconds) {\n      return {\n        value: unitInSeconds * quantity.value,\n        unit: 's'\n      };\n    } else {\n      const unit = quantity.unit.replace(surroundingApostrophesRegex, '');\n      const convRes = ucumUtils.convertToBaseUnits(unit, quantity.value);\n      if (convRes.status !== 'succeeded' || convRes.fromUnitIsSpecial) {\n        // If it is not a UCUM quantity or it has a special unit\n        return null;\n      }\n      return {\n        value: convRes.magnitude,\n        unit: Object.keys(convRes.unitToExp).map(key => key+convRes.unitToExp[key]).join('.') || \"1\"\n      };\n    }\n  }\n\n  /**\n   * If both quantities have one of these units: year or month,\n   * then a special case will apply; otherwise returns null.\n   * In the special case of comparison, the fact that 1 year = 12 months is used.\n   *\n   * Just note: in general, for a calendar duration:\n   * 1 year = 365 days\n   * 12 month = 12*30 days = 360 days\n   * so, 1 year != 12 month\n   * That's why this special case is needed\n   *\n   * @param {FP_Quantity} otherQuantity\n   * @return {null|{isEqual: boolean}}\n   * @private\n   */\n  _compareYearsAndMonths(otherQuantity) {\n    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],\n      magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n\n    if ( magnitude1 && magnitude2) {\n      return {\n        isEqual: numbers.isEqual(this.value*magnitude1, otherQuantity.value*magnitude2)\n      };\n    }\n\n    return null;\n  }\n\n}\n\nconst  surroundingApostrophesRegex = /^'|'$/g;\n/**\n * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code\n * or removing single quotes for a UCUM unit.\n * @param {string} unit\n * @return {string}\n */\nFP_Quantity.getEquivalentUcumUnitCode = function (unit) {\n  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');\n};\n\n/**\n * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.\n * @param {number} value\n * @param {string} unit\n * @returns { {value: number, unit: string} }\n */\nFP_Quantity.toUcumQuantity = function (value, unit) {\n  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];\n  if (magnitude) {\n    return {\n      value: magnitude * value,\n      unit: 's'\n    };\n  }\n\n  return {\n    value,\n    unit: unit.replace(surroundingApostrophesRegex, '')\n  };\n};\n\n\n/**\n * Converts FHIRPath value/unit to other FHIRPath value/unit.\n * @param {string} fromUnit\n * @param {number} value\n * @param {string} toUnit\n * @return {FP_Quantity|null}\n */\nFP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {\n  // 1 Year <-> 12 Months\n  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],\n    toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];\n  if (fromYearMonthMagnitude && toYearMonthMagnitude) {\n    return new FP_Quantity( fromYearMonthMagnitude*value/toYearMonthMagnitude, toUnit);\n  }\n\n  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],\n    toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit];\n\n  // To FHIR path calendar duration\n  if (toMagnitude) {\n    if (fromMagnitude) {\n      return new FP_Quantity( fromMagnitude*value/toMagnitude, toUnit);\n    } else {\n      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');\n\n      if (convResult.status === 'succeeded') {\n        return new FP_Quantity(convResult.toVal/toMagnitude, toUnit);\n      }\n    }\n  // To Ucum unit\n  } else {\n    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude*value, toUnit.replace(/^'|'$/g, ''))\n      : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));\n\n    if(convResult.status === 'succeeded') {\n      return new FP_Quantity(convResult.toVal, toUnit);\n    }\n  }\n\n  return null;\n};\n\n\n// Defines conversion factors for calendar durations\nFP_Quantity._calendarDuration2Seconds = {\n  'years': 365*24*60*60,\n  'months': 30*24*60*60,\n  'weeks': 7*24*60*60,\n  'days': 24*60*60,\n  'hours': 60*60,\n  'minutes': 60,\n  'seconds': 1,\n  'milliseconds': .001,\n  'year': 365*24*60*60,\n  'month': 30*24*60*60,\n  'week': 7*24*60*60,\n  'day': 24*60*60,\n  'hour': 60*60,\n  'minute': 60,\n  'second': 1,\n  'millisecond': .001\n};\n\n// Defines special case to compare years with months for calendar durations\nFP_Quantity._yearMonthConversionFactor = {\n  'years': 12,\n  'months': 1,\n  'year': 12,\n  'month': 1\n};\n\n/**\n *  Defines a map from time units that are supported for date/time arithmetic\n *  (including some UCUM time based units) to FHIRPath time units.\n */\nFP_Quantity.dateTimeArithmeticDurationUnits = {\n  'years': \"year\",\n  'months': \"month\",\n  'weeks': \"week\",\n  'days': \"day\",\n  'hours': \"hour\",\n  'minutes': \"minute\",\n  'seconds': \"second\",\n  'milliseconds': \"millisecond\",\n  'year': \"year\",\n  'month': \"month\",\n  'week': \"week\",\n  'day': \"day\",\n  'hour': \"hour\",\n  'minute': \"minute\",\n  'second': \"second\",\n  'millisecond': \"millisecond\",\n  \"'s'\": \"second\",\n  \"'ms'\": \"millisecond\"\n};\n\n/**\n *  Defines a map from UCUM code to FHIRPath time units.\n */\nFP_Quantity.mapUCUMCodeToTimeUnits = {\n  'a': \"year\",\n  'mo': \"month\",\n  'wk': \"week\",\n  'd': \"day\",\n  'h': \"hour\",\n  'min': \"minute\",\n  's': \"second\",\n  'ms': \"millisecond\",\n};\n\n/**\n *  Defines a map from FHIRPath time units to UCUM code.\n */\nFP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits)\n  .reduce(function (res, key) {\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]+'s'] = key;\n    return res;\n  }, {});\n\nclass FP_TimeBase extends FP_Type {\n  constructor(timeStr) {\n    super();\n    this.asStr = timeStr;\n  }\n\n  /**\n   *  Adds a time-based quantity to this date/time.\n   * @param timeQuantity a quantity to be added to this date/time.  See the\n   *  FHIRPath specification for supported units.\n   */\n  plus(timeQuantity) {\n    const unit = timeQuantity.unit;\n    let timeUnit = FP_Quantity.dateTimeArithmeticDurationUnits[unit];\n    if (!timeUnit) {\n      throw new Error('For date/time arithmetic, the unit of the quantity ' +\n        'must be one of the following time-based units: ' +\n        Object.keys(FP_Quantity.dateTimeArithmeticDurationUnits));\n    }\n    const cls = this.constructor;\n    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];\n    if (unitPrecision === undefined) {\n      throw new Error('Unsupported unit for +.  The unit should be one of ' +\n        Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');\n    }\n    let qVal = timeQuantity.value;\n    const isTime = (cls === FP_Time);\n\n    // From the FHIRPath specification: \"For precisions above seconds, the\n    // decimal portion of the time-valued quantity is ignored, since date/time\n    // arithmetic above seconds is performed with calendar duration semantics.\"\n    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {\n      qVal = Math.trunc(qVal);\n    }\n\n    // If the precision of the time quantity is higher than the precision of the\n    // date, we need to convert the time quantity to the precision of the date.\n    if (this._getPrecision() < unitPrecision) {\n      const neededUnit = cls._datePrecisionToTimeUnit[\n        this._getPrecision()];\n      if (neededUnit !== 'second') {\n        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);\n        timeUnit = newQuantity.unit;\n        qVal = Math.trunc(newQuantity.value);\n      }\n    }\n    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal);\n    // newDate is a Date.  We need to make a string with the correct precision.\n    let precision = this._getPrecision();\n    if (isTime)\n      precision += 3; // based on dateTimeRE, not timeRE\n    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);\n    if (isTime) {\n      // FP_Time just needs the time part of the string\n      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);\n    }\n\n    return new cls(newDateStr);\n  }\n\n\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same\n   *  as the type of \"this\".\n   */\n  equals(otherDateTime) {\n    // From the 2019May ballot:\n    // For Date, DateTime and Time equality, the comparison is performed by\n    // considering each precision in order, beginning with years (or hours for\n    // time values), and respecting timezone offsets. If the values are the\n    // same, comparison proceeds to the next precision; if the values are\n    // different, the comparison stops and the result is false. If one input has\n    // a value for the precision and the other does not, the comparison stops\n    // and the result is empty ({ }); if neither input has a value for the\n    // precision, or the last precision has been reached, the comparison stops\n    // and the result is true.\n    // Note:  Per the spec above\n    //   2012-01 = 2012 //  empty\n    //   2012-01 = 2011 //  false\n    //   2012-01 ~ 2012 //  false\n    var rtn;\n    if (!(otherDateTime instanceof this.constructor) && !(this instanceof otherDateTime.constructor))\n      rtn = false;\n    else {\n      var thisPrec  = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n\n      if (thisPrec == otherPrec) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      }\n      else {\n        // The dates are not equal, but decide whether to return empty or false.\n        var commonPrec  = thisPrec <= otherPrec ? thisPrec : otherPrec;\n        // Adjust for timezone offsets, if any, so they are at a common timezone\n        var thisUTCStr  = this._getDateObj().toISOString();\n        var otherUTCStr = otherDateTime._getDateObj().toISOString();\n\n        if (this.constructor === FP_Time) {\n          commonPrec += 3; // because we now have year, month, and day\n          thisPrec += 3;\n          otherPrec += 3;\n        }\n\n        // Now parse the strings and compare the adjusted time parts.\n        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date\n        var thisAdj  = thisPrec > 2 ? (new FP_DateTime(thisUTCStr))._getTimeParts() : this._getTimeParts();\n        var otherAdj = otherPrec > 2 ? (new FP_DateTime(otherUTCStr))._getTimeParts() : otherDateTime._getTimeParts();\n\n        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {\n          rtn = thisAdj[i] == otherAdj[i];\n        }\n        // if rtn is still true, then return empty to indicate the difference in\n        // precision.\n        if (rtn)\n          rtn = undefined;\n      }\n    }\n    // else return undefined (empty)\n    return rtn;\n  }\n\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true\n   *  or false.\n   */\n  equivalentTo(otherDateTime) {\n    var rtn = otherDateTime instanceof this.constructor;\n    if (rtn) {\n      var thisPrec = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n      rtn = thisPrec == otherPrec;\n      if (rtn) {\n        rtn = this._getDateObj().getTime() ==\n          otherDateTime._getDateObj().getTime();\n      }\n    }\n    return rtn;\n  }\n\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this (date) time is less than, equal to, or greater than otherTime.\n   *  Comparisons are made at the lesser of the two time precisions.\n   *  @param {FP_TimeBase} otherTime\n   *  @return {number}\n   */\n  compare(otherTime) {\n    var thisPrecision = this._getPrecision();\n    var otherPrecision = otherTime._getPrecision();\n    var thisTimeInt = thisPrecision <= otherPrecision ?\n      this._getDateObj().getTime(): this._dateAtPrecision(otherPrecision).getTime();\n    var otherTimeInt = otherPrecision <= thisPrecision ?\n      otherTime._getDateObj().getTime(): otherTime._dateAtPrecision(thisPrecision).getTime();\n    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {\n      return null;\n    }\n    return thisTimeInt - otherTimeInt;\n  }\n\n\n  /**\n   *  Returns a number representing the precision of the time string given to\n   *  the constructor.  (Higher means more precise).  The number is the number\n   *  of components of the time string (ignoring the time zone) produced by\n   *  matching against the time regular expression, except that milliseconds\n   *  and seconds are counted together as a single of level of precision.\n   *  @return {number}\n   */\n  _getPrecision() {\n    if (this.precision === undefined)\n      this._getMatchData();\n    return this.precision;\n  }\n\n  /**\n   *  Returns the match data from matching the given RegExp against the\n   *  date/time string given to the constructor.\n   *  Also sets this.precision.\n   * @param regEx The regular expression to match against the date/time string.\n   * @param maxPrecision the maximum precision possible for the type\n   */\n  _getMatchData(regEx, maxPrecision) {\n    if (this.timeMatchData === undefined) {\n      this.timeMatchData = this.asStr.match(regEx);\n      if (this.timeMatchData) {\n        for (let i=maxPrecision; i>=0 && this.precision === undefined; --i) {\n          if (this.timeMatchData[i])\n            this.precision = i;\n        }\n      }\n    }\n    return this.timeMatchData;\n  }\n\n  /**\n   *  Returns an array of the pieces of the given time string, for use in\n   *  constructing lower precision versions of the time. The returned array will\n   *  contain separate elements for the hour, minutes, seconds, and milliseconds\n   *  (or as many of those are as present).  The length of the returned array\n   *  will therefore be an indication of the precision.\n   *  It will not include the timezone.\n   * @timeMatchData the result of matching the time portion of the string passed\n   *  into the constructor against the \"timeRE\" regular expression.\n   */\n  _getTimeParts(timeMatchData) {\n    var timeParts = [];\n    // Finish parsing the data into pieces, for later use in building\n    // lower-precision versions of the date if needed.\n    timeParts = [timeMatchData[0]];\n    var timeZone = timeMatchData[4];\n    if (timeZone) { // remove time zone from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-timeZone.length);\n    }\n    var min = timeMatchData[1];\n    if (min) { // remove minutes from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-min.length);\n      timeParts[1] = min;\n      var sec = timeMatchData[2];\n      if (sec) { // remove seconds from minutes\n        timeParts[1] = min.slice(0, min.length-sec.length);\n        timeParts[2] = sec;\n        var ms = timeMatchData[3];\n        if (ms) { // remove milliseconds from seconds\n          timeParts[2] = sec.slice(0, sec.length-ms.length);\n          timeParts[3] = ms;\n        }\n      }\n    }\n    return timeParts;\n  }\n\n\n  /**\n   *  Returns a date object representing this time on a certain date.\n   */\n  _getDateObj() {\n    if (!this.dateObj) {\n      var precision = this._getPrecision();\n      // We cannot directly pass the string into the date constructor because\n      // (1) we don't want to introduce a time-dependent system date and (2) the\n      // time string might not have contained minutes, which are required by the\n      // Date constructor.\n      this.dateObj = this._dateAtPrecision(precision);\n    }\n    return this.dateObj;\n  }\n\n\n  /**\n   *  Creates a date object for the given timezone.  The returned date object\n   *  will have the specified date and time in the specified timezone.\n   * @param year...ms Just as in the Date constructor.\n   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the\n   *  timezone offset.  If not provided, the local timzone will be assumed (as the\n   *  Date constructor does).\n   */\n  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {\n    var d = new Date(year, month, day, hour, minutes, seconds, ms);\n    if (timezoneOffset) {\n      // d is in local time.  Adjust for the timezone offset.\n      // First adjust the date by the timezone offset before reducing its\n      // precision.  Otherwise,\n      // @2018-11-01T-04:00 < @2018T-05:00\n      var localTimezoneMinutes = d.getTimezoneOffset();\n      var timezoneMinutes = 0; // if Z\n      if (timezoneOffset != 'Z') {\n        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes\n        var hours = parseInt(timezoneParts[0]);\n        timezoneMinutes = parseInt(timezoneParts[1]);\n        if (hours < 0)\n          timezoneMinutes = -timezoneMinutes;\n        timezoneMinutes += 60*hours;\n      }\n      // localTimezoneMinutes has the inverse sign of its timezone offset\n      d = addMinutes(d, -localTimezoneMinutes-timezoneMinutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  A map from a FHIRPath time units to a function used to add that\n *  quantity to a date/time.\n */\nFP_TimeBase.timeUnitToAddFn = {\n  \"year\": __webpack_require__(/*! date-fns/add_years */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_years/index.js\"),\n  \"month\": __webpack_require__(/*! date-fns/add_months */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_months/index.js\"),\n  \"week\": __webpack_require__(/*! date-fns/add_weeks */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_weeks/index.js\"),\n  \"day\": __webpack_require__(/*! date-fns/add_days */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_days/index.js\"),\n  \"hour\": __webpack_require__(/*! date-fns/add_hours */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_hours/index.js\"),\n  \"minute\": __webpack_require__(/*! date-fns/add_minutes */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_minutes/index.js\"),\n  \"second\": __webpack_require__(/*! date-fns/add_seconds */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_seconds/index.js\"),\n  \"millisecond\": __webpack_require__(/*! date-fns/add_milliseconds */ \"(ssr)/../node_modules/.pnpm/date-fns@1.30.1/node_modules/date-fns/add_milliseconds/index.js\")\n};\n\n\nclass FP_DateTime extends FP_TimeBase {\n  /**\n   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater\n   *  than otherDateTime.  Comparisons are made at the lesser of the two date time\n   *  precisions.\n   */\n  compare(otherDateTime) {\n    if (!(otherDateTime instanceof FP_DateTime))\n      throw 'Invalid comparison of a DateTime with something else';\n    return super.compare(otherDateTime);\n  }\n\n\n  /**\n   *  Returns the match data from matching dateTimeRE against the datetime string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(dateTimeRE, 5);\n  }\n\n  /**\n   *  Returns an array of the pieces of the date time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  date time. The returned array will contain separate elements for the year,\n   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those\n   *  are as present).  The length of the returned array will therefore be an\n   *  indication of the precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      let timeMatchData =  this._getMatchData();\n      let year = timeMatchData[0];\n      this.timeParts = [year];\n      var month = timeMatchData[1];\n      if (month) { // Remove other information from year\n        this.timeParts[0] = year.slice(0, year.length-month.length);\n        this.timeParts[1] = month;\n        let day = timeMatchData[2];\n        if (day) { // Remove day information from month\n          this.timeParts[1] = month.slice(0, month.length-day.length);\n          this.timeParts[2] = day;\n          let time = timeMatchData[3];\n          if (time) { // Remove time from day\n            this.timeParts[2] = day.slice(0, day.length-time.length);\n            if (time[0] === 'T') // remove T from hour\n              timeMatchData[3] = time.slice(1);\n            this.timeParts = this.timeParts.concat(\n              super._getTimeParts(timeMatchData.slice(3)));\n          }\n        }\n      }\n    }\n    return this.timeParts;\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   * @param precision the new precision, which is assumed to be less than\n   *  or equal to the current precision.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[7];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = parseInt(timeParts[0]);\n    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;\n    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;\n    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;\n    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)): 0;\n    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)): 0;\n    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      year = d.getFullYear();\n      month = precision > 0 ? d.getMonth() : 0;\n      day = precision > 1 ? d.getDate() : 1;\n      hour = precision > 2 ? d.getHours() : 0;\n      minutes = precision > 3 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a DateTime.\n * @return If str is convertible to a DateTime, returns an FP_DateTime;\n *  otherwise returns null.\n */\nFP_DateTime.checkString = function(str) {\n  let d = new FP_DateTime(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_DateTime._timeUnitToDatePrecision = {\n  \"year\": 0,\n  \"month\": 1,\n  \"week\": 2, // wk is just 7*d\n  \"day\": 2,\n  \"hour\": 3,\n  \"minute\": 4,\n  \"second\": 5,\n  \"millisecond\": 6\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_DateTime._datePrecisionToTimeUnit = [\n  \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"\n];\n\n\n\nclass FP_Time extends FP_TimeBase {\n  /**\n   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_Time.checkString instead.\n   */\n  constructor(timeStr) {\n    if (timeStr[0] == 'T')\n      timeStr = timeStr.slice(1);\n    super(timeStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater\n   *  than otherTime.  Comparisons are made at the lesser of the two time\n   *  precisions.\n   */\n  compare(otherTime) {\n    if (!(otherTime instanceof FP_Time))\n      throw 'Invalid comparison of a time with something else';\n    return super.compare(otherTime);\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   *  The \"date\" portion of the returned Date object is not meaningful, and\n   *  should be ignored.\n   * @param precision the new precision, which is assumed to be less than the\n   *  or equal to the current precision.  A precision of 0 means the hour.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[4];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = 2010; // Have to pick some year for the date object\n    var month = 0;\n    var day = 1;\n    var hour = parseInt(timeParts[0]);\n    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)): 0;\n    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)): 0;\n    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (timezoneOffset) {\n      // Keep the date the same (in the local timezone), so it is not a relevant\n      // factor when comparing different times.\n      d.setYear(year);\n      d.setMonth(month);\n      d.setDate(day);\n    }\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      hour = d.getHours();\n      minutes = precision > 0 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n\n\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(timeRE, 2);\n  }\n\n  /**\n   *  Returns an array of the pieces of the time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  time. The returned array will contain separate elements for the hour,\n   *  minutes, seconds, and milliseconds (or as many of those are as present).\n   *  The length of the returned array will therefore be an indication of the\n   *  precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      this.timeParts = super._getTimeParts(this._getMatchData());\n    }\n    return this.timeParts;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a Time.\n * @return If str is convertible to a Time, returns an FP_Time;\n *  otherwise returns null.\n */\nFP_Time.checkString = function(str) {\n  let d = new FP_Time(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_Time._timeUnitToDatePrecision = {\n  \"hour\": 0,\n  \"minute\": 1,\n  \"second\": 2,\n  \"millisecond\": 3\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_Time._datePrecisionToTimeUnit = [\"hour\", \"minute\", \"second\", \"millisecond\"];\n\n\n/**\n *  Returns either the given number or a string with the number prefixed by\n *  zeros if the given number is less than the given length.\n * @param num the nubmer to format\n * @param len the number of returned digits.  For now this must either be 2 or\n *  3. (Optional-- default is 2).\n */\nfunction formatNum(num, len) {\n  // Could use String.repeat, but that requires convertin num to an string first\n  // to get its length.  This might be slightly faster given that we only need 2\n  // or three 3 digit return values.\n  var rtn = num;\n  if (len === 3 && num < 100)\n    rtn = '0' + num;\n  if (num < 10)\n    rtn = '0' + rtn;\n  return rtn;\n}\n\n\n/**\n *  Formats the given date object into an ISO8601 datetime string, expressing it\n *  in the local timezone.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDateTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 5; // maximum\n  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm\n  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.\n  // Actually, I wanted to keep the original timezone given in the constructor,\n  // but that is difficult due to daylight savings time changes.  (For instance,\n  // if you add 6 months, the timezone offset could change).\n  var rtn = '' + date.getFullYear();\n  if (precision > 0) {\n    rtn += '-' + formatNum(date.getMonth() + 1);\n    if (precision > 1) {\n      rtn += '-' + formatNum(date.getDate());\n      if (precision > 2) {\n        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);\n      }\n    }\n  }\n  // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not\n  // have a time part (except that the grammar allows 'Z', which is\n  // inconsistent).\n  if (precision > 2) {\n    // Note:  getTimezoneoffset returns the offset for the local system at the\n    // given date.\n    var tzOffset = date.getTimezoneOffset();\n    // tzOffset is a number of minutes, and is positive for negative timezones,\n    // and negative for positive timezones.\n    var tzSign = tzOffset < 0 ? '+' : '-';\n    tzOffset = Math.abs(tzOffset);\n    var tzMin = tzOffset % 60;\n    var tzHour = (tzOffset - tzMin) / 60;\n    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);\n  }\n  return rtn;\n};\n\n\n/**\n *  Returns a time string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  timeRE.\n * @return a string in ISO 8601 format.\n */\nFP_DateTime.isoTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 2; // maximum\n\n  let rtn = '' + formatNum(date.getHours());\n  if (precision > 0) {\n    rtn += ':' + formatNum(date.getMinutes());\n    if (precision > 1) {\n      rtn += ':' + formatNum(date.getSeconds() );\n      if (date.getMilliseconds())\n        rtn += '.' + formatNum(date.getMilliseconds(), 3);\n    }\n  }\n  return rtn;\n};\n\n\nclass FP_Date extends FP_DateTime {\n  /**\n   * Constructs an FP_Date, assuming dateStr is valid.  If you don't know\n   * whether a string is a valid Date, use FP_Date.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   * Returns the match data from matching dateRE against the date string.\n   * Also sets this.precision.\n   */\n  _getMatchData() {\n    return FP_TimeBase.prototype._getMatchData.apply(this, [dateRE, 2]);\n  }\n}\n\n\n/**\n * Tests str to see if it is convertible to a Date.\n * @return If str is convertible to a Date, returns an FP_Date;\n *  otherwise returns null.\n */\nFP_Date.checkString = function(str) {\n  let d = new FP_Date(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n\n/**\n * Returns a date string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_Date.isoDate = function(date, precision) {\n  if (precision === undefined || precision > 2)\n    precision = 2;\n  return FP_DateTime.isoDateTime(date, precision);\n};\n\nclass FP_Instant extends FP_DateTime {\n  /**\n   * Constructs an FP_Instant, assuming instantStr is valid.  If you don't know\n   * whether a string is a valid \"instant\", use FP_Instant.checkString instead.\n   */\n  constructor(instantStr) {\n    super(instantStr);\n  }\n\n\n  /**\n   * Returns the match data from matching instantRE against the \"instant\" string.\n   * Also sets this.precision.\n   */\n  _getMatchData() {\n    return FP_TimeBase.prototype._getMatchData.apply(this, [instantRE, 5]);\n  }\n}\n\n\n/**\n * Tests str to see if it is convertible to an \"instant\".\n * @return If str match the \"instant\" RegExp, returns an FP_Instant;\n *  otherwise returns null.\n */\nFP_Instant.checkString = function(str) {\n  let d = new FP_Instant(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A class that represents a node in a FHIR resource, with path and possibly type\n *  information.\n */\nclass ResourceNode {\n  /**\n   *  Constructs a instance for the given node (\"data\") of a resource.  If the\n   *  data is the top-level node of a resouce, the path and type parameters will\n   *  be ignored in favor of the resource's resourceType field.\n   * @param {*} data - the node's data or value (which might be an object with\n   *  sub-nodes, an array, or FHIR data type)\n   * @param {ResourceNode} parentResNode - parent ResourceNode.\n   * @param {string} path - the node's path in the resource (e.g. Patient.name).\n   *  If the data's type can be determined from data, that will take precedence\n   *  over this parameter.\n   * @param {*} _data - additional data stored in a property named with \"_\"\n   *  prepended, see https://www.hl7.org/fhir/element.html#json for details.\n   * @param {string} fhirNodeDataType - FHIR node data type, if the resource node\n   *  is described in the FHIR model.\n   *  @param {Object} model - the model object specific to a domain, e.g. R4.\n   */\n  constructor(data, parentResNode, path, _data, fhirNodeDataType, model) {\n    // If data is a resource (maybe a contained resource) reset the path\n    // information to the resource type.\n    if (data?.resourceType) {\n      path = data.resourceType;\n      fhirNodeDataType = data.resourceType;\n    }\n    this.parentResNode = parentResNode || null;\n    this.path = path || null;\n    this.data = data;\n    this._data = _data || {};\n    this.fhirNodeDataType = fhirNodeDataType || null;\n    this.model = model || null;\n  }\n\n  /**\n   * Returns resource node type info.\n   * @return {TypeInfo}\n   */\n  getTypeInfo() {\n    if (!this.typeInfo) {\n      let typeInfo;\n\n      if (this.fhirNodeDataType) {\n        if (/^System\\.(.*)$/.test(this.fhirNodeDataType)) {\n          typeInfo = new TypeInfo({namespace: TypeInfo.System, name: RegExp.$1});\n        } else {\n          typeInfo = new TypeInfo({\n            namespace: TypeInfo.FHIR,\n            name: this.fhirNodeDataType\n          });\n        }\n      }\n\n      this.typeInfo = typeInfo\n        // Resource object properties that are not defined in the model now have\n        // System.* data types:\n        || TypeInfo.createByValueInSystemNamespace(this.data);\n    }\n    return this.typeInfo;\n  }\n\n  toJSON() {\n    return JSON.stringify(this.data);\n  }\n\n  /**\n   * Converts a resource node value to an instance of the FHIRPath system type\n   * (FP_Quantity, FP_Date, FP_DateTime, or FP_Time) for use in evaluating\n   * a FHIRPath expression if the node path matches the specified type in the\n   * model and when conversion is possible, otherwise returns the data as is.\n   * Throws an exception if the data is a Quantity that has a comparator.\n   * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:\n   * https://www.hl7.org/fhir/fhirpath.html#quantity\n   * this.data is not changed, but converted value is returned.\n   * @return {FP_Type|any}\n   */\n  convertData() {\n    if (!this.convertedData) {\n      var data = this.data;\n      if (data != null) {\n        const cls = TypeInfo.typeToClassWithCheckString[this.path];\n        if (cls) {\n          data = cls.checkString(data) || data;\n        } else if (TypeInfo.isType(this.path, 'Quantity', this.model)) {\n          if (data?.system === ucumSystemUrl) {\n            if (typeof data.value === 'number' && typeof data.code === 'string') {\n              if (data.comparator !== undefined)\n                throw new Error('Cannot convert a FHIR.Quantity that has a comparator');\n              data = new FP_Quantity(\n                data.value,\n                FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\\'' + data.code + '\\''\n              );\n            }\n          }\n        }\n      }\n\n      this.convertedData = data;\n    }\n    return this.convertedData;\n  }\n\n}\n\n\n/**\n *  Returns a ResourceNode for the given data node, checking first to see if the\n *  given node is already a ResourceNode.  Takes the same arguments as the\n *  constructor for ResourceNode.\n */\nResourceNode.makeResNode = function(data, parentResNode, path, _data, fhirNodeDataType, model) {\n  return (data instanceof ResourceNode) ? data : new ResourceNode(data, parentResNode, path, _data, fhirNodeDataType, model);\n};\n\n// The set of available data types in the System namespace\nconst availableSystemTypes = new Set();\n// IE11 probably doesn't support `new Set(iterable)`\n['Boolean', 'String', 'Integer', 'Decimal', 'Date', 'DateTime', 'Time', 'Quantity'].forEach(i => availableSystemTypes.add(i));\n\n/**\n * Object class defining type information.\n * Used for minimal type support.\n * (see http://hl7.org/fhirpath/#types-and-reflection)\n */\nclass TypeInfo {\n  constructor({name, namespace}) {\n    this.name = name;\n    this.namespace = namespace;\n  }\n\n  // The \"model\" data object specific to a domain, e.g. R4.\n  static model = null;\n\n  /**\n   * Checks for equality with another TypeInfo object, or that another TypeInfo\n   * object specifies a superclass for the type specified by this object.\n   * @param {TypeInfo} other - the TypeInfo object to compare with.\n   * @param {Object} model - the model object specific to a domain, e.g. R4.\n   * @return {boolean}\n   */\n  is(other, model) {\n    if (\n      other instanceof TypeInfo &&\n      (!this.namespace || !other.namespace || this.namespace === other.namespace)\n    ) {\n      return model && (!this.namespace || this.namespace === TypeInfo.FHIR)\n        ? TypeInfo.isType(this.name, other.name, model)\n        : this.name === other.name;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the string representation of type info.\n   * @returns {string}\n   */\n  toString() {\n    return (this.namespace ? this.namespace + '.' : '') + this.name;\n  }\n\n  /**\n   * Returns true if type info represents a valid type identifier, false otherwise.\n   * @param {Object} model - the model object specific to a domain, e.g. R4.\n   * @returns {boolean}\n   */\n  isValid(model) {\n    let result = false;\n    if (this.namespace === 'System') {\n      result = availableSystemTypes.has(this.name);\n    } else if (this.namespace === 'FHIR') {\n      result = model.availableTypes.has(this.name);\n    } else if (!this.namespace) {\n      result = availableSystemTypes.has(this.name)\n        || model.availableTypes.has(this.name);\n    }\n    return result;\n  }\n}\n\n/**\n * Defines a map from a datatype to a datatype class which has a checkString method.\n * @type {Object.<string, FP_DateTime | FP_Time>}\n */\nTypeInfo.typeToClassWithCheckString = {\n  date: FP_Date,\n  dateTime: FP_DateTime,\n  instant: FP_Instant,\n  time: FP_Time\n};\n\n/**\n * Checks if the type name or its parent type name is equal to\n * the expected type name.\n * @param type - type name to check.\n * @param superType - expected type name.\n * @param model - the model object specific to a domain, e.g. R4.\n * @return {boolean}\n */\nTypeInfo.isType = function(type, superType, model) {\n  do {\n    if (type === superType) {\n      return true;\n    }\n  } while ((type = model?.type2Parent[type]));\n  return false;\n};\n\n// Available namespaces:\nTypeInfo.System = 'System';\nTypeInfo.FHIR = 'FHIR';\n\n/**\n * Creates new TypeInfo object for specified value in the System namespace.\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.createByValueInSystemNamespace = function(value) {\n  let name = typeof value;\n\n  if (Number.isInteger(value)) {\n    name = 'integer';\n  } else if (name === \"number\") {\n    name = 'decimal';\n  } else if (value instanceof FP_Date) {\n    name = 'date';\n  } else if (value instanceof FP_DateTime) {\n    name = 'dateTime';\n  } else if (value instanceof FP_Time) {\n    name = 'time';\n  } else if (value instanceof FP_Quantity) {\n    name = 'Quantity';\n  }\n\n  name = name.replace(/^\\w/, c => c.toUpperCase());\n\n  // Currently can return name = \"Object\" which is probably wrong,\n  // but the isValid method allows you to check this.\n  return new TypeInfo({namespace: TypeInfo.System, name}) ;\n};\n\n/**\n * Retrieves TypeInfo by value\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.fromValue = function (value) {\n  return value instanceof ResourceNode\n    ? value.getTypeInfo()\n    : TypeInfo.createByValueInSystemNamespace(value);\n};\n\n/**\n * Set of primitive data type names.\n */\nconst primitives = new Set();\n// IE11 probably doesn't support `new Set(iterable)`\n[\n  \"instant\",\n  \"time\",\n  \"date\",\n  \"dateTime\",\n  \"base64Binary\",\n  \"decimal\",\n  \"integer64\",\n  \"boolean\",\n  \"string\",\n  \"code\",\n  \"markdown\",\n  \"id\",\n  \"integer\",\n  \"unsignedInt\",\n  \"positiveInt\",\n  \"uri\",\n  \"oid\",\n  \"uuid\",\n  \"canonical\",\n  \"url\",\n  \"Integer\",\n  \"Decimal\",\n  \"String\",\n  \"Date\",\n  \"DateTime\",\n  \"Time\"\n].forEach(i => primitives.add(i));\n\n/**\n * Checks whether the specified type information contains a primitive data type.\n * @param {TypeInfo} typeInfo\n * @return {boolean}\n */\nTypeInfo.isPrimitive = function(typeInfo) {\n  return primitives.has(typeInfo.name);\n};\n\n/**\n * Checks whether the specified value is of a primitive data type.\n * @param {*} value - The value to check.\n * @returns {boolean} - Returns true if the value is a primitive data type,\n *  otherwise false.\n */\n\nTypeInfo.isPrimitiveValue = function(value) {\n  if (value instanceof ResourceNode) {\n    return primitives.has(value.getTypeInfo().name);\n  } else {\n    // Simplified check for primitive data types:\n    return typeof value !== 'object' || value instanceof FP_Type;\n  }\n};\n\n/**\n * Basic \"type()\" function implementation\n * (see http://hl7.org/fhirpath/#reflection)\n * @param {Array<*>} coll - input collection\n * @return {Array<*>}\n */\nfunction typeFn(coll) {\n  return coll.map(value => {\n    return TypeInfo.fromValue(value);\n  });\n}\n\n/**\n * Implementation of function \"is(type : type specifier)\" and operator \"is\"\n * (see http://hl7.org/fhirpath/#is-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {boolean|[]}\n */\nfunction isFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of 'is', got \" + JSON.stringify(coll));\n  }\n\n  const ctx = this;\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo, ctx.model);\n}\n\n/**\n * Implementation of function \"as(type : type specifier)\" and operator \"as\"\n * (see http://hl7.org/fhirpath/#as-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {Array<*>}\n */\nfunction asFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of 'as', got \" + JSON.stringify(coll));\n  }\n\n  const ctx = this;\n  return TypeInfo.fromValue(coll[0]).is(typeInfo, ctx.model) ? coll : [];\n}\n\nmodule.exports = {\n  FP_Type,\n  FP_TimeBase,\n  FP_Date,\n  FP_DateTime,\n  FP_Instant,\n  FP_Time,\n  FP_Quantity,\n  timeRE,\n  dateTimeRE,\n  dateRE,\n  instantRE,\n  ResourceNode,\n  TypeInfo,\n  typeFn,\n  isFn,\n  asFn\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLG9IQUFzQjtBQUNqRCxrQkFBa0Isb0tBQXdDO0FBQzFELGdCQUFnQixtQkFBTyxDQUFDLG1HQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVyxLQUFLLFlBQVk7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVyxLQUFLLFlBQVk7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2RkFBNkY7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsZ0hBQW9CO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxrSEFBcUI7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLGdIQUFvQjtBQUN0QyxTQUFTLG1CQUFPLENBQUMsOEdBQW1CO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxnSEFBb0I7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLG9IQUFzQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsb0hBQXNCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLDhIQUEyQjtBQUNwRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLDRDQUE0QztBQUMvRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9maGlycGF0aEAzLjE4LjAvbm9kZV9tb2R1bGVzL2ZoaXJwYXRoL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhZGRNaW51dGVzID0gcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX21pbnV0ZXMnKTtcbmNvbnN0IHVjdW1VdGlscyA9IHJlcXVpcmUoJ0BsaG5jYmMvdWN1bS1saGMnKS5VY3VtTGhjVXRpbHMuZ2V0SW5zdGFuY2UoKTtcbmNvbnN0IG51bWJlcnMgPSByZXF1aXJlKCcuL251bWJlcnMnKTtcblxuY29uc3QgdWN1bVN5c3RlbVVybCA9ICdodHRwOi8vdW5pdHNvZm1lYXN1cmUub3JnJztcbmxldCB0aW1lRm9ybWF0ID1cbiAgJ1swLTldWzAtOV0oXFxcXDpbMC05XVswLTldKFxcXFw6WzAtOV1bMC05XShcXFxcLlswLTldKyk/KT8pPyhafChcXFxcK3wtKVswLTldWzAtOV1cXFxcOlswLTldWzAtOV0pPyc7XG5sZXQgdGltZVJFID0gbmV3IFJlZ0V4cCgnXlQ/Jyt0aW1lRm9ybWF0KyckJyk7XG5sZXQgZGF0ZVRpbWVSRSA9IG5ldyBSZWdFeHAoXG4gICdeWzAtOV1bMC05XVswLTldWzAtOV0oLVswLTldWzAtOV0oLVswLTldWzAtOV0oVCcrdGltZUZvcm1hdCsnKT8pPyk/Wj8kJyk7XG5sZXQgZGF0ZVJFID0gbmV3IFJlZ0V4cChcbiAgJ15bMC05XVswLTldWzAtOV1bMC05XSgtWzAtOV1bMC05XSgtWzAtOV1bMC05XSk/KT8kJyk7XG5sZXQgaW5zdGFudFJFID0gbmV3IFJlZ0V4cChcbiAgJ15bMC05XVswLTldWzAtOV1bMC05XSgtWzAtOV1bMC05XSgtWzAtOV1bMC05XShUWzAtOV1bMC05XShcXFxcOlswLTldWzAtOV0oXFxcXDpbMC05XVswLTldKFxcXFwuWzAtOV0rKT8pKShafChcXFxcK3wtKVswLTldWzAtOV1cXFxcOlswLTldWzAtOV0pKSkpJCcpO1xuLy8gRkhJUiBkYXRlL3RpbWUgcmVndWxhciBleHByZXNzaW9ucyBhcmUgc2xpZ2h0bHkgZGlmZmVyZW50LiAgRm9yIG5vdywgd2Ugd2lsbFxuLy8gc3RpY2sgd2l0aCB0aGUgRkhJUlBhdGggcmVndWxhciBleHByZXNzaW9ucy5cbi8vbGV0IGZoaXJUaW1lUkUgPSAvKFswMV1bMC05XXwyWzAtM10pOlswLTVdWzAtOV06KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/Lztcbi8vbGV0IGZoaXJEYXRlVGltZVJFID1cbi8vLyhbMC05XShbMC05XShbMC05XVsxLTldfFsxLTldMCl8WzEtOV0wMCl8WzEtOV0wMDApKC0oMFsxLTldfDFbMC0yXSkoLSgwWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pKFQoWzAxXVswLTldfDJbMC0zXSk6WzAtNV1bMC05XTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKCgwWzAtOV18MVswLTNdKTpbMC01XVswLTldfDE0OjAwKSkpPyk/KT8vO1xuXG4vKipcbiAqICAgQ2xhc3MgRlBfVHlwZSBpcyB0aGUgc3VwZXJjbGFzcyBmb3IgRkhJUlBhdGggdHlwZXMgdGhhdCByZXF1aXJlZCBzcGVjaWFsXG4gKiAgIGhhbmRsaW5nLlxuICovXG5jbGFzcyBGUF9UeXBlIHtcbiAgLyoqXG4gICAqICBUZXN0cyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGVxdWFsIHRvIGFub3RoZXIuICBSZXR1cm5zIGVpdGhlciB0cnVlLFxuICAgKiAgZmFsc2UsIG9yIHVuZGVmaW5lZCAod2hlcmUgaW4gdGhlIEZISVJQYXRoIHNwZWNpZmljYXRpb24gZW1wdHkgd291bGQgYmVcbiAgICogIHJldHVybmVkKS4gIFRoZSB1bmRlZmluZWQgcmV0dXJuIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZXMgd2VyZSB0aGVcbiAgICogIHNhbWUgdG8gdGhlIHNoYXJlZCBwcmVjaXNpb24sIGJ1dCB0aGF0IHRoZXkgaGFkIGRpZmZlcm5lbnQgbGV2ZWxzIG9mXG4gICAqICBwcmVjaXNpb24uXG4gICAqL1xuICBlcXVhbHMoLyogb3RoZXJPYmogKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogIFRlc3RzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgZXF1aXZhbGFudCB0byBhbm90aGVyLiAgUmV0dXJucyBlaXRoZXIgdHJ1ZSxcbiAgICogIGZhbHNlLCBvciB1bmRlZmluZWQgKHdoZXJlIGluIHRoZSBGSElSUGF0aCBzcGVjaWZpY2F0aW9uIGVtcHR5IHdvdWxkIGJlXG4gICAqICByZXR1cm5lZCkuXG4gICAqL1xuICBlcXVpdmFsZW50VG8oLyogb3RoZXJPYmogKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5hc1N0ciA/IHRoaXMuYXNTdHIgOiBzdXBlci50b1N0cmluZygpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgLTEsIDAsIG9yIDEgaWYgdGhpcyBvYmplY3QgaXMgbGVzcyB0aGVuLCBlcXVhbCB0bywgb3IgZ3JlYXRlclxuICAgKiAgdGhhbiBvdGhlck9iai5cbiAgICovXG4gIGNvbXBhcmUoLyogb3RoZXJPYmogKi8pIHtcbiAgICB0aHJvdyAnQ29tcGFyaXNvbiBub3QgaW1wbGVtZW50ZWQgZm9yICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogIEFkZHMgb3RoZXIgdmFsdWUgdG8gdGhpcyB2YWx1ZS5cbiAgICovXG4gIHBsdXMoLyogb3RoZXJPYmogKi8pIHtcbiAgICB0aHJvdyAnQWRkaXRpb24gbm90IGltcGxlbWVudGVkIGZvciAnICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2YWx1ZSBieSBhbm90aGVyIHZhbHVlLlxuICAgKi9cbiAgbXVsKC8qIG90aGVyT2JqICovKSB7XG4gICAgdGhyb3cgJ011bHRpcGxpY2F0aW9uIG5vdCBpbXBsZW1lbnRlZCBmb3IgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgdmFsdWUgYnkgYW5vdGhlciB2YWx1ZS5cbiAgICovXG4gIGRpdigvKiBvdGhlck9iaiAqLykge1xuICAgIHRocm93ICdEaXZpc2lvbiBub3QgaW1wbGVtZW50ZWQgZm9yICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbn1cblxuXG4vKipcbiAqICBBIGNsYXNzIGZvciBRdWFudGl0aWVzLlxuICovXG5jbGFzcyBGUF9RdWFudGl0eSBleHRlbmRzIEZQX1R5cGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdW5pdCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hc1N0ciA9IHZhbHVlICsgJyAnICsgdW5pdDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgfVxuXG4gIGVxdWFscyhvdGhlclF1YW50aXR5KSB7XG4gICAgaWYgKCEob3RoZXJRdWFudGl0eSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGhpc1VuaXRJblNlY29uZHMgPSBGUF9RdWFudGl0eS5fY2FsZW5kYXJEdXJhdGlvbjJTZWNvbmRzW3RoaXMudW5pdF07XG4gICAgY29uc3Qgb3RoZXJVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1tvdGhlclF1YW50aXR5LnVuaXRdO1xuXG4gICAgaWYgKFxuICAgICAgIXRoaXNVbml0SW5TZWNvbmRzICE9PSAhb3RoZXJVbml0SW5TZWNvbmRzICYmXG4gICAgICAodGhpc1VuaXRJblNlY29uZHMgPiAxIHx8IG90aGVyVW5pdEluU2Vjb25kcyA+IDEpXG4gICAgKSB7XG4gICAgICAvLyBJZiBvbmUgb2YgdGhlIG9wZXJhbmRzIGlzIGEgY2FsZW5kYXIgZHVyYXRpb24gZ3JlYXRlciB0aGFuIHNlY29uZHMgYW5kXG4gICAgICAvLyBhbm90aGVyIG9uZSBpcyBub3QgYSBjYWxlbmRhciBkdXJhdGlvbiwgcmV0dXJuIGVtcHR5IHJlc3VsdFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudW5pdCA9PT0gb3RoZXJRdWFudGl0eS51bml0KSB7XG4gICAgICByZXR1cm4gbnVtYmVycy5pc0VxdWFsKHRoaXMudmFsdWUsIG90aGVyUXVhbnRpdHkudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgeWVhci9tb250aCBjb21wYXJpc29uIGNhc2U6IDEgeWVhciA9IDEyIG1vbnRoXG4gICAgY29uc3QgY29tcGFyZVllYXJzQW5kTW9udGhzID0gdGhpcy5fY29tcGFyZVllYXJzQW5kTW9udGhzKG90aGVyUXVhbnRpdHkpO1xuICAgIGlmIChjb21wYXJlWWVhcnNBbmRNb250aHMpIHtcbiAgICAgIHJldHVybiBjb21wYXJlWWVhcnNBbmRNb250aHMuaXNFcXVhbDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNvbXBhcmlzb24gY2FzZVxuICAgIGNvbnN0IHRoaXNRdWFudGl0eSA9IEZQX1F1YW50aXR5LnRvVWN1bVF1YW50aXR5KHRoaXMudmFsdWUsIHRoaXMudW5pdCksXG4gICAgICBub3JtYWxpemVkT3RoZXJRdWFudGl0eSA9IEZQX1F1YW50aXR5LnRvVWN1bVF1YW50aXR5KG90aGVyUXVhbnRpdHkudmFsdWUsIG90aGVyUXVhbnRpdHkudW5pdCksXG4gICAgICBjb252UmVzdWx0ID0gdWN1bVV0aWxzLmNvbnZlcnRVbml0VG8obm9ybWFsaXplZE90aGVyUXVhbnRpdHkudW5pdCwgbm9ybWFsaXplZE90aGVyUXVhbnRpdHkudmFsdWUsIHRoaXNRdWFudGl0eS51bml0KTtcblxuICAgIGlmIChjb252UmVzdWx0LnN0YXR1cyAhPT0gJ3N1Y2NlZWRlZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtYmVycy5pc0VxdWFsKHRoaXNRdWFudGl0eS52YWx1ZSwgY29udlJlc3VsdC50b1ZhbCk7XG4gIH1cblxuICBlcXVpdmFsZW50VG8ob3RoZXJRdWFudGl0eSkge1xuICAgIGlmICghKG90aGVyUXVhbnRpdHkgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVuaXQgPT09IG90aGVyUXVhbnRpdHkudW5pdCkge1xuICAgICAgcmV0dXJuIG51bWJlcnMuaXNFcXVpdmFsZW50KHRoaXMudmFsdWUsIG90aGVyUXVhbnRpdHkudmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHVjdW1Vbml0Q29kZSA9IEZQX1F1YW50aXR5LmdldEVxdWl2YWxlbnRVY3VtVW5pdENvZGUodGhpcy51bml0KSxcbiAgICAgIG90aGVyVWN1bVVuaXRDb2RlID0gRlBfUXVhbnRpdHkuZ2V0RXF1aXZhbGVudFVjdW1Vbml0Q29kZShvdGhlclF1YW50aXR5LnVuaXQpLFxuICAgICAgY29udlJlc3VsdCA9IHVjdW1VdGlscy5jb252ZXJ0VW5pdFRvKG90aGVyVWN1bVVuaXRDb2RlLCBvdGhlclF1YW50aXR5LnZhbHVlLCB1Y3VtVW5pdENvZGUpO1xuXG4gICAgaWYgKGNvbnZSZXN1bHQuc3RhdHVzICE9PSAnc3VjY2VlZGVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJzLmlzRXF1aXZhbGVudCh0aGlzLnZhbHVlLCBjb252UmVzdWx0LnRvVmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIG51bWJlciBsZXNzIHRoYW4gMCwgZXF1YWwgdG8gMCBvciBncmVhdGVyIHRoYW4gMFxuICAgKiAgaWYgdGhpcyBxdWFudGl0eSBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gb3RoZXJRdWFudGl0eS5cbiAgICogIElmIHRoZSBxdWFudGl0aWVzIGNvdWxkIG5vdCBiZSBjb21wYXJlZCwgcmV0dXJucyBudWxsLCB3aGljaCB3aWxsIGJlXG4gICAqICBjb252ZXJ0ZWQgdG8gYW4gZW1wdHkgY29sbGVjdGlvbiBpbiB0aGUgXCJkb0ludm9rZVwiIGZ1bmN0aW9uXG4gICAqICBTZWUgaHR0cHM6Ly9obDcub3JnL2ZoaXJwYXRoLyNjb21wYXJpc29uXG4gICAqICBAcGFyYW0ge0ZQX1F1YW50aXR5fSBvdGhlclF1YW50aXR5XG4gICAqICBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAgICovXG4gIGNvbXBhcmUob3RoZXJRdWFudGl0eSkge1xuICAgIGlmICh0aGlzLnVuaXQgPT09IG90aGVyUXVhbnRpdHkudW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgLSBvdGhlclF1YW50aXR5LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRoaXNVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1t0aGlzLnVuaXRdO1xuICAgIGNvbnN0IG90aGVyVW5pdEluU2Vjb25kcyA9IEZQX1F1YW50aXR5Ll9jYWxlbmRhckR1cmF0aW9uMlNlY29uZHNbb3RoZXJRdWFudGl0eS51bml0XTtcblxuICAgIGlmIChcbiAgICAgICF0aGlzVW5pdEluU2Vjb25kcyAhPT0gIW90aGVyVW5pdEluU2Vjb25kcyAmJlxuICAgICAgKHRoaXNVbml0SW5TZWNvbmRzID4gMSB8fCBvdGhlclVuaXRJblNlY29uZHMgPiAxKVxuICAgICkge1xuICAgICAgLy8gSWYgb25lIG9mIHRoZSBvcGVyYW5kcyBpcyBhIGNhbGVuZGFyIGR1cmF0aW9uIGdyZWF0ZXIgdGhhbiBzZWNvbmRzIGFuZFxuICAgICAgLy8gYW5vdGhlciBvbmUgaXMgbm90IGEgY2FsZW5kYXIgZHVyYXRpb24sIHJldHVybiBlbXB0eSByZXN1bHRcbiAgICAgIC8vIEZvciBleGFtcGxlLCAxIHllYXIgPiAxICdhJyBzaG91bGQgcmV0dXJuIFtdXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB1Y3VtVW5pdENvZGUgPSBGUF9RdWFudGl0eS5nZXRFcXVpdmFsZW50VWN1bVVuaXRDb2RlKHRoaXMudW5pdCksXG4gICAgICBvdGhlclVjdW1Vbml0Q29kZSA9IEZQX1F1YW50aXR5LmdldEVxdWl2YWxlbnRVY3VtVW5pdENvZGUob3RoZXJRdWFudGl0eS51bml0KSxcbiAgICAgIGNvbnZSZXN1bHQgPSB1Y3VtVXRpbHMuY29udmVydFVuaXRUbyhvdGhlclVjdW1Vbml0Q29kZSwgb3RoZXJRdWFudGl0eS52YWx1ZSwgdWN1bVVuaXRDb2RlKTtcblxuICAgIGlmIChjb252UmVzdWx0LnN0YXR1cyAhPT0gJ3N1Y2NlZWRlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZhbHVlIC0gY29udlJlc3VsdC50b1ZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQWRkcyBhIHF1YW50aXR5IHRvIHRoaXMgcXVhbnRpdHkuXG4gICAqIEBwYXJhbSB7RlBfUXVhbnRpdHl9IG90aGVyUXVhbnRpdHkgYSBxdWFudGl0eSB0byBiZSBhZGRlZCB0byB0aGlzIHF1YW50aXR5LlxuICAgKiBAcmV0dXJuIHtGUF9RdWFudGl0eXxudWxsfVxuICAgKi9cbiAgcGx1cyhvdGhlclF1YW50aXR5KSB7XG4gICAgY29uc3QgdGhpc0NvbnZGYWN0b3IgPSBGUF9RdWFudGl0eS5feWVhck1vbnRoQ29udmVyc2lvbkZhY3Rvclt0aGlzLnVuaXRdO1xuICAgIGNvbnN0IG90aGVyQ29udkZhY3RvciA9IEZQX1F1YW50aXR5Ll95ZWFyTW9udGhDb252ZXJzaW9uRmFjdG9yW290aGVyUXVhbnRpdHkudW5pdF07XG4gICAgaWYgKHRoaXNDb252RmFjdG9yICYmIG90aGVyQ29udkZhY3Rvcikge1xuICAgICAgLy8gSWYgdGhlIHZhbHVlcyBhcmUgaW5kaWNhdGVkIGluIHllYXJzIGFuZCBtb250aHMsIHdlIHVzZSB0aGUgY29udmVyc2lvbiBmYWN0b3I6IDEgeWVhciA9IDEyIG1vbnRoc1xuICAgICAgcmV0dXJuIG5ldyBGUF9RdWFudGl0eSh0aGlzLnZhbHVlICsgb3RoZXJRdWFudGl0eS52YWx1ZSAqIG90aGVyQ29udkZhY3RvciAvIHRoaXNDb252RmFjdG9yLCB0aGlzLnVuaXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHRoaXNVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1t0aGlzLnVuaXRdO1xuICAgIGNvbnN0IG90aGVyVW5pdEluU2Vjb25kcyA9IEZQX1F1YW50aXR5Ll9jYWxlbmRhckR1cmF0aW9uMlNlY29uZHNbb3RoZXJRdWFudGl0eS51bml0XTtcblxuICAgIGlmIChcbiAgICAgICF0aGlzVW5pdEluU2Vjb25kcyAhPT0gIW90aGVyVW5pdEluU2Vjb25kcyAmJlxuICAgICAgKHRoaXNVbml0SW5TZWNvbmRzID4gMSB8fCBvdGhlclVuaXRJblNlY29uZHMgPiAxKVxuICAgICkge1xuICAgICAgLy8gSWYgb25lIG9mIHRoZSBvcGVyYW5kcyBpcyBhIGNhbGVuZGFyIGR1cmF0aW9uIGdyZWF0ZXIgdGhhbiBzZWNvbmRzIGFuZFxuICAgICAgLy8gYW5vdGhlciBvbmUgaXMgbm90IGEgY2FsZW5kYXIgZHVyYXRpb24sIHJldHVybiBlbXB0eSByZXN1bHRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRoaXNVY3VtVW5pdENvZGUgPSB0aGlzVW5pdEluU2Vjb25kcyA/ICdzJyA6IHRoaXMudW5pdC5yZXBsYWNlKHN1cnJvdW5kaW5nQXBvc3Ryb3BoZXNSZWdleCwgJycpO1xuICAgIGNvbnN0IHRoaXNWYWx1ZSA9ICh0aGlzVW5pdEluU2Vjb25kcyB8fCAxKSAqIHRoaXMudmFsdWU7XG5cbiAgICBjb25zdCBvdGhlclVjdW1Vbml0Q29kZSA9IG90aGVyVW5pdEluU2Vjb25kcyA/ICdzJyA6IG90aGVyUXVhbnRpdHkudW5pdC5yZXBsYWNlKHN1cnJvdW5kaW5nQXBvc3Ryb3BoZXNSZWdleCwgJycpO1xuICAgIGNvbnN0IG90aGVyVmFsdWUgPSAob3RoZXJVbml0SW5TZWNvbmRzIHx8IDEpICogb3RoZXJRdWFudGl0eS52YWx1ZTtcblxuICAgIGNvbnN0IGNvbnZSZXN1bHQgPSB1Y3VtVXRpbHMuY29udmVydFVuaXRUbyhvdGhlclVjdW1Vbml0Q29kZSwgb3RoZXJWYWx1ZSwgdGhpc1VjdW1Vbml0Q29kZSk7XG5cbiAgICBpZiAoY29udlJlc3VsdC5zdGF0dXMgIT09ICdzdWNjZWVkZWQnXG4gICAgICB8fCBjb252UmVzdWx0LmZyb21Vbml0LmlzU3BlY2lhbF9cbiAgICAgIHx8IGNvbnZSZXN1bHQudG9Vbml0LmlzU3BlY2lhbF8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRlBfUXVhbnRpdHkodGhpc1ZhbHVlICsgY29udlJlc3VsdC50b1ZhbCwgdGhpc1VjdW1Vbml0Q29kZSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIHF1YW50aXR5IHRvIGFub3RoZXIgcXVhbnRpdHkuXG4gICAqIEBwYXJhbSB7RlBfUXVhbnRpdHl9IG90aGVyUXVhbnRpdHkgYSBxdWFudGl0eSBieSB3aGljaCB0byBtdWx0aXBseSB0aGlzIHF1YW50aXR5LlxuICAgKiBAcmV0dXJuIHtGUF9RdWFudGl0eX1cbiAgICovXG4gIG11bChvdGhlclF1YW50aXR5KSB7XG4gICAgY29uc3QgdGhpc1VuaXRJblNlY29uZHMgPSBGUF9RdWFudGl0eS5fY2FsZW5kYXJEdXJhdGlvbjJTZWNvbmRzW3RoaXMudW5pdF07XG4gICAgY29uc3Qgb3RoZXJVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1tvdGhlclF1YW50aXR5LnVuaXRdO1xuXG4gICAgaWYgKFxuICAgICAgKHRoaXNVbml0SW5TZWNvbmRzID4gMSAmJiBvdGhlclF1YW50aXR5LnVuaXQgIT09IFwiJzEnXCIpIHx8XG4gICAgICAob3RoZXJVbml0SW5TZWNvbmRzID4gMSAmJiB0aGlzLnVuaXQgIT09IFwiJzEnXCIpXG4gICAgKSB7XG4gICAgICAvLyBJZiBvbmUgb2YgdGhlIG9wZXJhbmRzIGlzIGEgY2FsZW5kYXIgZHVyYXRpb24gZ3JlYXRlciB0aGFuIHNlY29uZHMgYW5kXG4gICAgICAvLyBhbm90aGVyIG9uZSBpcyBub3QgYSBudW1iZXIsIHJldHVybiBlbXB0eSByZXN1bHRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRoaXNRID0gdGhpcy5jb252VG9VY3VtVW5pdHModGhpcywgdGhpc1VuaXRJblNlY29uZHMpO1xuICAgIGlmICghdGhpc1EpIHtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBvcGVyYW5kIGlzIG5vdCBhIFVDVU0gcXVhbnRpdHkgb3IgaXQgaGFzIGEgc3BlY2lhbCB1bml0XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBvdGhlclEgPSB0aGlzLmNvbnZUb1VjdW1Vbml0cyhvdGhlclF1YW50aXR5LCBvdGhlclVuaXRJblNlY29uZHMpO1xuICAgIGlmICghb3RoZXJRKSB7XG4gICAgICAvLyBJZiB0aGUgc2Vjb25kIG9wZXJhbmQgaXMgbm90IGEgVUNVTSBxdWFudGl0eSBvciBpdCBoYXMgYSBzcGVjaWFsIHVuaXRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCB1c2UgVUNVTSB1bml0IGNvZGVzIGZvciBkdXJhdGlvbnMgaW4gc2ltcGxlIGNhc2VzXG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCInMSdcIikge1xuICAgICAgcmV0dXJuIG5ldyBGUF9RdWFudGl0eSh0aGlzLnZhbHVlICogb3RoZXJRdWFudGl0eS52YWx1ZSwgb3RoZXJRdWFudGl0eS51bml0KTtcbiAgICB9IGVsc2UgaWYgKG90aGVyUXVhbnRpdHkudW5pdCA9PT0gXCInMSdcIikge1xuICAgICAgcmV0dXJuIG5ldyBGUF9RdWFudGl0eSh0aGlzLnZhbHVlICogb3RoZXJRdWFudGl0eS52YWx1ZSwgdGhpcy51bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZQX1F1YW50aXR5KFxuICAgICAgdGhpc1EudmFsdWUgKiBvdGhlclEudmFsdWUsXG4gICAgICBgJygke3RoaXNRLnVuaXR9KS4oJHtvdGhlclEudW5pdH0pJ2BcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdGhpcyBxdWFudGl0eSBieSBhbm90aGVyIHF1YW50aXR5LlxuICAgKiBAcGFyYW0ge0ZQX1F1YW50aXR5fSBvdGhlclF1YW50aXR5IGEgcXVhbnRpdHkgYnkgd2hpY2ggdG8gZGl2aWRlIHRoaXMgcXVhbnRpdHkuXG4gICAqIEByZXR1cm4ge0ZQX1F1YW50aXR5fVxuICAgKi9cbiAgZGl2KG90aGVyUXVhbnRpdHkpIHtcbiAgICAvLyBEaXZpc2lvbiBieSB6ZXJvIGFsd2F5cyBnaXZlcyBhbiBlbXB0eSByZXN1bHRcbiAgICBpZiAob3RoZXJRdWFudGl0eS52YWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGhpc1VuaXRJblNlY29uZHMgPSBGUF9RdWFudGl0eS5fY2FsZW5kYXJEdXJhdGlvbjJTZWNvbmRzW3RoaXMudW5pdF07XG4gICAgY29uc3Qgb3RoZXJVbml0SW5TZWNvbmRzID0gRlBfUXVhbnRpdHkuX2NhbGVuZGFyRHVyYXRpb24yU2Vjb25kc1tvdGhlclF1YW50aXR5LnVuaXRdO1xuXG4gICAgaWYgKHRoaXNVbml0SW5TZWNvbmRzKSB7XG4gICAgICBpZiAob3RoZXJVbml0SW5TZWNvbmRzKSB7XG4gICAgICAgIC8vIElmIGJvdGggb3BlcmFuZHMgYXJlIGNhbGVuZGFyIGR1cmF0aW9uIHF1YW50aXRpZXNcbiAgICAgICAgY29uc3QgdGhpc0NvbnZGYWN0b3IgPSBGUF9RdWFudGl0eS5feWVhck1vbnRoQ29udmVyc2lvbkZhY3Rvclt0aGlzLnVuaXRdO1xuICAgICAgICBjb25zdCBvdGhlckNvbnZGYWN0b3IgPSBGUF9RdWFudGl0eS5feWVhck1vbnRoQ29udmVyc2lvbkZhY3RvcltvdGhlclF1YW50aXR5LnVuaXRdO1xuICAgICAgICBpZiAodGhpc0NvbnZGYWN0b3IgJiYgb3RoZXJDb252RmFjdG9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHZhbHVlcyBhcmUgaW5kaWNhdGVkIGluIHllYXJzIGFuZCBtb250aHMsIHdlIHVzZSB0aGUgY29udmVyc2lvbiBmYWN0b3I6IDEgeWVhciA9IDEyIG1vbnRoc1xuICAgICAgICAgIHJldHVybiBuZXcgRlBfUXVhbnRpdHkodGhpcy52YWx1ZSAqIHRoaXNDb252RmFjdG9yIC8gKG90aGVyUXVhbnRpdHkudmFsdWUgKiBvdGhlckNvbnZGYWN0b3IpLCBcIicxJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvdGhlclF1YW50aXR5LnVuaXQgPT09IFwiJzEnXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlY29uZCBvcGVyYW5kIGlzIGEgbnVtYmVyXG4gICAgICAgIHJldHVybiBuZXcgRlBfUXVhbnRpdHkodGhpcy52YWx1ZSAvIG90aGVyUXVhbnRpdHkudmFsdWUsIHRoaXMudW5pdCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNVbml0SW5TZWNvbmRzID4gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZmlyc3Qgb3BlcmFuZCBpcyBhIGNhbGVuZGFyIGR1cmF0aW9uIGdyZWF0ZXIgdGhhbiBzZWNvbmRzXG4gICAgICAgIC8vIGFuZCB0aGUgb3RoZXIgaXMgbm90IGEgY2FsZW5kYXIgZHVyYXRpb24gb3IgbnVtYmVyLCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyVW5pdEluU2Vjb25kcyA+IDEpIHtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBvcGVyYW5kcyBpcyBub3QgYSBjYWxlbmRhciBkdXJhdGlvbiBhbmQgdGhlIG90aGVyIGlzIGFcbiAgICAgIC8vIGNhbGVuZGFyIGR1cmF0aW9uIGdyZWF0ZXIgdGhhbiBzZWNvbmRzLCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGhpc1EgPSB0aGlzLmNvbnZUb1VjdW1Vbml0cyh0aGlzLCB0aGlzVW5pdEluU2Vjb25kcyk7XG4gICAgaWYgKCF0aGlzUSkge1xuICAgICAgLy8gSWYgdGhlIGZpcnN0IG9wZXJhbmQgaXMgbm90IGEgVUNVTSBxdWFudGl0eSBvciBpdCBoYXMgYSBzcGVjaWFsIHVuaXRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG90aGVyUSA9IHRoaXMuY29udlRvVWN1bVVuaXRzKG90aGVyUXVhbnRpdHksIG90aGVyVW5pdEluU2Vjb25kcyk7XG4gICAgaWYgKCFvdGhlclEpIHtcbiAgICAgIC8vIElmIHRoZSBzZWNvbmQgb3BlcmFuZCBpcyBub3QgYSBVQ1VNIHF1YW50aXR5IG9yIGl0IGhhcyBhIHNwZWNpYWwgdW5pdFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0VW5pdCA9IG90aGVyUS51bml0ID09PSAnMSdcbiAgICAgID8gdGhpc1EudW5pdFxuICAgICAgOiBgKCR7dGhpc1EudW5pdH0pLygke290aGVyUS51bml0fSlgO1xuXG4gICAgY29uc3QgY29udlJlc3VsdCA9IHVjdW1VdGlscy5jb252ZXJ0VG9CYXNlVW5pdHMocmVzdWx0VW5pdCwgdGhpc1EudmFsdWUgLyBvdGhlclEudmFsdWUpO1xuICAgIGlmIChjb252UmVzdWx0LnN0YXR1cyAhPT0gJ3N1Y2NlZWRlZCcpIHtcbiAgICAgIC8vIElmIHRoZSByZXN1bHQgdW5pdHMgYXJlIHVuY2xlYXJcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZQX1F1YW50aXR5KFxuICAgICAgY29udlJlc3VsdC5tYWduaXR1ZGUsXG4gICAgICBgJyR7T2JqZWN0LmtleXMoY29udlJlc3VsdC51bml0VG9FeHApLm1hcChrZXkgPT4ga2V5K2NvbnZSZXN1bHQudW5pdFRvRXhwW2tleV0pLmpvaW4oJy4nKSB8fCBcIjFcIn0nYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBxdWFudGl0eSB0byBVQ1VNIHVuaXQgaWYgcG9zc2libGUsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAqIEBwYXJhbSB7RlBfUXVhbnRpdHl9IHF1YW50aXR5IC0gc291cmNlIHF1YW50aXR5LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHVuaXRJblNlY29uZHMgLSBpZiB0aGUgc291cmNlIHF1YW50aXR5IGlzIGFcbiAgICogIGNhbGVuZGFyIGR1cmF0aW9uIHRoZW4gdGhlIHZhbHVlIG9mIHRoZSBxdWFudGl0eSB1bml0IGluIHNlY29uZHMsXG4gICAqICBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJuIHt7dW5pdDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyfSB8IG51bGx9XG4gICAqL1xuICBjb252VG9VY3VtVW5pdHMocXVhbnRpdHksIHVuaXRJblNlY29uZHMpIHtcbiAgICBpZiAodW5pdEluU2Vjb25kcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuaXRJblNlY29uZHMgKiBxdWFudGl0eS52YWx1ZSxcbiAgICAgICAgdW5pdDogJ3MnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1bml0ID0gcXVhbnRpdHkudW5pdC5yZXBsYWNlKHN1cnJvdW5kaW5nQXBvc3Ryb3BoZXNSZWdleCwgJycpO1xuICAgICAgY29uc3QgY29udlJlcyA9IHVjdW1VdGlscy5jb252ZXJ0VG9CYXNlVW5pdHModW5pdCwgcXVhbnRpdHkudmFsdWUpO1xuICAgICAgaWYgKGNvbnZSZXMuc3RhdHVzICE9PSAnc3VjY2VlZGVkJyB8fCBjb252UmVzLmZyb21Vbml0SXNTcGVjaWFsKSB7XG4gICAgICAgIC8vIElmIGl0IGlzIG5vdCBhIFVDVU0gcXVhbnRpdHkgb3IgaXQgaGFzIGEgc3BlY2lhbCB1bml0XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNvbnZSZXMubWFnbml0dWRlLFxuICAgICAgICB1bml0OiBPYmplY3Qua2V5cyhjb252UmVzLnVuaXRUb0V4cCkubWFwKGtleSA9PiBrZXkrY29udlJlcy51bml0VG9FeHBba2V5XSkuam9pbignLicpIHx8IFwiMVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBib3RoIHF1YW50aXRpZXMgaGF2ZSBvbmUgb2YgdGhlc2UgdW5pdHM6IHllYXIgb3IgbW9udGgsXG4gICAqIHRoZW4gYSBzcGVjaWFsIGNhc2Ugd2lsbCBhcHBseTsgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICogSW4gdGhlIHNwZWNpYWwgY2FzZSBvZiBjb21wYXJpc29uLCB0aGUgZmFjdCB0aGF0IDEgeWVhciA9IDEyIG1vbnRocyBpcyB1c2VkLlxuICAgKlxuICAgKiBKdXN0IG5vdGU6IGluIGdlbmVyYWwsIGZvciBhIGNhbGVuZGFyIGR1cmF0aW9uOlxuICAgKiAxIHllYXIgPSAzNjUgZGF5c1xuICAgKiAxMiBtb250aCA9IDEyKjMwIGRheXMgPSAzNjAgZGF5c1xuICAgKiBzbywgMSB5ZWFyICE9IDEyIG1vbnRoXG4gICAqIFRoYXQncyB3aHkgdGhpcyBzcGVjaWFsIGNhc2UgaXMgbmVlZGVkXG4gICAqXG4gICAqIEBwYXJhbSB7RlBfUXVhbnRpdHl9IG90aGVyUXVhbnRpdHlcbiAgICogQHJldHVybiB7bnVsbHx7aXNFcXVhbDogYm9vbGVhbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcGFyZVllYXJzQW5kTW9udGhzKG90aGVyUXVhbnRpdHkpIHtcbiAgICBjb25zdCBtYWduaXR1ZGUxID0gRlBfUXVhbnRpdHkuX3llYXJNb250aENvbnZlcnNpb25GYWN0b3JbdGhpcy51bml0XSxcbiAgICAgIG1hZ25pdHVkZTIgPSBGUF9RdWFudGl0eS5feWVhck1vbnRoQ29udmVyc2lvbkZhY3RvcltvdGhlclF1YW50aXR5LnVuaXRdO1xuXG4gICAgaWYgKCBtYWduaXR1ZGUxICYmIG1hZ25pdHVkZTIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzRXF1YWw6IG51bWJlcnMuaXNFcXVhbCh0aGlzLnZhbHVlKm1hZ25pdHVkZTEsIG90aGVyUXVhbnRpdHkudmFsdWUqbWFnbml0dWRlMilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jb25zdCAgc3Vycm91bmRpbmdBcG9zdHJvcGhlc1JlZ2V4ID0gL14nfCckL2c7XG4vKipcbiAqIENvbnZlcnRzIGEgRkhJUiBwYXRoIHVuaXQgdG8gYSBVQ1VNIHVuaXQgY29kZSBieSBjb252ZXJ0aW5nIGEgY2FsZW5kYXIgZHVyYXRpb24ga2V5d29yZCB0byBhbiBlcXVpdmFsZW50IFVDVU0gdW5pdCBjb2RlXG4gKiBvciByZW1vdmluZyBzaW5nbGUgcXVvdGVzIGZvciBhIFVDVU0gdW5pdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZQX1F1YW50aXR5LmdldEVxdWl2YWxlbnRVY3VtVW5pdENvZGUgPSBmdW5jdGlvbiAodW5pdCkge1xuICByZXR1cm4gRlBfUXVhbnRpdHkubWFwVGltZVVuaXRzVG9VQ1VNQ29kZVt1bml0XSB8fCB1bml0LnJlcGxhY2Uoc3Vycm91bmRpbmdBcG9zdHJvcGhlc1JlZ2V4LCAnJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEZISVIgcGF0aCB2YWx1ZS91bml0IHRvIFVDVU0gdmFsdWUvdW5pdC4gVXNhYmxlIGZvciBjb21wYXJpc29uLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdFxuICogQHJldHVybnMgeyB7dmFsdWU6IG51bWJlciwgdW5pdDogc3RyaW5nfSB9XG4gKi9cbkZQX1F1YW50aXR5LnRvVWN1bVF1YW50aXR5ID0gZnVuY3Rpb24gKHZhbHVlLCB1bml0KSB7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IEZQX1F1YW50aXR5Ll9jYWxlbmRhckR1cmF0aW9uMlNlY29uZHNbdW5pdF07XG4gIGlmIChtYWduaXR1ZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1hZ25pdHVkZSAqIHZhbHVlLFxuICAgICAgdW5pdDogJ3MnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdW5pdDogdW5pdC5yZXBsYWNlKHN1cnJvdW5kaW5nQXBvc3Ryb3BoZXNSZWdleCwgJycpXG4gIH07XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgRkhJUlBhdGggdmFsdWUvdW5pdCB0byBvdGhlciBGSElSUGF0aCB2YWx1ZS91bml0LlxuICogQHBhcmFtIHtzdHJpbmd9IGZyb21Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b1VuaXRcbiAqIEByZXR1cm4ge0ZQX1F1YW50aXR5fG51bGx9XG4gKi9cbkZQX1F1YW50aXR5LmNvbnZVbml0VG8gPSBmdW5jdGlvbiAoZnJvbVVuaXQsIHZhbHVlLCB0b1VuaXQpIHtcbiAgLy8gMSBZZWFyIDwtPiAxMiBNb250aHNcbiAgY29uc3QgZnJvbVllYXJNb250aE1hZ25pdHVkZSA9IEZQX1F1YW50aXR5Ll95ZWFyTW9udGhDb252ZXJzaW9uRmFjdG9yW2Zyb21Vbml0XSxcbiAgICB0b1llYXJNb250aE1hZ25pdHVkZSA9IEZQX1F1YW50aXR5Ll95ZWFyTW9udGhDb252ZXJzaW9uRmFjdG9yW3RvVW5pdF07XG4gIGlmIChmcm9tWWVhck1vbnRoTWFnbml0dWRlICYmIHRvWWVhck1vbnRoTWFnbml0dWRlKSB7XG4gICAgcmV0dXJuIG5ldyBGUF9RdWFudGl0eSggZnJvbVllYXJNb250aE1hZ25pdHVkZSp2YWx1ZS90b1llYXJNb250aE1hZ25pdHVkZSwgdG9Vbml0KTtcbiAgfVxuXG4gIGNvbnN0IGZyb21NYWduaXR1ZGUgPSBGUF9RdWFudGl0eS5fY2FsZW5kYXJEdXJhdGlvbjJTZWNvbmRzW2Zyb21Vbml0XSxcbiAgICB0b01hZ25pdHVkZSA9IEZQX1F1YW50aXR5Ll9jYWxlbmRhckR1cmF0aW9uMlNlY29uZHNbdG9Vbml0XTtcblxuICAvLyBUbyBGSElSIHBhdGggY2FsZW5kYXIgZHVyYXRpb25cbiAgaWYgKHRvTWFnbml0dWRlKSB7XG4gICAgaWYgKGZyb21NYWduaXR1ZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRlBfUXVhbnRpdHkoIGZyb21NYWduaXR1ZGUqdmFsdWUvdG9NYWduaXR1ZGUsIHRvVW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnZSZXN1bHQgPSB1Y3VtVXRpbHMuY29udmVydFVuaXRUbyhmcm9tVW5pdC5yZXBsYWNlKC9eJ3wnJC9nLCAnJyksIHZhbHVlLCAncycpO1xuXG4gICAgICBpZiAoY29udlJlc3VsdC5zdGF0dXMgPT09ICdzdWNjZWVkZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRlBfUXVhbnRpdHkoY29udlJlc3VsdC50b1ZhbC90b01hZ25pdHVkZSwgdG9Vbml0KTtcbiAgICAgIH1cbiAgICB9XG4gIC8vIFRvIFVjdW0gdW5pdFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnZSZXN1bHQgPSBmcm9tTWFnbml0dWRlID8gdWN1bVV0aWxzLmNvbnZlcnRVbml0VG8oJ3MnLCBmcm9tTWFnbml0dWRlKnZhbHVlLCB0b1VuaXQucmVwbGFjZSgvXid8JyQvZywgJycpKVxuICAgICAgOiB1Y3VtVXRpbHMuY29udmVydFVuaXRUbyhmcm9tVW5pdC5yZXBsYWNlKC9eJ3wnJC9nLCAnJyksIHZhbHVlLCB0b1VuaXQucmVwbGFjZSgvXid8JyQvZywgJycpKTtcblxuICAgIGlmKGNvbnZSZXN1bHQuc3RhdHVzID09PSAnc3VjY2VlZGVkJykge1xuICAgICAgcmV0dXJuIG5ldyBGUF9RdWFudGl0eShjb252UmVzdWx0LnRvVmFsLCB0b1VuaXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vLyBEZWZpbmVzIGNvbnZlcnNpb24gZmFjdG9ycyBmb3IgY2FsZW5kYXIgZHVyYXRpb25zXG5GUF9RdWFudGl0eS5fY2FsZW5kYXJEdXJhdGlvbjJTZWNvbmRzID0ge1xuICAneWVhcnMnOiAzNjUqMjQqNjAqNjAsXG4gICdtb250aHMnOiAzMCoyNCo2MCo2MCxcbiAgJ3dlZWtzJzogNyoyNCo2MCo2MCxcbiAgJ2RheXMnOiAyNCo2MCo2MCxcbiAgJ2hvdXJzJzogNjAqNjAsXG4gICdtaW51dGVzJzogNjAsXG4gICdzZWNvbmRzJzogMSxcbiAgJ21pbGxpc2Vjb25kcyc6IC4wMDEsXG4gICd5ZWFyJzogMzY1KjI0KjYwKjYwLFxuICAnbW9udGgnOiAzMCoyNCo2MCo2MCxcbiAgJ3dlZWsnOiA3KjI0KjYwKjYwLFxuICAnZGF5JzogMjQqNjAqNjAsXG4gICdob3VyJzogNjAqNjAsXG4gICdtaW51dGUnOiA2MCxcbiAgJ3NlY29uZCc6IDEsXG4gICdtaWxsaXNlY29uZCc6IC4wMDFcbn07XG5cbi8vIERlZmluZXMgc3BlY2lhbCBjYXNlIHRvIGNvbXBhcmUgeWVhcnMgd2l0aCBtb250aHMgZm9yIGNhbGVuZGFyIGR1cmF0aW9uc1xuRlBfUXVhbnRpdHkuX3llYXJNb250aENvbnZlcnNpb25GYWN0b3IgPSB7XG4gICd5ZWFycyc6IDEyLFxuICAnbW9udGhzJzogMSxcbiAgJ3llYXInOiAxMixcbiAgJ21vbnRoJzogMVxufTtcblxuLyoqXG4gKiAgRGVmaW5lcyBhIG1hcCBmcm9tIHRpbWUgdW5pdHMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBkYXRlL3RpbWUgYXJpdGhtZXRpY1xuICogIChpbmNsdWRpbmcgc29tZSBVQ1VNIHRpbWUgYmFzZWQgdW5pdHMpIHRvIEZISVJQYXRoIHRpbWUgdW5pdHMuXG4gKi9cbkZQX1F1YW50aXR5LmRhdGVUaW1lQXJpdGhtZXRpY0R1cmF0aW9uVW5pdHMgPSB7XG4gICd5ZWFycyc6IFwieWVhclwiLFxuICAnbW9udGhzJzogXCJtb250aFwiLFxuICAnd2Vla3MnOiBcIndlZWtcIixcbiAgJ2RheXMnOiBcImRheVwiLFxuICAnaG91cnMnOiBcImhvdXJcIixcbiAgJ21pbnV0ZXMnOiBcIm1pbnV0ZVwiLFxuICAnc2Vjb25kcyc6IFwic2Vjb25kXCIsXG4gICdtaWxsaXNlY29uZHMnOiBcIm1pbGxpc2Vjb25kXCIsXG4gICd5ZWFyJzogXCJ5ZWFyXCIsXG4gICdtb250aCc6IFwibW9udGhcIixcbiAgJ3dlZWsnOiBcIndlZWtcIixcbiAgJ2RheSc6IFwiZGF5XCIsXG4gICdob3VyJzogXCJob3VyXCIsXG4gICdtaW51dGUnOiBcIm1pbnV0ZVwiLFxuICAnc2Vjb25kJzogXCJzZWNvbmRcIixcbiAgJ21pbGxpc2Vjb25kJzogXCJtaWxsaXNlY29uZFwiLFxuICBcIidzJ1wiOiBcInNlY29uZFwiLFxuICBcIidtcydcIjogXCJtaWxsaXNlY29uZFwiXG59O1xuXG4vKipcbiAqICBEZWZpbmVzIGEgbWFwIGZyb20gVUNVTSBjb2RlIHRvIEZISVJQYXRoIHRpbWUgdW5pdHMuXG4gKi9cbkZQX1F1YW50aXR5Lm1hcFVDVU1Db2RlVG9UaW1lVW5pdHMgPSB7XG4gICdhJzogXCJ5ZWFyXCIsXG4gICdtbyc6IFwibW9udGhcIixcbiAgJ3drJzogXCJ3ZWVrXCIsXG4gICdkJzogXCJkYXlcIixcbiAgJ2gnOiBcImhvdXJcIixcbiAgJ21pbic6IFwibWludXRlXCIsXG4gICdzJzogXCJzZWNvbmRcIixcbiAgJ21zJzogXCJtaWxsaXNlY29uZFwiLFxufTtcblxuLyoqXG4gKiAgRGVmaW5lcyBhIG1hcCBmcm9tIEZISVJQYXRoIHRpbWUgdW5pdHMgdG8gVUNVTSBjb2RlLlxuICovXG5GUF9RdWFudGl0eS5tYXBUaW1lVW5pdHNUb1VDVU1Db2RlID0gT2JqZWN0LmtleXMoRlBfUXVhbnRpdHkubWFwVUNVTUNvZGVUb1RpbWVVbml0cylcbiAgLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXkpIHtcbiAgICByZXNbRlBfUXVhbnRpdHkubWFwVUNVTUNvZGVUb1RpbWVVbml0c1trZXldXSA9IGtleTtcbiAgICByZXNbRlBfUXVhbnRpdHkubWFwVUNVTUNvZGVUb1RpbWVVbml0c1trZXldKydzJ10gPSBrZXk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSwge30pO1xuXG5jbGFzcyBGUF9UaW1lQmFzZSBleHRlbmRzIEZQX1R5cGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lU3RyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFzU3RyID0gdGltZVN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQWRkcyBhIHRpbWUtYmFzZWQgcXVhbnRpdHkgdG8gdGhpcyBkYXRlL3RpbWUuXG4gICAqIEBwYXJhbSB0aW1lUXVhbnRpdHkgYSBxdWFudGl0eSB0byBiZSBhZGRlZCB0byB0aGlzIGRhdGUvdGltZS4gIFNlZSB0aGVcbiAgICogIEZISVJQYXRoIHNwZWNpZmljYXRpb24gZm9yIHN1cHBvcnRlZCB1bml0cy5cbiAgICovXG4gIHBsdXModGltZVF1YW50aXR5KSB7XG4gICAgY29uc3QgdW5pdCA9IHRpbWVRdWFudGl0eS51bml0O1xuICAgIGxldCB0aW1lVW5pdCA9IEZQX1F1YW50aXR5LmRhdGVUaW1lQXJpdGhtZXRpY0R1cmF0aW9uVW5pdHNbdW5pdF07XG4gICAgaWYgKCF0aW1lVW5pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgZGF0ZS90aW1lIGFyaXRobWV0aWMsIHRoZSB1bml0IG9mIHRoZSBxdWFudGl0eSAnICtcbiAgICAgICAgJ211c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdGltZS1iYXNlZCB1bml0czogJyArXG4gICAgICAgIE9iamVjdC5rZXlzKEZQX1F1YW50aXR5LmRhdGVUaW1lQXJpdGhtZXRpY0R1cmF0aW9uVW5pdHMpKTtcbiAgICB9XG4gICAgY29uc3QgY2xzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCB1bml0UHJlY2lzaW9uID0gY2xzLl90aW1lVW5pdFRvRGF0ZVByZWNpc2lvblt0aW1lVW5pdF07XG4gICAgaWYgKHVuaXRQcmVjaXNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB1bml0IGZvciArLiAgVGhlIHVuaXQgc2hvdWxkIGJlIG9uZSBvZiAnICtcbiAgICAgICAgT2JqZWN0LmtleXMoY2xzLl90aW1lVW5pdFRvRGF0ZVByZWNpc2lvbikuam9pbignLCAnKSArICcuJyk7XG4gICAgfVxuICAgIGxldCBxVmFsID0gdGltZVF1YW50aXR5LnZhbHVlO1xuICAgIGNvbnN0IGlzVGltZSA9IChjbHMgPT09IEZQX1RpbWUpO1xuXG4gICAgLy8gRnJvbSB0aGUgRkhJUlBhdGggc3BlY2lmaWNhdGlvbjogXCJGb3IgcHJlY2lzaW9ucyBhYm92ZSBzZWNvbmRzLCB0aGVcbiAgICAvLyBkZWNpbWFsIHBvcnRpb24gb2YgdGhlIHRpbWUtdmFsdWVkIHF1YW50aXR5IGlzIGlnbm9yZWQsIHNpbmNlIGRhdGUvdGltZVxuICAgIC8vIGFyaXRobWV0aWMgYWJvdmUgc2Vjb25kcyBpcyBwZXJmb3JtZWQgd2l0aCBjYWxlbmRhciBkdXJhdGlvbiBzZW1hbnRpY3MuXCJcbiAgICBpZiAoaXNUaW1lID8gdW5pdFByZWNpc2lvbiA8IDIgOiB1bml0UHJlY2lzaW9uIDwgNSkge1xuICAgICAgcVZhbCA9IE1hdGgudHJ1bmMocVZhbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHByZWNpc2lvbiBvZiB0aGUgdGltZSBxdWFudGl0eSBpcyBoaWdoZXIgdGhhbiB0aGUgcHJlY2lzaW9uIG9mIHRoZVxuICAgIC8vIGRhdGUsIHdlIG5lZWQgdG8gY29udmVydCB0aGUgdGltZSBxdWFudGl0eSB0byB0aGUgcHJlY2lzaW9uIG9mIHRoZSBkYXRlLlxuICAgIGlmICh0aGlzLl9nZXRQcmVjaXNpb24oKSA8IHVuaXRQcmVjaXNpb24pIHtcbiAgICAgIGNvbnN0IG5lZWRlZFVuaXQgPSBjbHMuX2RhdGVQcmVjaXNpb25Ub1RpbWVVbml0W1xuICAgICAgICB0aGlzLl9nZXRQcmVjaXNpb24oKV07XG4gICAgICBpZiAobmVlZGVkVW5pdCAhPT0gJ3NlY29uZCcpIHtcbiAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBGUF9RdWFudGl0eS5jb252VW5pdFRvKHRpbWVVbml0LCBxVmFsLCBuZWVkZWRVbml0KTtcbiAgICAgICAgdGltZVVuaXQgPSBuZXdRdWFudGl0eS51bml0O1xuICAgICAgICBxVmFsID0gTWF0aC50cnVuYyhuZXdRdWFudGl0eS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld0RhdGUgPSBGUF9UaW1lQmFzZS50aW1lVW5pdFRvQWRkRm5bdGltZVVuaXRdKHRoaXMuX2dldERhdGVPYmooKSwgcVZhbCk7XG4gICAgLy8gbmV3RGF0ZSBpcyBhIERhdGUuICBXZSBuZWVkIHRvIG1ha2UgYSBzdHJpbmcgd2l0aCB0aGUgY29ycmVjdCBwcmVjaXNpb24uXG4gICAgbGV0IHByZWNpc2lvbiA9IHRoaXMuX2dldFByZWNpc2lvbigpO1xuICAgIGlmIChpc1RpbWUpXG4gICAgICBwcmVjaXNpb24gKz0gMzsgLy8gYmFzZWQgb24gZGF0ZVRpbWVSRSwgbm90IHRpbWVSRVxuICAgIGxldCBuZXdEYXRlU3RyID0gRlBfRGF0ZVRpbWUuaXNvRGF0ZVRpbWUobmV3RGF0ZSwgcHJlY2lzaW9uKTtcbiAgICBpZiAoaXNUaW1lKSB7XG4gICAgICAvLyBGUF9UaW1lIGp1c3QgbmVlZHMgdGhlIHRpbWUgcGFydCBvZiB0aGUgc3RyaW5nXG4gICAgICBuZXdEYXRlU3RyID0gbmV3RGF0ZVN0ci5zbGljZShuZXdEYXRlU3RyLmluZGV4T2YoJ1QnKSArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgY2xzKG5ld0RhdGVTdHIpO1xuICB9XG5cblxuICAvKipcbiAgICogIFRlc3RzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgZXF1YWwgdG8gYW5vdGhlci4gIFJldHVybnMgZWl0aGVyIHRydWUsXG4gICAqICBmYWxzZSwgb3IgdW5kZWZpbmVkICh3aGVyZSBpbiB0aGUgRkhJUlBhdGggc3BlY2lmaWNhdGlvbiBlbXB0eSB3b3VsZCBiZVxuICAgKiAgcmV0dXJuZWQpLiAgVGhlIHVuZGVmaW5lZCByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHZhbHVlcyB3ZXJlIHRoZVxuICAgKiAgc2FtZSB0byB0aGUgc2hhcmVkIHByZWNpc2lvbiwgYnV0IHRoYXQgdGhleSBoYWQgZGlmZmVybmVudCBsZXZlbHMgb2ZcbiAgICogIHByZWNpc2lvbi5cbiAgICogQHBhcmFtIG90aGVyRGF0ZVRpbWUgYW55IHN1Yi10eXBlIG9mIEZQX1RpbWVCYXNlLCBidXQgaXQgc2hvdWxkIGJlIHRoZSBzYW1lXG4gICAqICBhcyB0aGUgdHlwZSBvZiBcInRoaXNcIi5cbiAgICovXG4gIGVxdWFscyhvdGhlckRhdGVUaW1lKSB7XG4gICAgLy8gRnJvbSB0aGUgMjAxOU1heSBiYWxsb3Q6XG4gICAgLy8gRm9yIERhdGUsIERhdGVUaW1lIGFuZCBUaW1lIGVxdWFsaXR5LCB0aGUgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgYnlcbiAgICAvLyBjb25zaWRlcmluZyBlYWNoIHByZWNpc2lvbiBpbiBvcmRlciwgYmVnaW5uaW5nIHdpdGggeWVhcnMgKG9yIGhvdXJzIGZvclxuICAgIC8vIHRpbWUgdmFsdWVzKSwgYW5kIHJlc3BlY3RpbmcgdGltZXpvbmUgb2Zmc2V0cy4gSWYgdGhlIHZhbHVlcyBhcmUgdGhlXG4gICAgLy8gc2FtZSwgY29tcGFyaXNvbiBwcm9jZWVkcyB0byB0aGUgbmV4dCBwcmVjaXNpb247IGlmIHRoZSB2YWx1ZXMgYXJlXG4gICAgLy8gZGlmZmVyZW50LCB0aGUgY29tcGFyaXNvbiBzdG9wcyBhbmQgdGhlIHJlc3VsdCBpcyBmYWxzZS4gSWYgb25lIGlucHV0IGhhc1xuICAgIC8vIGEgdmFsdWUgZm9yIHRoZSBwcmVjaXNpb24gYW5kIHRoZSBvdGhlciBkb2VzIG5vdCwgdGhlIGNvbXBhcmlzb24gc3RvcHNcbiAgICAvLyBhbmQgdGhlIHJlc3VsdCBpcyBlbXB0eSAoeyB9KTsgaWYgbmVpdGhlciBpbnB1dCBoYXMgYSB2YWx1ZSBmb3IgdGhlXG4gICAgLy8gcHJlY2lzaW9uLCBvciB0aGUgbGFzdCBwcmVjaXNpb24gaGFzIGJlZW4gcmVhY2hlZCwgdGhlIGNvbXBhcmlzb24gc3RvcHNcbiAgICAvLyBhbmQgdGhlIHJlc3VsdCBpcyB0cnVlLlxuICAgIC8vIE5vdGU6ICBQZXIgdGhlIHNwZWMgYWJvdmVcbiAgICAvLyAgIDIwMTItMDEgPSAyMDEyIC8vICBlbXB0eVxuICAgIC8vICAgMjAxMi0wMSA9IDIwMTEgLy8gIGZhbHNlXG4gICAgLy8gICAyMDEyLTAxIH4gMjAxMiAvLyAgZmFsc2VcbiAgICB2YXIgcnRuO1xuICAgIGlmICghKG90aGVyRGF0ZVRpbWUgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvdGhlckRhdGVUaW1lLmNvbnN0cnVjdG9yKSlcbiAgICAgIHJ0biA9IGZhbHNlO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHRoaXNQcmVjICA9IHRoaXMuX2dldFByZWNpc2lvbigpO1xuICAgICAgdmFyIG90aGVyUHJlYyA9IG90aGVyRGF0ZVRpbWUuX2dldFByZWNpc2lvbigpO1xuXG4gICAgICBpZiAodGhpc1ByZWMgPT0gb3RoZXJQcmVjKSB7XG4gICAgICAgIHJ0biA9IHRoaXMuX2dldERhdGVPYmooKS5nZXRUaW1lKCkgPT0gb3RoZXJEYXRlVGltZS5fZ2V0RGF0ZU9iaigpLmdldFRpbWUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgZGF0ZXMgYXJlIG5vdCBlcXVhbCwgYnV0IGRlY2lkZSB3aGV0aGVyIHRvIHJldHVybiBlbXB0eSBvciBmYWxzZS5cbiAgICAgICAgdmFyIGNvbW1vblByZWMgID0gdGhpc1ByZWMgPD0gb3RoZXJQcmVjID8gdGhpc1ByZWMgOiBvdGhlclByZWM7XG4gICAgICAgIC8vIEFkanVzdCBmb3IgdGltZXpvbmUgb2Zmc2V0cywgaWYgYW55LCBzbyB0aGV5IGFyZSBhdCBhIGNvbW1vbiB0aW1lem9uZVxuICAgICAgICB2YXIgdGhpc1VUQ1N0ciAgPSB0aGlzLl9nZXREYXRlT2JqKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgdmFyIG90aGVyVVRDU3RyID0gb3RoZXJEYXRlVGltZS5fZ2V0RGF0ZU9iaigpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEZQX1RpbWUpIHtcbiAgICAgICAgICBjb21tb25QcmVjICs9IDM7IC8vIGJlY2F1c2Ugd2Ugbm93IGhhdmUgeWVhciwgbW9udGgsIGFuZCBkYXlcbiAgICAgICAgICB0aGlzUHJlYyArPSAzO1xuICAgICAgICAgIG90aGVyUHJlYyArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHBhcnNlIHRoZSBzdHJpbmdzIGFuZCBjb21wYXJlIHRoZSBhZGp1c3RlZCB0aW1lIHBhcnRzLlxuICAgICAgICAvLyBEYXRlcyB3aXRob3V0IHRpbWUgc3BlY2lmeSBubyB0aW1lem9uZSBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYWxyZWFkeSBub3JtYWxpemVkIHRvIFVUQy4gU28gd2UgZG8gbm90IGFkanVzdCB0aGUgdGltZXpvbmUsIGFzIHRoaXMgd291bGQgY2hhbmdlIHRoZSBkYXRlXG4gICAgICAgIHZhciB0aGlzQWRqICA9IHRoaXNQcmVjID4gMiA/IChuZXcgRlBfRGF0ZVRpbWUodGhpc1VUQ1N0cikpLl9nZXRUaW1lUGFydHMoKSA6IHRoaXMuX2dldFRpbWVQYXJ0cygpO1xuICAgICAgICB2YXIgb3RoZXJBZGogPSBvdGhlclByZWMgPiAyID8gKG5ldyBGUF9EYXRlVGltZShvdGhlclVUQ1N0cikpLl9nZXRUaW1lUGFydHMoKSA6IG90aGVyRGF0ZVRpbWUuX2dldFRpbWVQYXJ0cygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvbW1vblByZWMgJiYgcnRuICE9PSBmYWxzZTsgKytpKSB7XG4gICAgICAgICAgcnRuID0gdGhpc0FkaltpXSA9PSBvdGhlckFkaltpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBydG4gaXMgc3RpbGwgdHJ1ZSwgdGhlbiByZXR1cm4gZW1wdHkgdG8gaW5kaWNhdGUgdGhlIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgLy8gcHJlY2lzaW9uLlxuICAgICAgICBpZiAocnRuKVxuICAgICAgICAgIHJ0biA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkIChlbXB0eSlcbiAgICByZXR1cm4gcnRuO1xuICB9XG5cblxuICAvKipcbiAgICogIFRlc3RzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgZXF1aXZhbGFudCB0byBhbm90aGVyLiAgUmV0dXJucyBlaXRoZXIgdHJ1ZVxuICAgKiAgb3IgZmFsc2UuXG4gICAqL1xuICBlcXVpdmFsZW50VG8ob3RoZXJEYXRlVGltZSkge1xuICAgIHZhciBydG4gPSBvdGhlckRhdGVUaW1lIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAocnRuKSB7XG4gICAgICB2YXIgdGhpc1ByZWMgPSB0aGlzLl9nZXRQcmVjaXNpb24oKTtcbiAgICAgIHZhciBvdGhlclByZWMgPSBvdGhlckRhdGVUaW1lLl9nZXRQcmVjaXNpb24oKTtcbiAgICAgIHJ0biA9IHRoaXNQcmVjID09IG90aGVyUHJlYztcbiAgICAgIGlmIChydG4pIHtcbiAgICAgICAgcnRuID0gdGhpcy5fZ2V0RGF0ZU9iaigpLmdldFRpbWUoKSA9PVxuICAgICAgICAgIG90aGVyRGF0ZVRpbWUuX2dldERhdGVPYmooKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydG47XG4gIH1cblxuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIG51bWJlciBsZXNzIHRoYW4gMCwgZXF1YWwgdG8gMCBvciBncmVhdGVyIHRoYW4gMFxuICAgKiAgaWYgdGhpcyAoZGF0ZSkgdGltZSBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gb3RoZXJUaW1lLlxuICAgKiAgQ29tcGFyaXNvbnMgYXJlIG1hZGUgYXQgdGhlIGxlc3NlciBvZiB0aGUgdHdvIHRpbWUgcHJlY2lzaW9ucy5cbiAgICogIEBwYXJhbSB7RlBfVGltZUJhc2V9IG90aGVyVGltZVxuICAgKiAgQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY29tcGFyZShvdGhlclRpbWUpIHtcbiAgICB2YXIgdGhpc1ByZWNpc2lvbiA9IHRoaXMuX2dldFByZWNpc2lvbigpO1xuICAgIHZhciBvdGhlclByZWNpc2lvbiA9IG90aGVyVGltZS5fZ2V0UHJlY2lzaW9uKCk7XG4gICAgdmFyIHRoaXNUaW1lSW50ID0gdGhpc1ByZWNpc2lvbiA8PSBvdGhlclByZWNpc2lvbiA/XG4gICAgICB0aGlzLl9nZXREYXRlT2JqKCkuZ2V0VGltZSgpOiB0aGlzLl9kYXRlQXRQcmVjaXNpb24ob3RoZXJQcmVjaXNpb24pLmdldFRpbWUoKTtcbiAgICB2YXIgb3RoZXJUaW1lSW50ID0gb3RoZXJQcmVjaXNpb24gPD0gdGhpc1ByZWNpc2lvbiA/XG4gICAgICBvdGhlclRpbWUuX2dldERhdGVPYmooKS5nZXRUaW1lKCk6IG90aGVyVGltZS5fZGF0ZUF0UHJlY2lzaW9uKHRoaXNQcmVjaXNpb24pLmdldFRpbWUoKTtcbiAgICBpZiAodGhpc1ByZWNpc2lvbiAhPT0gb3RoZXJQcmVjaXNpb24gJiYgdGhpc1RpbWVJbnQgPT09IG90aGVyVGltZUludCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzVGltZUludCAtIG90aGVyVGltZUludDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcHJlY2lzaW9uIG9mIHRoZSB0aW1lIHN0cmluZyBnaXZlbiB0b1xuICAgKiAgdGhlIGNvbnN0cnVjdG9yLiAgKEhpZ2hlciBtZWFucyBtb3JlIHByZWNpc2UpLiAgVGhlIG51bWJlciBpcyB0aGUgbnVtYmVyXG4gICAqICBvZiBjb21wb25lbnRzIG9mIHRoZSB0aW1lIHN0cmluZyAoaWdub3JpbmcgdGhlIHRpbWUgem9uZSkgcHJvZHVjZWQgYnlcbiAgICogIG1hdGNoaW5nIGFnYWluc3QgdGhlIHRpbWUgcmVndWxhciBleHByZXNzaW9uLCBleGNlcHQgdGhhdCBtaWxsaXNlY29uZHNcbiAgICogIGFuZCBzZWNvbmRzIGFyZSBjb3VudGVkIHRvZ2V0aGVyIGFzIGEgc2luZ2xlIG9mIGxldmVsIG9mIHByZWNpc2lvbi5cbiAgICogIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIF9nZXRQcmVjaXNpb24oKSB7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQpXG4gICAgICB0aGlzLl9nZXRNYXRjaERhdGEoKTtcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNpb247XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgdGhlIG1hdGNoIGRhdGEgZnJvbSBtYXRjaGluZyB0aGUgZ2l2ZW4gUmVnRXhwIGFnYWluc3QgdGhlXG4gICAqICBkYXRlL3RpbWUgc3RyaW5nIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogIEFsc28gc2V0cyB0aGlzLnByZWNpc2lvbi5cbiAgICogQHBhcmFtIHJlZ0V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdCB0aGUgZGF0ZS90aW1lIHN0cmluZy5cbiAgICogQHBhcmFtIG1heFByZWNpc2lvbiB0aGUgbWF4aW11bSBwcmVjaXNpb24gcG9zc2libGUgZm9yIHRoZSB0eXBlXG4gICAqL1xuICBfZ2V0TWF0Y2hEYXRhKHJlZ0V4LCBtYXhQcmVjaXNpb24pIHtcbiAgICBpZiAodGhpcy50aW1lTWF0Y2hEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGltZU1hdGNoRGF0YSA9IHRoaXMuYXNTdHIubWF0Y2gocmVnRXgpO1xuICAgICAgaWYgKHRoaXMudGltZU1hdGNoRGF0YSkge1xuICAgICAgICBmb3IgKGxldCBpPW1heFByZWNpc2lvbjsgaT49MCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkOyAtLWkpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lTWF0Y2hEYXRhW2ldKVxuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbWVNYXRjaERhdGE7XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBpZWNlcyBvZiB0aGUgZ2l2ZW4gdGltZSBzdHJpbmcsIGZvciB1c2UgaW5cbiAgICogIGNvbnN0cnVjdGluZyBsb3dlciBwcmVjaXNpb24gdmVyc2lvbnMgb2YgdGhlIHRpbWUuIFRoZSByZXR1cm5lZCBhcnJheSB3aWxsXG4gICAqICBjb250YWluIHNlcGFyYXRlIGVsZW1lbnRzIGZvciB0aGUgaG91ciwgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgKiAgKG9yIGFzIG1hbnkgb2YgdGhvc2UgYXJlIGFzIHByZXNlbnQpLiAgVGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICogIHdpbGwgdGhlcmVmb3JlIGJlIGFuIGluZGljYXRpb24gb2YgdGhlIHByZWNpc2lvbi5cbiAgICogIEl0IHdpbGwgbm90IGluY2x1ZGUgdGhlIHRpbWV6b25lLlxuICAgKiBAdGltZU1hdGNoRGF0YSB0aGUgcmVzdWx0IG9mIG1hdGNoaW5nIHRoZSB0aW1lIHBvcnRpb24gb2YgdGhlIHN0cmluZyBwYXNzZWRcbiAgICogIGludG8gdGhlIGNvbnN0cnVjdG9yIGFnYWluc3QgdGhlIFwidGltZVJFXCIgcmVndWxhciBleHByZXNzaW9uLlxuICAgKi9cbiAgX2dldFRpbWVQYXJ0cyh0aW1lTWF0Y2hEYXRhKSB7XG4gICAgdmFyIHRpbWVQYXJ0cyA9IFtdO1xuICAgIC8vIEZpbmlzaCBwYXJzaW5nIHRoZSBkYXRhIGludG8gcGllY2VzLCBmb3IgbGF0ZXIgdXNlIGluIGJ1aWxkaW5nXG4gICAgLy8gbG93ZXItcHJlY2lzaW9uIHZlcnNpb25zIG9mIHRoZSBkYXRlIGlmIG5lZWRlZC5cbiAgICB0aW1lUGFydHMgPSBbdGltZU1hdGNoRGF0YVswXV07XG4gICAgdmFyIHRpbWVab25lID0gdGltZU1hdGNoRGF0YVs0XTtcbiAgICBpZiAodGltZVpvbmUpIHsgLy8gcmVtb3ZlIHRpbWUgem9uZSBmcm9tIGhvdXJzXG4gICAgICBsZXQgaG91cnMgPSB0aW1lUGFydHNbMF07XG4gICAgICB0aW1lUGFydHNbMF0gPSBob3Vycy5zbGljZSgwLCBob3Vycy5sZW5ndGgtdGltZVpvbmUubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIG1pbiA9IHRpbWVNYXRjaERhdGFbMV07XG4gICAgaWYgKG1pbikgeyAvLyByZW1vdmUgbWludXRlcyBmcm9tIGhvdXJzXG4gICAgICBsZXQgaG91cnMgPSB0aW1lUGFydHNbMF07XG4gICAgICB0aW1lUGFydHNbMF0gPSBob3Vycy5zbGljZSgwLCBob3Vycy5sZW5ndGgtbWluLmxlbmd0aCk7XG4gICAgICB0aW1lUGFydHNbMV0gPSBtaW47XG4gICAgICB2YXIgc2VjID0gdGltZU1hdGNoRGF0YVsyXTtcbiAgICAgIGlmIChzZWMpIHsgLy8gcmVtb3ZlIHNlY29uZHMgZnJvbSBtaW51dGVzXG4gICAgICAgIHRpbWVQYXJ0c1sxXSA9IG1pbi5zbGljZSgwLCBtaW4ubGVuZ3RoLXNlYy5sZW5ndGgpO1xuICAgICAgICB0aW1lUGFydHNbMl0gPSBzZWM7XG4gICAgICAgIHZhciBtcyA9IHRpbWVNYXRjaERhdGFbM107XG4gICAgICAgIGlmIChtcykgeyAvLyByZW1vdmUgbWlsbGlzZWNvbmRzIGZyb20gc2Vjb25kc1xuICAgICAgICAgIHRpbWVQYXJ0c1syXSA9IHNlYy5zbGljZSgwLCBzZWMubGVuZ3RoLW1zLmxlbmd0aCk7XG4gICAgICAgICAgdGltZVBhcnRzWzNdID0gbXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbWVQYXJ0cztcbiAgfVxuXG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgZGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgdGltZSBvbiBhIGNlcnRhaW4gZGF0ZS5cbiAgICovXG4gIF9nZXREYXRlT2JqKCkge1xuICAgIGlmICghdGhpcy5kYXRlT2JqKSB7XG4gICAgICB2YXIgcHJlY2lzaW9uID0gdGhpcy5fZ2V0UHJlY2lzaW9uKCk7XG4gICAgICAvLyBXZSBjYW5ub3QgZGlyZWN0bHkgcGFzcyB0aGUgc3RyaW5nIGludG8gdGhlIGRhdGUgY29uc3RydWN0b3IgYmVjYXVzZVxuICAgICAgLy8gKDEpIHdlIGRvbid0IHdhbnQgdG8gaW50cm9kdWNlIGEgdGltZS1kZXBlbmRlbnQgc3lzdGVtIGRhdGUgYW5kICgyKSB0aGVcbiAgICAgIC8vIHRpbWUgc3RyaW5nIG1pZ2h0IG5vdCBoYXZlIGNvbnRhaW5lZCBtaW51dGVzLCB3aGljaCBhcmUgcmVxdWlyZWQgYnkgdGhlXG4gICAgICAvLyBEYXRlIGNvbnN0cnVjdG9yLlxuICAgICAgdGhpcy5kYXRlT2JqID0gdGhpcy5fZGF0ZUF0UHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGVPYmo7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhIGRhdGUgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdGltZXpvbmUuICBUaGUgcmV0dXJuZWQgZGF0ZSBvYmplY3RcbiAgICogIHdpbGwgaGF2ZSB0aGUgc3BlY2lmaWVkIGRhdGUgYW5kIHRpbWUgaW4gdGhlIHNwZWNpZmllZCB0aW1lem9uZS5cbiAgICogQHBhcmFtIHllYXIuLi5tcyBKdXN0IGFzIGluIHRoZSBEYXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gdGltZXpvbmVPZmZzZXQgKG9wdGlvbmFsKSBhIHN0cmluZyBpbiB0aGUgZm9ybWF0ICgrLSlISDptbSBvciBaLCByZXByZXNlbnRpbmcgdGhlXG4gICAqICB0aW1lem9uZSBvZmZzZXQuICBJZiBub3QgcHJvdmlkZWQsIHRoZSBsb2NhbCB0aW16b25lIHdpbGwgYmUgYXNzdW1lZCAoYXMgdGhlXG4gICAqICBEYXRlIGNvbnN0cnVjdG9yIGRvZXMpLlxuICAgKi9cbiAgX2NyZWF0ZURhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlcywgc2Vjb25kcywgbXMsIHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgdmFyIGQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtcyk7XG4gICAgaWYgKHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICAvLyBkIGlzIGluIGxvY2FsIHRpbWUuICBBZGp1c3QgZm9yIHRoZSB0aW1lem9uZSBvZmZzZXQuXG4gICAgICAvLyBGaXJzdCBhZGp1c3QgdGhlIGRhdGUgYnkgdGhlIHRpbWV6b25lIG9mZnNldCBiZWZvcmUgcmVkdWNpbmcgaXRzXG4gICAgICAvLyBwcmVjaXNpb24uICBPdGhlcndpc2UsXG4gICAgICAvLyBAMjAxOC0xMS0wMVQtMDQ6MDAgPCBAMjAxOFQtMDU6MDBcbiAgICAgIHZhciBsb2NhbFRpbWV6b25lTWludXRlcyA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB0aW1lem9uZU1pbnV0ZXMgPSAwOyAvLyBpZiBaXG4gICAgICBpZiAodGltZXpvbmVPZmZzZXQgIT0gJ1onKSB7XG4gICAgICAgIHZhciB0aW1lem9uZVBhcnRzID0gdGltZXpvbmVPZmZzZXQuc3BsaXQoJzonKTsgLy8gKCstKWhvdXJzOm1pbnV0ZXNcbiAgICAgICAgdmFyIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmVQYXJ0c1swXSk7XG4gICAgICAgIHRpbWV6b25lTWludXRlcyA9IHBhcnNlSW50KHRpbWV6b25lUGFydHNbMV0pO1xuICAgICAgICBpZiAoaG91cnMgPCAwKVxuICAgICAgICAgIHRpbWV6b25lTWludXRlcyA9IC10aW1lem9uZU1pbnV0ZXM7XG4gICAgICAgIHRpbWV6b25lTWludXRlcyArPSA2MCpob3VycztcbiAgICAgIH1cbiAgICAgIC8vIGxvY2FsVGltZXpvbmVNaW51dGVzIGhhcyB0aGUgaW52ZXJzZSBzaWduIG9mIGl0cyB0aW1lem9uZSBvZmZzZXRcbiAgICAgIGQgPSBhZGRNaW51dGVzKGQsIC1sb2NhbFRpbWV6b25lTWludXRlcy10aW1lem9uZU1pbnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfVxufVxuXG4vKipcbiAqICBBIG1hcCBmcm9tIGEgRkhJUlBhdGggdGltZSB1bml0cyB0byBhIGZ1bmN0aW9uIHVzZWQgdG8gYWRkIHRoYXRcbiAqICBxdWFudGl0eSB0byBhIGRhdGUvdGltZS5cbiAqL1xuRlBfVGltZUJhc2UudGltZVVuaXRUb0FkZEZuID0ge1xuICBcInllYXJcIjogcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX3llYXJzJyksXG4gIFwibW9udGhcIjogcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX21vbnRocycpLFxuICBcIndlZWtcIjogcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX3dlZWtzJyksXG4gIFwiZGF5XCI6IHJlcXVpcmUoJ2RhdGUtZm5zL2FkZF9kYXlzJyksXG4gIFwiaG91clwiOiByZXF1aXJlKCdkYXRlLWZucy9hZGRfaG91cnMnKSxcbiAgXCJtaW51dGVcIjogcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX21pbnV0ZXMnKSxcbiAgXCJzZWNvbmRcIjogcmVxdWlyZSgnZGF0ZS1mbnMvYWRkX3NlY29uZHMnKSxcbiAgXCJtaWxsaXNlY29uZFwiOiByZXF1aXJlKCdkYXRlLWZucy9hZGRfbWlsbGlzZWNvbmRzJylcbn07XG5cblxuY2xhc3MgRlBfRGF0ZVRpbWUgZXh0ZW5kcyBGUF9UaW1lQmFzZSB7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0cyBhbiBGUF9EYXRlVGltZSwgYXNzdW1pbmcgZGF0ZVN0ciBpcyB2YWxpZC4gIElmIHlvdSBkb24ndCBrbm93XG4gICAqICB3aGV0aGVyIGEgc3RyaW5nIGlzIGEgdmFsaWQgRGF0ZVRpbWUsIHVzZSBGUF9EYXRlVGltZS5jaGVja1N0cmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0ZVN0cikge1xuICAgIHN1cGVyKGRhdGVTdHIpO1xuICB9XG5cblxuICAvKipcbiAgICogIFJldHVybnMgLTEsIDAsIG9yIDEgaWYgdGhpcyBkYXRlIHRpbWUgaXMgbGVzcyB0aGVuLCBlcXVhbCB0bywgb3IgZ3JlYXRlclxuICAgKiAgdGhhbiBvdGhlckRhdGVUaW1lLiAgQ29tcGFyaXNvbnMgYXJlIG1hZGUgYXQgdGhlIGxlc3NlciBvZiB0aGUgdHdvIGRhdGUgdGltZVxuICAgKiAgcHJlY2lzaW9ucy5cbiAgICovXG4gIGNvbXBhcmUob3RoZXJEYXRlVGltZSkge1xuICAgIGlmICghKG90aGVyRGF0ZVRpbWUgaW5zdGFuY2VvZiBGUF9EYXRlVGltZSkpXG4gICAgICB0aHJvdyAnSW52YWxpZCBjb21wYXJpc29uIG9mIGEgRGF0ZVRpbWUgd2l0aCBzb21ldGhpbmcgZWxzZSc7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXBhcmUob3RoZXJEYXRlVGltZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAgUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBmcm9tIG1hdGNoaW5nIGRhdGVUaW1lUkUgYWdhaW5zdCB0aGUgZGF0ZXRpbWUgc3RyaW5nLlxuICAgKiAgQWxzbyBzZXRzIHRoaXMucHJlY2lzaW9uLlxuICAgKi9cbiAgX2dldE1hdGNoRGF0YSgpIHtcbiAgICByZXR1cm4gc3VwZXIuX2dldE1hdGNoRGF0YShkYXRlVGltZVJFLCA1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGllY2VzIG9mIHRoZSBkYXRlIHRpbWUgc3RyaW5nIHBhc3NlZCBpbnRvIHRoZVxuICAgKiAgY29uc3RydWN0b3IsIGZvciB1c2UgaW4gY29uc3RydWN0aW5nIGxvd2VyIHByZWNpc2lvbiB2ZXJzaW9ucyBvZiB0aGVcbiAgICogIGRhdGUgdGltZS4gVGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29udGFpbiBzZXBhcmF0ZSBlbGVtZW50cyBmb3IgdGhlIHllYXIsXG4gICAqICBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIChvciBhcyBtYW55IG9mIHRob3NlXG4gICAqICBhcmUgYXMgcHJlc2VudCkuICBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIHRoZXJlZm9yZSBiZSBhblxuICAgKiAgaW5kaWNhdGlvbiBvZiB0aGUgcHJlY2lzaW9uLiAgSXQgd2lsbCBub3QgaW5jbHVkZSB0aGUgdGltZXpvbmUuXG4gICAqL1xuICBfZ2V0VGltZVBhcnRzKCkge1xuICAgIGlmICghdGhpcy50aW1lUGFydHMpIHtcbiAgICAgIGxldCB0aW1lTWF0Y2hEYXRhID0gIHRoaXMuX2dldE1hdGNoRGF0YSgpO1xuICAgICAgbGV0IHllYXIgPSB0aW1lTWF0Y2hEYXRhWzBdO1xuICAgICAgdGhpcy50aW1lUGFydHMgPSBbeWVhcl07XG4gICAgICB2YXIgbW9udGggPSB0aW1lTWF0Y2hEYXRhWzFdO1xuICAgICAgaWYgKG1vbnRoKSB7IC8vIFJlbW92ZSBvdGhlciBpbmZvcm1hdGlvbiBmcm9tIHllYXJcbiAgICAgICAgdGhpcy50aW1lUGFydHNbMF0gPSB5ZWFyLnNsaWNlKDAsIHllYXIubGVuZ3RoLW1vbnRoLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudGltZVBhcnRzWzFdID0gbW9udGg7XG4gICAgICAgIGxldCBkYXkgPSB0aW1lTWF0Y2hEYXRhWzJdO1xuICAgICAgICBpZiAoZGF5KSB7IC8vIFJlbW92ZSBkYXkgaW5mb3JtYXRpb24gZnJvbSBtb250aFxuICAgICAgICAgIHRoaXMudGltZVBhcnRzWzFdID0gbW9udGguc2xpY2UoMCwgbW9udGgubGVuZ3RoLWRheS5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMudGltZVBhcnRzWzJdID0gZGF5O1xuICAgICAgICAgIGxldCB0aW1lID0gdGltZU1hdGNoRGF0YVszXTtcbiAgICAgICAgICBpZiAodGltZSkgeyAvLyBSZW1vdmUgdGltZSBmcm9tIGRheVxuICAgICAgICAgICAgdGhpcy50aW1lUGFydHNbMl0gPSBkYXkuc2xpY2UoMCwgZGF5Lmxlbmd0aC10aW1lLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGltZVswXSA9PT0gJ1QnKSAvLyByZW1vdmUgVCBmcm9tIGhvdXJcbiAgICAgICAgICAgICAgdGltZU1hdGNoRGF0YVszXSA9IHRpbWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVQYXJ0cyA9IHRoaXMudGltZVBhcnRzLmNvbmNhdChcbiAgICAgICAgICAgICAgc3VwZXIuX2dldFRpbWVQYXJ0cyh0aW1lTWF0Y2hEYXRhLnNsaWNlKDMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbWVQYXJ0cztcbiAgfVxuXG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgbmV3IERhdGUgb2JqZWN0IGZvciBhIHRpbWUgZXF1YWwgdG8gd2hhdCB0aGlzIHRpbWUgd291bGQgYmUgaWZcbiAgICogIHRoZSBzdHJpbmcgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIGhhZCB0aGUgZ2l2ZW4gcHJlY2lzaW9uLlxuICAgKiBAcGFyYW0gcHJlY2lzaW9uIHRoZSBuZXcgcHJlY2lzaW9uLCB3aGljaCBpcyBhc3N1bWVkIHRvIGJlIGxlc3MgdGhhblxuICAgKiAgb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgcHJlY2lzaW9uLlxuICAgKi9cbiAgX2RhdGVBdFByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGltZVBhcnRzID0gdGhpcy5fZ2V0VGltZVBhcnRzKCk7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy5fZ2V0TWF0Y2hEYXRhKClbN107XG4gICAgLy8gR2V0IHRoZSBkYXRlIG9iamVjdCBmaXJzdCBhdCB0aGUgY3VycmVudCBwcmVjaXNpb24uXG4gICAgdmFyIHRoaXNQcmVjaXNpb24gPSB0aGlzLl9nZXRQcmVjaXNpb24oKTtcbiAgICB2YXIgeWVhciA9IHBhcnNlSW50KHRpbWVQYXJ0c1swXSk7XG4gICAgdmFyIG1vbnRoID0gdGhpc1ByZWNpc2lvbiA+IDAgPyBwYXJzZUludCh0aW1lUGFydHNbMV0uc2xpY2UoMSkpIC0gMSA6IDA7XG4gICAgdmFyIGRheSA9IHRoaXNQcmVjaXNpb24gPiAxID8gcGFyc2VJbnQodGltZVBhcnRzWzJdLnNsaWNlKDEpKSA6IDE7XG4gICAgdmFyIGhvdXIgPSB0aGlzUHJlY2lzaW9uID4gMiA/IHBhcnNlSW50KHRpbWVQYXJ0c1szXSkgOiAwO1xuICAgIHZhciBtaW51dGVzID0gdGhpc1ByZWNpc2lvbiA+IDMgPyBwYXJzZUludCh0aW1lUGFydHNbNF0uc2xpY2UoMSkpOiAwO1xuICAgIHZhciBzZWNvbmRzID0gdGhpc1ByZWNpc2lvbiA+IDQgPyBwYXJzZUludCh0aW1lUGFydHNbNV0uc2xpY2UoMSkpOiAwO1xuICAgIHZhciBtcyA9IHRpbWVQYXJ0cy5sZW5ndGggPiA2ID8gcGFyc2VJbnQodGltZVBhcnRzWzZdLnNsaWNlKDEpKTogMDtcbiAgICB2YXIgZCA9IHRoaXMuX2NyZWF0ZURhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlcywgc2Vjb25kcywgbXMsXG4gICAgICB0aW1lem9uZU9mZnNldCk7XG4gICAgaWYgKHByZWNpc2lvbiA8IHRoaXNQcmVjaXNpb24pIHtcbiAgICAgIC8vIEFkanVzdCB0aGUgcHJlY2lzaW9uXG4gICAgICB5ZWFyID0gZC5nZXRGdWxsWWVhcigpO1xuICAgICAgbW9udGggPSBwcmVjaXNpb24gPiAwID8gZC5nZXRNb250aCgpIDogMDtcbiAgICAgIGRheSA9IHByZWNpc2lvbiA+IDEgPyBkLmdldERhdGUoKSA6IDE7XG4gICAgICBob3VyID0gcHJlY2lzaW9uID4gMiA/IGQuZ2V0SG91cnMoKSA6IDA7XG4gICAgICBtaW51dGVzID0gcHJlY2lzaW9uID4gMyA/IGQuZ2V0TWludXRlcygpOiAwO1xuICAgICAgLy8gSGVyZSB0aGUgcHJlY2lzaW9uIHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiB0aGUgbWF4aW11bVxuICAgICAgLy8gZHVlIHRvIHRoZSBjb25kaXRpb24gaW4gdGhlIGlmIHN0YXRlbWVudDogXCJwcmVjaXNpb24gPCB0aGlzUHJlY2lzaW9uXCJcbiAgICAgIGQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH1cbn1cblxuLyoqXG4gKiAgVGVzdHMgc3RyIHRvIHNlZSBpZiBpdCBpcyBjb252ZXJ0aWJsZSB0byBhIERhdGVUaW1lLlxuICogQHJldHVybiBJZiBzdHIgaXMgY29udmVydGlibGUgdG8gYSBEYXRlVGltZSwgcmV0dXJucyBhbiBGUF9EYXRlVGltZTtcbiAqICBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICovXG5GUF9EYXRlVGltZS5jaGVja1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBsZXQgZCA9IG5ldyBGUF9EYXRlVGltZShzdHIpO1xuICBpZiAoIWQuX2dldE1hdGNoRGF0YSgpKVxuICAgIGQgPSBudWxsO1xuICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogIEEgbWFwIGZyb20gRkhJUlBhdGggdGltZSB1bml0cyB0byB0aGUgaW50ZXJuYWwgRGF0ZVRpbWUgXCJwcmVjaXNpb25cIiBudW1iZXIuXG4gKi9cbkZQX0RhdGVUaW1lLl90aW1lVW5pdFRvRGF0ZVByZWNpc2lvbiA9IHtcbiAgXCJ5ZWFyXCI6IDAsXG4gIFwibW9udGhcIjogMSxcbiAgXCJ3ZWVrXCI6IDIsIC8vIHdrIGlzIGp1c3QgNypkXG4gIFwiZGF5XCI6IDIsXG4gIFwiaG91clwiOiAzLFxuICBcIm1pbnV0ZVwiOiA0LFxuICBcInNlY29uZFwiOiA1LFxuICBcIm1pbGxpc2Vjb25kXCI6IDZcbn07XG5cbi8qKlxuICogIFRoZSBpbnZlcnNlIG9mIF90aW1lVW5pdFRvRGF0ZVByZWNpc2lvbi5cbiAqL1xuRlBfRGF0ZVRpbWUuX2RhdGVQcmVjaXNpb25Ub1RpbWVVbml0ID0gW1xuICBcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXG5dO1xuXG5cblxuY2xhc3MgRlBfVGltZSBleHRlbmRzIEZQX1RpbWVCYXNlIHtcbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RzIGFuIEZQX1RpbWUsIGFzc3VtaW5nIGRhdGVTdHIgaXMgdmFsaWQuICBJZiB5b3UgZG9uJ3Qga25vd1xuICAgKiAgd2hldGhlciBhIHN0cmluZyBpcyBhIHZhbGlkIERhdGVUaW1lLCB1c2UgRlBfVGltZS5jaGVja1N0cmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGltZVN0cikge1xuICAgIGlmICh0aW1lU3RyWzBdID09ICdUJylcbiAgICAgIHRpbWVTdHIgPSB0aW1lU3RyLnNsaWNlKDEpO1xuICAgIHN1cGVyKHRpbWVTdHIpO1xuICB9XG5cblxuICAvKipcbiAgICogIFJldHVybnMgLTEsIDAsIG9yIDEgaWYgdGhpcyB0aW1lIGlzIGxlc3MgdGhlbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXJcbiAgICogIHRoYW4gb3RoZXJUaW1lLiAgQ29tcGFyaXNvbnMgYXJlIG1hZGUgYXQgdGhlIGxlc3NlciBvZiB0aGUgdHdvIHRpbWVcbiAgICogIHByZWNpc2lvbnMuXG4gICAqL1xuICBjb21wYXJlKG90aGVyVGltZSkge1xuICAgIGlmICghKG90aGVyVGltZSBpbnN0YW5jZW9mIEZQX1RpbWUpKVxuICAgICAgdGhyb3cgJ0ludmFsaWQgY29tcGFyaXNvbiBvZiBhIHRpbWUgd2l0aCBzb21ldGhpbmcgZWxzZSc7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXBhcmUob3RoZXJUaW1lKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgbmV3IERhdGUgb2JqZWN0IGZvciBhIHRpbWUgZXF1YWwgdG8gd2hhdCB0aGlzIHRpbWUgd291bGQgYmUgaWZcbiAgICogIHRoZSBzdHJpbmcgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIGhhZCB0aGUgZ2l2ZW4gcHJlY2lzaW9uLlxuICAgKiAgVGhlIFwiZGF0ZVwiIHBvcnRpb24gb2YgdGhlIHJldHVybmVkIERhdGUgb2JqZWN0IGlzIG5vdCBtZWFuaW5nZnVsLCBhbmRcbiAgICogIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gcHJlY2lzaW9uIHRoZSBuZXcgcHJlY2lzaW9uLCB3aGljaCBpcyBhc3N1bWVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICogIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHByZWNpc2lvbi4gIEEgcHJlY2lzaW9uIG9mIDAgbWVhbnMgdGhlIGhvdXIuXG4gICAqL1xuICBfZGF0ZUF0UHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIHZhciB0aW1lUGFydHMgPSB0aGlzLl9nZXRUaW1lUGFydHMoKTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLl9nZXRNYXRjaERhdGEoKVs0XTtcbiAgICAvLyBHZXQgdGhlIGRhdGUgb2JqZWN0IGZpcnN0IGF0IHRoZSBjdXJyZW50IHByZWNpc2lvbi5cbiAgICB2YXIgdGhpc1ByZWNpc2lvbiA9IHRoaXMuX2dldFByZWNpc2lvbigpO1xuICAgIHZhciB5ZWFyID0gMjAxMDsgLy8gSGF2ZSB0byBwaWNrIHNvbWUgeWVhciBmb3IgdGhlIGRhdGUgb2JqZWN0XG4gICAgdmFyIG1vbnRoID0gMDtcbiAgICB2YXIgZGF5ID0gMTtcbiAgICB2YXIgaG91ciA9IHBhcnNlSW50KHRpbWVQYXJ0c1swXSk7XG4gICAgdmFyIG1pbnV0ZXMgPSB0aGlzUHJlY2lzaW9uID4gMCA/IHBhcnNlSW50KHRpbWVQYXJ0c1sxXS5zbGljZSgxKSk6IDA7XG4gICAgdmFyIHNlY29uZHMgPSB0aGlzUHJlY2lzaW9uID4gMSA/IHBhcnNlSW50KHRpbWVQYXJ0c1syXS5zbGljZSgxKSk6IDA7XG4gICAgdmFyIG1zID0gdGltZVBhcnRzLmxlbmd0aCA+IDMgPyBwYXJzZUludCh0aW1lUGFydHNbM10uc2xpY2UoMSkpOiAwO1xuICAgIHZhciBkID0gdGhpcy5fY3JlYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtcyxcbiAgICAgIHRpbWV6b25lT2Zmc2V0KTtcbiAgICBpZiAodGltZXpvbmVPZmZzZXQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGRhdGUgdGhlIHNhbWUgKGluIHRoZSBsb2NhbCB0aW1lem9uZSksIHNvIGl0IGlzIG5vdCBhIHJlbGV2YW50XG4gICAgICAvLyBmYWN0b3Igd2hlbiBjb21wYXJpbmcgZGlmZmVyZW50IHRpbWVzLlxuICAgICAgZC5zZXRZZWFyKHllYXIpO1xuICAgICAgZC5zZXRNb250aChtb250aCk7XG4gICAgICBkLnNldERhdGUoZGF5KTtcbiAgICB9XG4gICAgaWYgKHByZWNpc2lvbiA8IHRoaXNQcmVjaXNpb24pIHtcbiAgICAgIC8vIEFkanVzdCB0aGUgcHJlY2lzaW9uXG4gICAgICBob3VyID0gZC5nZXRIb3VycygpO1xuICAgICAgbWludXRlcyA9IHByZWNpc2lvbiA+IDAgPyBkLmdldE1pbnV0ZXMoKTogMDtcbiAgICAgIC8vIEhlcmUgdGhlIHByZWNpc2lvbiB3aWxsIGFsd2F5cyBiZSBsZXNzIHRoYW4gdGhlIG1heGltdW1cbiAgICAgIC8vIGR1ZSB0byB0aGUgY29uZGl0aW9uIGluIHRoZSBpZiBzdGF0ZW1lbnQ6IFwicHJlY2lzaW9uIDwgdGhpc1ByZWNpc2lvblwiXG4gICAgICBkID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9XG5cblxuICAvKipcbiAgICogIFJldHVybnMgdGhlIG1hdGNoIGRhdGEgZnJvbSBtYXRjaGluZyB0aW1lUkUgYWdhaW5zdCB0aGUgdGltZSBzdHJpbmcuXG4gICAqICBBbHNvIHNldHMgdGhpcy5wcmVjaXNpb24uXG4gICAqL1xuICBfZ2V0TWF0Y2hEYXRhKCkge1xuICAgIHJldHVybiBzdXBlci5fZ2V0TWF0Y2hEYXRhKHRpbWVSRSwgMik7XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBpZWNlcyBvZiB0aGUgdGltZSBzdHJpbmcgcGFzc2VkIGludG8gdGhlXG4gICAqICBjb25zdHJ1Y3RvciwgZm9yIHVzZSBpbiBjb25zdHJ1Y3RpbmcgbG93ZXIgcHJlY2lzaW9uIHZlcnNpb25zIG9mIHRoZVxuICAgKiAgdGltZS4gVGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29udGFpbiBzZXBhcmF0ZSBlbGVtZW50cyBmb3IgdGhlIGhvdXIsXG4gICAqICBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIChvciBhcyBtYW55IG9mIHRob3NlIGFyZSBhcyBwcmVzZW50KS5cbiAgICogIFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgdGhlcmVmb3JlIGJlIGFuIGluZGljYXRpb24gb2YgdGhlXG4gICAqICBwcmVjaXNpb24uICBJdCB3aWxsIG5vdCBpbmNsdWRlIHRoZSB0aW1lem9uZS5cbiAgICovXG4gIF9nZXRUaW1lUGFydHMoKSB7XG4gICAgaWYgKCF0aGlzLnRpbWVQYXJ0cykge1xuICAgICAgdGhpcy50aW1lUGFydHMgPSBzdXBlci5fZ2V0VGltZVBhcnRzKHRoaXMuX2dldE1hdGNoRGF0YSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGltZVBhcnRzO1xuICB9XG59XG5cbi8qKlxuICogIFRlc3RzIHN0ciB0byBzZWUgaWYgaXQgaXMgY29udmVydGlibGUgdG8gYSBUaW1lLlxuICogQHJldHVybiBJZiBzdHIgaXMgY29udmVydGlibGUgdG8gYSBUaW1lLCByZXR1cm5zIGFuIEZQX1RpbWU7XG4gKiAgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqL1xuRlBfVGltZS5jaGVja1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBsZXQgZCA9IG5ldyBGUF9UaW1lKHN0cik7XG4gIGlmICghZC5fZ2V0TWF0Y2hEYXRhKCkpXG4gICAgZCA9IG51bGw7XG4gIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiAgQSBtYXAgZnJvbSBGSElSUGF0aCB0aW1lIHVuaXRzIHRvIHRoZSBpbnRlcm5hbCBEYXRlVGltZSBcInByZWNpc2lvblwiIG51bWJlci5cbiAqL1xuRlBfVGltZS5fdGltZVVuaXRUb0RhdGVQcmVjaXNpb24gPSB7XG4gIFwiaG91clwiOiAwLFxuICBcIm1pbnV0ZVwiOiAxLFxuICBcInNlY29uZFwiOiAyLFxuICBcIm1pbGxpc2Vjb25kXCI6IDNcbn07XG5cbi8qKlxuICogIFRoZSBpbnZlcnNlIG9mIF90aW1lVW5pdFRvRGF0ZVByZWNpc2lvbi5cbiAqL1xuRlBfVGltZS5fZGF0ZVByZWNpc2lvblRvVGltZVVuaXQgPSBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cblxuLyoqXG4gKiAgUmV0dXJucyBlaXRoZXIgdGhlIGdpdmVuIG51bWJlciBvciBhIHN0cmluZyB3aXRoIHRoZSBudW1iZXIgcHJlZml4ZWQgYnlcbiAqICB6ZXJvcyBpZiB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICogQHBhcmFtIG51bSB0aGUgbnVibWVyIHRvIGZvcm1hdFxuICogQHBhcmFtIGxlbiB0aGUgbnVtYmVyIG9mIHJldHVybmVkIGRpZ2l0cy4gIEZvciBub3cgdGhpcyBtdXN0IGVpdGhlciBiZSAyIG9yXG4gKiAgMy4gKE9wdGlvbmFsLS0gZGVmYXVsdCBpcyAyKS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgbGVuKSB7XG4gIC8vIENvdWxkIHVzZSBTdHJpbmcucmVwZWF0LCBidXQgdGhhdCByZXF1aXJlcyBjb252ZXJ0aW4gbnVtIHRvIGFuIHN0cmluZyBmaXJzdFxuICAvLyB0byBnZXQgaXRzIGxlbmd0aC4gIFRoaXMgbWlnaHQgYmUgc2xpZ2h0bHkgZmFzdGVyIGdpdmVuIHRoYXQgd2Ugb25seSBuZWVkIDJcbiAgLy8gb3IgdGhyZWUgMyBkaWdpdCByZXR1cm4gdmFsdWVzLlxuICB2YXIgcnRuID0gbnVtO1xuICBpZiAobGVuID09PSAzICYmIG51bSA8IDEwMClcbiAgICBydG4gPSAnMCcgKyBudW07XG4gIGlmIChudW0gPCAxMClcbiAgICBydG4gPSAnMCcgKyBydG47XG4gIHJldHVybiBydG47XG59XG5cblxuLyoqXG4gKiAgRm9ybWF0cyB0aGUgZ2l2ZW4gZGF0ZSBvYmplY3QgaW50byBhbiBJU084NjAxIGRhdGV0aW1lIHN0cmluZywgZXhwcmVzc2luZyBpdFxuICogIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqIEBkYXRlIHRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHByZWNpc2lvbiB0aGUgcHJlY2lzaW9uIGF0IHdoaWNoIHRvIHRlcm1pbmF0ZSBzdHJpbmcgc3RyaW5nLiAgKFRoaXMgaXNcbiAqICBvcHRpb25hbCkuIElmIHByZXNlbnQsIGl0IHdpbGwgYmUgYW4gaW50ZWdlciBpbnRvIHRoZSBtYXRjaGluZyBjb21wb25lbnRzIG9mXG4gKiAgZGF0ZVRpbWVSRS5cbiAqIEByZXR1cm4gYSBzdHJpbmcgaW4gSVNPODYwMSBmb3JtYXQuXG4gKi9cbkZQX0RhdGVUaW1lLmlzb0RhdGVUaW1lID0gZnVuY3Rpb24oZGF0ZSwgcHJlY2lzaW9uKSB7XG4gIGlmIChwcmVjaXNpb24gPT09IHVuZGVmaW5lZClcbiAgICBwcmVjaXNpb24gPSA1OyAvLyBtYXhpbXVtXG4gIC8vIFlZWVktTU0tRERUSEg6bW06c3Muc3NzWystXUhIOm1tXG4gIC8vIE5vdGU6ICBEYXRlLnRvSVNPU3RyaW5nIHNldHMgdGhlIHRpbWV6b25lIGF0ICdaJywgd2hpY2ggSSBkaWQgbm90IHdhbnQuXG4gIC8vIEFjdHVhbGx5LCBJIHdhbnRlZCB0byBrZWVwIHRoZSBvcmlnaW5hbCB0aW1lem9uZSBnaXZlbiBpbiB0aGUgY29uc3RydWN0b3IsXG4gIC8vIGJ1dCB0aGF0IGlzIGRpZmZpY3VsdCBkdWUgdG8gZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGNoYW5nZXMuICAoRm9yIGluc3RhbmNlLFxuICAvLyBpZiB5b3UgYWRkIDYgbW9udGhzLCB0aGUgdGltZXpvbmUgb2Zmc2V0IGNvdWxkIGNoYW5nZSkuXG4gIHZhciBydG4gPSAnJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICBydG4gKz0gJy0nICsgZm9ybWF0TnVtKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuICAgIGlmIChwcmVjaXNpb24gPiAxKSB7XG4gICAgICBydG4gKz0gJy0nICsgZm9ybWF0TnVtKGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgIGlmIChwcmVjaXNpb24gPiAyKSB7XG4gICAgICAgIHJ0biArPSAnVCcgKyBGUF9EYXRlVGltZS5pc29UaW1lKGRhdGUsIHByZWNpc2lvbiAtIDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBGSElSUGF0aCBTVFUxIGRvZXMgbm90IGFsbG93IGEgdGltZXpvbmUgb2Zmc2V0IG9uIGEgZGF0ZVRpbWUgdGhhdCBkb2VzIG5vdFxuICAvLyBoYXZlIGEgdGltZSBwYXJ0IChleGNlcHQgdGhhdCB0aGUgZ3JhbW1hciBhbGxvd3MgJ1onLCB3aGljaCBpc1xuICAvLyBpbmNvbnNpc3RlbnQpLlxuICBpZiAocHJlY2lzaW9uID4gMikge1xuICAgIC8vIE5vdGU6ICBnZXRUaW1lem9uZW9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgZm9yIHRoZSBsb2NhbCBzeXN0ZW0gYXQgdGhlXG4gICAgLy8gZ2l2ZW4gZGF0ZS5cbiAgICB2YXIgdHpPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgLy8gdHpPZmZzZXQgaXMgYSBudW1iZXIgb2YgbWludXRlcywgYW5kIGlzIHBvc2l0aXZlIGZvciBuZWdhdGl2ZSB0aW1lem9uZXMsXG4gICAgLy8gYW5kIG5lZ2F0aXZlIGZvciBwb3NpdGl2ZSB0aW1lem9uZXMuXG4gICAgdmFyIHR6U2lnbiA9IHR6T2Zmc2V0IDwgMCA/ICcrJyA6ICctJztcbiAgICB0ek9mZnNldCA9IE1hdGguYWJzKHR6T2Zmc2V0KTtcbiAgICB2YXIgdHpNaW4gPSB0ek9mZnNldCAlIDYwO1xuICAgIHZhciB0ekhvdXIgPSAodHpPZmZzZXQgLSB0ek1pbikgLyA2MDtcbiAgICBydG4gKz0gdHpTaWduICsgZm9ybWF0TnVtKHR6SG91cikgKyAnOicgKyBmb3JtYXROdW0odHpNaW4pO1xuICB9XG4gIHJldHVybiBydG47XG59O1xuXG5cbi8qKlxuICogIFJldHVybnMgYSB0aW1lIHN0cmluZyBpbiBJU08gZm9ybWF0IGF0IHRoZSBnaXZlbiBwcmVjaXNpb24gbGV2ZWwuXG4gKiBAZGF0ZSB0aGUgZGF0ZSB0byBmb3JtYXRcbiAqIEBwcmVjaXNpb24gdGhlIHByZWNpc2lvbiBhdCB3aGljaCB0byB0ZXJtaW5hdGUgc3RyaW5nLiAgKFRoaXMgaXNcbiAqICBvcHRpb25hbCkuIElmIHByZXNlbnQsIGl0IHdpbGwgYmUgYW4gaW50ZWdlciBpbnRvIHRoZSBtYXRjaGluZyBjb21wb25lbnRzIG9mXG4gKiAgdGltZVJFLlxuICogQHJldHVybiBhIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQuXG4gKi9cbkZQX0RhdGVUaW1lLmlzb1RpbWUgPSBmdW5jdGlvbihkYXRlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKVxuICAgIHByZWNpc2lvbiA9IDI7IC8vIG1heGltdW1cblxuICBsZXQgcnRuID0gJycgKyBmb3JtYXROdW0oZGF0ZS5nZXRIb3VycygpKTtcbiAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICBydG4gKz0gJzonICsgZm9ybWF0TnVtKGRhdGUuZ2V0TWludXRlcygpKTtcbiAgICBpZiAocHJlY2lzaW9uID4gMSkge1xuICAgICAgcnRuICs9ICc6JyArIGZvcm1hdE51bShkYXRlLmdldFNlY29uZHMoKSApO1xuICAgICAgaWYgKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpXG4gICAgICAgIHJ0biArPSAnLicgKyBmb3JtYXROdW0oZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydG47XG59O1xuXG5cbmNsYXNzIEZQX0RhdGUgZXh0ZW5kcyBGUF9EYXRlVGltZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIEZQX0RhdGUsIGFzc3VtaW5nIGRhdGVTdHIgaXMgdmFsaWQuICBJZiB5b3UgZG9uJ3Qga25vd1xuICAgKiB3aGV0aGVyIGEgc3RyaW5nIGlzIGEgdmFsaWQgRGF0ZSwgdXNlIEZQX0RhdGUuY2hlY2tTdHJpbmcgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGVTdHIpIHtcbiAgICBzdXBlcihkYXRlU3RyKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1hdGNoIGRhdGEgZnJvbSBtYXRjaGluZyBkYXRlUkUgYWdhaW5zdCB0aGUgZGF0ZSBzdHJpbmcuXG4gICAqIEFsc28gc2V0cyB0aGlzLnByZWNpc2lvbi5cbiAgICovXG4gIF9nZXRNYXRjaERhdGEoKSB7XG4gICAgcmV0dXJuIEZQX1RpbWVCYXNlLnByb3RvdHlwZS5fZ2V0TWF0Y2hEYXRhLmFwcGx5KHRoaXMsIFtkYXRlUkUsIDJdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogVGVzdHMgc3RyIHRvIHNlZSBpZiBpdCBpcyBjb252ZXJ0aWJsZSB0byBhIERhdGUuXG4gKiBAcmV0dXJuIElmIHN0ciBpcyBjb252ZXJ0aWJsZSB0byBhIERhdGUsIHJldHVybnMgYW4gRlBfRGF0ZTtcbiAqICBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICovXG5GUF9EYXRlLmNoZWNrU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIGxldCBkID0gbmV3IEZQX0RhdGUoc3RyKTtcbiAgaWYgKCFkLl9nZXRNYXRjaERhdGEoKSlcbiAgICBkID0gbnVsbDtcbiAgcmV0dXJuIGQ7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGRhdGUgc3RyaW5nIGluIElTTyBmb3JtYXQgYXQgdGhlIGdpdmVuIHByZWNpc2lvbiBsZXZlbC5cbiAqIEBkYXRlIHRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHByZWNpc2lvbiB0aGUgcHJlY2lzaW9uIGF0IHdoaWNoIHRvIHRlcm1pbmF0ZSBzdHJpbmcuICAoVGhpcyBpc1xuICogIG9wdGlvbmFsKS4gSWYgcHJlc2VudCwgaXQgd2lsbCBiZSBhbiBpbnRlZ2VyIGludG8gdGhlIG1hdGNoaW5nIGNvbXBvbmVudHMgb2ZcbiAqICBkYXRlVGltZVJFLlxuICogQHJldHVybiBhIHN0cmluZyBpbiBJU084NjAxIGZvcm1hdC5cbiAqL1xuRlBfRGF0ZS5pc29EYXRlID0gZnVuY3Rpb24oZGF0ZSwgcHJlY2lzaW9uKSB7XG4gIGlmIChwcmVjaXNpb24gPT09IHVuZGVmaW5lZCB8fCBwcmVjaXNpb24gPiAyKVxuICAgIHByZWNpc2lvbiA9IDI7XG4gIHJldHVybiBGUF9EYXRlVGltZS5pc29EYXRlVGltZShkYXRlLCBwcmVjaXNpb24pO1xufTtcblxuY2xhc3MgRlBfSW5zdGFudCBleHRlbmRzIEZQX0RhdGVUaW1lIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gRlBfSW5zdGFudCwgYXNzdW1pbmcgaW5zdGFudFN0ciBpcyB2YWxpZC4gIElmIHlvdSBkb24ndCBrbm93XG4gICAqIHdoZXRoZXIgYSBzdHJpbmcgaXMgYSB2YWxpZCBcImluc3RhbnRcIiwgdXNlIEZQX0luc3RhbnQuY2hlY2tTdHJpbmcgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RhbnRTdHIpIHtcbiAgICBzdXBlcihpbnN0YW50U3RyKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1hdGNoIGRhdGEgZnJvbSBtYXRjaGluZyBpbnN0YW50UkUgYWdhaW5zdCB0aGUgXCJpbnN0YW50XCIgc3RyaW5nLlxuICAgKiBBbHNvIHNldHMgdGhpcy5wcmVjaXNpb24uXG4gICAqL1xuICBfZ2V0TWF0Y2hEYXRhKCkge1xuICAgIHJldHVybiBGUF9UaW1lQmFzZS5wcm90b3R5cGUuX2dldE1hdGNoRGF0YS5hcHBseSh0aGlzLCBbaW5zdGFudFJFLCA1XSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRlc3RzIHN0ciB0byBzZWUgaWYgaXQgaXMgY29udmVydGlibGUgdG8gYW4gXCJpbnN0YW50XCIuXG4gKiBAcmV0dXJuIElmIHN0ciBtYXRjaCB0aGUgXCJpbnN0YW50XCIgUmVnRXhwLCByZXR1cm5zIGFuIEZQX0luc3RhbnQ7XG4gKiAgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqL1xuRlBfSW5zdGFudC5jaGVja1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBsZXQgZCA9IG5ldyBGUF9JbnN0YW50KHN0cik7XG4gIGlmICghZC5fZ2V0TWF0Y2hEYXRhKCkpXG4gICAgZCA9IG51bGw7XG4gIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiAgQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBub2RlIGluIGEgRkhJUiByZXNvdXJjZSwgd2l0aCBwYXRoIGFuZCBwb3NzaWJseSB0eXBlXG4gKiAgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIFJlc291cmNlTm9kZSB7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0cyBhIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbm9kZSAoXCJkYXRhXCIpIG9mIGEgcmVzb3VyY2UuICBJZiB0aGVcbiAgICogIGRhdGEgaXMgdGhlIHRvcC1sZXZlbCBub2RlIG9mIGEgcmVzb3VjZSwgdGhlIHBhdGggYW5kIHR5cGUgcGFyYW1ldGVycyB3aWxsXG4gICAqICBiZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZSByZXNvdXJjZSdzIHJlc291cmNlVHlwZSBmaWVsZC5cbiAgICogQHBhcmFtIHsqfSBkYXRhIC0gdGhlIG5vZGUncyBkYXRhIG9yIHZhbHVlICh3aGljaCBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aFxuICAgKiAgc3ViLW5vZGVzLCBhbiBhcnJheSwgb3IgRkhJUiBkYXRhIHR5cGUpXG4gICAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlfSBwYXJlbnRSZXNOb2RlIC0gcGFyZW50IFJlc291cmNlTm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgbm9kZSdzIHBhdGggaW4gdGhlIHJlc291cmNlIChlLmcuIFBhdGllbnQubmFtZSkuXG4gICAqICBJZiB0aGUgZGF0YSdzIHR5cGUgY2FuIGJlIGRldGVybWluZWQgZnJvbSBkYXRhLCB0aGF0IHdpbGwgdGFrZSBwcmVjZWRlbmNlXG4gICAqICBvdmVyIHRoaXMgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0geyp9IF9kYXRhIC0gYWRkaXRpb25hbCBkYXRhIHN0b3JlZCBpbiBhIHByb3BlcnR5IG5hbWVkIHdpdGggXCJfXCJcbiAgICogIHByZXBlbmRlZCwgc2VlIGh0dHBzOi8vd3d3LmhsNy5vcmcvZmhpci9lbGVtZW50Lmh0bWwjanNvbiBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZoaXJOb2RlRGF0YVR5cGUgLSBGSElSIG5vZGUgZGF0YSB0eXBlLCBpZiB0aGUgcmVzb3VyY2Ugbm9kZVxuICAgKiAgaXMgZGVzY3JpYmVkIGluIHRoZSBGSElSIG1vZGVsLlxuICAgKiAgQHBhcmFtIHtPYmplY3R9IG1vZGVsIC0gdGhlIG1vZGVsIG9iamVjdCBzcGVjaWZpYyB0byBhIGRvbWFpbiwgZS5nLiBSNC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHBhcmVudFJlc05vZGUsIHBhdGgsIF9kYXRhLCBmaGlyTm9kZURhdGFUeXBlLCBtb2RlbCkge1xuICAgIC8vIElmIGRhdGEgaXMgYSByZXNvdXJjZSAobWF5YmUgYSBjb250YWluZWQgcmVzb3VyY2UpIHJlc2V0IHRoZSBwYXRoXG4gICAgLy8gaW5mb3JtYXRpb24gdG8gdGhlIHJlc291cmNlIHR5cGUuXG4gICAgaWYgKGRhdGE/LnJlc291cmNlVHlwZSkge1xuICAgICAgcGF0aCA9IGRhdGEucmVzb3VyY2VUeXBlO1xuICAgICAgZmhpck5vZGVEYXRhVHlwZSA9IGRhdGEucmVzb3VyY2VUeXBlO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudFJlc05vZGUgPSBwYXJlbnRSZXNOb2RlIHx8IG51bGw7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCBudWxsO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fZGF0YSA9IF9kYXRhIHx8IHt9O1xuICAgIHRoaXMuZmhpck5vZGVEYXRhVHlwZSA9IGZoaXJOb2RlRGF0YVR5cGUgfHwgbnVsbDtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWwgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlc291cmNlIG5vZGUgdHlwZSBpbmZvLlxuICAgKiBAcmV0dXJuIHtUeXBlSW5mb31cbiAgICovXG4gIGdldFR5cGVJbmZvKCkge1xuICAgIGlmICghdGhpcy50eXBlSW5mbykge1xuICAgICAgbGV0IHR5cGVJbmZvO1xuXG4gICAgICBpZiAodGhpcy5maGlyTm9kZURhdGFUeXBlKSB7XG4gICAgICAgIGlmICgvXlN5c3RlbVxcLiguKikkLy50ZXN0KHRoaXMuZmhpck5vZGVEYXRhVHlwZSkpIHtcbiAgICAgICAgICB0eXBlSW5mbyA9IG5ldyBUeXBlSW5mbyh7bmFtZXNwYWNlOiBUeXBlSW5mby5TeXN0ZW0sIG5hbWU6IFJlZ0V4cC4kMX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVJbmZvID0gbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogVHlwZUluZm8uRkhJUixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZmhpck5vZGVEYXRhVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHlwZUluZm8gPSB0eXBlSW5mb1xuICAgICAgICAvLyBSZXNvdXJjZSBvYmplY3QgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgbW9kZWwgbm93IGhhdmVcbiAgICAgICAgLy8gU3lzdGVtLiogZGF0YSB0eXBlczpcbiAgICAgICAgfHwgVHlwZUluZm8uY3JlYXRlQnlWYWx1ZUluU3lzdGVtTmFtZXNwYWNlKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR5cGVJbmZvO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcmVzb3VyY2Ugbm9kZSB2YWx1ZSB0byBhbiBpbnN0YW5jZSBvZiB0aGUgRkhJUlBhdGggc3lzdGVtIHR5cGVcbiAgICogKEZQX1F1YW50aXR5LCBGUF9EYXRlLCBGUF9EYXRlVGltZSwgb3IgRlBfVGltZSkgZm9yIHVzZSBpbiBldmFsdWF0aW5nXG4gICAqIGEgRkhJUlBhdGggZXhwcmVzc2lvbiBpZiB0aGUgbm9kZSBwYXRoIG1hdGNoZXMgdGhlIHNwZWNpZmllZCB0eXBlIGluIHRoZVxuICAgKiBtb2RlbCBhbmQgd2hlbiBjb252ZXJzaW9uIGlzIHBvc3NpYmxlLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgZGF0YSBhcyBpcy5cbiAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgZGF0YSBpcyBhIFF1YW50aXR5IHRoYXQgaGFzIGEgY29tcGFyYXRvci5cbiAgICogVGhlIE1hcHBpbmcgZnJvbSBGSElSIFF1YW50aXR5IHRvIEZISVJQYXRoIFN5c3RlbS5RdWFudGl0eSBpcyBleHBsYWluZWQgaGVyZTpcbiAgICogaHR0cHM6Ly93d3cuaGw3Lm9yZy9maGlyL2ZoaXJwYXRoLmh0bWwjcXVhbnRpdHlcbiAgICogdGhpcy5kYXRhIGlzIG5vdCBjaGFuZ2VkLCBidXQgY29udmVydGVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtGUF9UeXBlfGFueX1cbiAgICovXG4gIGNvbnZlcnREYXRhKCkge1xuICAgIGlmICghdGhpcy5jb252ZXJ0ZWREYXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2xzID0gVHlwZUluZm8udHlwZVRvQ2xhc3NXaXRoQ2hlY2tTdHJpbmdbdGhpcy5wYXRoXTtcbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgIGRhdGEgPSBjbHMuY2hlY2tTdHJpbmcoZGF0YSkgfHwgZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChUeXBlSW5mby5pc1R5cGUodGhpcy5wYXRoLCAnUXVhbnRpdHknLCB0aGlzLm1vZGVsKSkge1xuICAgICAgICAgIGlmIChkYXRhPy5zeXN0ZW0gPT09IHVjdW1TeXN0ZW1VcmwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS52YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGRhdGEuY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuY29tcGFyYXRvciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBGSElSLlF1YW50aXR5IHRoYXQgaGFzIGEgY29tcGFyYXRvcicpO1xuICAgICAgICAgICAgICBkYXRhID0gbmV3IEZQX1F1YW50aXR5KFxuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUsXG4gICAgICAgICAgICAgICAgRlBfUXVhbnRpdHkubWFwVUNVTUNvZGVUb1RpbWVVbml0c1tkYXRhLmNvZGVdIHx8ICdcXCcnICsgZGF0YS5jb2RlICsgJ1xcJydcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb252ZXJ0ZWREYXRhID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydGVkRGF0YTtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiAgUmV0dXJucyBhIFJlc291cmNlTm9kZSBmb3IgdGhlIGdpdmVuIGRhdGEgbm9kZSwgY2hlY2tpbmcgZmlyc3QgdG8gc2VlIGlmIHRoZVxuICogIGdpdmVuIG5vZGUgaXMgYWxyZWFkeSBhIFJlc291cmNlTm9kZS4gIFRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGVcbiAqICBjb25zdHJ1Y3RvciBmb3IgUmVzb3VyY2VOb2RlLlxuICovXG5SZXNvdXJjZU5vZGUubWFrZVJlc05vZGUgPSBmdW5jdGlvbihkYXRhLCBwYXJlbnRSZXNOb2RlLCBwYXRoLCBfZGF0YSwgZmhpck5vZGVEYXRhVHlwZSwgbW9kZWwpIHtcbiAgcmV0dXJuIChkYXRhIGluc3RhbmNlb2YgUmVzb3VyY2VOb2RlKSA/IGRhdGEgOiBuZXcgUmVzb3VyY2VOb2RlKGRhdGEsIHBhcmVudFJlc05vZGUsIHBhdGgsIF9kYXRhLCBmaGlyTm9kZURhdGFUeXBlLCBtb2RlbCk7XG59O1xuXG4vLyBUaGUgc2V0IG9mIGF2YWlsYWJsZSBkYXRhIHR5cGVzIGluIHRoZSBTeXN0ZW0gbmFtZXNwYWNlXG5jb25zdCBhdmFpbGFibGVTeXN0ZW1UeXBlcyA9IG5ldyBTZXQoKTtcbi8vIElFMTEgcHJvYmFibHkgZG9lc24ndCBzdXBwb3J0IGBuZXcgU2V0KGl0ZXJhYmxlKWBcblsnQm9vbGVhbicsICdTdHJpbmcnLCAnSW50ZWdlcicsICdEZWNpbWFsJywgJ0RhdGUnLCAnRGF0ZVRpbWUnLCAnVGltZScsICdRdWFudGl0eSddLmZvckVhY2goaSA9PiBhdmFpbGFibGVTeXN0ZW1UeXBlcy5hZGQoaSkpO1xuXG4vKipcbiAqIE9iamVjdCBjbGFzcyBkZWZpbmluZyB0eXBlIGluZm9ybWF0aW9uLlxuICogVXNlZCBmb3IgbWluaW1hbCB0eXBlIHN1cHBvcnQuXG4gKiAoc2VlIGh0dHA6Ly9obDcub3JnL2ZoaXJwYXRoLyN0eXBlcy1hbmQtcmVmbGVjdGlvbilcbiAqL1xuY2xhc3MgVHlwZUluZm8ge1xuICBjb25zdHJ1Y3Rvcih7bmFtZSwgbmFtZXNwYWNlfSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIH1cblxuICAvLyBUaGUgXCJtb2RlbFwiIGRhdGEgb2JqZWN0IHNwZWNpZmljIHRvIGEgZG9tYWluLCBlLmcuIFI0LlxuICBzdGF0aWMgbW9kZWwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIGVxdWFsaXR5IHdpdGggYW5vdGhlciBUeXBlSW5mbyBvYmplY3QsIG9yIHRoYXQgYW5vdGhlciBUeXBlSW5mb1xuICAgKiBvYmplY3Qgc3BlY2lmaWVzIGEgc3VwZXJjbGFzcyBmb3IgdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IHRoaXMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1R5cGVJbmZvfSBvdGhlciAtIHRoZSBUeXBlSW5mbyBvYmplY3QgdG8gY29tcGFyZSB3aXRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgLSB0aGUgbW9kZWwgb2JqZWN0IHNwZWNpZmljIHRvIGEgZG9tYWluLCBlLmcuIFI0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXMob3RoZXIsIG1vZGVsKSB7XG4gICAgaWYgKFxuICAgICAgb3RoZXIgaW5zdGFuY2VvZiBUeXBlSW5mbyAmJlxuICAgICAgKCF0aGlzLm5hbWVzcGFjZSB8fCAhb3RoZXIubmFtZXNwYWNlIHx8IHRoaXMubmFtZXNwYWNlID09PSBvdGhlci5uYW1lc3BhY2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbW9kZWwgJiYgKCF0aGlzLm5hbWVzcGFjZSB8fCB0aGlzLm5hbWVzcGFjZSA9PT0gVHlwZUluZm8uRkhJUilcbiAgICAgICAgPyBUeXBlSW5mby5pc1R5cGUodGhpcy5uYW1lLCBvdGhlci5uYW1lLCBtb2RlbClcbiAgICAgICAgOiB0aGlzLm5hbWUgPT09IG90aGVyLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdHlwZSBpbmZvLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICh0aGlzLm5hbWVzcGFjZSA/IHRoaXMubmFtZXNwYWNlICsgJy4nIDogJycpICsgdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0eXBlIGluZm8gcmVwcmVzZW50cyBhIHZhbGlkIHR5cGUgaWRlbnRpZmllciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgLSB0aGUgbW9kZWwgb2JqZWN0IHNwZWNpZmljIHRvIGEgZG9tYWluLCBlLmcuIFI0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzVmFsaWQobW9kZWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlID09PSAnU3lzdGVtJykge1xuICAgICAgcmVzdWx0ID0gYXZhaWxhYmxlU3lzdGVtVHlwZXMuaGFzKHRoaXMubmFtZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5hbWVzcGFjZSA9PT0gJ0ZISVInKSB7XG4gICAgICByZXN1bHQgPSBtb2RlbC5hdmFpbGFibGVUeXBlcy5oYXModGhpcy5uYW1lKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgcmVzdWx0ID0gYXZhaWxhYmxlU3lzdGVtVHlwZXMuaGFzKHRoaXMubmFtZSlcbiAgICAgICAgfHwgbW9kZWwuYXZhaWxhYmxlVHlwZXMuaGFzKHRoaXMubmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIGEgbWFwIGZyb20gYSBkYXRhdHlwZSB0byBhIGRhdGF0eXBlIGNsYXNzIHdoaWNoIGhhcyBhIGNoZWNrU3RyaW5nIG1ldGhvZC5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgRlBfRGF0ZVRpbWUgfCBGUF9UaW1lPn1cbiAqL1xuVHlwZUluZm8udHlwZVRvQ2xhc3NXaXRoQ2hlY2tTdHJpbmcgPSB7XG4gIGRhdGU6IEZQX0RhdGUsXG4gIGRhdGVUaW1lOiBGUF9EYXRlVGltZSxcbiAgaW5zdGFudDogRlBfSW5zdGFudCxcbiAgdGltZTogRlBfVGltZVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHR5cGUgbmFtZSBvciBpdHMgcGFyZW50IHR5cGUgbmFtZSBpcyBlcXVhbCB0b1xuICogdGhlIGV4cGVjdGVkIHR5cGUgbmFtZS5cbiAqIEBwYXJhbSB0eXBlIC0gdHlwZSBuYW1lIHRvIGNoZWNrLlxuICogQHBhcmFtIHN1cGVyVHlwZSAtIGV4cGVjdGVkIHR5cGUgbmFtZS5cbiAqIEBwYXJhbSBtb2RlbCAtIHRoZSBtb2RlbCBvYmplY3Qgc3BlY2lmaWMgdG8gYSBkb21haW4sIGUuZy4gUjQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlSW5mby5pc1R5cGUgPSBmdW5jdGlvbih0eXBlLCBzdXBlclR5cGUsIG1vZGVsKSB7XG4gIGRvIHtcbiAgICBpZiAodHlwZSA9PT0gc3VwZXJUeXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKCh0eXBlID0gbW9kZWw/LnR5cGUyUGFyZW50W3R5cGVdKSk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIEF2YWlsYWJsZSBuYW1lc3BhY2VzOlxuVHlwZUluZm8uU3lzdGVtID0gJ1N5c3RlbSc7XG5UeXBlSW5mby5GSElSID0gJ0ZISVInO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IFR5cGVJbmZvIG9iamVjdCBmb3Igc3BlY2lmaWVkIHZhbHVlIGluIHRoZSBTeXN0ZW0gbmFtZXNwYWNlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7VHlwZUluZm99XG4gKi9cblR5cGVJbmZvLmNyZWF0ZUJ5VmFsdWVJblN5c3RlbU5hbWVzcGFjZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGxldCBuYW1lID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIG5hbWUgPSAnaW50ZWdlcic7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJudW1iZXJcIikge1xuICAgIG5hbWUgPSAnZGVjaW1hbCc7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGUF9EYXRlKSB7XG4gICAgbmFtZSA9ICdkYXRlJztcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZQX0RhdGVUaW1lKSB7XG4gICAgbmFtZSA9ICdkYXRlVGltZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGUF9UaW1lKSB7XG4gICAgbmFtZSA9ICd0aW1lJztcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZQX1F1YW50aXR5KSB7XG4gICAgbmFtZSA9ICdRdWFudGl0eSc7XG4gIH1cblxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eXFx3LywgYyA9PiBjLnRvVXBwZXJDYXNlKCkpO1xuXG4gIC8vIEN1cnJlbnRseSBjYW4gcmV0dXJuIG5hbWUgPSBcIk9iamVjdFwiIHdoaWNoIGlzIHByb2JhYmx5IHdyb25nLFxuICAvLyBidXQgdGhlIGlzVmFsaWQgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2hlY2sgdGhpcy5cbiAgcmV0dXJuIG5ldyBUeXBlSW5mbyh7bmFtZXNwYWNlOiBUeXBlSW5mby5TeXN0ZW0sIG5hbWV9KSA7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBUeXBlSW5mbyBieSB2YWx1ZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7VHlwZUluZm99XG4gKi9cblR5cGVJbmZvLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGVcbiAgICA/IHZhbHVlLmdldFR5cGVJbmZvKClcbiAgICA6IFR5cGVJbmZvLmNyZWF0ZUJ5VmFsdWVJblN5c3RlbU5hbWVzcGFjZSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFNldCBvZiBwcmltaXRpdmUgZGF0YSB0eXBlIG5hbWVzLlxuICovXG5jb25zdCBwcmltaXRpdmVzID0gbmV3IFNldCgpO1xuLy8gSUUxMSBwcm9iYWJseSBkb2Vzbid0IHN1cHBvcnQgYG5ldyBTZXQoaXRlcmFibGUpYFxuW1xuICBcImluc3RhbnRcIixcbiAgXCJ0aW1lXCIsXG4gIFwiZGF0ZVwiLFxuICBcImRhdGVUaW1lXCIsXG4gIFwiYmFzZTY0QmluYXJ5XCIsXG4gIFwiZGVjaW1hbFwiLFxuICBcImludGVnZXI2NFwiLFxuICBcImJvb2xlYW5cIixcbiAgXCJzdHJpbmdcIixcbiAgXCJjb2RlXCIsXG4gIFwibWFya2Rvd25cIixcbiAgXCJpZFwiLFxuICBcImludGVnZXJcIixcbiAgXCJ1bnNpZ25lZEludFwiLFxuICBcInBvc2l0aXZlSW50XCIsXG4gIFwidXJpXCIsXG4gIFwib2lkXCIsXG4gIFwidXVpZFwiLFxuICBcImNhbm9uaWNhbFwiLFxuICBcInVybFwiLFxuICBcIkludGVnZXJcIixcbiAgXCJEZWNpbWFsXCIsXG4gIFwiU3RyaW5nXCIsXG4gIFwiRGF0ZVwiLFxuICBcIkRhdGVUaW1lXCIsXG4gIFwiVGltZVwiXG5dLmZvckVhY2goaSA9PiBwcmltaXRpdmVzLmFkZChpKSk7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB0eXBlIGluZm9ybWF0aW9uIGNvbnRhaW5zIGEgcHJpbWl0aXZlIGRhdGEgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZUluZm99IHR5cGVJbmZvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlSW5mby5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uKHR5cGVJbmZvKSB7XG4gIHJldHVybiBwcmltaXRpdmVzLmhhcyh0eXBlSW5mby5uYW1lKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBvZiBhIHByaW1pdGl2ZSBkYXRhIHR5cGUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHByaW1pdGl2ZSBkYXRhIHR5cGUsXG4gKiAgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5cblR5cGVJbmZvLmlzUHJpbWl0aXZlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZXNvdXJjZU5vZGUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlcy5oYXModmFsdWUuZ2V0VHlwZUluZm8oKS5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW1wbGlmaWVkIGNoZWNrIGZvciBwcmltaXRpdmUgZGF0YSB0eXBlczpcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZQX1R5cGU7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzaWMgXCJ0eXBlKClcIiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICogKHNlZSBodHRwOi8vaGw3Lm9yZy9maGlycGF0aC8jcmVmbGVjdGlvbilcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGNvbGwgLSBpbnB1dCBjb2xsZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTwqPn1cbiAqL1xuZnVuY3Rpb24gdHlwZUZuKGNvbGwpIHtcbiAgcmV0dXJuIGNvbGwubWFwKHZhbHVlID0+IHtcbiAgICByZXR1cm4gVHlwZUluZm8uZnJvbVZhbHVlKHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgZnVuY3Rpb24gXCJpcyh0eXBlIDogdHlwZSBzcGVjaWZpZXIpXCIgYW5kIG9wZXJhdG9yIFwiaXNcIlxuICogKHNlZSBodHRwOi8vaGw3Lm9yZy9maGlycGF0aC8jaXMtdHlwZS1zcGVjaWZpZXIpXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBjb2xsIC0gaW5wdXQgY29sbGVjdGlvblxuICogQHBhcmFtIHtUeXBlSW5mb30gdHlwZUluZm9cbiAqIEByZXR1cm4ge2Jvb2xlYW58W119XG4gKi9cbmZ1bmN0aW9uIGlzRm4oY29sbCwgdHlwZUluZm8pIHtcbiAgaWYoY29sbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZihjb2xsLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzaW5nbGV0b24gb24gbGVmdCBzaWRlIG9mICdpcycsIGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KGNvbGwpKTtcbiAgfVxuXG4gIGNvbnN0IGN0eCA9IHRoaXM7XG5cbiAgcmV0dXJuIFR5cGVJbmZvLmZyb21WYWx1ZShjb2xsWzBdKS5pcyh0eXBlSW5mbywgY3R4Lm1vZGVsKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBmdW5jdGlvbiBcImFzKHR5cGUgOiB0eXBlIHNwZWNpZmllcilcIiBhbmQgb3BlcmF0b3IgXCJhc1wiXG4gKiAoc2VlIGh0dHA6Ly9obDcub3JnL2ZoaXJwYXRoLyNhcy10eXBlLXNwZWNpZmllcilcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGNvbGwgLSBpbnB1dCBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge1R5cGVJbmZvfSB0eXBlSW5mb1xuICogQHJldHVybiB7QXJyYXk8Kj59XG4gKi9cbmZ1bmN0aW9uIGFzRm4oY29sbCwgdHlwZUluZm8pIHtcbiAgaWYoY29sbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZihjb2xsLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzaW5nbGV0b24gb24gbGVmdCBzaWRlIG9mICdhcycsIGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KGNvbGwpKTtcbiAgfVxuXG4gIGNvbnN0IGN0eCA9IHRoaXM7XG4gIHJldHVybiBUeXBlSW5mby5mcm9tVmFsdWUoY29sbFswXSkuaXModHlwZUluZm8sIGN0eC5tb2RlbCkgPyBjb2xsIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGUF9UeXBlLFxuICBGUF9UaW1lQmFzZSxcbiAgRlBfRGF0ZSxcbiAgRlBfRGF0ZVRpbWUsXG4gIEZQX0luc3RhbnQsXG4gIEZQX1RpbWUsXG4gIEZQX1F1YW50aXR5LFxuICB0aW1lUkUsXG4gIGRhdGVUaW1lUkUsXG4gIGRhdGVSRSxcbiAgaW5zdGFudFJFLFxuICBSZXNvdXJjZU5vZGUsXG4gIFR5cGVJbmZvLFxuICB0eXBlRm4sXG4gIGlzRm4sXG4gIGFzRm5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js":
/*!************************************************************************************!*\
  !*** ../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file holds utility functions used in implementing the public functions.\n\nconst util =  {};\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/types.js\");\nconst {ResourceNode} = types;\n\n/**\n *  Reports and error to the calling environment and stops processing.\n * @param message the error message\n * @param fnName the name of the function raising the error (optional)\n */\nutil.raiseError = function(message, fnName) {\n  fnName = fnName ? fnName + \": \" : \"\";\n  throw fnName + message;\n};\n\n/**\n *  Throws an exception if the collection contains not one value.\n * @param collection the collection to be checked.\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n */\nutil.assertOnlyOne = function (collection, errorMsgPrefix) {\n  if (collection.length !== 1) {\n    util.raiseError(\"Was expecting only one element but got \" +\n      JSON.stringify(collection), errorMsgPrefix);\n  }\n};\n\n/**\n *  Throws an exception if the data is not one of the expected types.\n * @param data the value to be checked.  This may be a ResourceNode.\n * @param types an array of the permitted types\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n * @return the value that was checked.  If \"data\" was a ResourceNode, this will\n *  be the ReourceNode's data.\n */\nutil.assertType = function(data, types, errorMsgPrefix) {\n  let val = this.valData(data);\n  if (types.indexOf(typeof val) < 0) {\n    let typeList = types.length > 1 ? \"one of \"+types.join(\", \") : types[0];\n    util.raiseError(\"Found type '\"+(typeof data)+\"' but was expecting \" +\n      typeList, errorMsgPrefix);\n  }\n  return val;\n};\n\nutil.isEmpty = function(x){\n  return Array.isArray(x) && x.length === 0;\n};\n\nutil.isSome = function(x){\n  return x !== null && x !== undefined && !util.isEmpty(x);\n};\n\nutil.isTrue = function(x){\n  // We use util.valData because we can use a boolean node as a criterion\n  return x !== null && x !== undefined && (x === true || (x.length === 1 && util.valData(x[0]) === true));\n};\n\nutil.isCapitalized = function(x){\n  return x && (x[0] === x[0].toUpperCase());\n};\n\nutil.capitalize = function(x){\n  return x[0].toUpperCase() + x.substring(1);\n};\n\nutil.flatten = function(x){\n  if (x.some(i => i instanceof Promise)) {\n    return Promise.all(x).then(arr => flattenSync(arr));\n  }\n  return flattenSync(x);\n};\n\n/**\n * Creates a shallow copy of the source array and replaces those elements of the\n * source array that are arrays with their contents.\n * For example:\n * [1, [2, 3]] -> [1, 2, 3]\n * @param {Array} x - source array\n * @return {Array}\n */\nfunction flattenSync(x) {\n  return [].concat(...x);\n}\n\nutil.arraify = function(x){\n  if(Array.isArray(x)){ return x; }\n  if(util.isSome(x)){ return [x]; }\n  return [];\n};\n\n/**\n * If the input parameter is a promise, arraify the result of that promise,\n * otherwise arraify the input parameter.\n * @param {*|Promise<*>} x - input parameter\n * @return {*[]|Promise<*[]>}\n */\nutil.resolveAndArraify = function(x){\n  return x instanceof Promise\n    ? x.then(r => util.arraify(r))\n    : util.arraify(x);\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.\n */\nutil.valData = function(val) {\n  return (val instanceof ResourceNode) ? val.data : val;\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.  In the case of a\n *  ResourceNode that is a Quantity, the returned value will have been converted\n *  to an FP_Quantity.\n */\nutil.valDataConverted = function(val) {\n  if (val instanceof ResourceNode) {\n    val = val.convertData();\n  }\n  return val;\n};\n\n/**\n * Prepares a string for insertion into a regular expression\n * @param {string} str\n * @return {string}\n */\nutil.escapeStringForRegExp = function (str) {\n  return str.replace(/[-[\\]{}()*+?.,\\\\/^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * Binding to the Array.prototype.push.apply function to define a function to\n * push the contents of the source array to the destination array.\n * @name pushFn\n * @function\n * @param {Array} destArray - destination array\n * @param {Array} sourceArray - source array\n * @returns the new length property of destArray\n */\nutil.pushFn = Function.prototype.apply.bind(Array.prototype.push);\n\n/**\n * Creates child resource nodes for the specified resource node property.\n * @param {ResourceNode} parentResNode - resource node\n * @param {string} childProperty - name of property\n * @param {object} [model] - \"model\" data object\n * @return {ResourceNode[]}\n */\nutil.makeChildResNodes = function(parentResNode, childProperty, model) {\n  let childPath = parentResNode.path + '.' + childProperty;\n\n  if (model) {\n    let defPath = model.pathsDefinedElsewhere[childPath];\n    if (defPath)\n      childPath = defPath;\n  }\n  let toAdd, _toAdd;\n  let actualTypes = model && model.choiceTypePaths[childPath];\n  if (actualTypes) {\n    // Use actualTypes to find the field's value\n    for (let t of actualTypes) {\n      let field = childProperty + t;\n      toAdd = parentResNode.data?.[field];\n      _toAdd = parentResNode.data?.['_' + field];\n      if (toAdd !== undefined || _toAdd !== undefined) {\n        childPath += t;\n        break;\n      }\n    }\n  }\n  else {\n    toAdd = parentResNode.data?.[childProperty];\n    _toAdd = parentResNode.data?.['_' + childProperty];\n    if (toAdd === undefined && _toAdd === undefined) {\n      toAdd = parentResNode._data[childProperty];\n    }\n    if (childProperty === 'extension') {\n      childPath = 'Extension';\n    }\n  }\n\n  let fhirNodeDataType = null;\n  if (model) {\n    fhirNodeDataType = model.path2Type[childPath];\n    childPath = model.path2TypeWithoutElements[childPath] || childPath;\n  }\n\n  let result;\n  if (util.isSome(toAdd) || util.isSome(_toAdd)) {\n    if(Array.isArray(toAdd)) {\n      result = toAdd.map((x, i)=>\n        ResourceNode.makeResNode(x, parentResNode, childPath, _toAdd && _toAdd[i], fhirNodeDataType, model));\n      // Add items to the end of the ResourceNode list that have no value\n      // but have associated data, such as extensions or ids.\n      const _toAddLength = _toAdd?.length || 0;\n      for (let i = toAdd.length; i < _toAddLength; ++i) {\n        result.push(ResourceNode.makeResNode(null, parentResNode, childPath, _toAdd[i], fhirNodeDataType, model));\n      }\n    } else if (toAdd == null && Array.isArray(_toAdd)) {\n      // Add items to the end of the ResourceNode list when there are no\n      // values at all, but there is a list of associated data, such as\n      // extensions or ids.\n      result = _toAdd.map((x) => ResourceNode.makeResNode(null, parentResNode, childPath, x, fhirNodeDataType, model));\n    } else {\n      result = [ResourceNode.makeResNode(toAdd, parentResNode, childPath, _toAdd, fhirNodeDataType, model)];\n    }\n  } else {\n    result = [];\n  }\n  return result;\n};\n\n\n// Object for storing fetch promises.\nconst requestCache = {};\n// Duration of data storage in cache.\nconst requestCacheStorageTime = 3600000; // 1 hour = 60 * 60 * 1000\n\n\n/**\n * fetch() wrapper for caching server responses.\n * @param {string} url - a URL of the resource you want to fetch.\n * @param {object} [options] - optional object containing any custom settings\n *  that you want to apply to the request.\n * @return {Promise}\n */\nutil.fetchWithCache = function(url, options) {\n  const requestKey = [\n    url, options ? JSON.stringify(options) : ''\n  ].join('|');\n\n  const timestamp = Date.now();\n  for (const key in requestCache) {\n    if (timestamp - requestCache[key].timestamp > requestCacheStorageTime) {\n      // Remove responses older than an hour\n      delete requestCache[key];\n    }\n  }\n\n  if (!requestCache[requestKey]) {\n    requestCache[requestKey] = {\n      timestamp,\n      // In Jest unit tests, a promise returned by 'fetch' is not an instance of\n      // Promise that we have in our application context, so we use Promise.resolve\n      // to do the conversion.\n      promise: Promise.resolve(options ? fetch(url, options) : fetch(url))\n        .then(r => {\n          const contentType = r.headers.get('Content-Type');\n          const isJson = contentType.includes('application/json') ||\n            contentType.includes('application/fhir+json');\n          try {\n            if (isJson) {\n              return r.json().then((json) => r.ok ? json : Promise.reject(json));\n            } else {\n              return r.text().then((text) => Promise.reject(text));\n            }\n          } catch (e) {\n            return Promise.reject(new Error(e));\n          }\n        })\n    };\n  }\n\n  return requestCache[requestKey].promise;\n};\n\n\nmodule.exports = util;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZoaXJwYXRoQDMuMTguMC9ub2RlX21vZHVsZXMvZmhpcnBhdGgvc3JjL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrRkFBUztBQUMvQixPQUFPLGNBQWM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7O0FBR3pDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vZmhpcnBhdGhAMy4xOC4wL25vZGVfbW9kdWxlcy9maGlycGF0aC9zcmMvdXRpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBob2xkcyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGluIGltcGxlbWVudGluZyB0aGUgcHVibGljIGZ1bmN0aW9ucy5cblxuY29uc3QgdXRpbCA9ICB7fTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3Qge1Jlc291cmNlTm9kZX0gPSB0eXBlcztcblxuLyoqXG4gKiAgUmVwb3J0cyBhbmQgZXJyb3IgdG8gdGhlIGNhbGxpbmcgZW52aXJvbm1lbnQgYW5kIHN0b3BzIHByb2Nlc3NpbmcuXG4gKiBAcGFyYW0gbWVzc2FnZSB0aGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIGZuTmFtZSB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gcmFpc2luZyB0aGUgZXJyb3IgKG9wdGlvbmFsKVxuICovXG51dGlsLnJhaXNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBmbk5hbWUpIHtcbiAgZm5OYW1lID0gZm5OYW1lID8gZm5OYW1lICsgXCI6IFwiIDogXCJcIjtcbiAgdGhyb3cgZm5OYW1lICsgbWVzc2FnZTtcbn07XG5cbi8qKlxuICogIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGNvbGxlY3Rpb24gY29udGFpbnMgbm90IG9uZSB2YWx1ZS5cbiAqIEBwYXJhbSBjb2xsZWN0aW9uIHRoZSBjb2xsZWN0aW9uIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gZXJyb3JNc2dQcmVmaXggQW4gb3B0aW9uYWwgcHJlZml4IGZvciB0aGUgZXJyb3IgbWVzc2FnZSB0byBhc3Npc3QgaW5cbiAqICBkZWJ1Z2dpbmcuXG4gKi9cbnV0aWwuYXNzZXJ0T25seU9uZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBlcnJvck1zZ1ByZWZpeCkge1xuICBpZiAoY29sbGVjdGlvbi5sZW5ndGggIT09IDEpIHtcbiAgICB1dGlsLnJhaXNlRXJyb3IoXCJXYXMgZXhwZWN0aW5nIG9ubHkgb25lIGVsZW1lbnQgYnV0IGdvdCBcIiArXG4gICAgICBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKSwgZXJyb3JNc2dQcmVmaXgpO1xuICB9XG59O1xuXG4vKipcbiAqICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBkYXRhIGlzIG5vdCBvbmUgb2YgdGhlIGV4cGVjdGVkIHR5cGVzLlxuICogQHBhcmFtIGRhdGEgdGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuICBUaGlzIG1heSBiZSBhIFJlc291cmNlTm9kZS5cbiAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiB0aGUgcGVybWl0dGVkIHR5cGVzXG4gKiBAcGFyYW0gZXJyb3JNc2dQcmVmaXggQW4gb3B0aW9uYWwgcHJlZml4IGZvciB0aGUgZXJyb3IgbWVzc2FnZSB0byBhc3Npc3QgaW5cbiAqICBkZWJ1Z2dpbmcuXG4gKiBAcmV0dXJuIHRoZSB2YWx1ZSB0aGF0IHdhcyBjaGVja2VkLiAgSWYgXCJkYXRhXCIgd2FzIGEgUmVzb3VyY2VOb2RlLCB0aGlzIHdpbGxcbiAqICBiZSB0aGUgUmVvdXJjZU5vZGUncyBkYXRhLlxuICovXG51dGlsLmFzc2VydFR5cGUgPSBmdW5jdGlvbihkYXRhLCB0eXBlcywgZXJyb3JNc2dQcmVmaXgpIHtcbiAgbGV0IHZhbCA9IHRoaXMudmFsRGF0YShkYXRhKTtcbiAgaWYgKHR5cGVzLmluZGV4T2YodHlwZW9mIHZhbCkgPCAwKSB7XG4gICAgbGV0IHR5cGVMaXN0ID0gdHlwZXMubGVuZ3RoID4gMSA/IFwib25lIG9mIFwiK3R5cGVzLmpvaW4oXCIsIFwiKSA6IHR5cGVzWzBdO1xuICAgIHV0aWwucmFpc2VFcnJvcihcIkZvdW5kIHR5cGUgJ1wiKyh0eXBlb2YgZGF0YSkrXCInIGJ1dCB3YXMgZXhwZWN0aW5nIFwiICtcbiAgICAgIHR5cGVMaXN0LCBlcnJvck1zZ1ByZWZpeCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSAmJiB4Lmxlbmd0aCA9PT0gMDtcbn07XG5cbnV0aWwuaXNTb21lID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB4ICE9PSBudWxsICYmIHggIT09IHVuZGVmaW5lZCAmJiAhdXRpbC5pc0VtcHR5KHgpO1xufTtcblxudXRpbC5pc1RydWUgPSBmdW5jdGlvbih4KXtcbiAgLy8gV2UgdXNlIHV0aWwudmFsRGF0YSBiZWNhdXNlIHdlIGNhbiB1c2UgYSBib29sZWFuIG5vZGUgYXMgYSBjcml0ZXJpb25cbiAgcmV0dXJuIHggIT09IG51bGwgJiYgeCAhPT0gdW5kZWZpbmVkICYmICh4ID09PSB0cnVlIHx8ICh4Lmxlbmd0aCA9PT0gMSAmJiB1dGlsLnZhbERhdGEoeFswXSkgPT09IHRydWUpKTtcbn07XG5cbnV0aWwuaXNDYXBpdGFsaXplZCA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geCAmJiAoeFswXSA9PT0geFswXS50b1VwcGVyQ2FzZSgpKTtcbn07XG5cbnV0aWwuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geFswXS50b1VwcGVyQ2FzZSgpICsgeC5zdWJzdHJpbmcoMSk7XG59O1xuXG51dGlsLmZsYXR0ZW4gPSBmdW5jdGlvbih4KXtcbiAgaWYgKHguc29tZShpID0+IGkgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh4KS50aGVuKGFyciA9PiBmbGF0dGVuU3luYyhhcnIpKTtcbiAgfVxuICByZXR1cm4gZmxhdHRlblN5bmMoeCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHNvdXJjZSBhcnJheSBhbmQgcmVwbGFjZXMgdGhvc2UgZWxlbWVudHMgb2YgdGhlXG4gKiBzb3VyY2UgYXJyYXkgdGhhdCBhcmUgYXJyYXlzIHdpdGggdGhlaXIgY29udGVudHMuXG4gKiBGb3IgZXhhbXBsZTpcbiAqIFsxLCBbMiwgM11dIC0+IFsxLCAyLCAzXVxuICogQHBhcmFtIHtBcnJheX0geCAtIHNvdXJjZSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TeW5jKHgpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCguLi54KTtcbn1cblxudXRpbC5hcnJhaWZ5ID0gZnVuY3Rpb24oeCl7XG4gIGlmKEFycmF5LmlzQXJyYXkoeCkpeyByZXR1cm4geDsgfVxuICBpZih1dGlsLmlzU29tZSh4KSl7IHJldHVybiBbeF07IH1cbiAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgaW5wdXQgcGFyYW1ldGVyIGlzIGEgcHJvbWlzZSwgYXJyYWlmeSB0aGUgcmVzdWx0IG9mIHRoYXQgcHJvbWlzZSxcbiAqIG90aGVyd2lzZSBhcnJhaWZ5IHRoZSBpbnB1dCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0geyp8UHJvbWlzZTwqPn0geCAtIGlucHV0IHBhcmFtZXRlclxuICogQHJldHVybiB7KltdfFByb21pc2U8KltdPn1cbiAqL1xudXRpbC5yZXNvbHZlQW5kQXJyYWlmeSA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geCBpbnN0YW5jZW9mIFByb21pc2VcbiAgICA/IHgudGhlbihyID0+IHV0aWwuYXJyYWlmeShyKSlcbiAgICA6IHV0aWwuYXJyYWlmeSh4KTtcbn07XG5cbi8qKlxuICogIFJldHVybnMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGdpdmVuIHBhcmFtZXRlciwgd2hpY2ggbWlnaHQgYmUgYSBSZXNvdXJjZU5vZGUuXG4gKiAgT3RoZXJ3aXNlLCBpdCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gKi9cbnV0aWwudmFsRGF0YSA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gKHZhbCBpbnN0YW5jZW9mIFJlc291cmNlTm9kZSkgPyB2YWwuZGF0YSA6IHZhbDtcbn07XG5cbi8qKlxuICogIFJldHVybnMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGdpdmVuIHBhcmFtZXRlciwgd2hpY2ggbWlnaHQgYmUgYSBSZXNvdXJjZU5vZGUuXG4gKiAgT3RoZXJ3aXNlLCBpdCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uICBJbiB0aGUgY2FzZSBvZiBhXG4gKiAgUmVzb3VyY2VOb2RlIHRoYXQgaXMgYSBRdWFudGl0eSwgdGhlIHJldHVybmVkIHZhbHVlIHdpbGwgaGF2ZSBiZWVuIGNvbnZlcnRlZFxuICogIHRvIGFuIEZQX1F1YW50aXR5LlxuICovXG51dGlsLnZhbERhdGFDb252ZXJ0ZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlc291cmNlTm9kZSkge1xuICAgIHZhbCA9IHZhbC5jb252ZXJ0RGF0YSgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIFByZXBhcmVzIGEgc3RyaW5nIGZvciBpbnNlcnRpb24gaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG51dGlsLmVzY2FwZVN0cmluZ0ZvclJlZ0V4cCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcL14kfCNcXHNdL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICogQmluZGluZyB0byB0aGUgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZnVuY3Rpb24gdG9cbiAqIHB1c2ggdGhlIGNvbnRlbnRzIG9mIHRoZSBzb3VyY2UgYXJyYXkgdG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5LlxuICogQG5hbWUgcHVzaEZuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGRlc3RBcnJheSAtIGRlc3RpbmF0aW9uIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VBcnJheSAtIHNvdXJjZSBhcnJheVxuICogQHJldHVybnMgdGhlIG5ldyBsZW5ndGggcHJvcGVydHkgb2YgZGVzdEFycmF5XG4gKi9cbnV0aWwucHVzaEZuID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmJpbmQoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuXG4vKipcbiAqIENyZWF0ZXMgY2hpbGQgcmVzb3VyY2Ugbm9kZXMgZm9yIHRoZSBzcGVjaWZpZWQgcmVzb3VyY2Ugbm9kZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7UmVzb3VyY2VOb2RlfSBwYXJlbnRSZXNOb2RlIC0gcmVzb3VyY2Ugbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkUHJvcGVydHkgLSBuYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge29iamVjdH0gW21vZGVsXSAtIFwibW9kZWxcIiBkYXRhIG9iamVjdFxuICogQHJldHVybiB7UmVzb3VyY2VOb2RlW119XG4gKi9cbnV0aWwubWFrZUNoaWxkUmVzTm9kZXMgPSBmdW5jdGlvbihwYXJlbnRSZXNOb2RlLCBjaGlsZFByb3BlcnR5LCBtb2RlbCkge1xuICBsZXQgY2hpbGRQYXRoID0gcGFyZW50UmVzTm9kZS5wYXRoICsgJy4nICsgY2hpbGRQcm9wZXJ0eTtcblxuICBpZiAobW9kZWwpIHtcbiAgICBsZXQgZGVmUGF0aCA9IG1vZGVsLnBhdGhzRGVmaW5lZEVsc2V3aGVyZVtjaGlsZFBhdGhdO1xuICAgIGlmIChkZWZQYXRoKVxuICAgICAgY2hpbGRQYXRoID0gZGVmUGF0aDtcbiAgfVxuICBsZXQgdG9BZGQsIF90b0FkZDtcbiAgbGV0IGFjdHVhbFR5cGVzID0gbW9kZWwgJiYgbW9kZWwuY2hvaWNlVHlwZVBhdGhzW2NoaWxkUGF0aF07XG4gIGlmIChhY3R1YWxUeXBlcykge1xuICAgIC8vIFVzZSBhY3R1YWxUeXBlcyB0byBmaW5kIHRoZSBmaWVsZCdzIHZhbHVlXG4gICAgZm9yIChsZXQgdCBvZiBhY3R1YWxUeXBlcykge1xuICAgICAgbGV0IGZpZWxkID0gY2hpbGRQcm9wZXJ0eSArIHQ7XG4gICAgICB0b0FkZCA9IHBhcmVudFJlc05vZGUuZGF0YT8uW2ZpZWxkXTtcbiAgICAgIF90b0FkZCA9IHBhcmVudFJlc05vZGUuZGF0YT8uWydfJyArIGZpZWxkXTtcbiAgICAgIGlmICh0b0FkZCAhPT0gdW5kZWZpbmVkIHx8IF90b0FkZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoaWxkUGF0aCArPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdG9BZGQgPSBwYXJlbnRSZXNOb2RlLmRhdGE/LltjaGlsZFByb3BlcnR5XTtcbiAgICBfdG9BZGQgPSBwYXJlbnRSZXNOb2RlLmRhdGE/LlsnXycgKyBjaGlsZFByb3BlcnR5XTtcbiAgICBpZiAodG9BZGQgPT09IHVuZGVmaW5lZCAmJiBfdG9BZGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdG9BZGQgPSBwYXJlbnRSZXNOb2RlLl9kYXRhW2NoaWxkUHJvcGVydHldO1xuICAgIH1cbiAgICBpZiAoY2hpbGRQcm9wZXJ0eSA9PT0gJ2V4dGVuc2lvbicpIHtcbiAgICAgIGNoaWxkUGF0aCA9ICdFeHRlbnNpb24nO1xuICAgIH1cbiAgfVxuXG4gIGxldCBmaGlyTm9kZURhdGFUeXBlID0gbnVsbDtcbiAgaWYgKG1vZGVsKSB7XG4gICAgZmhpck5vZGVEYXRhVHlwZSA9IG1vZGVsLnBhdGgyVHlwZVtjaGlsZFBhdGhdO1xuICAgIGNoaWxkUGF0aCA9IG1vZGVsLnBhdGgyVHlwZVdpdGhvdXRFbGVtZW50c1tjaGlsZFBhdGhdIHx8IGNoaWxkUGF0aDtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG4gIGlmICh1dGlsLmlzU29tZSh0b0FkZCkgfHwgdXRpbC5pc1NvbWUoX3RvQWRkKSkge1xuICAgIGlmKEFycmF5LmlzQXJyYXkodG9BZGQpKSB7XG4gICAgICByZXN1bHQgPSB0b0FkZC5tYXAoKHgsIGkpPT5cbiAgICAgICAgUmVzb3VyY2VOb2RlLm1ha2VSZXNOb2RlKHgsIHBhcmVudFJlc05vZGUsIGNoaWxkUGF0aCwgX3RvQWRkICYmIF90b0FkZFtpXSwgZmhpck5vZGVEYXRhVHlwZSwgbW9kZWwpKTtcbiAgICAgIC8vIEFkZCBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBSZXNvdXJjZU5vZGUgbGlzdCB0aGF0IGhhdmUgbm8gdmFsdWVcbiAgICAgIC8vIGJ1dCBoYXZlIGFzc29jaWF0ZWQgZGF0YSwgc3VjaCBhcyBleHRlbnNpb25zIG9yIGlkcy5cbiAgICAgIGNvbnN0IF90b0FkZExlbmd0aCA9IF90b0FkZD8ubGVuZ3RoIHx8IDA7XG4gICAgICBmb3IgKGxldCBpID0gdG9BZGQubGVuZ3RoOyBpIDwgX3RvQWRkTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goUmVzb3VyY2VOb2RlLm1ha2VSZXNOb2RlKG51bGwsIHBhcmVudFJlc05vZGUsIGNoaWxkUGF0aCwgX3RvQWRkW2ldLCBmaGlyTm9kZURhdGFUeXBlLCBtb2RlbCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9BZGQgPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KF90b0FkZCkpIHtcbiAgICAgIC8vIEFkZCBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBSZXNvdXJjZU5vZGUgbGlzdCB3aGVuIHRoZXJlIGFyZSBub1xuICAgICAgLy8gdmFsdWVzIGF0IGFsbCwgYnV0IHRoZXJlIGlzIGEgbGlzdCBvZiBhc3NvY2lhdGVkIGRhdGEsIHN1Y2ggYXNcbiAgICAgIC8vIGV4dGVuc2lvbnMgb3IgaWRzLlxuICAgICAgcmVzdWx0ID0gX3RvQWRkLm1hcCgoeCkgPT4gUmVzb3VyY2VOb2RlLm1ha2VSZXNOb2RlKG51bGwsIHBhcmVudFJlc05vZGUsIGNoaWxkUGF0aCwgeCwgZmhpck5vZGVEYXRhVHlwZSwgbW9kZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gW1Jlc291cmNlTm9kZS5tYWtlUmVzTm9kZSh0b0FkZCwgcGFyZW50UmVzTm9kZSwgY2hpbGRQYXRoLCBfdG9BZGQsIGZoaXJOb2RlRGF0YVR5cGUsIG1vZGVsKV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IFtdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIE9iamVjdCBmb3Igc3RvcmluZyBmZXRjaCBwcm9taXNlcy5cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IHt9O1xuLy8gRHVyYXRpb24gb2YgZGF0YSBzdG9yYWdlIGluIGNhY2hlLlxuY29uc3QgcmVxdWVzdENhY2hlU3RvcmFnZVRpbWUgPSAzNjAwMDAwOyAvLyAxIGhvdXIgPSA2MCAqIDYwICogMTAwMFxuXG5cbi8qKlxuICogZmV0Y2goKSB3cmFwcGVyIGZvciBjYWNoaW5nIHNlcnZlciByZXNwb25zZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gYSBVUkwgb2YgdGhlIHJlc291cmNlIHlvdSB3YW50IHRvIGZldGNoLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIGFueSBjdXN0b20gc2V0dGluZ3NcbiAqICB0aGF0IHlvdSB3YW50IHRvIGFwcGx5IHRvIHRoZSByZXF1ZXN0LlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xudXRpbC5mZXRjaFdpdGhDYWNoZSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICBjb25zdCByZXF1ZXN0S2V5ID0gW1xuICAgIHVybCwgb3B0aW9ucyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpIDogJydcbiAgXS5qb2luKCd8Jyk7XG5cbiAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVxdWVzdENhY2hlKSB7XG4gICAgaWYgKHRpbWVzdGFtcCAtIHJlcXVlc3RDYWNoZVtrZXldLnRpbWVzdGFtcCA+IHJlcXVlc3RDYWNoZVN0b3JhZ2VUaW1lKSB7XG4gICAgICAvLyBSZW1vdmUgcmVzcG9uc2VzIG9sZGVyIHRoYW4gYW4gaG91clxuICAgICAgZGVsZXRlIHJlcXVlc3RDYWNoZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVxdWVzdENhY2hlW3JlcXVlc3RLZXldKSB7XG4gICAgcmVxdWVzdENhY2hlW3JlcXVlc3RLZXldID0ge1xuICAgICAgdGltZXN0YW1wLFxuICAgICAgLy8gSW4gSmVzdCB1bml0IHRlc3RzLCBhIHByb21pc2UgcmV0dXJuZWQgYnkgJ2ZldGNoJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgIC8vIFByb21pc2UgdGhhdCB3ZSBoYXZlIGluIG91ciBhcHBsaWNhdGlvbiBjb250ZXh0LCBzbyB3ZSB1c2UgUHJvbWlzZS5yZXNvbHZlXG4gICAgICAvLyB0byBkbyB0aGUgY29udmVyc2lvbi5cbiAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZShvcHRpb25zID8gZmV0Y2godXJsLCBvcHRpb25zKSA6IGZldGNoKHVybCkpXG4gICAgICAgIC50aGVuKHIgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gci5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgY29uc3QgaXNKc29uID0gY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fFxuICAgICAgICAgICAgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2ZoaXIranNvbicpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICAgIHJldHVybiByLmpzb24oKS50aGVuKChqc29uKSA9PiByLm9rID8ganNvbiA6IFByb21pc2UucmVqZWN0KGpzb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByLnRleHQoKS50aGVuKCh0ZXh0KSA9PiBQcm9taXNlLnJlamVjdCh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdENhY2hlW3JlcXVlc3RLZXldLnByb21pc2U7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fhirpath@3.18.0/node_modules/fhirpath/src/utilities.js\n");

/***/ })

};
;