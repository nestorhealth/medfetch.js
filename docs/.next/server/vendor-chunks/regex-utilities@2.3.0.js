"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regex-utilities@2.3.0";
exports.ids = ["vendor-chunks/regex-utilities@2.3.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* binding */ Context),\n/* harmony export */   execUnescaped: () => (/* binding */ execUnescaped),\n/* harmony export */   forEachUnescaped: () => (/* binding */ forEachUnescaped),\n/* harmony export */   getGroupContents: () => (/* binding */ getGroupContents),\n/* harmony export */   hasUnescaped: () => (/* binding */ hasUnescaped),\n/* harmony export */   replaceUnescaped: () => (/* binding */ replaceUnescaped)\n/* harmony export */ });\n// Constant properties for tracking regex syntax context\nconst Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// → '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// → '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// → '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nfunction replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nfunction forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nfunction execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nfunction hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nfunction getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4LXV0aWxpdGllc0AyLjMuMC9ub2RlX21vZHVsZXMvcmVnZXgtdXRpbGl0aWVzL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsQ0FBQyxhQUFhO0FBQ2QsUUFBUSwwQkFBMEI7QUFDbEMsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1osUUFBUSwwQkFBMEI7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsMEJBQTBCO0FBQ2xDLFVBQVU7QUFDVjtBQUNPO0FBQ1AseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLDBCQUEwQjtBQUNsQyxVQUFVLFNBQVM7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXgtdXRpbGl0aWVzQDIuMy4wL25vZGVfbW9kdWxlcy9yZWdleC11dGlsaXRpZXMvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnN0YW50IHByb3BlcnRpZXMgZm9yIHRyYWNraW5nIHJlZ2V4IHN5bnRheCBjb250ZXh0XG5leHBvcnQgY29uc3QgQ29udGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICBERUZBVUxUOiAnREVGQVVMVCcsXG4gIENIQVJfQ0xBU1M6ICdDSEFSX0NMQVNTJyxcbn0pO1xuXG4vKipcblJlcGxhY2VzIGFsbCB1bmVzY2FwZWQgaW5zdGFuY2VzIG9mIGEgcmVnZXggcGF0dGVybiBpbiB0aGUgZ2l2ZW4gY29udGV4dCwgdXNpbmcgYSByZXBsYWNlbWVudFxuc3RyaW5nIG9yIGNhbGxiYWNrLlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7c3RyaW5nIHwgKG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIGRldGFpbHM6IHtcbiAgY29udGV4dDogJ0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnO1xuICBuZWdhdGVkOiBib29sZWFuO1xufSkgPT4gc3RyaW5nfSByZXBsYWNlbWVudFxuQHBhcmFtIHsnREVGQVVMVCcgfCAnQ0hBUl9DTEFTUyd9IFtjb250ZXh0XSBBbGwgY29udGV4dHMgaWYgbm90IHNwZWNpZmllZFxuQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBleHByZXNzaW9uXG5AZXhhbXBsZVxuY29uc3Qgc3RyID0gJy5cXFxcLlxcXFxcXFxcLltbXFxcXC5dLl0uJztcbnJlcGxhY2VVbmVzY2FwZWQoc3RyLCAnXFxcXC4nLCAnQCcpO1xuLy8g4oaSICdAXFxcXC5cXFxcXFxcXEBbW1xcXFwuXUBdQCdcbnJlcGxhY2VVbmVzY2FwZWQoc3RyLCAnXFxcXC4nLCAnQCcsIENvbnRleHQuREVGQVVMVCk7XG4vLyDihpIgJ0BcXFxcLlxcXFxcXFxcQFtbXFxcXC5dLl1AJ1xucmVwbGFjZVVuZXNjYXBlZChzdHIsICdcXFxcLicsICdAJywgQ29udGV4dC5DSEFSX0NMQVNTKTtcbi8vIOKGkiAnLlxcXFwuXFxcXFxcXFwuW1tcXFxcLl1AXS4nXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCByZXBsYWNlbWVudCwgY29udGV4dCkge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2Ake25lZWRsZX18KD88JHNraXA+XFxbXFxeP3xcXFxcPy4pYCwgJ2dzdScpO1xuICBjb25zdCBuZWdhdGVkID0gW2ZhbHNlXTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBleHByZXNzaW9uLm1hdGNoQWxsKHJlKSkge1xuICAgIGNvbnN0IHswOiBtLCBncm91cHM6IHskc2tpcH19ID0gbWF0Y2g7XG4gICAgaWYgKCEkc2tpcCAmJiAoIWNvbnRleHQgfHwgKGNvbnRleHQgPT09IENvbnRleHQuREVGQVVMVCkgPT09ICFudW1DaGFyQ2xhc3Nlc09wZW4pKSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gcmVwbGFjZW1lbnQobWF0Y2gsIHtcbiAgICAgICAgICBjb250ZXh0OiBudW1DaGFyQ2xhc3Nlc09wZW4gPyBDb250ZXh0LkNIQVJfQ0xBU1MgOiBDb250ZXh0LkRFRkFVTFQsXG4gICAgICAgICAgbmVnYXRlZDogbmVnYXRlZFtuZWdhdGVkLmxlbmd0aCAtIDFdLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSByZXBsYWNlbWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobVswXSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICAgIG5lZ2F0ZWQucHVzaChtWzFdID09PSAnXicpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ10nICYmIG51bUNoYXJDbGFzc2VzT3Blbikge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgICBuZWdhdGVkLnBvcCgpO1xuICAgIH1cbiAgICByZXN1bHQgKz0gbTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblJ1bnMgYSBjYWxsYmFjayBmb3IgZWFjaCB1bmVzY2FwZWQgaW5zdGFuY2Ugb2YgYSByZWdleCBwYXR0ZXJuIGluIHRoZSBnaXZlbiBjb250ZXh0LlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7KG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIGRldGFpbHM6IHtcbiAgY29udGV4dDogJ0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnO1xuICBuZWdhdGVkOiBib29sZWFuO1xufSkgPT4gdm9pZH0gY2FsbGJhY2tcbkBwYXJhbSB7J0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnfSBbY29udGV4dF0gQWxsIGNvbnRleHRzIGlmIG5vdCBzcGVjaWZpZWRcbiovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFVuZXNjYXBlZChleHByZXNzaW9uLCBuZWVkbGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5XG4gIHJlcGxhY2VVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCBjYWxsYmFjaywgY29udGV4dCk7XG59XG5cbi8qKlxuUmV0dXJucyBhIG1hdGNoIG9iamVjdCBmb3IgdGhlIGZpcnN0IHVuZXNjYXBlZCBpbnN0YW5jZSBvZiBhIHJlZ2V4IHBhdHRlcm4gaW4gdGhlIGdpdmVuIGNvbnRleHQsIG9yXG5gbnVsbGAuXG5cbkRvZXNuJ3Qgc2tpcCBvdmVyIGNvbXBsZXRlIG11bHRpY2hhcmFjdGVyIHRva2VucyAob25seSBgXFxgIHBsdXMgaXRzIGZvbG93aW5nIGNoYXIpIHNvIG11c3QgYmUgdXNlZFxud2l0aCBrbm93bGVkZ2Ugb2Ygd2hhdCdzIHNhZmUgdG8gZG8gZ2l2ZW4gcmVnZXggc3ludGF4LiBBc3N1bWVzIFVuaWNvZGVTZXRzLW1vZGUgc3ludGF4LlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU2VhcmNoIHRhcmdldFxuQHBhcmFtIHtzdHJpbmd9IG5lZWRsZSBTZWFyY2ggYXMgYSByZWdleCBwYXR0ZXJuLCB3aXRoIGZsYWdzIGBzdWAgYXBwbGllZFxuQHBhcmFtIHtudW1iZXJ9IFtwb3NdIE9mZnNldCB0byBzdGFydCB0aGUgc2VhcmNoXG5AcGFyYW0geydERUZBVUxUJyB8ICdDSEFSX0NMQVNTJ30gW2NvbnRleHRdIEFsbCBjb250ZXh0cyBpZiBub3Qgc3BlY2lmaWVkXG5AcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZXhlY1VuZXNjYXBlZChleHByZXNzaW9uLCBuZWVkbGUsIHBvcyA9IDAsIGNvbnRleHQpIHtcbiAgLy8gUXVpY2sgcGFydGlhbCB0ZXN0OyBhdm9pZCB0aGUgbG9vcCBpZiBub3QgbmVlZGVkXG4gIGlmICghKG5ldyBSZWdFeHAobmVlZGxlLCAnc3UnKS50ZXN0KGV4cHJlc3Npb24pKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgJHtuZWVkbGV9fCg/PCRza2lwPlxcXFxcXFxcPy4pYCwgJ2dzdScpO1xuICByZS5sYXN0SW5kZXggPSBwb3M7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZXhwcmVzc2lvbikpIHtcbiAgICBjb25zdCB7MDogbSwgZ3JvdXBzOiB7JHNraXB9fSA9IG1hdGNoO1xuICAgIGlmICghJHNraXAgJiYgKCFjb250ZXh0IHx8IChjb250ZXh0ID09PSBDb250ZXh0LkRFRkFVTFQpID09PSAhbnVtQ2hhckNsYXNzZXNPcGVuKSkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKG0gPT09ICddJyAmJiBudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgICAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIG9uIHplcm8tbGVuZ3RoIG1hdGNoZXNcbiAgICBpZiAocmUubGFzdEluZGV4ID09IG1hdGNoLmluZGV4KSB7XG4gICAgICByZS5sYXN0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuQ2hlY2tzIHdoZXRoZXIgYW4gdW5lc2NhcGVkIGluc3RhbmNlIG9mIGEgcmVnZXggcGF0dGVybiBhcHBlYXJzIGluIHRoZSBnaXZlbiBjb250ZXh0LlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7J0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnfSBbY29udGV4dF0gQWxsIGNvbnRleHRzIGlmIG5vdCBzcGVjaWZpZWRcbkByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXR0ZXJuIHdhcyBmb3VuZFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCBjb250ZXh0KSB7XG4gIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5XG4gIHJldHVybiAhIWV4ZWNVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCAwLCBjb250ZXh0KTtcbn1cblxuLyoqXG5FeHRyYWN0cyB0aGUgZnVsbCBjb250ZW50cyBvZiBhIGdyb3VwIChzdWJwYXR0ZXJuKSBmcm9tIHRoZSBnaXZlbiBleHByZXNzaW9uLCBhY2NvdW50aW5nIGZvclxuZXNjYXBlZCBjaGFyYWN0ZXJzLCBuZXN0ZWQgZ3JvdXBzLCBhbmQgY2hhcmFjdGVyIGNsYXNzZXMuIFRoZSBncm91cCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBwb3NpdGlvblxud2hlcmUgaXRzIGNvbnRlbnRzIHN0YXJ0ICh0aGUgc3RyaW5nIGluZGV4IGp1c3QgYWZ0ZXIgdGhlIGdyb3VwJ3Mgb3BlbmluZyBkZWxpbWl0ZXIpLiBSZXR1cm5zIHRoZVxucmVzdCBvZiB0aGUgc3RyaW5nIGlmIHRoZSBncm91cCBpcyB1bmNsb3NlZC5cblxuQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7bnVtYmVyfSBjb250ZW50c1N0YXJ0UG9zXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cENvbnRlbnRzKGV4cHJlc3Npb24sIGNvbnRlbnRzU3RhcnRQb3MpIHtcbiAgY29uc3QgdG9rZW4gPSAvXFxcXD8uL2dzdTtcbiAgdG9rZW4ubGFzdEluZGV4ID0gY29udGVudHNTdGFydFBvcztcbiAgbGV0IGNvbnRlbnRzRW5kUG9zID0gZXhwcmVzc2lvbi5sZW5ndGg7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICAvLyBTdGFydGluZyBzZWFyY2ggd2l0aGluIGFuIG9wZW4gZ3JvdXAsIGFmdGVyIHRoZSBncm91cCdzIG9wZW5pbmdcbiAgbGV0IG51bUdyb3Vwc09wZW4gPSAxO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHRva2VuLmV4ZWMoZXhwcmVzc2lvbikpIHtcbiAgICBjb25zdCBbbV0gPSBtYXRjaDtcbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIGlmIChtID09PSAnKCcpIHtcbiAgICAgICAgbnVtR3JvdXBzT3BlbisrO1xuICAgICAgfSBlbHNlIGlmIChtID09PSAnKScpIHtcbiAgICAgICAgbnVtR3JvdXBzT3Blbi0tO1xuICAgICAgICBpZiAoIW51bUdyb3Vwc09wZW4pIHtcbiAgICAgICAgICBjb250ZW50c0VuZFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtID09PSAnXScpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcmVzc2lvbi5zbGljZShjb250ZW50c1N0YXJ0UG9zLCBjb250ZW50c0VuZFBvcyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\n");

/***/ })

};
;