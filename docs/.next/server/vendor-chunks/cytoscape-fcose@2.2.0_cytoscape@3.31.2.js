/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-fcose@2.2.0_cytoscape@3.31.2";
exports.ids = ["vendor-chunks/cytoscape-fcose@2.2.0_cytoscape@3.31.2"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.31.2/node_modules/cytoscape-fcose/cytoscape-fcose.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.31.2/node_modules/cytoscape-fcose/cytoscape-fcose.js ***!
  \********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1129__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __nested_webpack_require_1129__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10973__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __nested_webpack_require_10973__(548);\nvar CoSELayout = __nested_webpack_require_10973__(140).CoSELayout;\nvar CoSENode = __nested_webpack_require_10973__(140).CoSENode;\nvar PointD = __nested_webpack_require_10973__(140).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_10973__(140).layoutBase.DimensionD;\nvar LayoutConstants = __nested_webpack_require_10973__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_10973__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_10973__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_22455__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __nested_webpack_require_22455__(658);\nvar aux = __nested_webpack_require_22455__(548);\n\nvar _require = __nested_webpack_require_22455__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __nested_webpack_require_22455__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41986__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __nested_webpack_require_41986__(548);\nvar Matrix = __nested_webpack_require_41986__(140).layoutBase.Matrix;\nvar SVD = __nested_webpack_require_41986__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_55337__) => {\n\n\n\nvar impl = __nested_webpack_require_55337__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_56127__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_56127__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_56127__(579);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2N5dG9zY2FwZS1mY29zZUAyLjIuMF9jeXRvc2NhcGVAMy4zMS4yL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxrR0FBVztBQUM5QyxNQUFNLEVBSytDO0FBQ3JELENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0QsbUNBQW1DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFcnBCO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsK0JBQW1COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0NBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBbUIsR0FBRyxnQ0FBbUI7QUFDdkQ7QUFDQSxpQkFBaUIsMEJBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL2N5dG9zY2FwZS1mY29zZUAyLjIuMF9jeXRvc2NhcGVAMy4zMS4yL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJjb3NlLWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUZjb3NlXCJdID0gZmFjdG9yeShyb290W1wiY29zZUJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTQwX18pIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDY1ODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG4vLyBTaW1wbGUsIGludGVybmFsIE9iamVjdC5hc3NpZ24oKSBwb2x5ZmlsbCBmb3Igb3B0aW9ucyBvYmplY3RzIGV0Yy5cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KSA6IGZ1bmN0aW9uICh0Z3QpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNyY3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3Jjc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzcmNzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHRndFtrXSA9IHNyY1trXTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRndDtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbi8qXG4gKiBBdXhpbGlhcnkgZnVuY3Rpb25zXG4gKi9cblxudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MaW5rZWRMaXN0O1xuXG52YXIgYXV4aWxpYXJ5ID0ge307XG5cbi8vIGdldCB0aGUgdG9wIG1vc3Qgbm9kZXNcbmF1eGlsaWFyeS5nZXRUb3BNb3N0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIG5vZGVzTWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2Rlc01hcFtub2Rlc1tpXS5pZCgpXSA9IHRydWU7XG4gIH1cbiAgdmFyIHJvb3RzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKVswXTtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChub2Rlc01hcFtwYXJlbnQuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvb3RzO1xufTtcblxuLy8gZmluZCBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyBhbmQgY3JlYXRlIGR1bW15IG5vZGVzIHRoYXQgY29ubmVjdCB0aGVtXG5hdXhpbGlhcnkuY29ubmVjdENvbXBvbmVudHMgPSBmdW5jdGlvbiAoY3ksIGVsZXMsIHRvcE1vc3ROb2RlcywgZHVtbXlOb2Rlcykge1xuICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHZpc2l0ZWRUb3BNb3N0Tm9kZXMgPSBbXTtcbiAgdmFyIGN1cnJlbnROZWlnaGJvciA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZU5vZGUgPSB2b2lkIDA7XG4gIHZhciBtaW5EZWdyZWUgPSB2b2lkIDA7XG5cbiAgdmFyIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHZhciBjb3VudCA9IDE7XG4gIHZhciBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkgPSBbXTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgY21wdCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG5cbiAgICB2YXIgY3VycmVudE5vZGUgPSB0b3BNb3N0Tm9kZXNbMF07XG4gICAgdmFyIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUubWVyZ2UoY3VycmVudE5vZGUpLm1lcmdlKGN1cnJlbnROb2RlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKTtcbiAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgY2hpbGRyZW5PZkN1cnJlbnROb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgICAgdmFyIG5laWdoYm9yTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjdXJyZW50Tm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGN1cnJlbnROb2RlLmVkZ2VzV2l0aChub2RlKSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5laWdoYm9yTm9kZXMubWVyZ2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgIGN1cnJlbnROZWlnaGJvciA9IHRvcE1vc3ROb2Rlcy5pbnRlcnNlY3Rpb24obmVpZ2hib3JOb2RlLnVuaW9uKG5laWdoYm9yTm9kZS5hbmNlc3RvcnMoKSkpO1xuICAgICAgICBpZiAoY3VycmVudE5laWdoYm9yICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvclswXSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5PZk5laWdoYm9yID0gY3VycmVudE5laWdoYm9yLnVuaW9uKGN1cnJlbnROZWlnaGJvci5kZXNjZW5kYW50cygpKTtcblxuICAgICAgICAgIGNoaWxkcmVuT2ZOZWlnaGJvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICAgICAgICBjbXB0Lm1lcmdlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHRvcE1vc3ROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggIT0gMCkge1xuICAgICAgX2xvb3AyKCk7XG4gICAgfVxuXG4gICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBlbGVzLmludGVyc2VjdGlvbihub2RlLmNvbm5lY3RlZEVkZ2VzKCkpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICBpZiAoY21wdC5oYXMoZS5zb3VyY2UoKSkgJiYgY21wdC5oYXMoZS50YXJnZXQoKSkpIHtcbiAgICAgICAgICAvLyBoYXMoKSBpcyBjaGVhcFxuICAgICAgICAgIGNtcHQubWVyZ2UoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHZpc2l0ZWRUb3BNb3N0Tm9kZXMubGVuZ3RoID09IHRvcE1vc3ROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29ubmVjdGVkIHx8IGlzQ29ubmVjdGVkICYmIGNvdW50ID4gMSkge1xuICAgICAgbWluRGVncmVlTm9kZSA9IHZpc2l0ZWRUb3BNb3N0Tm9kZXNbMF07XG4gICAgICBtaW5EZWdyZWUgPSBtaW5EZWdyZWVOb2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluRGVncmVlKSB7XG4gICAgICAgICAgbWluRGVncmVlID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aDtcbiAgICAgICAgICBtaW5EZWdyZWVOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkucHVzaChtaW5EZWdyZWVOb2RlLmlkKCkpO1xuICAgICAgLy8gVE8gRE86IENoZWNrIGVmZmljaWVuY3kgb2YgdGhpcyBwYXJ0XG4gICAgICB2YXIgdGVtcCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHRlbXAubWVyZ2UodmlzaXRlZFRvcE1vc3ROb2Rlc1swXSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGVtcC5tZXJnZShub2RlKTtcbiAgICAgIH0pO1xuICAgICAgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICAgICAgdG9wTW9zdE5vZGVzID0gdG9wTW9zdE5vZGVzLmRpZmZlcmVuY2UodGVtcCk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfTtcblxuICBkbyB7XG4gICAgX2xvb3AoKTtcbiAgfSB3aGlsZSAoIWlzQ29ubmVjdGVkKTtcblxuICBpZiAoZHVtbXlOb2Rlcykge1xuICAgIGlmIChub2Rlc0Nvbm5lY3RlZFRvRHVtbXkubGVuZ3RoID4gMCkge1xuICAgICAgZHVtbXlOb2Rlcy5zZXQoJ2R1bW15JyArIChkdW1teU5vZGVzLnNpemUgKyAxKSwgbm9kZXNDb25uZWN0ZWRUb0R1bW15KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG4vLyByZWxvY2F0ZXMgY29tcG9uZW50UmVzdWx0IHRvIG9yaWdpbmFsQ2VudGVyIGlmIHRoZXJlIGlzIG5vIGZpeGVkTm9kZUNvbnN0cmFpbnRcbmF1eGlsaWFyeS5yZWxvY2F0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvcmlnaW5hbENlbnRlciwgY29tcG9uZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgdmFyIG1pblhDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WENvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHZhciBtaW5ZQ29vcmQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heFlDb29yZCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY29tcG9uZW50UmVzdWx0Lm5vZGVJbmRleGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICAgICAgICAgIHZhciBrZXkgPSBfcmVmMlswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgICAgIHZhciBjeU5vZGUgPSBvcHRpb25zLmN5LmdldEVsZW1lbnRCeUlkKGtleSk7XG4gICAgICAgICAgaWYgKGN5Tm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVCQiA9IGN5Tm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdmFyIGxlZnRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdIC0gbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WCA9IGNvbXBvbmVudFJlc3VsdC54Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi53IC8gMjtcbiAgICAgICAgICAgIHZhciB0b3BZID0gY29tcG9uZW50UmVzdWx0LnlDb29yZHNbdmFsdWVdIC0gbm9kZUJCLmggLyAyO1xuICAgICAgICAgICAgdmFyIGJvdHRvbVkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gKyBub2RlQkIuaCAvIDI7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgICAgICBpZiAocmlnaHRYID4gbWF4WENvb3JkKSBtYXhYQ29vcmQgPSByaWdodFg7XG4gICAgICAgICAgICBpZiAodG9wWSA8IG1pbllDb29yZCkgbWluWUNvb3JkID0gdG9wWTtcbiAgICAgICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgZGlmZk9uWSA9IG9yaWdpbmFsQ2VudGVyLnkgLSAobWF4WUNvb3JkICsgbWluWUNvb3JkKSAvIDI7XG4gICAgICAvLyBtb3ZlIGNvbXBvbmVudCB0byBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIGNvbXBvbmVudFJlc3VsdC54Q29vcmRzID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ICsgZGlmZk9uWDtcbiAgICAgIH0pO1xuICAgICAgY29tcG9uZW50UmVzdWx0LnlDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkcy5tYXAoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgKyBkaWZmT25ZO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBjdXJyZW50IGJvdW5kaW5nIGJveFxuICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50UmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9uZW50UmVzdWx0W2l0ZW1dO1xuICAgICAgICB2YXIgbGVmdFggPSBub2RlLmdldFJlY3QoKS54O1xuICAgICAgICB2YXIgcmlnaHRYID0gbm9kZS5nZXRSZWN0KCkueCArIG5vZGUuZ2V0UmVjdCgpLndpZHRoO1xuICAgICAgICB2YXIgdG9wWSA9IG5vZGUuZ2V0UmVjdCgpLnk7XG4gICAgICAgIHZhciBib3R0b21ZID0gbm9kZS5nZXRSZWN0KCkueSArIG5vZGUuZ2V0UmVjdCgpLmhlaWdodDtcblxuICAgICAgICBpZiAobGVmdFggPCBtaW5YQ29vcmQpIG1pblhDb29yZCA9IGxlZnRYO1xuICAgICAgICBpZiAocmlnaHRYID4gbWF4WENvb3JkKSBtYXhYQ29vcmQgPSByaWdodFg7XG4gICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICBpZiAoYm90dG9tWSA+IG1heFlDb29yZCkgbWF4WUNvb3JkID0gYm90dG9tWTtcbiAgICAgIH0pO1xuICAgICAgLy8gZmluZCBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgb3JpZ2luYWwgY2VudGVyXG4gICAgICB2YXIgX2RpZmZPblggPSBvcmlnaW5hbENlbnRlci54IC0gKG1heFhDb29yZCArIG1pblhDb29yZCkgLyAyO1xuICAgICAgdmFyIF9kaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50UmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9uZW50UmVzdWx0W2l0ZW1dO1xuICAgICAgICBub2RlLnNldENlbnRlcihub2RlLmdldENlbnRlclgoKSArIF9kaWZmT25YLCBub2RlLmdldENlbnRlclkoKSArIF9kaWZmT25ZKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuYXV4aWxpYXJ5LmNhbGNCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcykge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciByaWdodCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgdG9wID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciBib3R0b20gPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgdmFyIG5vZGVMZWZ0ID0gdm9pZCAwO1xuICB2YXIgbm9kZVJpZ2h0ID0gdm9pZCAwO1xuICB2YXIgbm9kZVRvcCA9IHZvaWQgMDtcbiAgdmFyIG5vZGVCb3R0b20gPSB2b2lkIDA7XG5cbiAgdmFyIG5vZGVzID0gcGFyZW50Tm9kZS5kZXNjZW5kYW50cygpLm5vdChcIjpwYXJlbnRcIik7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBub2RlTGVmdCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldIC0gbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlUmlnaHQgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlLmlkKCkpXSArIG5vZGUud2lkdGgoKSAvIDI7XG4gICAgbm9kZVRvcCA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldIC0gbm9kZS5oZWlnaHQoKSAvIDI7XG4gICAgbm9kZUJvdHRvbSA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS5oZWlnaHQoKSAvIDI7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdCb3ggPSB7fTtcbiAgYm91bmRpbmdCb3gudG9wTGVmdFggPSBsZWZ0O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WSA9IHRvcDtcbiAgYm91bmRpbmdCb3gud2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGJvdW5kaW5nQm94LmhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgcmV0dXJuIGJvdW5kaW5nQm94O1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBmaW5kcyBhbmQgcmV0dXJucyBwYXJlbnQgbm9kZXMgd2hvc2UgYWxsIGNoaWxkcmVuIGFyZSBoaWRkZW5cbmF1eGlsaWFyeS5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjeSwgZWxlcykge1xuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgZWxlcy5ub2RlcygnOnBhcmVudCcpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIHZhciBjaGVjayA9IGZhbHNlO1xuICAgIHBhcmVudC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuY3NzKCdkaXNwbGF5JykgIT0gJ25vbmUnKSB7XG4gICAgICAgIGNoZWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICBwYXJlbnRzV2l0aG91dENoaWxkcmVuLm1lcmdlKHBhcmVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyZW50c1dpdGhvdXRDaGlsZHJlbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXV4aWxpYXJ5O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcG9zdHByb2Nlc3NpbmcgcGFydCB0aGF0IGFwcGxpZXMgQ29TRSBsYXlvdXQgb3ZlciB0aGUgc3BlY3RyYWwgbGF5b3V0XG4qL1xuXG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xudmFyIENvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkuQ29TRUxheW91dDtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTm9kZTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkRpbWVuc2lvbkQ7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFQ29uc3RhbnRzO1xuXG4vLyBtYWluIGZ1bmN0aW9uIHRoYXQgY29zZSBsYXlvdXQgaXMgcHJvY2Vzc2VkXG52YXIgY29zZUxheW91dCA9IGZ1bmN0aW9uIGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHQpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG5cbiAgdmFyIG5vZGVJbmRleGVzID0gdm9pZCAwO1xuICB2YXIgeENvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIHlDb29yZHMgPSB2b2lkIDA7XG4gIHZhciBpZFRvTE5vZGUgPSB7fTtcblxuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICBub2RlSW5kZXhlcyA9IHNwZWN0cmFsUmVzdWx0W1wibm9kZUluZGV4ZXNcIl07XG4gICAgeENvb3JkcyA9IHNwZWN0cmFsUmVzdWx0W1wieENvb3Jkc1wiXTtcbiAgICB5Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ5Q29vcmRzXCJdO1xuICB9XG5cbiAgdmFyIGlzRm4gPSBmdW5jdGlvbiBpc0ZuKGZuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICB2YXIgb3B0Rm4gPSBmdW5jdGlvbiBvcHRGbihvcHQsIGVsZSkge1xuICAgIGlmIChpc0ZuKG9wdCkpIHtcbiAgICAgIHJldHVybiBvcHQoZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqKiogUG9zdHByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgdmFyIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBhdXguY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4oY3ksIGVsZXMpO1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBub2RlcyB0byBjb3NlIG5vZGVzXG4gIHZhciBwcm9jZXNzQ2hpbGRyZW5MaXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuTGlzdChwYXJlbnQsIGNoaWxkcmVuLCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2l6ZSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIHRoZUNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSBudWxsO1xuICAgICAgaWYgKHRoZUNoaWxkLmludGVyc2VjdGlvbihwYXJlbnRzV2l0aG91dENoaWxkcmVuKS5sZW5ndGggPT0gMCkge1xuICAgICAgICBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IHRoZUNoaWxkLmNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgICB2YXIgdGhlTm9kZSA9IHZvaWQgMDtcblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGVDaGlsZC5sYXlvdXREaW1lbnNpb25zKHtcbiAgICAgICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGVDaGlsZC5vdXRlcldpZHRoKCkgIT0gbnVsbCAmJiB0aGVDaGlsZC5vdXRlckhlaWdodCgpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICAgICAgaWYgKCF0aGVDaGlsZC5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh4Q29vcmRzW25vZGVJbmRleGVzLmdldCh0aGVDaGlsZC5pZCgpKV0gLSBkaW1lbnNpb25zLncgLyAyLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldCh0aGVDaGlsZC5pZCgpKV0gLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveCh0aGVDaGlsZCwgeENvb3JkcywgeUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgaWYgKHRoZUNoaWxkLmludGVyc2VjdGlvbihwYXJlbnRzV2l0aG91dENoaWxkcmVuKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyZW50SW5mby53aWR0aCwgcGFyZW50SW5mby5oZWlnaHQpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIHBhcmVudHNXaXRob3V0Q2hpbGRyZW5cbiAgICAgICAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQocGFyZW50SW5mby50b3BMZWZ0WCwgcGFyZW50SW5mby50b3BMZWZ0WSksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh0aGVDaGlsZC5wb3NpdGlvbigneCcpIC0gZGltZW5zaW9ucy53IC8gMiwgdGhlQ2hpbGQucG9zaXRpb24oJ3knKSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyKSk7XG4gICAgICB9XG4gICAgICAvLyBBdHRhY2ggaWQgdG8gdGhlIGxheW91dCBub2RlIGFuZCByZXB1bHNpb24gdmFsdWVcbiAgICAgIHRoZU5vZGUuaWQgPSB0aGVDaGlsZC5kYXRhKFwiaWRcIik7XG4gICAgICB0aGVOb2RlLm5vZGVSZXB1bHNpb24gPSBvcHRGbihvcHRpb25zLm5vZGVSZXB1bHNpb24sIHRoZUNoaWxkKTtcbiAgICAgIC8vIEF0dGFjaCB0aGUgcGFkZGluZ3Mgb2YgY3kgbm9kZSB0byBsYXlvdXQgbm9kZVxuICAgICAgdGhlTm9kZS5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICAgIHRoZU5vZGUucGFkZGluZ1RvcCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICAgIHRoZU5vZGUucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuXG4gICAgICAvL0F0dGFjaCB0aGUgbGFiZWwgcHJvcGVydGllcyB0byBib3RoIGNvbXBvdW5kIGFuZCBzaW1wbGUgbm9kZXMgaWYgbGFiZWxzIHdpbGwgYmUgaW5jbHVkZWQgaW4gbm9kZSBkaW1lbnNpb25zXG4gICAgICAvL1RoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIHdoaWxlIHVwZGF0aW5nIGJvdW5kcyBvZiBjb21wb3VuZHMgZHVyaW5nIGl0ZXJhdGlvbnMgb3IgdGlsaW5nXG4gICAgICAvL2FuZCB3aWxsIGJlIHVzZWQgZm9yIHNpbXBsZSBub2RlcyB3aGlsZSB0cmFuc2ZlcnJpbmcgZmluYWwgcG9zaXRpb25zIHRvIGN5dG9zY2FwZVxuICAgICAgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgIHRoZU5vZGUubGFiZWxXaWR0aCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSwgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSB9KS53O1xuICAgICAgICB0aGVOb2RlLmxhYmVsSGVpZ2h0ID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLmg7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9IHRoZUNoaWxkLmNzcyhcInRleHQtdmFsaWduXCIpO1xuICAgICAgICB0aGVOb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9IHRoZUNoaWxkLmNzcyhcInRleHQtaGFsaWduXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgdGhlIGxheW91dCBub2RlXG4gICAgICBpZFRvTE5vZGVbdGhlQ2hpbGQuZGF0YShcImlkXCIpXSA9IHRoZU5vZGU7XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueCkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LnkpKSB7XG4gICAgICAgIHRoZU5vZGUucmVjdC55ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkcmVuX29mX2NoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW5fb2ZfY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGhlTmV3R3JhcGggPSB2b2lkIDA7XG4gICAgICAgIHRoZU5ld0dyYXBoID0gbGF5b3V0LmdldEdyYXBoTWFuYWdlcigpLmFkZChsYXlvdXQubmV3R3JhcGgoKSwgdGhlTm9kZSk7XG4gICAgICAgIHByb2Nlc3NDaGlsZHJlbkxpc3QodGhlTmV3R3JhcGgsIGNoaWxkcmVuX29mX2NoaWxkcmVuLCBsYXlvdXQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgZWRnZXMgdG8gY29zZSBlZGdlc1xuICB2YXIgcHJvY2Vzc0VkZ2VzID0gZnVuY3Rpb24gcHJvY2Vzc0VkZ2VzKGxheW91dCwgZ20sIGVkZ2VzKSB7XG4gICAgdmFyIGlkZWFsTGVuZ3RoVG90YWwgPSAwO1xuICAgIHZhciBlZGdlQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgc291cmNlTm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJzb3VyY2VcIildO1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBpZFRvTE5vZGVbZWRnZS5kYXRhKFwidGFyZ2V0XCIpXTtcbiAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUgJiYgc291cmNlTm9kZSAhPT0gdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlLmdldEVkZ2VzQmV0d2Vlbih0YXJnZXROb2RlKS5sZW5ndGggPT0gMCkge1xuICAgICAgICB2YXIgZTEgPSBnbS5hZGQobGF5b3V0Lm5ld0VkZ2UoKSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgICAgIGUxLmlkID0gZWRnZS5pZCgpO1xuICAgICAgICBlMS5pZGVhbExlbmd0aCA9IG9wdEZuKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoLCBlZGdlKTtcbiAgICAgICAgZTEuZWRnZUVsYXN0aWNpdHkgPSBvcHRGbihvcHRpb25zLmVkZ2VFbGFzdGljaXR5LCBlZGdlKTtcbiAgICAgICAgaWRlYWxMZW5ndGhUb3RhbCArPSBlMS5pZGVhbExlbmd0aDtcbiAgICAgICAgZWRnZUNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBpZGVhbCBlZGdlIGxlbmd0aCBjb25zdGFudCB3aXRoIHRoZSBhdmcuIGlkZWFsIGxlbmd0aCB2YWx1ZSBhZnRlciBwcm9jZXNzaW5nIGVkZ2VzXG4gICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBlZGdlLCB1c2Ugb3RoZXIgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICBpZiAoZWRnZUNvdW50ID4gMCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IGlkZWFsTGVuZ3RoVG90YWwgLyBlZGdlQ291bnQ7ZWxzZSBpZiAoIWlzRm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpKSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIGJ1dCBvcHRpb24gZ2l2ZXMgYSB2YWx1ZSB0byB1c2VcbiAgICAgICAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO2Vsc2UgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBlZGdlIGFuZCB3ZSBjYW5ub3QgZ2V0IGEgdmFsdWUgZnJvbSBvcHRpb24gKGJlY2F1c2UgaXQncyBhIGZ1bmN0aW9uKVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gNTA7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmFzZWQgb24gdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50XG4gICAgICBDb1NFQ29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuICAgICAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG4gIH07XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIGNvbnN0cmFpbnRzIHRvIGNvc2UgbGF5b3V0XG4gIHZhciBwcm9jZXNzQ29uc3RyYWludHMgPSBmdW5jdGlvbiBwcm9jZXNzQ29uc3RyYWludHMobGF5b3V0LCBvcHRpb25zKSB7XG4gICAgLy8gZ2V0IG5vZGVzIHRvIGJlIGZpeGVkXG4gICAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wiZml4ZWROb2RlQ29uc3RyYWludFwiXSA9IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludDtcbiAgICB9XG4gICAgLy8gZ2V0IG5vZGVzIHRvIGJlIGFsaWduZWRcbiAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJhbGlnbm1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgcmVsYXRpdmVseSBwbGFjZWRcbiAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcInJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludFwiXSA9IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBBcHBseSBwb3N0cHJvY2Vzc2luZyAqKioqL1xuICBpZiAob3B0aW9ucy5uZXN0aW5nRmFjdG9yICE9IG51bGwpIENvU0VDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gIGlmIChvcHRpb25zLmdyYXZpdHkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHk7XG4gIGlmIChvcHRpb25zLm51bUl0ZXIgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gb3B0aW9ucy5udW1JdGVyO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2UgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5Q29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHlDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsO1xuXG4gIGlmIChvcHRpb25zLnRpbGluZ0NvbXBhcmVCeSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLlRJTElOR19DT01QQVJFX0JZID0gb3B0aW9ucy50aWxpbmdDb21wYXJlQnk7XG5cbiAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAncHJvb2YnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDI7ZWxzZSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDA7XG5cbiAgQ29TRUNvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBGRExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gb3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM7XG4gIENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9ICFvcHRpb25zLnJhbmRvbWl6ZTtcbiAgQ29TRUNvbnN0YW50cy5BTklNQVRFID0gRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IExheW91dENvbnN0YW50cy5BTklNQVRFID0gb3B0aW9ucy5hbmltYXRlO1xuICBDb1NFQ29uc3RhbnRzLlRJTEUgPSBvcHRpb25zLnRpbGU7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWw7XG5cbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gdHJ1ZTtcbiAgQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IG9wdGlvbnMudW5pZm9ybU5vZGVEaW1lbnNpb25zO1xuXG4gIC8vIFRoaXMgcGFydCBpcyBmb3IgZGVidWcvZGVtbyBwdXJwb3NlXG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJ0cmFuc2Zvcm1lZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiZW5mb3JjZWRcIikge1xuICAgIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcImNvc2VcIikge1xuICAgIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtlbHNlIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50IHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNvc2VMYXlvdXQgPSBuZXcgQ29TRUxheW91dCgpO1xuICB2YXIgZ20gPSBjb3NlTGF5b3V0Lm5ld0dyYXBoTWFuYWdlcigpO1xuXG4gIHByb2Nlc3NDaGlsZHJlbkxpc3QoZ20uYWRkUm9vdCgpLCBhdXguZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgY29zZUxheW91dCwgb3B0aW9ucyk7XG4gIHByb2Nlc3NFZGdlcyhjb3NlTGF5b3V0LCBnbSwgZWRnZXMpO1xuICBwcm9jZXNzQ29uc3RyYWludHMoY29zZUxheW91dCwgb3B0aW9ucyk7XG5cbiAgY29zZUxheW91dC5ydW5MYXlvdXQoKTtcblxuICByZXR1cm4gaWRUb0xOb2RlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IGNvc2VMYXlvdXQ6IGNvc2VMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1OCk7XG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NyksXG4gICAgc3BlY3RyYWxMYXlvdXQgPSBfcmVxdWlyZS5zcGVjdHJhbExheW91dDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KSxcbiAgICBjb3NlTGF5b3V0ID0gX3JlcXVpcmUyLmNvc2VMYXlvdXQ7XG5cbnZhciBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuXG4gIC8vICdkcmFmdCcsICdkZWZhdWx0JyBvciAncHJvb2YnIFxuICAvLyAtICdkcmFmdCcgb25seSBhcHBsaWVzIHNwZWN0cmFsIGxheW91dCBcbiAgLy8gLSAnZGVmYXVsdCcgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChmYXN0IGNvb2xpbmcgcmF0ZSlcbiAgLy8gLSAncHJvb2YnIGltcHJvdmVzIHRoZSBxdWFsaXR5IHdpdGggc3Vic2VxdWVudCBDb1NFIGxheW91dCAoc2xvdyBjb29saW5nIHJhdGUpIFxuICBxdWFsaXR5OiBcImRlZmF1bHRcIixcbiAgLy8gVXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG4gIC8vIGlmIHRoaXMgaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgXCJwcm9vZlwiXG4gIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgLy8gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgbGF5b3V0XG4gIGFuaW1hdGU6IHRydWUsXG4gIC8vIER1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcywgaWYgZW5hYmxlZFxuICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgLy8gRWFzaW5nIG9mIGFuaW1hdGlvbiwgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gRml0IHRoZSB2aWV3cG9ydCB0byB0aGUgcmVwb3NpdGlvbmVkIG5vZGVzXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBhcm91bmQgbGF5b3V0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBXaGV0aGVyIHRvIGluY2x1ZGUgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucy4gVmFsaWQgaW4gXCJwcm9vZlwiIHF1YWxpdHlcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gV2hldGhlciBvciBub3Qgc2ltcGxlIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIGRpbWVuc2lvbnNcbiAgdW5pZm9ybU5vZGVEaW1lbnNpb25zOiBmYWxzZSxcbiAgLy8gV2hldGhlciB0byBwYWNrIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIC0gdmFsaWQgb25seSBpZiByYW5kb21pemU6IHRydWVcbiAgcGFja0NvbXBvbmVudHM6IHRydWUsXG4gIC8vIExheW91dCBzdGVwIC0gYWxsLCB0cmFuc2Zvcm1lZCwgZW5mb3JjZWQsIGNvc2UgLSBmb3IgZGVidWcgcHVycG9zZSBvbmx5XG4gIHN0ZXA6IFwiYWxsXCIsXG5cbiAgLyogc3BlY3RyYWwgbGF5b3V0IG9wdGlvbnMgKi9cblxuICAvLyBGYWxzZSBmb3IgcmFuZG9tLCB0cnVlIGZvciBncmVlZHlcbiAgc2FtcGxpbmdUeXBlOiB0cnVlLFxuICAvLyBTYW1wbGUgc2l6ZSB0byBjb25zdHJ1Y3QgZGlzdGFuY2UgbWF0cml4XG4gIHNhbXBsZVNpemU6IDI1LFxuICAvLyBTZXBhcmF0aW9uIGFtb3VudCBiZXR3ZWVuIG5vZGVzXG4gIG5vZGVTZXBhcmF0aW9uOiA3NSxcbiAgLy8gUG93ZXIgaXRlcmF0aW9uIHRvbGVyYW5jZVxuICBwaVRvbDogMC4wMDAwMDAxLFxuXG4gIC8qIENvU0UgbGF5b3V0IG9wdGlvbnMgKi9cblxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgIHJldHVybiA0NTAwO1xuICB9LFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiBpZGVhbEVkZ2VMZW5ndGgoZWRnZSkge1xuICAgIHJldHVybiA1MDtcbiAgfSxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgcmV0dXJuIDAuNDU7XG4gIH0sXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMC4xLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMC4yNSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDI1MDAsXG4gIC8vIEZvciBlbmFibGluZyB0aWxpbmdcbiAgdGlsZTogdHJ1ZSxcbiAgLy8gVGhlIGZ1bmN0aW9uIHRoYXQgc3BlY2lmaWVzIHRoZSBjcml0ZXJpYSBmb3IgY29tcGFyaW5nIG5vZGVzIHdoaWxlIHNvcnRpbmcgdGhlbSBkdXJpbmcgdGlsaW5nIG9wZXJhdGlvbi5cbiAgLy8gVGFrZXMgdGhlIG5vZGUgaWQgYXMgYSBwYXJhbWV0ZXIgYW5kIHRoZSBkZWZhdWx0IHRpbGluZyBvcGVyYXRpb24gaXMgcGVyZm9tZWQgd2hlbiB0aGlzIG9wdGlvbiBpcyBub3Qgc2V0LlxuICB0aWxpbmdDb21wYXJlQnk6IHVuZGVmaW5lZCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiAxMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSBob3Jpem9udGFsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogMTAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlSYW5nZUNvbXBvdW5kOiAxLjUsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlDb21wb3VuZDogMS4wLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudClcbiAgZ3Jhdml0eVJhbmdlOiAzLjgsXG4gIC8vIEluaXRpYWwgY29vbGluZyBmYWN0b3IgZm9yIGluY3JlbWVudGFsIGxheW91dCAgXG4gIGluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsOiAwLjMsXG5cbiAgLyogY29uc3RyYWludCBvcHRpb25zICovXG5cbiAgLy8gRml4IHJlcXVpcmVkIG5vZGVzIHRvIHByZWRlZmluZWQgcG9zaXRpb25zXG4gIC8vIFt7bm9kZUlkOiAnbjEnLCBwb3NpdGlvbjoge3g6IDEwMCwgeTogMjAwfSwgey4uLn1dXG4gIGZpeGVkTm9kZUNvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gQWxpZ24gcmVxdWlyZWQgbm9kZXMgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb25cbiAgLy8ge3ZlcnRpY2FsOiBbWyduMScsICduMicpXSwgWyduMycsICduNCddXSwgaG9yaXpvbnRhbDogWyduMicsICduNCddfVxuICBhbGlnbm1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG4gIC8vIFBsYWNlIHR3byBub2RlcyByZWxhdGl2ZWx5IGluIHZlcnRpY2FsL2hvcml6b250YWwgZGlyZWN0aW9uIFxuICAvLyBbe3RvcDogJ24xJywgYm90dG9tOiAnbjInLCBnYXA6IDEwMH0sIHtsZWZ0OiAnbjMnLCByaWdodDogJ240JywgZ2FwOiA3NX1dXG4gIHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDogdW5kZWZpbmVkLFxuXG4gIC8qIGxheW91dCBldmVudCBjYWxsYmFja3MgKi9cbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG59KTtcblxudmFyIExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGF5b3V0KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExheW91dCwgW3tcbiAgICBrZXk6ICdydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gICAgICB2YXIgc3BlY3RyYWxSZXN1bHQgPSBbXTtcbiAgICAgIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICAgICAgdmFyIHlDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgY29zZVJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgICB2YXIgY29tcG9uZW50Q2VudGVycyA9IFtdO1xuXG4gICAgICAvLyBiYXNpYyB2YWxpZGl0eSBjaGVjayBmb3IgY29uc3RyYWludCBpbnB1dHMgXG4gICAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50ICYmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHx8IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgICBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFueSBjb25zdHJhaW50IGV4aXN0cywgc2V0IHNvbWUgb3B0aW9uc1xuICAgICAgdmFyIGNvbnN0cmFpbnRFeGlzdCA9IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgICBpZiAoY29uc3RyYWludEV4aXN0KSB7XG4gICAgICAgIC8vIGNvbnN0cmFpbnRzIHdvcmsgd2l0aCB0aGVzZSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMudGlsZSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnBhY2tDb21wb25lbnRzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlY2lkZSBjb21wb25lbnQgcGFja2luZyBpcyBlbmFibGVkIG9yIG5vdFxuICAgICAgdmFyIGxheVV0aWwgPSB2b2lkIDA7XG4gICAgICB2YXIgcGFja2luZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChjeS5sYXlvdXRVdGlsaXRpZXMgJiYgb3B0aW9ucy5wYWNrQ29tcG9uZW50cykge1xuICAgICAgICBsYXlVdGlsID0gY3kubGF5b3V0VXRpbGl0aWVzKFwiZ2V0XCIpO1xuICAgICAgICBpZiAoIWxheVV0aWwpIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoKTtcbiAgICAgICAgcGFja2luZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlcy5ub2RlcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gaWYgcGFja2luZyBpcyBub3QgZW5hYmxlZCwgcGVyZm9ybSBsYXlvdXQgb24gdGhlIHdob2xlIGdyYXBoXG4gICAgICAgIGlmICghcGFja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgICAvLyBzdG9yZSBjb21wb25lbnQgY2VudGVyXG4gICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gb3B0aW9ucy5lbGVzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAvLyBhcHBseSBzcGVjdHJhbCBsYXlvdXRcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzcGVjdHJhbExheW91dChvcHRpb25zKTtcbiAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYXBwbHkgY29zZSBsYXlvdXQgYXMgcG9zdHByb2Nlc3NpbmdcbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIpIHtcbiAgICAgICAgICAgIGNvc2VSZXN1bHQucHVzaChjb3NlTGF5b3V0KG9wdGlvbnMsIHNwZWN0cmFsUmVzdWx0WzBdKSk7XG4gICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1swXSwgY29zZVJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1swXSwgc3BlY3RyYWxSZXN1bHRbMF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcGFja2luZyBpcyBlbmFibGVkXG4gICAgICAgICAgdmFyIHRvcE1vc3ROb2RlcyA9IGF1eC5nZXRUb3BNb3N0Tm9kZXMob3B0aW9ucy5lbGVzLm5vZGVzKCkpO1xuICAgICAgICAgIGNvbXBvbmVudHMgPSBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIG9wdGlvbnMuZWxlcywgdG9wTW9zdE5vZGVzKTtcbiAgICAgICAgICAvLyBzdG9yZSBjb21wb25lbnQgY2VudGVyc1xuICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBjb21wb25lbnQuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIGNvbXBvbmVudENlbnRlcnMucHVzaCh7IHg6IGJvdW5kaW5nQm94LngxICsgYm91bmRpbmdCb3gudyAvIDIsIHk6IGJvdW5kaW5nQm94LnkxICsgYm91bmRpbmdCb3guaCAvIDIgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvL3NlbmQgZWFjaCBjb21wb25lbnQgdG8gc3BlY3RyYWwgbGF5b3V0IGlmIHJhbmRvbWl6ZWRcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChzcGVjdHJhbExheW91dChvcHRpb25zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIpIHtcbiAgICAgICAgICAgIHZhciB0b0JlVGlsZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbGUpIHtcbiAgICAgICAgICAgICAgLy8gYmVoYXZlIG5vZGVzIHRvIGJlIHRpbGVkIGFzIG9uZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICB2YXIgX3hDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIF95Q29vcmRzID0gW107XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgIHZhciB0ZW1wU3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogX3hDb29yZHMsIHlDb29yZHM6IF95Q29vcmRzIH07XG4gICAgICAgICAgICAgIHZhciBpbmRleGVzVG9CZURlbGV0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5lZGdlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvQmVUaWxlZE5vZGVzLm1lcmdlKGNvbXBvbmVudC5ub2RlcygpW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BlY3RyYWxSZXN1bHQubm9kZUluZGV4ZXMuc2V0KGNvbXBvbmVudC5ub2RlcygpW2ldLmlkKCksIGNvdW50KyspO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC54Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS54KTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BlY3RyYWxSZXN1bHQueUNvb3Jkcy5wdXNoKGNvbXBvbmVudC5ub2RlcygpWzBdLnBvc2l0aW9uKCkueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaW5kZXhlc1RvQmVEZWxldGVkLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh0b0JlVGlsZWROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ib3VuZGluZ0JveCA9IHRvQmVUaWxlZE5vZGVzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogX2JvdW5kaW5nQm94LngxICsgX2JvdW5kaW5nQm94LncgLyAyLCB5OiBfYm91bmRpbmdCb3gueTEgKyBfYm91bmRpbmdCb3guaCAvIDIgfSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHRvQmVUaWxlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHRlbXBTcGVjdHJhbFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ZXNUb0JlRGVsZXRlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5zcGxpY2UoaW5kZXhlc1RvQmVEZWxldGVkW2ldLCAxKTtcbiAgICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5zcGxpY2UoaW5kZXhlc1RvQmVEZWxldGVkW2ldLCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gc2VuZCBlYWNoIGNvbXBvbmVudCB0byBjb3NlIGxheW91dFxuICAgICAgICAgICAgICBvcHRpb25zLmVsZXMgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgIGNvc2VSZXN1bHQucHVzaChjb3NlTGF5b3V0KG9wdGlvbnMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XSkpO1xuICAgICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1tpbmRleF0sIGNvc2VSZXN1bHRbaW5kZXhdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYWNraW5nXG4gICAgICAgICAgdmFyIGNvbXBvbmVudHNFdmFsdWF0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHN1YmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgdmFyIGhpZGRlbkVsZXMgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleGVzID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbaW5kZXhdLm5vZGVJbmRleGVzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5ub2RlcygpLm5vdChoaWRkZW5FbGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YmdyYXBoID0ge307XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGguZWRnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW25vZGVJbmRleF0gLSBub2RlLmJvdW5kaW5nYm94KCkudyAvIDIsIHk6IHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW25vZGVJbmRleF0gLSBub2RlLmJvdW5kaW5nYm94KCkuaCAvIDIsIHdpZHRoOiBub2RlLmJvdW5kaW5nYm94KCkudywgaGVpZ2h0OiBub2RlLmJvdW5kaW5nYm94KCkuaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3gobm9kZSwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IHBhcmVudEluZm8udG9wTGVmdFgsIHk6IHBhcmVudEluZm8udG9wTGVmdFksIHdpZHRoOiBwYXJlbnRJbmZvLndpZHRoLCBoZWlnaHQ6IHBhcmVudEluZm8uaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzLnB1c2goeyB4OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldExlZnQoKSwgeTogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRUb3AoKSwgd2lkdGg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0V2lkdGgoKSwgaGVpZ2h0OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldEhlaWdodCgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY3NzKFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIiAmJiB0YXJnZXQuY3NzKFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOb2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoc291cmNlLmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQodGFyZ2V0LmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2VudGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3goc291cmNlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFggKyBwYXJlbnRJbmZvLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChwYXJlbnRJbmZvLnRvcExlZnRZICsgcGFyZW50SW5mby5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbc291cmNlTm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3BhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRhcmdldCwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChfcGFyZW50SW5mby50b3BMZWZ0WCArIF9wYXJlbnRJbmZvLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChfcGFyZW50SW5mby50b3BMZWZ0WSArIF9wYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1t0YXJnZXROb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBzb3VyY2VDZW50ZXJbMF0sIHN0YXJ0WTogc291cmNlQ2VudGVyWzFdLCBlbmRYOiB0YXJnZXRDZW50ZXJbMF0sIGVuZFk6IHRhcmdldENlbnRlclsxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29zZVJlc3VsdFtpbmRleF1bc291cmNlLmlkKCldICYmIGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGguZWRnZXMucHVzaCh7IHN0YXJ0WDogY29zZVJlc3VsdFtpbmRleF1bc291cmNlLmlkKCldLmdldENlbnRlclgoKSwgc3RhcnRZOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWSgpLCBlbmRYOiBjb3NlUmVzdWx0W2luZGV4XVt0YXJnZXQuaWQoKV0uZ2V0Q2VudGVyWCgpLCBlbmRZOiBjb3NlUmVzdWx0W2luZGV4XVt0YXJnZXQuaWQoKV0uZ2V0Q2VudGVyWSgpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdWJncmFwaC5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBzdWJncmFwaHMucHVzaChzdWJncmFwaCk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzaGlmdFJlc3VsdCA9IGxheVV0aWwucGFja0NvbXBvbmVudHMoc3ViZ3JhcGhzLCBvcHRpb25zLnJhbmRvbWl6ZSkuc2hpZnRzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdYQ29vcmRzID0gcmVzdWx0LnhDb29yZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geCArIHNoaWZ0UmVzdWx0W2luZGV4XS5keDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3WUNvb3JkcyA9IHJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgKyBzaGlmdFJlc3VsdFtpbmRleF0uZHk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnhDb29yZHMgPSBuZXdYQ29vcmRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdC55Q29vcmRzID0gbmV3WUNvb3JkcztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgY29tcG9uZW50c0V2YWx1YXRlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvc2VSZXN1bHRbaW5kZXhdKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbm9kZVJlY3RhbmdsZSA9IGNvc2VSZXN1bHRbaW5kZXhdW2l0ZW1dO1xuICAgICAgICAgICAgICAgICAgbm9kZVJlY3RhbmdsZS5zZXRDZW50ZXIobm9kZVJlY3RhbmdsZS5nZXRDZW50ZXJYKCkgKyBzaGlmdFJlc3VsdFtfY291bnRdLmR4LCBub2RlUmVjdGFuZ2xlLmdldENlbnRlclkoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb3VudCsrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGVhY2ggZWxlbWVudCdzIGNhbGN1bGF0ZWQgcG9zaXRpb25cbiAgICAgIHZhciBnZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoZWxlLCBpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBlbGUgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciB0aGVJZCA9IGVsZS5kYXRhKCdpZCcpO1xuICAgICAgICAgIGNvc2VSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhlSWQgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHBvcyA9IHsgeDogcmVzdWx0W3RoZUlkXS5nZXRSZWN0KCkuZ2V0Q2VudGVyWCgpLCB5OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJZKCkgfTtcbiAgICAgICAgICAgICAgbm9kZSA9IHJlc3VsdFt0aGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHBvcy54ICs9IG5vZGUubGFiZWxXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgKz0gbm9kZS5sYWJlbEhlaWdodCAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSAtPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zID09IHVuZGVmaW5lZCkgcG9zID0geyB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLCB5OiBlbGUucG9zaXRpb24oXCJ5XCIpIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9zID0gdm9pZCAwO1xuICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lm5vZGVJbmRleGVzLmdldChlbGUuaWQoKSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9wb3MgPSB7IHg6IHJlc3VsdC54Q29vcmRzW2luZGV4XSwgeTogcmVzdWx0LnlDb29yZHNbaW5kZXhdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF9wb3MgPT0gdW5kZWZpbmVkKSBfcG9zID0geyB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLCB5OiBlbGUucG9zaXRpb24oXCJ5XCIpIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IF9wb3MueCxcbiAgICAgICAgICAgIHk6IF9wb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHF1YWxpdHkgPSBcImRyYWZ0XCIgYW5kIHJhbmRvbWl6ZSA9IGZhbHNlIGFyZSBjb250cmFkaWN0aXZlIHNvIGluIHRoYXQgY2FzZSBwb3NpdGlvbnMgZG9uJ3QgY2hhbmdlXG4gICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIgfHwgb3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgLy8gdHJhbnNmZXIgY2FsY3VsYXRlZCBwb3NpdGlvbnMgdG8gbm9kZXMgKHBvc2l0aW9ucyBvZiBvbmx5IHNpbXBsZSBub2RlcyBhcmUgZXZhbHVhdGVkLCBjb21wb3VuZHMgYXJlIHBvc2l0aW9uZWQgYXV0b21hdGljYWxseSlcbiAgICAgICAgdmFyIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBhdXguY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4oY3ksIGVsZXMpO1xuICAgICAgICB2YXIgX2hpZGRlbkVsZXMgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLmVsZXMgPSBlbGVzLm5vdChfaGlkZGVuRWxlcyk7XG5cbiAgICAgICAgZWxlcy5ub2RlcygpLm5vdChcIjpwYXJlbnRcIikubm90KF9oaWRkZW5FbGVzKS5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBnZXRQb3NpdGlvbnMpO1xuXG4gICAgICAgIGlmIChwYXJlbnRzV2l0aG91dENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJlbnRzV2l0aG91dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgZWxlLnBvc2l0aW9uKGdldFBvc2l0aW9ucyhlbGUpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJZiByYW5kb21pemUgb3B0aW9uIGlzIHNldCB0byBmYWxzZSwgdGhlbiBxdWFsaXR5IG9wdGlvbiBtdXN0IGJlICdkZWZhdWx0JyBvciAncHJvb2YnLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF5b3V0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDY1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbi8qKlxuICBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWN0cmFsIGxheW91dCB0aGF0IGlzIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBmY29zZSBsYXlvdXQgYWxnb3JpdGhtXG4qL1xuXG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xudmFyIE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLk1hdHJpeDtcbnZhciBTVkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5TVkQ7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBzcGVjdHJhbCBsYXlvdXQgaXMgcHJvY2Vzc2VkXG52YXIgc3BlY3RyYWxMYXlvdXQgPSBmdW5jdGlvbiBzcGVjdHJhbExheW91dChvcHRpb25zKSB7XG5cbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBhcmVudE5vZGVzID0gZWxlcy5ub2RlcyhcIjpwYXJlbnRcIik7XG5cbiAgdmFyIGR1bW15Tm9kZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGR1bW15IG5vZGVzIGFuZCB0aGVpciBuZWlnaGJvcnNcbiAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpOyAvLyBtYXAgdG8ga2VlcCBpbmRleGVzIHRvIG5vZGVzXG4gIHZhciBwYXJlbnRDaGlsZE1hcCA9IG5ldyBNYXAoKTsgLy8gbWFwcGluZyBidHcuIGNvbXBvdW5kIGFuZCBpdHMgcmVwcmVzZW50YXRpdmUgbm9kZSBcbiAgdmFyIGFsbE5vZGVzTmVpZ2hib3Job29kID0gW107IC8vIGFycmF5IHRvIGtlZXAgbmVpZ2hib3Job29kIG9mIGFsbCBub2Rlc1xuICB2YXIgeENvb3JkcyA9IFtdO1xuICB2YXIgeUNvb3JkcyA9IFtdO1xuXG4gIHZhciBzYW1wbGVzQ29sdW1uID0gW107IC8vIHNhbXBsZWQgdmVydGljZXNcbiAgdmFyIG1pbkRpc3RhbmNlc0NvbHVtbiA9IFtdO1xuICB2YXIgQyA9IFtdOyAvLyBjb2x1bW4gc2FtcGxpbmcgbWF0cml4XG4gIHZhciBQSEkgPSBbXTsgLy8gaW50ZXJzZWN0aW9uIG9mIGNvbHVtbiBhbmQgcm93IHNhbXBsaW5nIG1hdHJpY2VzIFxuICB2YXIgSU5WID0gW107IC8vIGludmVyc2Ugb2YgUEhJIFxuXG4gIHZhciBmaXJzdFNhbXBsZSA9IHZvaWQgMDsgLy8gdGhlIGZpcnN0IHNhbXBsZWQgbm9kZVxuICB2YXIgbm9kZVNpemUgPSB2b2lkIDA7XG5cbiAgdmFyIGluZmluaXR5ID0gMTAwMDAwMDAwO1xuICB2YXIgc21hbGwgPSAwLjAwMDAwMDAwMTtcblxuICB2YXIgcGlUb2wgPSBvcHRpb25zLnBpVG9sO1xuICB2YXIgc2FtcGxpbmdUeXBlID0gb3B0aW9ucy5zYW1wbGluZ1R5cGU7IC8vIGZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICB2YXIgbm9kZVNlcGFyYXRpb24gPSBvcHRpb25zLm5vZGVTZXBhcmF0aW9uO1xuICB2YXIgc2FtcGxlU2l6ZSA9IHZvaWQgMDtcblxuICAvKioqKiBTcGVjdHJhbC1wcmVwcm9jZXNzaW5nIGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8qKioqIFNwZWN0cmFsIGxheW91dCBmdW5jdGlvbnMgKioqKi9cblxuICAvLyBkZXRlcm1pbmUgd2hpY2ggY29sdW1ucyB0byBiZSBzYW1wbGVkXG4gIHZhciByYW5kb21TYW1wbGVDUiA9IGZ1bmN0aW9uIHJhbmRvbVNhbXBsZUNSKCkge1xuICAgIHZhciBzYW1wbGUgPSAwO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgIHdoaWxlIChjb3VudCA8IHNhbXBsZVNpemUpIHtcbiAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVTaXplKTtcblxuICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChzYW1wbGVzQ29sdW1uW2ldID09IHNhbXBsZSkge1xuICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZmxhZykge1xuICAgICAgICBzYW1wbGVzQ29sdW1uW2NvdW50XSA9IHNhbXBsZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyB0YWtlcyB0aGUgaW5kZXggb2YgdGhlIG5vZGUocGl2b3QpIHRvIGluaXRpYXRlIEJGUyBhcyBhIHBhcmFtZXRlclxuICB2YXIgQkZTID0gZnVuY3Rpb24gQkZTKHBpdm90LCBpbmRleCwgc2FtcGxpbmdNZXRob2QpIHtcbiAgICB2YXIgcGF0aCA9IFtdOyAvLyB0aGUgZnJvbnQgb2YgdGhlIHBhdGhcbiAgICB2YXIgZnJvbnQgPSAwOyAvLyB0aGUgYmFjayBvZiB0aGUgcGF0aFxuICAgIHZhciBiYWNrID0gMDtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG4gICAgdmFyIGRpc3RhbmNlID0gW107XG5cbiAgICB2YXIgbWF4X2Rpc3QgPSAwOyAvLyB0aGUgZnVydGhlc3Qgbm9kZSB0byBiZSByZXR1cm5lZFxuICAgIHZhciBtYXhfaW5kID0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVNpemU7IGkrKykge1xuICAgICAgZGlzdGFuY2VbaV0gPSBpbmZpbml0eTtcbiAgICB9XG5cbiAgICBwYXRoW2JhY2tdID0gcGl2b3Q7XG4gICAgZGlzdGFuY2VbcGl2b3RdID0gMDtcblxuICAgIHdoaWxlIChiYWNrID49IGZyb250KSB7XG4gICAgICBjdXJyZW50ID0gcGF0aFtmcm9udCsrXTtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBhbGxOb2Rlc05laWdoYm9yaG9vZFtjdXJyZW50XTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRlbXAgPSBub2RlSW5kZXhlcy5nZXQobmVpZ2hib3JzW19pXSk7XG4gICAgICAgIGlmIChkaXN0YW5jZVt0ZW1wXSA9PSBpbmZpbml0eSkge1xuICAgICAgICAgIGRpc3RhbmNlW3RlbXBdID0gZGlzdGFuY2VbY3VycmVudF0gKyAxO1xuICAgICAgICAgIHBhdGhbKytiYWNrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENbY3VycmVudF1baW5kZXhdID0gZGlzdGFuY2VbY3VycmVudF0gKiBub2RlU2VwYXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdNZXRob2QpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVTaXplOyBfaTIrKykge1xuICAgICAgICBpZiAoQ1tfaTJdW2luZGV4XSA8IG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdKSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kyXSA9IENbX2kyXVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVTaXplOyBfaTMrKykge1xuICAgICAgICBpZiAobWluRGlzdGFuY2VzQ29sdW1uW19pM10gPiBtYXhfZGlzdCkge1xuICAgICAgICAgIG1heF9kaXN0ID0gbWluRGlzdGFuY2VzQ29sdW1uW19pM107XG4gICAgICAgICAgbWF4X2luZCA9IF9pMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4X2luZDtcbiAgfTtcblxuICAvLyBhcHBseSBCRlMgdG8gYWxsIG5vZGVzIG9yIHNlbGVjdGVkIHNhbXBsZXNcbiAgdmFyIGFsbEJGUyA9IGZ1bmN0aW9uIGFsbEJGUyhzYW1wbGluZ01ldGhvZCkge1xuXG4gICAgdmFyIHNhbXBsZSA9IHZvaWQgMDtcblxuICAgIGlmICghc2FtcGxpbmdNZXRob2QpIHtcbiAgICAgIHJhbmRvbVNhbXBsZUNSKCk7XG5cbiAgICAgIC8vIGNhbGwgQkZTXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZVNpemU7IGkrKykge1xuICAgICAgICBCRlMoc2FtcGxlc0NvbHVtbltpXSwgaSwgc2FtcGxpbmdNZXRob2QsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuICAgICAgZmlyc3RTYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVTaXplOyBfaTQrKykge1xuICAgICAgICBtaW5EaXN0YW5jZXNDb2x1bW5bX2k0XSA9IGluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzYW1wbGVTaXplOyBfaTUrKykge1xuICAgICAgICBzYW1wbGVzQ29sdW1uW19pNV0gPSBzYW1wbGU7XG4gICAgICAgIHNhbXBsZSA9IEJGUyhzYW1wbGUsIF9pNSwgc2FtcGxpbmdNZXRob2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvcm0gdGhlIHNxdWFyZWQgZGlzdGFuY2VzIGZvciBDXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbm9kZVNpemU7IF9pNisrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNhbXBsZVNpemU7IGorKykge1xuICAgICAgICBDW19pNl1bal0gKj0gQ1tfaTZdW2pdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvcm0gUEhJXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgc2FtcGxlU2l6ZTsgX2k3KyspIHtcbiAgICAgIFBISVtfaTddID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgc2FtcGxlU2l6ZTsgX2k4KyspIHtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzYW1wbGVTaXplOyBfaisrKSB7XG4gICAgICAgIFBISVtfaThdW19qXSA9IENbc2FtcGxlc0NvbHVtbltfal1dW19pOF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHBlcmZvcm0gdGhlIFNWRCBhbGdvcml0aG0gYW5kIGFwcGx5IGEgcmVndWxhcml6YXRpb24gc3RlcFxuICB2YXIgc2FtcGxlID0gZnVuY3Rpb24gc2FtcGxlKCkge1xuXG4gICAgdmFyIFNWRFJlc3VsdCA9IFNWRC5zdmQoUEhJKTtcblxuICAgIHZhciBhX3EgPSBTVkRSZXN1bHQuUztcbiAgICB2YXIgYV91ID0gU1ZEUmVzdWx0LlU7XG4gICAgdmFyIGFfdiA9IFNWRFJlc3VsdC5WO1xuXG4gICAgdmFyIG1heF9zID0gYV9xWzBdICogYV9xWzBdICogYV9xWzBdO1xuXG4gICAgdmFyIGFfU2lnID0gW107XG5cbiAgICAvLyAgcmVndWxhcml6YXRpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZVNpemU7IGkrKykge1xuICAgICAgYV9TaWdbaV0gPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIGFfU2lnW2ldW2pdID0gMDtcbiAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgIGFfU2lnW2ldW2pdID0gYV9xW2ldIC8gKGFfcVtpXSAqIGFfcVtpXSArIG1heF9zIC8gKGFfcVtpXSAqIGFfcVtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgSU5WID0gTWF0cml4Lm11bHRNYXQoTWF0cml4Lm11bHRNYXQoYV92LCBhX1NpZyksIE1hdHJpeC50cmFuc3Bvc2UoYV91KSk7XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIGZpbmFsIGNvb3JkaW5hdGVzIFxuICB2YXIgcG93ZXJJdGVyYXRpb24gPSBmdW5jdGlvbiBwb3dlckl0ZXJhdGlvbigpIHtcbiAgICAvLyB0d28gbGFyZ2VzdCBlaWdlbnZhbHVlc1xuICAgIHZhciB0aGV0YTEgPSB2b2lkIDA7XG4gICAgdmFyIHRoZXRhMiA9IHZvaWQgMDtcblxuICAgIC8vIGluaXRpYWwgZ3Vlc3NlcyBmb3IgZWlnZW52ZWN0b3JzXG4gICAgdmFyIFkxID0gW107XG4gICAgdmFyIFkyID0gW107XG5cbiAgICB2YXIgVjEgPSBbXTtcbiAgICB2YXIgVjIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVNpemU7IGkrKykge1xuICAgICAgWTFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgWTJbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgIH1cblxuICAgIFkxID0gTWF0cml4Lm5vcm1hbGl6ZShZMSk7XG4gICAgWTIgPSBNYXRyaXgubm9ybWFsaXplKFkyKTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiB0aGUgaW1wcm92ZW1lbnQgcmF0aW8gaW4gcG93ZXIgaXRlcmF0aW9uXG4gICAgdmFyIGN1cnJlbnQgPSBzbWFsbDtcbiAgICB2YXIgcHJldmlvdXMgPSBzbWFsbDtcblxuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG5vZGVTaXplOyBfaTkrKykge1xuICAgICAgICBWMVtfaTldID0gWTFbX2k5XTtcbiAgICAgIH1cblxuICAgICAgWTEgPSBNYXRyaXgubXVsdEdhbW1hKE1hdHJpeC5tdWx0TChNYXRyaXgubXVsdEdhbW1hKFYxKSwgQywgSU5WKSk7XG4gICAgICB0aGV0YTEgPSBNYXRyaXguZG90UHJvZHVjdChWMSwgWTEpO1xuICAgICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcblxuICAgICAgY3VycmVudCA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG5cbiAgICAgIHRlbXAgPSBNYXRoLmFicyhjdXJyZW50IC8gcHJldmlvdXMpO1xuXG4gICAgICBpZiAodGVtcCA8PSAxICsgcGlUb2wgJiYgdGVtcCA+PSAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBub2RlU2l6ZTsgX2kxMCsrKSB7XG4gICAgICBWMVtfaTEwXSA9IFkxW19pMTBdO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2aW91cyA9IHNtYWxsO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb3VudCsrO1xuXG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG5vZGVTaXplOyBfaTExKyspIHtcbiAgICAgICAgVjJbX2kxMV0gPSBZMltfaTExXTtcbiAgICAgIH1cblxuICAgICAgVjIgPSBNYXRyaXgubWludXNPcChWMiwgTWF0cml4Lm11bHRDb25zKFYxLCBNYXRyaXguZG90UHJvZHVjdChWMSwgVjIpKSk7XG4gICAgICBZMiA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjIpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMiA9IE1hdHJpeC5kb3RQcm9kdWN0KFYyLCBZMik7XG4gICAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IG5vZGVTaXplOyBfaTEyKyspIHtcbiAgICAgIFYyW19pMTJdID0gWTJbX2kxMl07XG4gICAgfVxuXG4gICAgLy8gdGhldGExIG5vdyBjb250YWlucyBkb21pbmFudCBlaWdlbnZhbHVlXG4gICAgLy8gdGhldGEyIG5vdyBjb250YWlucyB0aGUgc2Vjb25kLWxhcmdlc3QgZWlnZW52YWx1ZVxuICAgIC8vIFYxIG5vdyBjb250YWlucyB0aGV0YTEncyBlaWdlbnZlY3RvclxuICAgIC8vIFYyIG5vdyBjb250YWlucyB0aGV0YTIncyBlaWdlbnZlY3RvclxuXG4gICAgLy9wb3B1bGF0ZSB0aGUgdHdvIHZlY3RvcnNcbiAgICB4Q29vcmRzID0gTWF0cml4Lm11bHRDb25zKFYxLCBNYXRoLnNxcnQoTWF0aC5hYnModGhldGExKSkpO1xuICAgIHlDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjIsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTIpKSk7XG4gIH07XG5cbiAgLyoqKiogUHJlcGFyYXRpb24gZm9yIHNwZWN0cmFsIGxheW91dCAoUHJlcHJvY2Vzc2luZykgKioqKi9cblxuICAvLyBjb25uZWN0IGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIChmaXJzdCB0b3AgbGV2ZWwsIHRoZW4gaW5zaWRlIG9mIGVhY2ggY29tcG91bmQgbm9kZSlcbiAgYXV4LmNvbm5lY3RDb21wb25lbnRzKGN5LCBlbGVzLCBhdXguZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgZHVtbXlOb2Rlcyk7XG5cbiAgcGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgYXV4LmNvbm5lY3RDb21wb25lbnRzKGN5LCBlbGVzLCBhdXguZ2V0VG9wTW9zdE5vZGVzKGVsZS5kZXNjZW5kYW50cygpLmludGVyc2VjdGlvbihlbGVzKSksIGR1bW15Tm9kZXMpO1xuICB9KTtcblxuICAvLyBhc3NpZ24gaW5kZXhlcyB0byBub2RlcyAoZmlyc3QgcmVhbCwgdGhlbiBkdW1teSBub2RlcylcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbm9kZXNbaV0uaXNQYXJlbnQoKSkge1xuICAgICAgbm9kZUluZGV4ZXMuc2V0KG5vZGVzW2ldLmlkKCksIGluZGV4KyspO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGR1bW15Tm9kZXMua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBub2RlSW5kZXhlcy5zZXQoa2V5LCBpbmRleCsrKTtcbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB0aGUgbmVpZ2hib3Job29kIG1hdHJpeFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kxMysrKSB7XG4gICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbX2kxM10gPSBbXTtcbiAgfVxuXG4gIC8vIGZvcm0gYSBwYXJlbnQtY2hpbGQgbWFwIHRvIGtlZXAgcmVwcmVzZW50YXRpdmUgbm9kZSBvZiBlYWNoIGNvbXBvdW5kIG5vZGUgIFxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGUuY2hpbGRyZW4oKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG5cbiAgICAvLyAgICAgIGxldCByYW5kb20gPSAwO1xuICAgIHdoaWxlIChjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoID09IDApIHtcbiAgICAgIC8vICAgICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcygpLmxlbmd0aCk7IC8vIGlmIGFsbCBjaGlsZHJlbiBhcmUgY29tcG91bmQgdGhlbiBwcm9jZWVkIHJhbmRvbWx5XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLm5vZGVzKClbMF0uY2hpbGRyZW4oKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgfVxuICAgIC8vICBzZWxlY3QgdGhlIHJlcHJlc2VudGF0aXZlIG5vZGUgLSB3ZSBjYW4gYXBwbHkgZGlmZmVyZW50IG1ldGhvZHMgaGVyZVxuICAgIC8vICAgICAgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbWluID0gY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpWzBdLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUyLCBpKSB7XG4gICAgICBpZiAoZWxlMi5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aCA8IG1pbikge1xuICAgICAgICBtaW4gPSBlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGFyZW50Q2hpbGRNYXAuc2V0KGVsZS5pZCgpLCBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbaW5kZXhdLmlkKCkpO1xuICB9KTtcblxuICAvLyBhZGQgbmVpZ2hib3Job29kIHJlbGF0aW9ucyAoZmlyc3QgcmVhbCwgdGhlbiBkdW1teSBub2RlcylcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGVsZUluZGV4ID0gdm9pZCAwO1xuXG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChwYXJlbnRDaGlsZE1hcC5nZXQoZWxlLmlkKCkpKTtlbHNlIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcblxuICAgIGVsZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChlbGVzLmludGVyc2VjdGlvbihlbGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChub2RlLmlzUGFyZW50KCkpIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKHBhcmVudENoaWxkTWFwLmdldChub2RlLmlkKCkpKTtlbHNlIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKG5vZGUuaWQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9rZXkpIHtcbiAgICB2YXIgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoX2tleSk7XG4gICAgdmFyIGRpc2Nvbm5lY3RlZElkID0gdm9pZCAwO1xuICAgIGR1bW15Tm9kZXMuZ2V0KF9rZXkpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoY3kuZ2V0RWxlbWVudEJ5SWQoaWQpLmlzUGFyZW50KCkpIGRpc2Nvbm5lY3RlZElkID0gcGFyZW50Q2hpbGRNYXAuZ2V0KGlkKTtlbHNlIGRpc2Nvbm5lY3RlZElkID0gaWQ7XG5cbiAgICAgIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKGRpc2Nvbm5lY3RlZElkKTtcbiAgICAgIGFsbE5vZGVzTmVpZ2hib3Job29kW25vZGVJbmRleGVzLmdldChkaXNjb25uZWN0ZWRJZCldLnB1c2goX2tleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGR1bW15Tm9kZXMua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICB2YXIgX2tleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgX2xvb3AoX2tleSk7XG4gICAgfVxuXG4gICAgLy8gbm9kZVNpemUgbm93IG9ubHkgY29uc2lkZXJzIHRoZSBzaXplIG9mIHRyYW5zZm9ybWVkIGdyYXBoXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vZGVTaXplID0gbm9kZUluZGV4ZXMuc2l6ZTtcblxuICB2YXIgc3BlY3RyYWxSZXN1bHQgPSB2b2lkIDA7XG5cbiAgLy8gSWYgbnVtYmVyIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIDEgb3IgMiwgZWl0aGVyIFNWRCBvciBwb3dlckl0ZXJhdGlvbiBjYXVzZXMgcHJvYmxlbVxuICAvLyBTbyBza2lwIHNwZWN0cmFsIGFuZCBsYXlvdXQgdGhlIGdyYXBoIHdpdGggY29zZVxuICBpZiAobm9kZVNpemUgPiAyKSB7XG4gICAgLy8gaWYgIyBvZiBub2RlcyBpbiB0cmFuc2Zvcm1lZCBncmFwaCBpcyBzbWFsbGVyIHRoYW4gc2FtcGxlIHNpemUsXG4gICAgLy8gdGhlbiB1c2UgIyBvZiBub2RlcyBhcyBzYW1wbGUgc2l6ZVxuICAgIHNhbXBsZVNpemUgPSBub2RlU2l6ZSA8IG9wdGlvbnMuc2FtcGxlU2l6ZSA/IG5vZGVTaXplIDogb3B0aW9ucy5zYW1wbGVTaXplO1xuXG4gICAgLy8gaW5zdGFudGlhdGVzIHRoZSBwYXJ0aWFsIG1hdHJpY2VzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHNwZWN0cmFsIGxheW91dFxuICAgIGZvciAodmFyIF9pMTQgPSAwOyBfaTE0IDwgbm9kZVNpemU7IF9pMTQrKykge1xuICAgICAgQ1tfaTE0XSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IHNhbXBsZVNpemU7IF9pMTUrKykge1xuICAgICAgSU5WW19pMTVdID0gW107XG4gICAgfVxuXG4gICAgLyoqKiogQXBwbHkgc3BlY3RyYWwgbGF5b3V0ICoqKiovXG5cbiAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIiB8fCBvcHRpb25zLnN0ZXAgPT0gXCJhbGxcIikge1xuICAgICAgYWxsQkZTKHNhbXBsaW5nVHlwZSk7XG4gICAgICBzYW1wbGUoKTtcbiAgICAgIHBvd2VySXRlcmF0aW9uKCk7XG5cbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZUluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB4Q29vcmRzLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KS5wb3NpdGlvbihcInhcIikpO1xuICAgICAgICB5Q29vcmRzLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KS5wb3NpdGlvbihcInlcIikpO1xuICAgICAgfSk7XG4gICAgICBzcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiB4Q29vcmRzLCB5Q29vcmRzOiB5Q29vcmRzIH07XG4gICAgfVxuICAgIHJldHVybiBzcGVjdHJhbFJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBub2RlSW5kZXhlcy5rZXlzKCk7XG4gICAgdmFyIGZpcnN0Tm9kZSA9IGN5LmdldEVsZW1lbnRCeUlkKGl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgdmFyIGZpcnN0Tm9kZVBvcyA9IGZpcnN0Tm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciBmaXJzdE5vZGVXaWR0aCA9IGZpcnN0Tm9kZS5vdXRlcldpZHRoKCk7XG4gICAgeENvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy54KTtcbiAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIGlmIChub2RlU2l6ZSA9PSAyKSB7XG4gICAgICB2YXIgc2Vjb25kTm9kZSA9IGN5LmdldEVsZW1lbnRCeUlkKGl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgICB2YXIgc2Vjb25kTm9kZVdpZHRoID0gc2Vjb25kTm9kZS5vdXRlcldpZHRoKCk7XG4gICAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnggKyBmaXJzdE5vZGVXaWR0aCAvIDIgKyBzZWNvbmROb2RlV2lkdGggLyAyICsgb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpO1xuICAgICAgeUNvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy55KTtcbiAgICB9XG5cbiAgICBzcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiB4Q29vcmRzLCB5Q29vcmRzOiB5Q29vcmRzIH07XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3BlY3RyYWxMYXlvdXQ6IHNwZWN0cmFsTGF5b3V0IH07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Nzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgaW1wbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcblxuLy8gcmVnaXN0ZXJzIHRoZSBleHRlbnNpb24gb24gYSBjeXRvc2NhcGUgbGliIHJlZlxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY3l0b3NjYXBlKSB7XG4gIGlmICghY3l0b3NjYXBlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNhbid0IHJlZ2lzdGVyIGlmIGN5dG9zY2FwZSB1bnNwZWNpZmllZFxuXG4gIGN5dG9zY2FwZSgnbGF5b3V0JywgJ2Zjb3NlJywgaW1wbCk7IC8vIHJlZ2lzdGVyIHdpdGggY3l0b3NjYXBlLmpzXG59O1xuXG5pZiAodHlwZW9mIGN5dG9zY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZXhwb3NlIHRvIGdsb2JhbCBjeXRvc2NhcGUgKGkuZS4gd2luZG93LmN5dG9zY2FwZSlcbiAgcmVnaXN0ZXIoY3l0b3NjYXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTQwX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTc5KTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.31.2/node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ })

};
;