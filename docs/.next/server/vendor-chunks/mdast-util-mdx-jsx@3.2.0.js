"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-mdx-jsx@3.2.0";
exports.ids = ["vendor-chunks/mdast-util-mdx-jsx@3.2.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/mdast-util-mdx-jsx@3.2.0/node_modules/mdast-util-mdx-jsx/lib/index.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/.pnpm/mdast-util-mdx-jsx@3.2.0/node_modules/mdast-util-mdx-jsx/lib/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxJsxFromMarkdown: () => (/* binding */ mdxJsxFromMarkdown),\n/* harmony export */   mdxJsxToMarkdown: () => (/* binding */ mdxJsxToMarkdown)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ccount */ \"(rsc)/../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(rsc)/../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var parse_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-entities */ \"(rsc)/../node_modules/.pnpm/parse-entities@4.0.2/node_modules/parse-entities/lib/index.js\");\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stringify-entities */ \"(rsc)/../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-stringify-position */ \"(rsc)/../node_modules/.pnpm/unist-util-stringify-position@4.0.0/node_modules/unist-util-stringify-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-message */ \"(rsc)/../node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, OnEnterError, OnExitError, Token} from 'mdast-util-from-markdown'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State, Tracker} from 'mdast-util-to-markdown'\n * @import {Point} from 'unist'\n * @import {MdxJsxAttribute, MdxJsxAttributeValueExpression, MdxJsxExpressionAttribute, MdxJsxFlowElement, MdxJsxTextElement} from '../index.js'\n */\n\n/**\n * @typedef Tag\n *   Single tag.\n * @property {string | undefined} name\n *   Name of tag, or `undefined` for fragment.\n *\n *   > ðŸ‘‰ **Note**: `null` is used in the AST for fragments, as it serializes in\n *   > JSON.\n * @property {Array<MdxJsxAttribute | MdxJsxExpressionAttribute>} attributes\n *   Attributes.\n * @property {boolean} close\n *   Whether the tag is closing (`</x>`).\n * @property {boolean} selfClosing\n *   Whether the tag is self-closing (`<x/>`).\n * @property {Token['start']} start\n *   Start point.\n * @property {Token['start']} end\n *   End point.\n *\n * @typedef ToMarkdownOptions\n *   Configuration.\n * @property {'\"' | \"'\" | null | undefined} [quote='\"']\n *   Preferred quote to use around attribute values (default: `'\"'`).\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n * @property {number | null | undefined} [printWidth=Infinity]\n *   Try and wrap syntax at this width (default: `Infinity`).\n *\n *   When set to a finite number (say, `80`), the formatter will print\n *   attributes on separate lines when a tag doesnâ€™t fit on one line.\n *   The normal behavior is to print attributes with spaces between them\n *   instead of line endings.\n */\n\n\n\n\n\n\n\n\nconst indent = '  '\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n *   When using the syntax extension with `addResult`, nodes will have a\n *   `data.estree` field set to an ESTree `Program` node.\n */\nfunction mdxJsxFromMarkdown() {\n  return {\n    canContainEols: ['mdxJsxTextElement'],\n    enter: {\n      mdxJsxFlowTag: enterMdxJsxTag,\n      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,\n      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,\n      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n      mdxJsxFlowTagAttributeValueLiteral: buffer,\n      mdxJsxFlowTagAttributeValueExpression: buffer,\n      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,\n\n      mdxJsxTextTag: enterMdxJsxTag,\n      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,\n      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,\n      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n      mdxJsxTextTagAttributeValueLiteral: buffer,\n      mdxJsxTextTagAttributeValueExpression: buffer,\n      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker\n    },\n    exit: {\n      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,\n      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,\n      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,\n      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,\n      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n      mdxJsxFlowTagExpressionAttributeValue: data,\n      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n      mdxJsxFlowTagAttributeValueLiteralValue: data,\n      mdxJsxFlowTagAttributeValueExpression:\n        exitMdxJsxTagAttributeValueExpression,\n      mdxJsxFlowTagAttributeValueExpressionValue: data,\n      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n      mdxJsxFlowTag: exitMdxJsxTag,\n\n      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,\n      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,\n      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,\n      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,\n      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n      mdxJsxTextTagExpressionAttributeValue: data,\n      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n      mdxJsxTextTagAttributeValueLiteralValue: data,\n      mdxJsxTextTagAttributeValueExpression:\n        exitMdxJsxTagAttributeValueExpression,\n      mdxJsxTextTagAttributeValueExpressionValue: data,\n      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n      mdxJsxTextTag: exitMdxJsxTag\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function buffer() {\n    this.buffer()\n  }\n\n  /**\n   * Copy a point-like value.\n   *\n   * @param {Point} d\n   *   Point-like value.\n   * @returns {Point}\n   *   unist point.\n   */\n  function point(d) {\n    return {line: d.line, column: d.column, offset: d.offset}\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function data(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTag(token) {\n    /** @type {Tag} */\n    const tag = {\n      name: undefined,\n      attributes: [],\n      close: false,\n      selfClosing: false,\n      start: token.start,\n      end: token.end\n    }\n    if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = []\n    this.data.mdxJsxTag = tag\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagClosingMarker(token) {\n    const stack = this.data.mdxJsxTagStack\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, 'expected `mdxJsxTagStack`')\n\n    if (stack.length === 0) {\n      throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n        'Unexpected closing slash `/` in tag, expected an open tag first',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-closing-slash'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagAnyAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n\n    if (tag.close) {\n      throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n        'Unexpected attribute in closing tag, expected the end of the tag',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-attribute'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagSelfClosingMarker(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n\n    if (tag.close) {\n      throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n        'Unexpected self-closing slash `/` in closing tag, expected the end of the tag',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-self-closing-slash'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagClosingMarker() {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    tag.close = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNamePrimary(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    tag.name = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNameMember(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    tag.name += '.' + this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNameLocal(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    tag.name += ':' + this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    enterMdxJsxTagAnyAttribute.call(this, token)\n    tag.attributes.push({\n      type: 'mdxJsxAttribute',\n      name: '',\n      value: null,\n      position: {\n        start: point(token.start),\n        // @ts-expect-error: `end` will be patched later.\n        end: undefined\n      }\n    })\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagExpressionAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    enterMdxJsxTagAnyAttribute.call(this, token)\n    tag.attributes.push({\n      type: 'mdxJsxExpressionAttribute',\n      value: '',\n      position: {\n        start: point(token.start),\n        // @ts-expect-error: `end` will be patched later.\n        end: undefined\n      }\n    })\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagExpressionAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const tail = tag.attributes[tag.attributes.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === 'mdxJsxExpressionAttribute')\n    const estree = token.estree\n\n    tail.value = this.resume()\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position !== undefined)\n    tail.position.end = point(token.end)\n\n    if (estree) {\n      tail.data = {estree}\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeNamePrimary(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'mdxJsxAttribute')\n    node.name = this.sliceSerialize(token)\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeNameLocal(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'mdxJsxAttribute')\n    node.name += ':' + this.sliceSerialize(token)\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeValueLiteral(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    node.value = (0,parse_entities__WEBPACK_IMPORTED_MODULE_2__.parseEntities)(this.resume(), {nonTerminated: false})\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeValueExpression(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const tail = tag.attributes[tag.attributes.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === 'mdxJsxAttribute')\n    /** @type {MdxJsxAttributeValueExpression} */\n    const node = {type: 'mdxJsxAttributeValueExpression', value: this.resume()}\n    const estree = token.estree\n\n    if (estree) {\n      node.data = {estree}\n    }\n\n    tail.value = node\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position !== undefined)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagSelfClosingMarker() {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n\n    tag.selfClosing = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTag(token) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const stack = this.data.mdxJsxTagStack\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, 'expected `mdxJsxTagStack`')\n    const tail = stack[stack.length - 1]\n\n    if (tag.close && tail.name !== tag.name) {\n      throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n        'Unexpected closing tag `' +\n          serializeAbbreviatedTag(tag) +\n          '`, expected corresponding closing tag for `' +\n          serializeAbbreviatedTag(tail) +\n          '` (' +\n          (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(tail) +\n          ')',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:end-tag-mismatch'\n      )\n    }\n\n    // End of a tag, so drop the buffer.\n    this.resume()\n\n    if (tag.close) {\n      stack.pop()\n    } else {\n      this.enter(\n        {\n          type:\n            token.type === 'mdxJsxTextTag'\n              ? 'mdxJsxTextElement'\n              : 'mdxJsxFlowElement',\n          name: tag.name || null,\n          attributes: tag.attributes,\n          children: []\n        },\n        token,\n        onErrorRightIsTag\n      )\n    }\n\n    if (tag.selfClosing || tag.close) {\n      this.exit(token, onErrorLeftIsTag)\n    } else {\n      stack.push(tag)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {OnEnterError}\n   */\n  function onErrorRightIsTag(closing, open) {\n    const stack = this.data.mdxJsxTagStack\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, 'expected `mdxJsxTagStack`')\n    const tag = stack[stack.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n    const place = closing ? ' before the end of `' + closing.type + '`' : ''\n    const position = closing\n      ? {start: closing.start, end: closing.end}\n      : undefined\n\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n      'Expected a closing tag for `' +\n        serializeAbbreviatedTag(tag) +\n        '` (' +\n        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)({start: open.start, end: open.end}) +\n        ')' +\n        place,\n      position,\n      'mdast-util-mdx-jsx:end-tag-mismatch'\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {OnExitError}\n   */\n  function onErrorLeftIsTag(a, b) {\n    const tag = this.data.mdxJsxTag\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, 'expected `mdxJsxTag`')\n\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\n      'Expected the closing tag `' +\n        serializeAbbreviatedTag(tag) +\n        '` either after the end of `' +\n        b.type +\n        '` (' +\n        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.end) +\n        ') or another opening tag after the start of `' +\n        b.type +\n        '` (' +\n        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.start) +\n        ')',\n      {start: a.start, end: a.end},\n      'mdast-util-mdx-jsx:end-tag-mismatch'\n    )\n  }\n\n  /**\n   * Serialize a tag, excluding attributes.\n   * `self-closing` is not supported, because we donâ€™t need it yet.\n   *\n   * @param {Tag} tag\n   * @returns {string}\n   */\n  function serializeAbbreviatedTag(tag) {\n    return '<' + (tag.close ? '/' : '') + (tag.name || '') + '>'\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX JSX.\n *\n * This extension configures `mdast-util-to-markdown` with\n * `options.fences: true` and `options.resourceLink: true` too, do not\n * overwrite them!\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX JSX.\n */\nfunction mdxJsxToMarkdown(options) {\n  const options_ = options || {}\n  const quote = options_.quote || '\"'\n  const quoteSmart = options_.quoteSmart || false\n  const tightSelfClosing = options_.tightSelfClosing || false\n  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY\n  const alternative = quote === '\"' ? \"'\" : '\"'\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error(\n      'Cannot serialize attribute values with `' +\n        quote +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  mdxElement.peek = peekElement\n\n  return {\n    handlers: {\n      mdxJsxFlowElement: mdxElement,\n      mdxJsxTextElement: mdxElement\n    },\n    unsafe: [\n      {character: '<', inConstruct: ['phrasing']},\n      {atBreak: true, character: '<'}\n    ],\n    // Always generate fenced code (never indented code).\n    fences: true,\n    // Always generate links with resources (never autolinks).\n    resourceLink: true\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n   */\n  // eslint-disable-next-line complexity\n  function mdxElement(node, _, state, info) {\n    const flow = node.type === 'mdxJsxFlowElement'\n    const selfClosing = node.name\n      ? !node.children || node.children.length === 0\n      : false\n    const depth = inferDepth(state)\n    const currentIndent = createIndent(depth)\n    const trackerOneLine = state.createTracker(info)\n    const trackerMultiLine = state.createTracker(info)\n    /** @type {Array<string>} */\n    const serializedAttributes = []\n    const prefix = (flow ? currentIndent : '') + '<' + (node.name || '')\n    const exit = state.enter(node.type)\n\n    trackerOneLine.move(prefix)\n    trackerMultiLine.move(prefix)\n\n    // None.\n    if (node.attributes && node.attributes.length > 0) {\n      if (!node.name) {\n        throw new Error('Cannot serialize fragment w/ attributes')\n      }\n\n      let index = -1\n      while (++index < node.attributes.length) {\n        const attribute = node.attributes[index]\n        /** @type {string} */\n        let result\n\n        if (attribute.type === 'mdxJsxExpressionAttribute') {\n          result = '{' + (attribute.value || '') + '}'\n        } else {\n          if (!attribute.name) {\n            throw new Error('Cannot serialize attribute w/o name')\n          }\n\n          const value = attribute.value\n          const left = attribute.name\n          /** @type {string} */\n          let right = ''\n\n          if (value === null || value === undefined) {\n            // Empty.\n          } else if (typeof value === 'object') {\n            right = '{' + (value.value || '') + '}'\n          } else {\n            // If the alternative is less common than `quote`, switch.\n            const appliedQuote =\n              quoteSmart && (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, quote) > (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, alternative)\n                ? alternative\n                : quote\n            right =\n              appliedQuote +\n              (0,stringify_entities__WEBPACK_IMPORTED_MODULE_5__.stringifyEntitiesLight)(value, {subset: [appliedQuote]}) +\n              appliedQuote\n          }\n\n          result = left + (right ? '=' : '') + right\n        }\n\n        serializedAttributes.push(result)\n      }\n    }\n\n    let attributesOnTheirOwnLine = false\n    const attributesOnOneLine = serializedAttributes.join(' ')\n\n    if (\n      // Block:\n      flow &&\n      // Including a line ending (expressions).\n      (/\\r?\\n|\\r/.test(attributesOnOneLine) ||\n        // Current position (including `<tag`).\n        trackerOneLine.current().now.column +\n          // -1 because columns, +1 for ` ` before attributes.\n          // Attributes joined by spaces.\n          attributesOnOneLine.length +\n          // ` />`.\n          (selfClosing ? (tightSelfClosing ? 2 : 3) : 1) >\n          printWidth)\n    ) {\n      attributesOnTheirOwnLine = true\n    }\n\n    let tracker = trackerOneLine\n    let value = prefix\n\n    if (attributesOnTheirOwnLine) {\n      tracker = trackerMultiLine\n\n      let index = -1\n\n      while (++index < serializedAttributes.length) {\n        // Only indent first line of of attributes, we canâ€™t indent attribute\n        // values.\n        serializedAttributes[index] =\n          currentIndent + indent + serializedAttributes[index]\n      }\n\n      value += tracker.move(\n        '\\n' + serializedAttributes.join('\\n') + '\\n' + currentIndent\n      )\n    } else if (attributesOnOneLine) {\n      value += tracker.move(' ' + attributesOnOneLine)\n    }\n\n    if (selfClosing) {\n      value += tracker.move(\n        (tightSelfClosing || attributesOnTheirOwnLine ? '' : ' ') + '/'\n      )\n    }\n\n    value += tracker.move('>')\n\n    if (node.children && node.children.length > 0) {\n      if (node.type === 'mdxJsxTextElement') {\n        value += tracker.move(\n          state.containerPhrasing(node, {\n            ...tracker.current(),\n            before: '>',\n            after: '<'\n          })\n        )\n      } else {\n        tracker.shift(2)\n        value += tracker.move('\\n')\n        value += tracker.move(containerFlow(node, state, tracker.current()))\n        value += tracker.move('\\n')\n      }\n    }\n\n    if (!selfClosing) {\n      value += tracker.move(\n        (flow ? currentIndent : '') + '</' + (node.name || '') + '>'\n      )\n    }\n\n    exit()\n    return value\n  }\n}\n\n// Modified copy of:\n// <https://github.com/syntax-tree/mdast-util-to-markdown/blob/a381cbc/lib/util/container-flow.js>.\n//\n// To do: add `indent` support to `mdast-util-to-markdown`.\n// As indents are only used for JSX, itâ€™s fine for now, but perhaps better\n// there.\n/**\n * @param {MdxJsxFlowElement} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {ReturnType<Tracker['current']>} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children\n  const tracker = state.createTracker(info)\n  const currentIndent = createIndent(inferDepth(state))\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    const childInfo = {before: '\\n', after: '\\n', ...tracker.current()}\n\n    const result = state.handle(child, parent, state, childInfo)\n\n    const serializedChild =\n      child.type === 'mdxJsxFlowElement'\n        ? result\n        : state.indentLines(result, function (line, _, blank) {\n            return (blank ? '' : currentIndent) + line\n          })\n\n    results.push(tracker.move(serializedChild))\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(tracker.move('\\n\\n'))\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {State} state\n * @returns {number}\n */\nfunction inferDepth(state) {\n  let depth = 0\n  let index = state.stack.length\n\n  while (--index > -1) {\n    const name = state.stack[index]\n\n    if (name === 'blockquote' || name === 'listItem') break\n    if (name === 'mdxJsxFlowElement') depth++\n  }\n\n  return depth\n}\n\n/**\n * @param {number} depth\n * @returns {string}\n */\nfunction createIndent(depth) {\n  return indent.repeat(depth)\n}\n\n/**\n * @type {ToMarkdownHandle}\n */\nfunction peekElement() {\n  return '<'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21kYXN0LXV0aWwtbWR4LWpzeEAzLjIuMC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tZHgtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxvSEFBb0g7QUFDaEksWUFBWSw0RUFBNEU7QUFDeEYsWUFBWSxPQUFPO0FBQ25CLFlBQVksa0hBQWtIO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDTTtBQUNTO0FBQ2E7QUFDTTtBQUNyQjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9tZGFzdC11dGlsLW1keC1qc3hAMy4yLjAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtbWR4LWpzeC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtDb21waWxlQ29udGV4dCwgRXh0ZW5zaW9uIGFzIEZyb21NYXJrZG93bkV4dGVuc2lvbiwgSGFuZGxlIGFzIEZyb21NYXJrZG93bkhhbmRsZSwgT25FbnRlckVycm9yLCBPbkV4aXRFcnJvciwgVG9rZW59IGZyb20gJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bidcbiAqIEBpbXBvcnQge0hhbmRsZSBhcyBUb01hcmtkb3duSGFuZGxlLCBPcHRpb25zIGFzIFRvTWFya2Rvd25FeHRlbnNpb24sIFN0YXRlLCBUcmFja2VyfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7UG9pbnR9IGZyb20gJ3VuaXN0J1xuICogQGltcG9ydCB7TWR4SnN4QXR0cmlidXRlLCBNZHhKc3hBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb24sIE1keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUsIE1keEpzeEZsb3dFbGVtZW50LCBNZHhKc3hUZXh0RWxlbWVudH0gZnJvbSAnLi4vaW5kZXguanMnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUYWdcbiAqICAgU2luZ2xlIHRhZy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBuYW1lXG4gKiAgIE5hbWUgb2YgdGFnLCBvciBgdW5kZWZpbmVkYCBmb3IgZnJhZ21lbnQuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGBudWxsYCBpcyB1c2VkIGluIHRoZSBBU1QgZm9yIGZyYWdtZW50cywgYXMgaXQgc2VyaWFsaXplcyBpblxuICogICA+IEpTT04uXG4gKiBAcHJvcGVydHkge0FycmF5PE1keEpzeEF0dHJpYnV0ZSB8IE1keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGU+fSBhdHRyaWJ1dGVzXG4gKiAgIEF0dHJpYnV0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsb3NlXG4gKiAgIFdoZXRoZXIgdGhlIHRhZyBpcyBjbG9zaW5nIChgPC94PmApLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzZWxmQ2xvc2luZ1xuICogICBXaGV0aGVyIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nIChgPHgvPmApLlxuICogQHByb3BlcnR5IHtUb2tlblsnc3RhcnQnXX0gc3RhcnRcbiAqICAgU3RhcnQgcG9pbnQuXG4gKiBAcHJvcGVydHkge1Rva2VuWydzdGFydCddfSBlbmRcbiAqICAgRW5kIHBvaW50LlxuICpcbiAqIEB0eXBlZGVmIFRvTWFya2Rvd25PcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkgeydcIicgfCBcIidcIiB8IG51bGwgfCB1bmRlZmluZWR9IFtxdW90ZT0nXCInXVxuICogICBQcmVmZXJyZWQgcXVvdGUgdG8gdXNlIGFyb3VuZCBhdHRyaWJ1dGUgdmFsdWVzIChkZWZhdWx0OiBgJ1wiJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3F1b3RlU21hcnQ9ZmFsc2VdXG4gKiAgIFVzZSB0aGUgb3RoZXIgcXVvdGUgaWYgdGhhdCByZXN1bHRzIGluIGxlc3MgYnl0ZXMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RpZ2h0U2VsZkNsb3Npbmc9ZmFsc2VdXG4gKiAgIERvIG5vdCB1c2UgYW4gZXh0cmEgc3BhY2Ugd2hlbiBjbG9zaW5nIHNlbGYtY2xvc2luZyBlbGVtZW50czogYDxpbWcvPmBcbiAqICAgaW5zdGVhZCBvZiBgPGltZyAvPmAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJpbnRXaWR0aD1JbmZpbml0eV1cbiAqICAgVHJ5IGFuZCB3cmFwIHN5bnRheCBhdCB0aGlzIHdpZHRoIChkZWZhdWx0OiBgSW5maW5pdHlgKS5cbiAqXG4gKiAgIFdoZW4gc2V0IHRvIGEgZmluaXRlIG51bWJlciAoc2F5LCBgODBgKSwgdGhlIGZvcm1hdHRlciB3aWxsIHByaW50XG4gKiAgIGF0dHJpYnV0ZXMgb24gc2VwYXJhdGUgbGluZXMgd2hlbiBhIHRhZyBkb2VzbuKAmXQgZml0IG9uIG9uZSBsaW5lLlxuICogICBUaGUgbm9ybWFsIGJlaGF2aW9yIGlzIHRvIHByaW50IGF0dHJpYnV0ZXMgd2l0aCBzcGFjZXMgYmV0d2VlbiB0aGVtXG4gKiAgIGluc3RlYWQgb2YgbGluZSBlbmRpbmdzLlxuICovXG5cbmltcG9ydCB7Y2NvdW50fSBmcm9tICdjY291bnQnXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtwYXJzZUVudGl0aWVzfSBmcm9tICdwYXJzZS1lbnRpdGllcydcbmltcG9ydCB7c3RyaW5naWZ5RW50aXRpZXNMaWdodH0gZnJvbSAnc3RyaW5naWZ5LWVudGl0aWVzJ1xuaW1wb3J0IHtzdHJpbmdpZnlQb3NpdGlvbn0gZnJvbSAndW5pc3QtdXRpbC1zdHJpbmdpZnktcG9zaXRpb24nXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcblxuY29uc3QgaW5kZW50ID0gJyAgJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICpcbiAqIEByZXR1cm5zIHtGcm9tTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtZnJvbS1tYXJrZG93bmAgdG8gZW5hYmxlIE1EWCBKU1guXG4gKlxuICogICBXaGVuIHVzaW5nIHRoZSBzeW50YXggZXh0ZW5zaW9uIHdpdGggYGFkZFJlc3VsdGAsIG5vZGVzIHdpbGwgaGF2ZSBhXG4gKiAgIGBkYXRhLmVzdHJlZWAgZmllbGQgc2V0IHRvIGFuIEVTVHJlZSBgUHJvZ3JhbWAgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1keEpzeEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5Db250YWluRW9sczogWydtZHhKc3hUZXh0RWxlbWVudCddLFxuICAgIGVudGVyOiB7XG4gICAgICBtZHhKc3hGbG93VGFnOiBlbnRlck1keEpzeFRhZyxcbiAgICAgIG1keEpzeEZsb3dUYWdDbG9zaW5nTWFya2VyOiBlbnRlck1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0F0dHJpYnV0ZSxcbiAgICAgIG1keEpzeEZsb3dUYWdFeHByZXNzaW9uQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsOiBidWZmZXIsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOiBidWZmZXIsXG4gICAgICBtZHhKc3hGbG93VGFnU2VsZkNsb3NpbmdNYXJrZXI6IGVudGVyTWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIsXG5cbiAgICAgIG1keEpzeFRleHRUYWc6IGVudGVyTWR4SnN4VGFnLFxuICAgICAgbWR4SnN4VGV4dFRhZ0Nsb3NpbmdNYXJrZXI6IGVudGVyTWR4SnN4VGFnQ2xvc2luZ01hcmtlcixcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGU6IGVudGVyTWR4SnN4VGFnQXR0cmlidXRlLFxuICAgICAgbWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGU6IGVudGVyTWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWw6IGJ1ZmZlcixcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb246IGJ1ZmZlcixcbiAgICAgIG1keEpzeFRleHRUYWdTZWxmQ2xvc2luZ01hcmtlcjogZW50ZXJNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlclxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbWR4SnN4Rmxvd1RhZ0Nsb3NpbmdNYXJrZXI6IGV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ05hbWVQcmltYXJ5OiBleGl0TWR4SnN4VGFnTmFtZVByaW1hcnksXG4gICAgICBtZHhKc3hGbG93VGFnTmFtZU1lbWJlcjogZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIsXG4gICAgICBtZHhKc3hGbG93VGFnTmFtZUxvY2FsOiBleGl0TWR4SnN4VGFnTmFtZUxvY2FsLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGU6IGV4aXRNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeTogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5LFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZU5hbWVMb2NhbDogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCxcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWw6IGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOlxuICAgICAgICBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvblZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4Rmxvd1RhZ1NlbGZDbG9zaW5nTWFya2VyOiBleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hGbG93VGFnOiBleGl0TWR4SnN4VGFnLFxuXG4gICAgICBtZHhKc3hUZXh0VGFnQ2xvc2luZ01hcmtlcjogZXhpdE1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnTmFtZVByaW1hcnk6IGV4aXRNZHhKc3hUYWdOYW1lUHJpbWFyeSxcbiAgICAgIG1keEpzeFRleHRUYWdOYW1lTWVtYmVyOiBleGl0TWR4SnN4VGFnTmFtZU1lbWJlcixcbiAgICAgIG1keEpzeFRleHRUYWdOYW1lTG9jYWw6IGV4aXRNZHhKc3hUYWdOYW1lTG9jYWwsXG4gICAgICBtZHhKc3hUZXh0VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZTogZXhpdE1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hUZXh0VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5OiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZVByaW1hcnksXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlTmFtZUxvY2FsOiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZUxvY2FsLFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbDogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbCxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWxWYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb246XG4gICAgICAgIGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb24sXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hUZXh0VGFnU2VsZkNsb3NpbmdNYXJrZXI6IGV4aXRNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlcixcbiAgICAgIG1keEpzeFRleHRUYWc6IGV4aXRNZHhKc3hUYWdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5IGEgcG9pbnQtbGlrZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludH0gZFxuICAgKiAgIFBvaW50LWxpa2UgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtQb2ludH1cbiAgICogICB1bmlzdCBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIHBvaW50KGQpIHtcbiAgICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBkYXRhKHRva2VuKSB7XG4gICAgdGhpcy5jb25maWcuZW50ZXIuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIHRoaXMuY29uZmlnLmV4aXQuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnKHRva2VuKSB7XG4gICAgLyoqIEB0eXBlIHtUYWd9ICovXG4gICAgY29uc3QgdGFnID0ge1xuICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBjbG9zZTogZmFsc2UsXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBzdGFydDogdG9rZW4uc3RhcnQsXG4gICAgICBlbmQ6IHRva2VuLmVuZFxuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5tZHhKc3hUYWdTdGFjaykgdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrID0gW11cbiAgICB0aGlzLmRhdGEubWR4SnN4VGFnID0gdGFnXG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnQ2xvc2luZ01hcmtlcih0b2tlbikge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBjbG9zaW5nIHNsYXNoIGAvYCBpbiB0YWcsIGV4cGVjdGVkIGFuIG9wZW4gdGFnIGZpcnN0JyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OnVuZXhwZWN0ZWQtY2xvc2luZy1zbGFzaCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNZHhKc3hUYWdBbnlBdHRyaWJ1dGUodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcblxuICAgIGlmICh0YWcuY2xvc2UpIHtcbiAgICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGF0dHJpYnV0ZSBpbiBjbG9zaW5nIHRhZywgZXhwZWN0ZWQgdGhlIGVuZCBvZiB0aGUgdGFnJyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OnVuZXhwZWN0ZWQtYXR0cmlidXRlJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICBpZiAodGFnLmNsb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBzZWxmLWNsb3Npbmcgc2xhc2ggYC9gIGluIGNsb3NpbmcgdGFnLCBleHBlY3RlZCB0aGUgZW5kIG9mIHRoZSB0YWcnLFxuICAgICAgICB7c3RhcnQ6IHRva2VuLnN0YXJ0LCBlbmQ6IHRva2VuLmVuZH0sXG4gICAgICAgICdtZGFzdC11dGlsLW1keC1qc3g6dW5leHBlY3RlZC1zZWxmLWNsb3Npbmctc2xhc2gnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIHRhZy5jbG9zZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnTmFtZVByaW1hcnkodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSArPSAnLicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdOYW1lTG9jYWwodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSArPSAnOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnQXR0cmlidXRlKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgZW50ZXJNZHhKc3hUYWdBbnlBdHRyaWJ1dGUuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB0YWcuYXR0cmlidXRlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdtZHhKc3hBdHRyaWJ1dGUnLFxuICAgICAgbmFtZTogJycsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwb2ludCh0b2tlbi5zdGFydCksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cbiAgICAgICAgZW5kOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGVudGVyTWR4SnN4VGFnQW55QXR0cmlidXRlLmNhbGwodGhpcywgdG9rZW4pXG4gICAgdGFnLmF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICB0eXBlOiAnbWR4SnN4RXhwcmVzc2lvbkF0dHJpYnV0ZScsXG4gICAgICB2YWx1ZTogJycsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgZW5kYCB3aWxsIGJlIHBhdGNoZWQgbGF0ZXIuXG4gICAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCB0YWlsID0gdGFnLmF0dHJpYnV0ZXNbdGFnLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQodGFpbC50eXBlID09PSAnbWR4SnN4RXhwcmVzc2lvbkF0dHJpYnV0ZScpXG4gICAgY29uc3QgZXN0cmVlID0gdG9rZW4uZXN0cmVlXG5cbiAgICB0YWlsLnZhbHVlID0gdGhpcy5yZXN1bWUoKVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG5cbiAgICBpZiAoZXN0cmVlKSB7XG4gICAgICB0YWlsLmRhdGEgPSB7ZXN0cmVlfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZVByaW1hcnkodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBub2RlID0gdGFnLmF0dHJpYnV0ZXNbdGFnLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbWR4SnN4QXR0cmlidXRlJylcbiAgICBub2RlLm5hbWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IG5vZGUgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdtZHhKc3hBdHRyaWJ1dGUnKVxuICAgIG5vZGUubmFtZSArPSAnOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbCh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IG5vZGUgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBwYXJzZUVudGl0aWVzKHRoaXMucmVzdW1lKCksIHtub25UZXJtaW5hdGVkOiBmYWxzZX0pXG4gICAgYXNzZXJ0KG5vZGUucG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICBub2RlLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgY29uc3QgdGFpbCA9IHRhZy5hdHRyaWJ1dGVzW3RhZy5hdHRyaWJ1dGVzLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KHRhaWwudHlwZSA9PT0gJ21keEpzeEF0dHJpYnV0ZScpXG4gICAgLyoqIEB0eXBlIHtNZHhKc3hBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb259ICovXG4gICAgY29uc3Qgbm9kZSA9IHt0eXBlOiAnbWR4SnN4QXR0cmlidXRlVmFsdWVFeHByZXNzaW9uJywgdmFsdWU6IHRoaXMucmVzdW1lKCl9XG4gICAgY29uc3QgZXN0cmVlID0gdG9rZW4uZXN0cmVlXG5cbiAgICBpZiAoZXN0cmVlKSB7XG4gICAgICBub2RlLmRhdGEgPSB7ZXN0cmVlfVxuICAgIH1cblxuICAgIHRhaWwudmFsdWUgPSBub2RlXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICB0YWcuc2VsZkNsb3NpbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZyh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG4gICAgY29uc3QgdGFpbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAodGFnLmNsb3NlICYmIHRhaWwubmFtZSAhPT0gdGFnLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGNsb3NpbmcgdGFnIGAnICtcbiAgICAgICAgICBzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyh0YWcpICtcbiAgICAgICAgICAnYCwgZXhwZWN0ZWQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHRhZyBmb3IgYCcgK1xuICAgICAgICAgIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhaWwpICtcbiAgICAgICAgICAnYCAoJyArXG4gICAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24odGFpbCkgK1xuICAgICAgICAgICcpJyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OmVuZC10YWctbWlzbWF0Y2gnXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIGEgdGFnLCBzbyBkcm9wIHRoZSBidWZmZXIuXG4gICAgdGhpcy5yZXN1bWUoKVxuXG4gICAgaWYgKHRhZy5jbG9zZSkge1xuICAgICAgc3RhY2sucG9wKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbnRlcihcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSAnbWR4SnN4VGV4dFRhZydcbiAgICAgICAgICAgICAgPyAnbWR4SnN4VGV4dEVsZW1lbnQnXG4gICAgICAgICAgICAgIDogJ21keEpzeEZsb3dFbGVtZW50JyxcbiAgICAgICAgICBuYW1lOiB0YWcubmFtZSB8fCBudWxsLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRhZy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9LFxuICAgICAgICB0b2tlbixcbiAgICAgICAgb25FcnJvclJpZ2h0SXNUYWdcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGFnLnNlbGZDbG9zaW5nIHx8IHRhZy5jbG9zZSkge1xuICAgICAgdGhpcy5leGl0KHRva2VuLCBvbkVycm9yTGVmdElzVGFnKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHRhZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7T25FbnRlckVycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gb25FcnJvclJpZ2h0SXNUYWcoY2xvc2luZywgb3Blbikge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG4gICAgY29uc3QgdGFnID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHBsYWNlID0gY2xvc2luZyA/ICcgYmVmb3JlIHRoZSBlbmQgb2YgYCcgKyBjbG9zaW5nLnR5cGUgKyAnYCcgOiAnJ1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY2xvc2luZ1xuICAgICAgPyB7c3RhcnQ6IGNsb3Npbmcuc3RhcnQsIGVuZDogY2xvc2luZy5lbmR9XG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgICdFeHBlY3RlZCBhIGNsb3NpbmcgdGFnIGZvciBgJyArXG4gICAgICAgIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhZykgK1xuICAgICAgICAnYCAoJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogb3Blbi5zdGFydCwgZW5kOiBvcGVuLmVuZH0pICtcbiAgICAgICAgJyknICtcbiAgICAgICAgcGxhY2UsXG4gICAgICBwb3NpdGlvbixcbiAgICAgICdtZGFzdC11dGlsLW1keC1qc3g6ZW5kLXRhZy1taXNtYXRjaCdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7T25FeGl0RXJyb3J9XG4gICAqL1xuICBmdW5jdGlvbiBvbkVycm9yTGVmdElzVGFnKGEsIGIpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcblxuICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAnRXhwZWN0ZWQgdGhlIGNsb3NpbmcgdGFnIGAnICtcbiAgICAgICAgc2VyaWFsaXplQWJicmV2aWF0ZWRUYWcodGFnKSArXG4gICAgICAgICdgIGVpdGhlciBhZnRlciB0aGUgZW5kIG9mIGAnICtcbiAgICAgICAgYi50eXBlICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbihiLmVuZCkgK1xuICAgICAgICAnKSBvciBhbm90aGVyIG9wZW5pbmcgdGFnIGFmdGVyIHRoZSBzdGFydCBvZiBgJyArXG4gICAgICAgIGIudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oYi5zdGFydCkgK1xuICAgICAgICAnKScsXG4gICAgICB7c3RhcnQ6IGEuc3RhcnQsIGVuZDogYS5lbmR9LFxuICAgICAgJ21kYXN0LXV0aWwtbWR4LWpzeDplbmQtdGFnLW1pc21hdGNoJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSB0YWcsIGV4Y2x1ZGluZyBhdHRyaWJ1dGVzLlxuICAgKiBgc2VsZi1jbG9zaW5nYCBpcyBub3Qgc3VwcG9ydGVkLCBiZWNhdXNlIHdlIGRvbuKAmXQgbmVlZCBpdCB5ZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFnfSB0YWdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhZykge1xuICAgIHJldHVybiAnPCcgKyAodGFnLmNsb3NlID8gJy8nIDogJycpICsgKHRhZy5uYW1lIHx8ICcnKSArICc+J1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICpcbiAqIFRoaXMgZXh0ZW5zaW9uIGNvbmZpZ3VyZXMgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHdpdGhcbiAqIGBvcHRpb25zLmZlbmNlczogdHJ1ZWAgYW5kIGBvcHRpb25zLnJlc291cmNlTGluazogdHJ1ZWAgdG9vLCBkbyBub3RcbiAqIG92ZXJ3cml0ZSB0aGVtIVxuICpcbiAqIEBwYXJhbSB7VG9NYXJrZG93bk9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWR4SnN4VG9NYXJrZG93bihvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBxdW90ZSA9IG9wdGlvbnNfLnF1b3RlIHx8ICdcIidcbiAgY29uc3QgcXVvdGVTbWFydCA9IG9wdGlvbnNfLnF1b3RlU21hcnQgfHwgZmFsc2VcbiAgY29uc3QgdGlnaHRTZWxmQ2xvc2luZyA9IG9wdGlvbnNfLnRpZ2h0U2VsZkNsb3NpbmcgfHwgZmFsc2VcbiAgY29uc3QgcHJpbnRXaWR0aCA9IG9wdGlvbnNfLnByaW50V2lkdGggfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIGNvbnN0IGFsdGVybmF0aXZlID0gcXVvdGUgPT09ICdcIicgPyBcIidcIiA6ICdcIidcblxuICBpZiAocXVvdGUgIT09ICdcIicgJiYgcXVvdGUgIT09IFwiJ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBzZXJpYWxpemUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGAnICtcbiAgICAgICAgcXVvdGUgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMucXVvdGVgLCBleHBlY3RlZCBgXCJgLCBvciBgXFwnYCdcbiAgICApXG4gIH1cblxuICBtZHhFbGVtZW50LnBlZWsgPSBwZWVrRWxlbWVudFxuXG4gIHJldHVybiB7XG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIG1keEpzeEZsb3dFbGVtZW50OiBtZHhFbGVtZW50LFxuICAgICAgbWR4SnN4VGV4dEVsZW1lbnQ6IG1keEVsZW1lbnRcbiAgICB9LFxuICAgIHVuc2FmZTogW1xuICAgICAge2NoYXJhY3RlcjogJzwnLCBpbkNvbnN0cnVjdDogWydwaHJhc2luZyddfSxcbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICc8J31cbiAgICBdLFxuICAgIC8vIEFsd2F5cyBnZW5lcmF0ZSBmZW5jZWQgY29kZSAobmV2ZXIgaW5kZW50ZWQgY29kZSkuXG4gICAgZmVuY2VzOiB0cnVlLFxuICAgIC8vIEFsd2F5cyBnZW5lcmF0ZSBsaW5rcyB3aXRoIHJlc291cmNlcyAobmV2ZXIgYXV0b2xpbmtzKS5cbiAgICByZXNvdXJjZUxpbms6IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtNZHhKc3hGbG93RWxlbWVudCB8IE1keEpzeFRleHRFbGVtZW50fSBub2RlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBmdW5jdGlvbiBtZHhFbGVtZW50KG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gICAgY29uc3QgZmxvdyA9IG5vZGUudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50J1xuICAgIGNvbnN0IHNlbGZDbG9zaW5nID0gbm9kZS5uYW1lXG4gICAgICA/ICFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwXG4gICAgICA6IGZhbHNlXG4gICAgY29uc3QgZGVwdGggPSBpbmZlckRlcHRoKHN0YXRlKVxuICAgIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSBjcmVhdGVJbmRlbnQoZGVwdGgpXG4gICAgY29uc3QgdHJhY2tlck9uZUxpbmUgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gICAgY29uc3QgdHJhY2tlck11bHRpTGluZSA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gICAgY29uc3Qgc2VyaWFsaXplZEF0dHJpYnV0ZXMgPSBbXVxuICAgIGNvbnN0IHByZWZpeCA9IChmbG93ID8gY3VycmVudEluZGVudCA6ICcnKSArICc8JyArIChub2RlLm5hbWUgfHwgJycpXG4gICAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKG5vZGUudHlwZSlcblxuICAgIHRyYWNrZXJPbmVMaW5lLm1vdmUocHJlZml4KVxuICAgIHRyYWNrZXJNdWx0aUxpbmUubW92ZShwcmVmaXgpXG5cbiAgICAvLyBOb25lLlxuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghbm9kZS5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlcmlhbGl6ZSBmcmFnbWVudCB3LyBhdHRyaWJ1dGVzJylcbiAgICAgIH1cblxuICAgICAgbGV0IGluZGV4ID0gLTFcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbaW5kZXhdXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICBsZXQgcmVzdWx0XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnbWR4SnN4RXhwcmVzc2lvbkF0dHJpYnV0ZScpIHtcbiAgICAgICAgICByZXN1bHQgPSAneycgKyAoYXR0cmlidXRlLnZhbHVlIHx8ICcnKSArICd9J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0cmlidXRlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlcmlhbGl6ZSBhdHRyaWJ1dGUgdy9vIG5hbWUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlXG4gICAgICAgICAgY29uc3QgbGVmdCA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgICAgbGV0IHJpZ2h0ID0gJydcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBFbXB0eS5cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gJ3snICsgKHZhbHVlLnZhbHVlIHx8ICcnKSArICd9J1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYWx0ZXJuYXRpdmUgaXMgbGVzcyBjb21tb24gdGhhbiBgcXVvdGVgLCBzd2l0Y2guXG4gICAgICAgICAgICBjb25zdCBhcHBsaWVkUXVvdGUgPVxuICAgICAgICAgICAgICBxdW90ZVNtYXJ0ICYmIGNjb3VudCh2YWx1ZSwgcXVvdGUpID4gY2NvdW50KHZhbHVlLCBhbHRlcm5hdGl2ZSlcbiAgICAgICAgICAgICAgICA/IGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgOiBxdW90ZVxuICAgICAgICAgICAgcmlnaHQgPVxuICAgICAgICAgICAgICBhcHBsaWVkUXVvdGUgK1xuICAgICAgICAgICAgICBzdHJpbmdpZnlFbnRpdGllc0xpZ2h0KHZhbHVlLCB7c3Vic2V0OiBbYXBwbGllZFF1b3RlXX0pICtcbiAgICAgICAgICAgICAgYXBwbGllZFF1b3RlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gbGVmdCArIChyaWdodCA/ICc9JyA6ICcnKSArIHJpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkQXR0cmlidXRlcy5wdXNoKHJlc3VsdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlc09uVGhlaXJPd25MaW5lID0gZmFsc2VcbiAgICBjb25zdCBhdHRyaWJ1dGVzT25PbmVMaW5lID0gc2VyaWFsaXplZEF0dHJpYnV0ZXMuam9pbignICcpXG5cbiAgICBpZiAoXG4gICAgICAvLyBCbG9jazpcbiAgICAgIGZsb3cgJiZcbiAgICAgIC8vIEluY2x1ZGluZyBhIGxpbmUgZW5kaW5nIChleHByZXNzaW9ucykuXG4gICAgICAoL1xccj9cXG58XFxyLy50ZXN0KGF0dHJpYnV0ZXNPbk9uZUxpbmUpIHx8XG4gICAgICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gKGluY2x1ZGluZyBgPHRhZ2ApLlxuICAgICAgICB0cmFja2VyT25lTGluZS5jdXJyZW50KCkubm93LmNvbHVtbiArXG4gICAgICAgICAgLy8gLTEgYmVjYXVzZSBjb2x1bW5zLCArMSBmb3IgYCBgIGJlZm9yZSBhdHRyaWJ1dGVzLlxuICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgam9pbmVkIGJ5IHNwYWNlcy5cbiAgICAgICAgICBhdHRyaWJ1dGVzT25PbmVMaW5lLmxlbmd0aCArXG4gICAgICAgICAgLy8gYCAvPmAuXG4gICAgICAgICAgKHNlbGZDbG9zaW5nID8gKHRpZ2h0U2VsZkNsb3NpbmcgPyAyIDogMykgOiAxKSA+XG4gICAgICAgICAgcHJpbnRXaWR0aClcbiAgICApIHtcbiAgICAgIGF0dHJpYnV0ZXNPblRoZWlyT3duTGluZSA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgdHJhY2tlciA9IHRyYWNrZXJPbmVMaW5lXG4gICAgbGV0IHZhbHVlID0gcHJlZml4XG5cbiAgICBpZiAoYXR0cmlidXRlc09uVGhlaXJPd25MaW5lKSB7XG4gICAgICB0cmFja2VyID0gdHJhY2tlck11bHRpTGluZVxuXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNlcmlhbGl6ZWRBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBPbmx5IGluZGVudCBmaXJzdCBsaW5lIG9mIG9mIGF0dHJpYnV0ZXMsIHdlIGNhbuKAmXQgaW5kZW50IGF0dHJpYnV0ZVxuICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgIHNlcmlhbGl6ZWRBdHRyaWJ1dGVzW2luZGV4XSA9XG4gICAgICAgICAgY3VycmVudEluZGVudCArIGluZGVudCArIHNlcmlhbGl6ZWRBdHRyaWJ1dGVzW2luZGV4XVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAgICdcXG4nICsgc2VyaWFsaXplZEF0dHJpYnV0ZXMuam9pbignXFxuJykgKyAnXFxuJyArIGN1cnJlbnRJbmRlbnRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXNPbk9uZUxpbmUpIHtcbiAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnICcgKyBhdHRyaWJ1dGVzT25PbmVMaW5lKVxuICAgIH1cblxuICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAodGlnaHRTZWxmQ2xvc2luZyB8fCBhdHRyaWJ1dGVzT25UaGVpck93bkxpbmUgPyAnJyA6ICcgJykgKyAnLydcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJz4nKVxuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnbWR4SnN4VGV4dEVsZW1lbnQnKSB7XG4gICAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICAgICBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgICAgICAgIGJlZm9yZTogJz4nLFxuICAgICAgICAgICAgYWZ0ZXI6ICc8J1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrZXIuc2hpZnQoMilcbiAgICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuICAgICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoY29udGFpbmVyRmxvdyhub2RlLCBzdGF0ZSwgdHJhY2tlci5jdXJyZW50KCkpKVxuICAgICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ1xcbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAoZmxvdyA/IGN1cnJlbnRJbmRlbnQgOiAnJykgKyAnPC8nICsgKG5vZGUubmFtZSB8fCAnJykgKyAnPidcbiAgICAgIClcbiAgICB9XG5cbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyBNb2RpZmllZCBjb3B5IG9mOlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvYTM4MWNiYy9saWIvdXRpbC9jb250YWluZXItZmxvdy5qcz4uXG4vL1xuLy8gVG8gZG86IGFkZCBgaW5kZW50YCBzdXBwb3J0IHRvIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYC5cbi8vIEFzIGluZGVudHMgYXJlIG9ubHkgdXNlZCBmb3IgSlNYLCBpdOKAmXMgZmluZSBmb3Igbm93LCBidXQgcGVyaGFwcyBiZXR0ZXJcbi8vIHRoZXJlLlxuLyoqXG4gKiBAcGFyYW0ge01keEpzeEZsb3dFbGVtZW50fSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGZsb3cgbm9kZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge1JldHVyblR5cGU8VHJhY2tlclsnY3VycmVudCddPn0gaW5mb1xuICogICBJbmZvIG9uIHdoZXJlIHdlIGFyZSBpbiB0aGUgZG9jdW1lbnQgd2UgYXJlIGdlbmVyYXRpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIGNoaWxkcmVuLCBqb2luZWQgYnkgKGJsYW5rKSBsaW5lcy5cbiAqL1xuZnVuY3Rpb24gY29udGFpbmVyRmxvdyhwYXJlbnQsIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IGluZGV4U3RhY2sgPSBzdGF0ZS5pbmRleFN0YWNrXG4gIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSBjcmVhdGVJbmRlbnQoaW5mZXJEZXB0aChzdGF0ZSkpXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgaW5kZXhTdGFjay5wdXNoKC0xKVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF1cblxuICAgIGluZGV4U3RhY2tbaW5kZXhTdGFjay5sZW5ndGggLSAxXSA9IGluZGV4XG5cbiAgICBjb25zdCBjaGlsZEluZm8gPSB7YmVmb3JlOiAnXFxuJywgYWZ0ZXI6ICdcXG4nLCAuLi50cmFja2VyLmN1cnJlbnQoKX1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRlLmhhbmRsZShjaGlsZCwgcGFyZW50LCBzdGF0ZSwgY2hpbGRJbmZvKVxuXG4gICAgY29uc3Qgc2VyaWFsaXplZENoaWxkID1cbiAgICAgIGNoaWxkLnR5cGUgPT09ICdtZHhKc3hGbG93RWxlbWVudCdcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiBzdGF0ZS5pbmRlbnRMaW5lcyhyZXN1bHQsIGZ1bmN0aW9uIChsaW5lLCBfLCBibGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIChibGFuayA/ICcnIDogY3VycmVudEluZGVudCkgKyBsaW5lXG4gICAgICAgICAgfSlcblxuICAgIHJlc3VsdHMucHVzaCh0cmFja2VyLm1vdmUoc2VyaWFsaXplZENoaWxkKSlcblxuICAgIGlmIChjaGlsZC50eXBlICE9PSAnbGlzdCcpIHtcbiAgICAgIHN0YXRlLmJ1bGxldExhc3RVc2VkID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHRyYWNrZXIubW92ZSgnXFxuXFxuJykpXG4gICAgfVxuICB9XG5cbiAgaW5kZXhTdGFjay5wb3AoKVxuXG4gIHJldHVybiByZXN1bHRzLmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGluZmVyRGVwdGgoc3RhdGUpIHtcbiAgbGV0IGRlcHRoID0gMFxuICBsZXQgaW5kZXggPSBzdGF0ZS5zdGFjay5sZW5ndGhcblxuICB3aGlsZSAoLS1pbmRleCA+IC0xKSB7XG4gICAgY29uc3QgbmFtZSA9IHN0YXRlLnN0YWNrW2luZGV4XVxuXG4gICAgaWYgKG5hbWUgPT09ICdibG9ja3F1b3RlJyB8fCBuYW1lID09PSAnbGlzdEl0ZW0nKSBicmVha1xuICAgIGlmIChuYW1lID09PSAnbWR4SnN4Rmxvd0VsZW1lbnQnKSBkZXB0aCsrXG4gIH1cblxuICByZXR1cm4gZGVwdGhcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGVudChkZXB0aCkge1xuICByZXR1cm4gaW5kZW50LnJlcGVhdChkZXB0aClcbn1cblxuLyoqXG4gKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gcGVla0VsZW1lbnQoKSB7XG4gIHJldHVybiAnPCdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mdast-util-mdx-jsx@3.2.0/node_modules/mdast-util-mdx-jsx/lib/index.js\n");

/***/ })

};
;