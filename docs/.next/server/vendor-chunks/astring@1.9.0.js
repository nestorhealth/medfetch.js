"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/astring@1.9.0";
exports.ids = ["vendor-chunks/astring@1.9.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nconst GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers, attributes } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n\n    if (attributes && attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < attributes.length; i++) {\n        this.ImportAttribute(attributes[i], state)\n        if (i < attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n    state.write(';')\n  },\n  ImportAttribute(node, state) {\n    this.Identifier(node.key, state)\n    state.write(': ')\n    this.Literal(node.value, state)\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n\n      if (node.attributes && node.attributes.length > 0) {\n        state.write(' with { ')\n        for (let i = 0; i < node.attributes.length; i++) {\n          this.ImportAttribute(node.attributes[i], state)\n          if (i < node.attributes.length - 1) state.write(', ')\n        }\n\n        state.write(' }')\n      }\n\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n\n    if (node.attributes && node.attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < node.attributes.length; i++) {\n        this.ImportAttribute(node.attributes[i], state)\n        if (i < node.attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nconst baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nfunction generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FzdHJpbmdAMS45LjAvbm9kZV9tb2R1bGVzL2FzdHJpbmcvZGlzdC9hc3RyaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGNBQWMsZUFBZTtBQUM3Qix3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9hc3RyaW5nQDEuOS4wL25vZGVfbW9kdWxlcy9hc3RyaW5nL2Rpc3QvYXN0cmluZy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXN0cmluZyBpcyBhIHRpbnkgYW5kIGZhc3QgSmF2YVNjcmlwdCBjb2RlIGdlbmVyYXRvciBmcm9tIGFuIEVTVHJlZS1jb21wbGlhbnQgQVNULlxuLy9cbi8vIEFzdHJpbmcgd2FzIHdyaXR0ZW4gYnkgRGF2aWQgQm9ubmV0IGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbi8vXG4vLyBUaGUgR2l0IHJlcG9zaXRvcnkgZm9yIEFzdHJpbmcgaXMgYXZhaWxhYmxlIGF0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcuZ2l0XG4vL1xuLy8gUGxlYXNlIHVzZSB0aGUgR2l0SHViIGJ1ZyB0cmFja2VyIHRvIHJlcG9ydCBpc3N1ZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRib25uZXQvYXN0cmluZy9pc3N1ZXNcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IEpTT05cblxuLyogYzggaWdub3JlIGlmICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUucmVwZWF0KSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgaXMgdW5kZWZpbmVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcjaW5zdGFsbGF0aW9uJyxcbiAgKVxufVxuXG4vKiBjOCBpZ25vcmUgaWYgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCkge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggaXMgdW5kZWZpbmVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcjaW5zdGFsbGF0aW9uJyxcbiAgKVxufVxuXG5jb25zdCBPUEVSQVRPUl9QUkVDRURFTkNFID0ge1xuICAnfHwnOiAyLFxuICAnPz8nOiAzLFxuICAnJiYnOiA0LFxuICAnfCc6IDUsXG4gICdeJzogNixcbiAgJyYnOiA3LFxuICAnPT0nOiA4LFxuICAnIT0nOiA4LFxuICAnPT09JzogOCxcbiAgJyE9PSc6IDgsXG4gICc8JzogOSxcbiAgJz4nOiA5LFxuICAnPD0nOiA5LFxuICAnPj0nOiA5LFxuICBpbjogOSxcbiAgaW5zdGFuY2VvZjogOSxcbiAgJzw8JzogMTAsXG4gICc+Pic6IDEwLFxuICAnPj4+JzogMTAsXG4gICcrJzogMTEsXG4gICctJzogMTEsXG4gICcqJzogMTIsXG4gICclJzogMTIsXG4gICcvJzogMTIsXG4gICcqKic6IDEzLFxufVxuXG4vLyBFbmFibGVzIHBhcmVudGhlc2lzIHJlZ2FyZGxlc3Mgb2YgcHJlY2VkZW5jZVxuZXhwb3J0IGNvbnN0IE5FRURTX1BBUkVOVEhFU0VTID0gMTdcblxuZXhwb3J0IGNvbnN0IEVYUFJFU1NJT05TX1BSRUNFREVOQ0UgPSB7XG4gIC8vIERlZmluaXRpb25zXG4gIEFycmF5RXhwcmVzc2lvbjogMjAsXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogMjAsXG4gIFRoaXNFeHByZXNzaW9uOiAyMCxcbiAgSWRlbnRpZmllcjogMjAsXG4gIFByaXZhdGVJZGVudGlmaWVyOiAyMCxcbiAgTGl0ZXJhbDogMTgsXG4gIFRlbXBsYXRlTGl0ZXJhbDogMjAsXG4gIFN1cGVyOiAyMCxcbiAgU2VxdWVuY2VFeHByZXNzaW9uOiAyMCxcbiAgLy8gT3BlcmF0aW9uc1xuICBNZW1iZXJFeHByZXNzaW9uOiAxOSxcbiAgQ2hhaW5FeHByZXNzaW9uOiAxOSxcbiAgQ2FsbEV4cHJlc3Npb246IDE5LFxuICBOZXdFeHByZXNzaW9uOiAxOSxcbiAgLy8gT3RoZXIgZGVmaW5pdGlvbnNcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBDbGFzc0V4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBPYmplY3RFeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgLy8gT3RoZXIgb3BlcmF0aW9uc1xuICBVcGRhdGVFeHByZXNzaW9uOiAxNixcbiAgVW5hcnlFeHByZXNzaW9uOiAxNSxcbiAgQXdhaXRFeHByZXNzaW9uOiAxNSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogMTQsXG4gIExvZ2ljYWxFeHByZXNzaW9uOiAxMyxcbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiA0LFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogMyxcbiAgWWllbGRFeHByZXNzaW9uOiAyLFxuICBSZXN0RWxlbWVudDogMSxcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGVzKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgYSBzZXF1ZW5jZSBvZiBgbm9kZXNgLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgc3RhdGUud3JpdGUoJygnKVxuICBpZiAobm9kZXMgIT0gbnVsbCAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgZ2VuZXJhdG9yW25vZGVzWzBdLnR5cGVdKG5vZGVzWzBdLCBzdGF0ZSlcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IG5vZGVzW2ldXG4gICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgZ2VuZXJhdG9yW3BhcmFtLnR5cGVdKHBhcmFtLCBzdGF0ZSlcbiAgICB9XG4gIH1cbiAgc3RhdGUud3JpdGUoJyknKVxufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpIHtcbiAgY29uc3Qgbm9kZVByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS50eXBlXVxuICBpZiAobm9kZVByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlUHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtwYXJlbnROb2RlLnR5cGVdXG4gIGlmIChub2RlUHJlY2VkZW5jZSAhPT0gcGFyZW50Tm9kZVByZWNlZGVuY2UpIHtcbiAgICAvLyBEaWZmZXJlbnQgbm9kZSB0eXBlc1xuICAgIHJldHVybiAoXG4gICAgICAoIWlzUmlnaHRIYW5kICYmXG4gICAgICAgIG5vZGVQcmVjZWRlbmNlID09PSAxNSAmJlxuICAgICAgICBwYXJlbnROb2RlUHJlY2VkZW5jZSA9PT0gMTQgJiZcbiAgICAgICAgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJyoqJykgfHxcbiAgICAgIG5vZGVQcmVjZWRlbmNlIDwgcGFyZW50Tm9kZVByZWNlZGVuY2VcbiAgICApXG4gIH1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlICE9PSAxMyAmJiBub2RlUHJlY2VkZW5jZSAhPT0gMTQpIHtcbiAgICAvLyBOb3QgYSBgTG9naWNhbEV4cHJlc3Npb25gIG9yIGBCaW5hcnlFeHByZXNzaW9uYFxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLm9wZXJhdG9yID09PSAnKionICYmIHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICcqKicpIHtcbiAgICAvLyBFeHBvbmVudGlhdGlvbiBvcGVyYXRvciBoYXMgcmlnaHQtdG8tbGVmdCBhc3NvY2lhdGl2aXR5XG4gICAgcmV0dXJuICFpc1JpZ2h0SGFuZFxuICB9XG4gIGlmIChcbiAgICBub2RlUHJlY2VkZW5jZSA9PT0gMTMgJiZcbiAgICBwYXJlbnROb2RlUHJlY2VkZW5jZSA9PT0gMTMgJiZcbiAgICAobm9kZS5vcGVyYXRvciA9PT0gJz8/JyB8fCBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnPz8nKVxuICApIHtcbiAgICAvLyBOdWxsaXNoIGNvYWxlc2NpbmcgYW5kIGJvb2xlYW4gb3BlcmF0b3JzIGNhbm5vdCBiZSBjb21iaW5lZFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmlnaHRIYW5kKSB7XG4gICAgLy8gUGFyZW50aGVzaXMgYXJlIHVzZWQgaWYgYm90aCBvcGVyYXRvcnMgaGF2ZSB0aGUgc2FtZSBwcmVjZWRlbmNlXG4gICAgcmV0dXJuIChcbiAgICAgIE9QRVJBVE9SX1BSRUNFREVOQ0Vbbm9kZS5vcGVyYXRvcl0gPD1cbiAgICAgIE9QRVJBVE9SX1BSRUNFREVOQ0VbcGFyZW50Tm9kZS5vcGVyYXRvcl1cbiAgICApXG4gIH1cbiAgcmV0dXJuIChcbiAgICBPUEVSQVRPUl9QUkVDRURFTkNFW25vZGUub3BlcmF0b3JdIDxcbiAgICBPUEVSQVRPUl9QUkVDRURFTkNFW3BhcmVudE5vZGUub3BlcmF0b3JdXG4gIClcbn1cblxuZnVuY3Rpb24gZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgcHJvdmlkZWQgYG5vZGVgLCBhZGRpbmcgcGFyZW50aGVzaXMgYXJvdW5kIGlmIHRoZSBwcm92aWRlZCBgcGFyZW50Tm9kZWAgbmVlZHMgaXQuIElmIGBub2RlYCBpcyBhIHJpZ2h0LWhhbmQgYXJndW1lbnQsIHRoZSBwcm92aWRlZCBgaXNSaWdodEhhbmRgIHBhcmFtZXRlciBzaG91bGQgYmUgYHRydWVgLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgaWYgKGV4cHJlc3Npb25OZWVkc1BhcmVudGhlc2lzKHN0YXRlLCBub2RlLCBwYXJlbnROb2RlLCBpc1JpZ2h0SGFuZCkpIHtcbiAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgZ2VuZXJhdG9yW25vZGUudHlwZV0obm9kZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyknKVxuICB9IGVsc2Uge1xuICAgIGdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlaW5kZW50KHN0YXRlLCB0ZXh0LCBpbmRlbnQsIGxpbmVFbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgYHRleHRgIHN0cmluZyByZWluZGVudGVkIHdpdGggdGhlIHByb3ZpZGVkIGBpbmRlbnRgLlxuICAqL1xuICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGVuZCA9IGxpbmVzLmxlbmd0aCAtIDFcbiAgc3RhdGUud3JpdGUobGluZXNbMF0udHJpbSgpKVxuICBpZiAoZW5kID4gMCkge1xuICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgbGluZXNbaV0udHJpbSgpICsgbGluZUVuZClcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoaW5kZW50ICsgbGluZXNbZW5kXS50cmltKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Q29tbWVudHMoc3RhdGUsIGNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgcHJvdmlkZWQgbGlzdCBvZiBgY29tbWVudHNgLCB3aXRoIHRoZSBnaXZlbiBgaW5kZW50YCBhbmQgYGxpbmVFbmRgIHN0cmluZ3MuXG4gIExpbmUgY29tbWVudHMgd2lsbCBlbmQgd2l0aCBgXCJcXG5cImAgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYGxpbmVFbmRgLlxuICBFeHBlY3RzIHRvIHN0YXJ0IG9uIGEgbmV3IHVuaW5kZW50ZWQgbGluZS5cbiAgKi9cbiAgY29uc3QgeyBsZW5ndGggfSA9IGNvbW1lbnRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV1cbiAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgaWYgKGNvbW1lbnQudHlwZVswXSA9PT0gJ0wnKSB7XG4gICAgICAvLyBMaW5lIGNvbW1lbnRcbiAgICAgIHN0YXRlLndyaXRlKCcvLyAnICsgY29tbWVudC52YWx1ZS50cmltKCkgKyAnXFxuJywgY29tbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmxvY2sgY29tbWVudFxuICAgICAgc3RhdGUud3JpdGUoJy8qJylcbiAgICAgIHJlaW5kZW50KHN0YXRlLCBjb21tZW50LnZhbHVlLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgICBzdGF0ZS53cml0ZSgnKi8nICsgbGluZUVuZClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAvKlxuICBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvdmlkZWQgYG5vZGVgIGNvbnRhaW5zIGEgY2FsbCBleHByZXNzaW9uIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgKi9cbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVxuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gY3VycmVudE5vZGVcbiAgICBpZiAodHlwZVswXSA9PT0gJ0MnICYmIHR5cGVbMV0gPT09ICdhJykge1xuICAgICAgLy8gSXMgQ2FsbEV4cHJlc3Npb25cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmICh0eXBlWzBdID09PSAnTScgJiYgdHlwZVsxXSA9PT0gJ2UnICYmIHR5cGVbMl0gPT09ICdtJykge1xuICAgICAgLy8gSXMgTWVtYmVyRXhwcmVzc2lvblxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5vYmplY3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIG5vZGUpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IG5vZGVcbiAgc3RhdGUud3JpdGUobm9kZS5raW5kICsgJyAnKVxuICBjb25zdCB7IGxlbmd0aCB9ID0gZGVjbGFyYXRpb25zXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgZ2VuZXJhdG9yLlZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXJhdGlvbnNbMF0sIHN0YXRlKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICBnZW5lcmF0b3IuVmFyaWFibGVEZWNsYXJhdG9yKGRlY2xhcmF0aW9uc1tpXSwgc3RhdGUpXG4gICAgfVxuICB9XG59XG5cbmxldCBGb3JJblN0YXRlbWVudCxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgUmVzdEVsZW1lbnQsXG4gIEJpbmFyeUV4cHJlc3Npb24sXG4gIEFycmF5RXhwcmVzc2lvbixcbiAgQmxvY2tTdGF0ZW1lbnRcblxuZXhwb3J0IGNvbnN0IEdFTkVSQVRPUiA9IHtcbiAgLypcbiAgRGVmYXVsdCBnZW5lcmF0b3IuXG4gICovXG4gIFByb2dyYW0obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgfVxuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBub2RlLmJvZHlcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RhdGVtZW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV1cbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHN0YXRlbWVudC5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKGluZGVudClcbiAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgIH1cbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgfSxcbiAgQmxvY2tTdGF0ZW1lbnQ6IChCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGluZGVudCA9IHN0YXRlLmluZGVudC5yZXBlYXQoc3RhdGUuaW5kZW50TGV2ZWwrKylcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgY29uc3Qgc3RhdGVtZW50SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBub2RlLmJvZHlcbiAgICBpZiAoc3RhdGVtZW50cyAhPSBudWxsICYmIHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHN0YXRlbWVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShzdGF0ZW1lbnRJbmRlbnQpXG4gICAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0pLFxuICBDbGFzc0JvZHk6IEJsb2NrU3RhdGVtZW50LFxuICBTdGF0aWNCbG9jayhub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdGF0aWMgJylcbiAgICB0aGlzLkJsb2NrU3RhdGVtZW50KG5vZGUsIHN0YXRlKVxuICB9LFxuICBFbXB0eVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5leHByZXNzaW9uLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIChwcmVjZWRlbmNlID09PSAzICYmIG5vZGUuZXhwcmVzc2lvbi5sZWZ0LnR5cGVbMF0gPT09ICdPJylcbiAgICApIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgaGF2ZSBwYXJlbnRoZXNlcyBvciBpcyBhbiBBc3NpZ25tZW50RXhwcmVzc2lvbiB0byBhbiBPYmplY3RQYXR0ZXJuXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuZXhwcmVzc2lvbi50eXBlXShub2RlLmV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuZXhwcmVzc2lvbi50eXBlXShub2RlLmV4cHJlc3Npb24sIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIElmU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2lmICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuY29uc2VxdWVudC50eXBlXShub2RlLmNvbnNlcXVlbnQsIHN0YXRlKVxuICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnIGVsc2UgJylcbiAgICAgIHRoaXNbbm9kZS5hbHRlcm5hdGUudHlwZV0obm9kZS5hbHRlcm5hdGUsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgTGFiZWxlZFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5sYWJlbC50eXBlXShub2RlLmxhYmVsLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOiAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIEJyZWFrU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2JyZWFrJylcbiAgICBpZiAobm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnY29udGludWUnKVxuICAgIGlmIChub2RlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5sYWJlbC50eXBlXShub2RlLmxhYmVsLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBXaXRoU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3dpdGggKCcpXG4gICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBTd2l0Y2hTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIHN0YXRlLmluZGVudExldmVsKytcbiAgICBjb25zdCBjYXNlSW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgY29uc3Qgc3RhdGVtZW50SW5kZW50ID0gY2FzZUluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCdzd2l0Y2ggKCcpXG4gICAgdGhpc1tub2RlLmRpc2NyaW1pbmFudC50eXBlXShub2RlLmRpc2NyaW1pbmFudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgeycgKyBsaW5lRW5kKVxuICAgIGNvbnN0IHsgY2FzZXM6IG9jY3VyZW5jZXMgfSA9IG5vZGVcbiAgICBjb25zdCB7IGxlbmd0aDogb2NjdXJlbmNlc0NvdW50IH0gPSBvY2N1cmVuY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvY2N1cmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgb2NjdXJlbmNlID0gb2NjdXJlbmNlc1tpXVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgb2NjdXJlbmNlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG9jY3VyZW5jZS5jb21tZW50cywgY2FzZUluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGlmIChvY2N1cmVuY2UudGVzdCkge1xuICAgICAgICBzdGF0ZS53cml0ZShjYXNlSW5kZW50ICsgJ2Nhc2UgJylcbiAgICAgICAgdGhpc1tvY2N1cmVuY2UudGVzdC50eXBlXShvY2N1cmVuY2UudGVzdCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCc6JyArIGxpbmVFbmQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZShjYXNlSW5kZW50ICsgJ2RlZmF1bHQ6JyArIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvbnNlcXVlbnQgfSA9IG9jY3VyZW5jZVxuICAgICAgY29uc3QgeyBsZW5ndGg6IGNvbnNlcXVlbnRDb3VudCB9ID0gY29uc2VxdWVudFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zZXF1ZW50Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBjb25zZXF1ZW50W2ldXG4gICAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHN0YXRlbWVudC5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIHN0YXRlbWVudC5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKHN0YXRlbWVudEluZGVudClcbiAgICAgICAgdGhpc1tzdGF0ZW1lbnQudHlwZV0oc3RhdGVtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuaW5kZW50TGV2ZWwgLT0gMlxuICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgfSxcbiAgUmV0dXJuU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3JldHVybicpXG4gICAgaWYgKG5vZGUuYXJndW1lbnQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBUaHJvd1N0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd0aHJvdyAnKVxuICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFRyeVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd0cnkgJylcbiAgICB0aGlzW25vZGUuYmxvY2sudHlwZV0obm9kZS5ibG9jaywgc3RhdGUpXG4gICAgaWYgKG5vZGUuaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBoYW5kbGVyIH0gPSBub2RlXG4gICAgICBpZiAoaGFuZGxlci5wYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgY2F0Y2ggJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgY2F0Y2ggKCcpXG4gICAgICAgIHRoaXNbaGFuZGxlci5wYXJhbS50eXBlXShoYW5kbGVyLnBhcmFtLCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJykgJylcbiAgICAgIH1cbiAgICAgIHRoaXNbaGFuZGxlci5ib2R5LnR5cGVdKGhhbmRsZXIuYm9keSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLmZpbmFsaXplcikge1xuICAgICAgc3RhdGUud3JpdGUoJyBmaW5hbGx5ICcpXG4gICAgICB0aGlzW25vZGUuZmluYWxpemVyLnR5cGVdKG5vZGUuZmluYWxpemVyLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFdoaWxlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3doaWxlICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBEb1doaWxlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2RvICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIHdoaWxlICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyk7JylcbiAgfSxcbiAgRm9yU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2ZvciAoJylcbiAgICBpZiAobm9kZS5pbml0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gbm9kZVxuICAgICAgaWYgKGluaXQudHlwZVswXSA9PT0gJ1YnKSB7XG4gICAgICAgIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIGluaXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2luaXQudHlwZV0oaW5pdCwgc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7ICcpXG4gICAgaWYgKG5vZGUudGVzdCkge1xuICAgICAgdGhpc1tub2RlLnRlc3QudHlwZV0obm9kZS50ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsgJylcbiAgICBpZiAobm9kZS51cGRhdGUpIHtcbiAgICAgIHRoaXNbbm9kZS51cGRhdGUudHlwZV0obm9kZS51cGRhdGUsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIEZvckluU3RhdGVtZW50OiAoRm9ySW5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShgZm9yICR7bm9kZS5hd2FpdCA/ICdhd2FpdCAnIDogJyd9KGApXG4gICAgY29uc3QgeyBsZWZ0IH0gPSBub2RlXG4gICAgaWYgKGxlZnQudHlwZVswXSA9PT0gJ1YnKSB7XG4gICAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBsZWZ0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2xlZnQudHlwZV0obGVmdCwgc3RhdGUpXG4gICAgfVxuICAgIC8vIElkZW50aWZ5aW5nIHdoZXRoZXIgbm9kZS50eXBlIGlzIGBGb3JJblN0YXRlbWVudGAgb3IgYEZvck9mU3RhdGVtZW50YFxuICAgIHN0YXRlLndyaXRlKG5vZGUudHlwZVszXSA9PT0gJ0knID8gJyBpbiAnIDogJyBvZiAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0pLFxuICBGb3JPZlN0YXRlbWVudDogRm9ySW5TdGF0ZW1lbnQsXG4gIERlYnVnZ2VyU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2RlYnVnZ2VyOycsIG5vZGUpXG4gIH0sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IChGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoXG4gICAgICAobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycpICtcbiAgICAgICAgKG5vZGUuZ2VuZXJhdG9yID8gJ2Z1bmN0aW9uKiAnIDogJ2Z1bmN0aW9uICcpICtcbiAgICAgICAgKG5vZGUuaWQgPyBub2RlLmlkLm5hbWUgOiAnJyksXG4gICAgICBub2RlLFxuICAgIClcbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZS5wYXJhbXMpXG4gICAgc3RhdGUud3JpdGUoJyAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0pLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBub2RlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmlkLnR5cGVdKG5vZGUuaWQsIHN0YXRlKVxuICAgIGlmIChub2RlLmluaXQgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyA9ICcpXG4gICAgICB0aGlzW25vZGUuaW5pdC50eXBlXShub2RlLmluaXQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdjbGFzcyAnICsgKG5vZGUuaWQgPyBgJHtub2RlLmlkLm5hbWV9IGAgOiAnJyksIG5vZGUpXG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcykge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4dGVuZHMgJylcbiAgICAgIGNvbnN0IHsgc3VwZXJDbGFzcyB9ID0gbm9kZVxuICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdXBlckNsYXNzXG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3R5cGVdXG4gICAgICBpZiAoXG4gICAgICAgICh0eXBlWzBdICE9PSAnQycgfHwgdHlwZVsxXSAhPT0gJ2wnIHx8IHR5cGVbNV0gIT09ICdFJykgJiZcbiAgICAgICAgKHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICAgICAgcHJlY2VkZW5jZSA8IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5DbGFzc0V4cHJlc3Npb24pXG4gICAgICApIHtcbiAgICAgICAgLy8gTm90IGEgQ2xhc3NFeHByZXNzaW9uIHRoYXQgbmVlZHMgcGFyZW50aGVzZXNcbiAgICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgICB0aGlzW25vZGUuc3VwZXJDbGFzcy50eXBlXShzdXBlckNsYXNzLCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzdXBlckNsYXNzLnR5cGVdKHN1cGVyQ2xhc3MsIHN0YXRlKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgIH1cbiAgICB0aGlzLkNsYXNzQm9keShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBJbXBvcnREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpbXBvcnQgJylcbiAgICBjb25zdCB7IHNwZWNpZmllcnMsIGF0dHJpYnV0ZXMgfSA9IG5vZGVcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3BlY2lmaWVyc1xuICAgIC8vIFRPRE86IE9uY2UgYmFiaWxpIGlzIGZpeGVkLCBwdXQgdGhpcyBhZnRlciBjb25kaXRpb25cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiaWxpL2lzc3Vlcy80MzBcbiAgICBsZXQgaSA9IDBcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICkge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgY29uc3QgdHlwZSA9IHNwZWNpZmllci50eXBlWzZdXG4gICAgICAgIGlmICh0eXBlID09PSAnRCcpIHtcbiAgICAgICAgICAvLyBJbXBvcnREZWZhdWx0U3BlY2lmaWVyXG4gICAgICAgICAgc3RhdGUud3JpdGUoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTicpIHtcbiAgICAgICAgICAvLyBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnKiBhcyAnICsgc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbXBvcnRTcGVjaWZpZXJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzcGVjaWZpZXIuaW1wb3J0ZWRcbiAgICAgICAgICBzdGF0ZS53cml0ZShuYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaWYgKG5hbWUgIT09IHNwZWNpZmllci5sb2NhbC5uYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnIGFzICcgKyBzcGVjaWZpZXIubG9jYWwubmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJyBmcm9tICcpXG4gICAgfVxuICAgIHRoaXMuTGl0ZXJhbChub2RlLnNvdXJjZSwgc3RhdGUpXG5cbiAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgd2l0aCB7ICcpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5JbXBvcnRBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXSwgc3RhdGUpXG4gICAgICAgIGlmIChpIDwgYXR0cmlidXRlcy5sZW5ndGggLSAxKSBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS53cml0ZSgnIH0nKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIEltcG9ydEF0dHJpYnV0ZShub2RlLCBzdGF0ZSkge1xuICAgIHRoaXMuSWRlbnRpZmllcihub2RlLmtleSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzogJylcbiAgICB0aGlzLkxpdGVyYWwobm9kZS52YWx1ZSwgc3RhdGUpXG4gIH0sXG4gIEltcG9ydEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaW1wb3J0KCcpXG4gICAgdGhpc1tub2RlLnNvdXJjZS50eXBlXShub2RlLnNvdXJjZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyknKVxuICB9LFxuICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZXhwb3J0IGRlZmF1bHQgJylcbiAgICB0aGlzW25vZGUuZGVjbGFyYXRpb24udHlwZV0obm9kZS5kZWNsYXJhdGlvbiwgc3RhdGUpXG4gICAgaWYgKFxuICAgICAgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuZGVjbGFyYXRpb24udHlwZV0gIT0gbnVsbCAmJlxuICAgICAgbm9kZS5kZWNsYXJhdGlvbi50eXBlWzBdICE9PSAnRidcbiAgICApIHtcbiAgICAgIC8vIEFsbCBleHByZXNzaW9uIG5vZGVzIGV4Y2VwdCBgRnVuY3Rpb25FeHByZXNzaW9uYFxuICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgIH1cbiAgfSxcbiAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdleHBvcnQgJylcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgdGhpc1tub2RlLmRlY2xhcmF0aW9uLnR5cGVdKG5vZGUuZGVjbGFyYXRpb24sIHN0YXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgICBjb25zdCB7IHNwZWNpZmllcnMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBzcGVjaWZpZXJzXG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgOyApIHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzcGVjaWZpZXIubG9jYWxcbiAgICAgICAgICBzdGF0ZS53cml0ZShuYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaWYgKG5hbWUgIT09IHNwZWNpZmllci5leHBvcnRlZC5uYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnIGFzICcgKyBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGZyb20gJylcbiAgICAgICAgdGhpcy5MaXRlcmFsKG5vZGUuc291cmNlLCBzdGF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIHdpdGggeyAnKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuSW1wb3J0QXR0cmlidXRlKG5vZGUuYXR0cmlidXRlc1tpXSwgc3RhdGUpXG4gICAgICAgICAgaWYgKGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMSkgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLndyaXRlKCcgfScpXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICB9XG4gIH0sXG4gIEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUuZXhwb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAqIGFzICcgKyBub2RlLmV4cG9ydGVkLm5hbWUgKyAnIGZyb20gJylcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAqIGZyb20gJylcbiAgICB9XG4gICAgdGhpcy5MaXRlcmFsKG5vZGUuc291cmNlLCBzdGF0ZSlcblxuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgd2l0aCB7ICcpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLkltcG9ydEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0sIHN0YXRlKVxuICAgICAgICBpZiAoaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGggLSAxKSBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS53cml0ZSgnIH0nKVxuICAgIH1cblxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kWzBdXG4gICAgaWYgKGtpbmQgPT09ICdnJyB8fCBraW5kID09PSAncycpIHtcbiAgICAgIC8vIEdldHRlciBvciBzZXR0ZXJcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUuYXN5bmMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdhc3luYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcqJylcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUudmFsdWUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUudmFsdWUuYm9keS50eXBlXShub2RlLnZhbHVlLmJvZHksIHN0YXRlKVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzLkNsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpXG4gIH0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycsIG5vZGUpXG4gICAgY29uc3QgeyBwYXJhbXMgfSA9IG5vZGVcbiAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcbiAgICAgIC8vIE9taXQgcGFyZW50aGVzaXMgaWYgb25seSBvbmUgbmFtZWQgcGFyYW1ldGVyXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0udHlwZVswXSA9PT0gJ0knKSB7XG4gICAgICAgIC8vIElmIHBhcmFtc1swXS50eXBlWzBdIHN0YXJ0cyB3aXRoICdJJywgaXQgY2FuJ3QgYmUgYEltcG9ydERlY2xhcmF0aW9uYCBub3IgYElmU3RhdGVtZW50YCBhbmQgdGh1cyBpcyBgSWRlbnRpZmllcmBcbiAgICAgICAgc3RhdGUud3JpdGUocGFyYW1zWzBdLm5hbWUsIHBhcmFtc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnBhcmFtcylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA9PiAnKVxuICAgIGlmIChub2RlLmJvZHkudHlwZVswXSA9PT0gJ08nKSB7XG4gICAgICAvLyBCb2R5IGlzIGFuIG9iamVjdCBleHByZXNzaW9uXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzLk9iamVjdEV4cHJlc3Npb24obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFRoaXNFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3RoaXMnLCBub2RlKVxuICB9LFxuICBTdXBlcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdXBlcicsIG5vZGUpXG4gIH0sXG4gIFJlc3RFbGVtZW50OiAoUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnLi4uJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gIH0pLFxuICBTcHJlYWRFbGVtZW50OiBSZXN0RWxlbWVudCxcbiAgWWllbGRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5kZWxlZ2F0ZSA/ICd5aWVsZConIDogJ3lpZWxkJylcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQXdhaXRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2F3YWl0ICcsIG5vZGUpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5hcmd1bWVudCwgbm9kZSlcbiAgfSxcbiAgVGVtcGxhdGVMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBxdWFzaXMsIGV4cHJlc3Npb25zIH0gPSBub2RlXG4gICAgc3RhdGUud3JpdGUoJ2AnKVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBleHByZXNzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXVxuICAgICAgY29uc3QgcXVhc2kgPSBxdWFzaXNbaV1cbiAgICAgIHN0YXRlLndyaXRlKHF1YXNpLnZhbHVlLnJhdywgcXVhc2kpXG4gICAgICBzdGF0ZS53cml0ZSgnJHsnKVxuICAgICAgdGhpc1tleHByZXNzaW9uLnR5cGVdKGV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBjb25zdCBxdWFzaSA9IHF1YXNpc1txdWFzaXMubGVuZ3RoIC0gMV1cbiAgICBzdGF0ZS53cml0ZShxdWFzaS52YWx1ZS5yYXcsIHF1YXNpKVxuICAgIHN0YXRlLndyaXRlKCdgJylcbiAgfSxcbiAgVGVtcGxhdGVFbGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS52YWx1ZS5yYXcsIG5vZGUpXG4gIH0sXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUudGFnLCBub2RlKVxuICAgIHRoaXNbbm9kZS5xdWFzaS50eXBlXShub2RlLnF1YXNpLCBzdGF0ZSlcbiAgfSxcbiAgQXJyYXlFeHByZXNzaW9uOiAoQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgZWxlbWVudHMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBlbGVtZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpc1tlbGVtZW50LnR5cGVdKGVsZW1lbnQsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ10nKVxuICB9KSxcbiAgQXJyYXlQYXR0ZXJuOiBBcnJheUV4cHJlc3Npb24sXG4gIE9iamVjdEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BlcnR5SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYSA9ICcsJyArIGxpbmVFbmRcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgcHJvcGVydHkuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBwcm9wZXJ0eS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocHJvcGVydHlJbmRlbnQpXG4gICAgICAgIHRoaXNbcHJvcGVydHkudHlwZV0ocHJvcGVydHksIHN0YXRlKVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoY29tbWEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgIH0gZWxzZSBpZiAod3JpdGVDb21tZW50cykge1xuICAgICAgaWYgKG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0sXG4gIFByb3BlcnR5KG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kIHx8IG5vZGUua2luZFswXSAhPT0gJ2knKSB7XG4gICAgICAvLyBFaXRoZXIgYSBtZXRob2Qgb3Igb2Yga2luZCBgc2V0YCBvciBgZ2V0YCAobm90IGBpbml0YClcbiAgICAgIHRoaXMuTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFub2RlLnNob3J0aGFuZCkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJzogJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS52YWx1ZS50eXBlXShub2RlLnZhbHVlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFByb3BlcnR5RGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIH1cbiAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5rZXkudHlwZVswXSAhPT0gJ0YnKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICB0aGlzW25vZGUudmFsdWUudHlwZV0obm9kZS52YWx1ZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBPYmplY3RQYXR0ZXJuKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydGllc1tpXS50eXBlXShwcm9wZXJ0aWVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gIH0sXG4gIFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLmV4cHJlc3Npb25zKVxuICB9LFxuICBVbmFyeUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgIGFyZ3VtZW50LFxuICAgICAgICBhcmd1bWVudDogeyB0eXBlIH0sXG4gICAgICB9ID0gbm9kZVxuICAgICAgc3RhdGUud3JpdGUob3BlcmF0b3IpXG4gICAgICBjb25zdCBuZWVkc1BhcmVudGhlc2VzID0gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIGFyZ3VtZW50LCBub2RlKVxuICAgICAgaWYgKFxuICAgICAgICAhbmVlZHNQYXJlbnRoZXNlcyAmJlxuICAgICAgICAob3BlcmF0b3IubGVuZ3RoID4gMSB8fFxuICAgICAgICAgICh0eXBlWzBdID09PSAnVScgJiZcbiAgICAgICAgICAgICh0eXBlWzFdID09PSAnbicgfHwgdHlwZVsxXSA9PT0gJ3AnKSAmJlxuICAgICAgICAgICAgYXJndW1lbnQucHJlZml4ICYmXG4gICAgICAgICAgICBhcmd1bWVudC5vcGVyYXRvclswXSA9PT0gb3BlcmF0b3IgJiZcbiAgICAgICAgICAgIChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnLScpKSlcbiAgICAgICkge1xuICAgICAgICAvLyBMYXJnZSBvcGVyYXRvciBvciBhcmd1bWVudCBpcyBVbmFyeUV4cHJlc3Npb24gb3IgVXBkYXRlRXhwcmVzc2lvbiBub2RlXG4gICAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1BhcmVudGhlc2VzKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZXJhdG9yLmxlbmd0aCA+IDEgPyAnICgnIDogJygnKVxuICAgICAgICB0aGlzW3R5cGVdKGFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1t0eXBlXShhcmd1bWVudCwgc3RhdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGNhc2UgbmV2ZXIgb2NjdXJzXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgIH1cbiAgfSxcbiAgVXBkYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIC8vIEFsd2F5cyBhcHBsaWVkIHRvIGlkZW50aWZpZXJzIG9yIG1lbWJlcnMsIG5vIHBhcmVudGhlc2lzIGNoZWNrIG5lZWRlZFxuICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICB9XG4gIH0sXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxlZnQudHlwZV0obm9kZS5sZWZ0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnICcgKyBub2RlLm9wZXJhdG9yICsgJyAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQXNzaWdubWVudFBhdHRlcm4obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGVmdC50eXBlXShub2RlLmxlZnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogKEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpc0luID0gbm9kZS5vcGVyYXRvciA9PT0gJ2luJ1xuICAgIGlmIChpc0luKSB7XG4gICAgICAvLyBBdm9pZHMgY29uZnVzaW9uIGluIGBmb3JgIGxvb3BzIGluaXRpYWxpemVyc1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgIH1cbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLmxlZnQsIG5vZGUsIGZhbHNlKVxuICAgIHN0YXRlLndyaXRlKCcgJyArIG5vZGUub3BlcmF0b3IgKyAnICcpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5yaWdodCwgbm9kZSwgdHJ1ZSlcbiAgICBpZiAoaXNJbikge1xuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH1cbiAgfSksXG4gIExvZ2ljYWxFeHByZXNzaW9uOiBCaW5hcnlFeHByZXNzaW9uLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHRlc3QgfSA9IG5vZGVcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3Rlc3QudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8PSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW3Rlc3QudHlwZV0odGVzdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbdGVzdC50eXBlXSh0ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA/ICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIDogJylcbiAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgfSxcbiAgTmV3RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCduZXcgJylcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuY2FsbGVlLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUuY2FsbGVlKVxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmNhbGxlZS50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNhbGxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENoYWluRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gIH0sXG4gIE1lbWJlckV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUub2JqZWN0LnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuTWVtYmVyRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcuJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUubWV0YS5uYW1lICsgJy4nICsgbm9kZS5wcm9wZXJ0eS5uYW1lLCBub2RlKVxuICB9LFxuICBJZGVudGlmaWVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5uYW1lLCBub2RlKVxuICB9LFxuICBQcml2YXRlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKGAjJHtub2RlLm5hbWV9YCwgbm9kZSlcbiAgfSxcbiAgTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnJhdyAhPSBudWxsKSB7XG4gICAgICAvLyBOb24tc3RhbmRhcmQgcHJvcGVydHlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUucmF3LCBub2RlKVxuICAgIH0gZWxzZSBpZiAobm9kZS5yZWdleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLlJlZ0V4cExpdGVyYWwobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLmJpZ2ludCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZShub2RlLmJpZ2ludCArICduJywgbm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoc3RyaW5naWZ5KG5vZGUudmFsdWUpLCBub2RlKVxuICAgIH1cbiAgfSxcbiAgUmVnRXhwTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgcmVnZXggfSA9IG5vZGVcbiAgICBzdGF0ZS53cml0ZShgLyR7cmVnZXgucGF0dGVybn0vJHtyZWdleC5mbGFnc31gLCBub2RlKVxuICB9LFxufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fVxuXG4vKlxuREVQUkVDQVRFRDogQWx0ZXJuYXRlIGV4cG9ydCBvZiBgR0VORVJBVE9SYC5cbiovXG5leHBvcnQgY29uc3QgYmFzZUdlbmVyYXRvciA9IEdFTkVSQVRPUlxuXG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXR1cCA9IG9wdGlvbnMgPT0gbnVsbCA/IEVNUFRZX09CSkVDVCA6IG9wdGlvbnNcbiAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgLy8gRnVuY3Rpb25hbCBvcHRpb25zXG4gICAgaWYgKHNldHVwLm91dHB1dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm91dHB1dCA9IHNldHVwLm91dHB1dFxuICAgICAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGVUb1N0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdG9yID0gc2V0dXAuZ2VuZXJhdG9yICE9IG51bGwgPyBzZXR1cC5nZW5lcmF0b3IgOiBHRU5FUkFUT1JcbiAgICB0aGlzLmV4cHJlc3Npb25zUHJlY2VkZW5jZSA9XG4gICAgICBzZXR1cC5leHByZXNzaW9uc1ByZWNlZGVuY2UgIT0gbnVsbFxuICAgICAgICA/IHNldHVwLmV4cHJlc3Npb25zUHJlY2VkZW5jZVxuICAgICAgICA6IEVYUFJFU1NJT05TX1BSRUNFREVOQ0VcbiAgICAvLyBGb3JtYXRpbmcgc2V0dXBcbiAgICB0aGlzLmluZGVudCA9IHNldHVwLmluZGVudCAhPSBudWxsID8gc2V0dXAuaW5kZW50IDogJyAgJ1xuICAgIHRoaXMubGluZUVuZCA9IHNldHVwLmxpbmVFbmQgIT0gbnVsbCA/IHNldHVwLmxpbmVFbmQgOiAnXFxuJ1xuICAgIHRoaXMuaW5kZW50TGV2ZWwgPVxuICAgICAgc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCAhPSBudWxsID8gc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCA6IDBcbiAgICB0aGlzLndyaXRlQ29tbWVudHMgPSBzZXR1cC5jb21tZW50cyA/IHNldHVwLmNvbW1lbnRzIDogZmFsc2VcbiAgICAvLyBTb3VyY2UgbWFwXG4gICAgaWYgKHNldHVwLnNvdXJjZU1hcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyaXRlID1cbiAgICAgICAgc2V0dXAub3V0cHV0ID09IG51bGwgPyB0aGlzLndyaXRlQW5kTWFwIDogdGhpcy53cml0ZVRvU3RyZWFtQW5kTWFwXG4gICAgICB0aGlzLnNvdXJjZU1hcCA9IHNldHVwLnNvdXJjZU1hcFxuICAgICAgdGhpcy5saW5lID0gMVxuICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB0aGlzLmxpbmVFbmRTaXplID0gdGhpcy5saW5lRW5kLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxXG4gICAgICB0aGlzLm1hcHBpbmcgPSB7XG4gICAgICAgIG9yaWdpbmFsOiBudWxsLFxuICAgICAgICAvLyBVc2VzIHRoZSBlbnRpcmUgc3RhdGUgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcGhlbWVyYWwgb2JqZWN0c1xuICAgICAgICBnZW5lcmF0ZWQ6IHRoaXMsXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc291cmNlOiBzZXR1cC5zb3VyY2VNYXAuZmlsZSB8fCBzZXR1cC5zb3VyY2VNYXAuX2ZpbGUsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd3JpdGUoY29kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IGNvZGVcbiAgfVxuXG4gIHdyaXRlVG9TdHJlYW0oY29kZSkge1xuICAgIHRoaXMub3V0cHV0LndyaXRlKGNvZGUpXG4gIH1cblxuICB3cml0ZUFuZE1hcChjb2RlLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY29kZVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICB3cml0ZVRvU3RyZWFtQW5kTWFwKGNvZGUsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dC53cml0ZShjb2RlKVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICBtYXAoY29kZSwgbm9kZSkge1xuICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZVxuICAgICAgaWYgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzJdID09PSAnbicpIHtcbiAgICAgICAgLy8gTGluZUNvbW1lbnRcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICAgIHRoaXMubGluZSsrXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubG9jICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBtYXBwaW5nIH0gPSB0aGlzXG4gICAgICAgIG1hcHBpbmcub3JpZ2luYWwgPSBub2RlLmxvYy5zdGFydFxuICAgICAgICBtYXBwaW5nLm5hbWUgPSBub2RlLm5hbWVcbiAgICAgICAgdGhpcy5zb3VyY2VNYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSA9PT0gJ1QnICYmIHR5cGVbOF0gPT09ICdFJykgfHxcbiAgICAgICAgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzFdID09PSAnaScgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRlbXBsYXRlRWxlbWVudCBvciBMaXRlcmFsIHN0cmluZyBub2RlXG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2RlXG4gICAgICAgIGxldCB7IGNvbHVtbiwgbGluZSB9ID0gdGhpc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvZGVbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSAwXG4gICAgICAgICAgICBsaW5lKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW5cbiAgICAgICAgdGhpcy5saW5lID0gbGluZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGNvZGVcbiAgICBjb25zdCB7IGxpbmVFbmQgfSA9IHRoaXNcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxpbmVFbmRTaXplID4gMCAmJlxuICAgICAgICAobGluZUVuZC5sZW5ndGggPT09IDFcbiAgICAgICAgICA/IGNvZGVbbGVuZ3RoIC0gMV0gPT09IGxpbmVFbmRcbiAgICAgICAgICA6IGNvZGUuZW5kc1dpdGgobGluZUVuZCkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5saW5lICs9IHRoaXMubGluZUVuZFNpemVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiArPSBsZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSwgb3B0aW9ucykge1xuICAvKlxuICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgY29kZSBvZiB0aGUgcHJvdmlkZWQgQVNUIGBub2RlYC5cbiAgVGhlIGBvcHRpb25zYCBhcmU6XG5cbiAgLSBgaW5kZW50YDogc3RyaW5nIHRvIHVzZSBmb3IgaW5kZW50YXRpb24gKGRlZmF1bHRzIHRvIGDikKPikKNgKVxuICAtIGBsaW5lRW5kYDogc3RyaW5nIHRvIHVzZSBmb3IgbGluZSBlbmRpbmdzIChkZWZhdWx0cyB0byBgXFxuYClcbiAgLSBgc3RhcnRpbmdJbmRlbnRMZXZlbGA6IGluZGVudCBsZXZlbCB0byBzdGFydCBmcm9tIChkZWZhdWx0cyB0byBgMGApXG4gIC0gYGNvbW1lbnRzYDogZ2VuZXJhdGUgY29tbWVudHMgaWYgYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKVxuICAtIGBvdXRwdXRgOiBvdXRwdXQgc3RyZWFtIHRvIHdyaXRlIHRoZSByZW5kZXJlZCBjb2RlIHRvIChkZWZhdWx0cyB0byBgbnVsbGApXG4gIC0gYGdlbmVyYXRvcmA6IGN1c3RvbSBjb2RlIGdlbmVyYXRvciAoZGVmYXVsdHMgdG8gYEdFTkVSQVRPUmApXG4gIC0gYGV4cHJlc3Npb25zUHJlY2VkZW5jZWA6IGN1c3RvbSBtYXAgb2Ygbm9kZSB0eXBlcyBhbmQgdGhlaXIgcHJlY2VkZW5jZSBsZXZlbCAoZGVmYXVsdHMgdG8gYEVYUFJFU1NJT05TX1BSRUNFREVOQ0VgKVxuICAqL1xuICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKVxuICAvLyBUcmF2ZWwgdGhyb3VnaCB0aGUgQVNUIG5vZGUgYW5kIGdlbmVyYXRlIHRoZSBjb2RlXG4gIHN0YXRlLmdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICByZXR1cm4gc3RhdGUub3V0cHV0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs\n");

/***/ })

};
;