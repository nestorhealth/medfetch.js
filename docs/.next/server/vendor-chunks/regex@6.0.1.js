"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regex@6.0.1";
exports.ids = ["vendor-chunks/regex@6.0.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/atomic.js":
/*!**************************************************************************!*\
  !*** ../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/atomic.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atomic: () => (/* binding */ atomic),\n/* harmony export */   possessive: () => (/* binding */ possessive)\n/* harmony export */ });\n/* harmony import */ var _utils_internals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-internals.js */ \"(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/utils-internals.js\");\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regex-utilities */ \"(rsc)/../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\n\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${_utils_internals_js__WEBPACK_IMPORTED_MODULE_0__.noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>â€¦)`.\n@param {string} expression\n@param {import('./regex.js').PluginData} [data]\n@returns {Required<import('./regex.js').PluginResult>}\n*/\nfunction atomic(expression, data) {\n  const hiddenCaptures = data?.hiddenCaptures ?? [];\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  if (!/\\(\\?>/.test(expression)) {\n    return {\n      pattern: expression,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n\n  const aGDelim = '(?>';\n  const emulatedAGDelim = '(?:(?=(';\n  const captureNumMap = [0];\n  const addedHiddenCaptures = [];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            const addedCaptureNum = numCapturesBeforeAG + numAGs;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Wrap the whole substitution (including the\n            // lookahead and following backref) in a noncapturing group to handle following\n            // quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${addedCaptureNum}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            addedHiddenCaptures.push(addedCaptureNum);\n            (0,_utils_internals_js__WEBPACK_IMPORTED_MODULE_0__.incrementIfAtLeast)(hiddenCaptures, addedCaptureNum);\n            if (captureTransfers.size) {\n              const newCaptureTransfers = new Map();\n              captureTransfers.forEach((from, to) => {\n                newCaptureTransfers.set(\n                  to >= addedCaptureNum ? to + 1 : to,\n                  from.map(f => f >= addedCaptureNum ? f + 1 : f)\n                );\n              });\n              captureTransfers = newCaptureTransfers;\n            }\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  // Second pass to adjust numbered backrefs\n  expression = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_1__.replaceUnescaped)(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    regex_utilities__WEBPACK_IMPORTED_MODULE_1__.Context.DEFAULT\n  );\n\n  return {\n    pattern: expression,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {import('./regex.js').PluginResult}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return {\n      pattern: expression,\n    };\n  }\n\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = (0,_utils_internals_js__WEBPACK_IMPORTED_MODULE_0__.spliceStr)(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n\n  return {\n    pattern: expression,\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvYXRvbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Y7QUFDNUI7O0FBRTFELHVFQUF1RSxrRUFBaUIsQ0FBQzs7QUFFekY7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLGlDQUFpQztBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0Isb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkIsRUFBRSxnQkFBZ0I7QUFDekU7QUFDQSxlQUFlLE9BQU8sZ0JBQWdCLElBQUksNEJBQTRCO0FBQ3RFO0FBQ0E7QUFDQSxZQUFZLHVFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0EsZUFBZSxpRUFBZ0I7QUFDL0I7QUFDQTtBQUNBLE1BQU0sZUFBZSwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxLQUFLO0FBQ0wsSUFBSSxvREFBTztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsY0FBYztBQUMzRCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxpQ0FBaUM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUUsTUFBTSxHQUFHLE1BQU0sSUFBSTtBQUN6QztBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBLDZCQUE2QjtBQUM3Qiw4REFBOEQsRUFBRTtBQUNoRTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCLHVCQUF1Qiw4REFBUztBQUNoQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQSw0QkFBNEIsK0JBQStCLEtBQUssbUNBQW1DLEVBQUUsTUFBTSxHQUFHLG1DQUFtQztBQUNqSixZQUFZO0FBQ1osNEJBQTRCLDhDQUE4QyxLQUFLLFVBQVUsRUFBRSxNQUFNLEdBQUcsbUNBQW1DO0FBQ3ZJO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvYXRvbWljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aW5jcmVtZW50SWZBdExlYXN0LCBub25jYXB0dXJpbmdEZWxpbSwgc3BsaWNlU3RyfSBmcm9tICcuL3V0aWxzLWludGVybmFscy5qcyc7XG5pbXBvcnQge0NvbnRleHQsIHJlcGxhY2VVbmVzY2FwZWR9IGZyb20gJ3JlZ2V4LXV0aWxpdGllcyc7XG5cbmNvbnN0IGF0b21pY1BsdWdpblRva2VuID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3YCg/PG5vbmNhcHR1cmluZ1N0YXJ0PiR7bm9uY2FwdHVyaW5nRGVsaW19KXwoPzxjYXB0dXJpbmdTdGFydD5cXCgoPzpcXD88W14+XSs+KT8pfFxcXFw/LmAsICdnc3UnKTtcblxuLyoqXG5BcHBseSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGF0b21pYyBncm91cHM6IGAoPz7igKYpYC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uXG5AcGFyYW0ge2ltcG9ydCgnLi9yZWdleC5qcycpLlBsdWdpbkRhdGF9IFtkYXRhXVxuQHJldHVybnMge1JlcXVpcmVkPGltcG9ydCgnLi9yZWdleC5qcycpLlBsdWdpblJlc3VsdD59XG4qL1xuZnVuY3Rpb24gYXRvbWljKGV4cHJlc3Npb24sIGRhdGEpIHtcbiAgY29uc3QgaGlkZGVuQ2FwdHVyZXMgPSBkYXRhPy5oaWRkZW5DYXB0dXJlcyA/PyBbXTtcbiAgLy8gQ2FwdHVyZSB0cmFuc2ZlciBpcyB1c2VkIGJ5IDxnaXRodWIuY29tL3NsZXZpdGhhbi9vbmlndXJ1bWEtdG8tZXM+XG4gIGxldCBjYXB0dXJlVHJhbnNmZXJzID0gZGF0YT8uY2FwdHVyZVRyYW5zZmVycyA/PyBuZXcgTWFwKCk7XG4gIGlmICghL1xcKFxcPz4vLnRlc3QoZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybjogZXhwcmVzc2lvbixcbiAgICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgICBoaWRkZW5DYXB0dXJlcyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgYUdEZWxpbSA9ICcoPz4nO1xuICBjb25zdCBlbXVsYXRlZEFHRGVsaW0gPSAnKD86KD89KCc7XG4gIGNvbnN0IGNhcHR1cmVOdW1NYXAgPSBbMF07XG4gIGNvbnN0IGFkZGVkSGlkZGVuQ2FwdHVyZXMgPSBbXTtcbiAgbGV0IG51bUNhcHR1cmVzQmVmb3JlQUcgPSAwO1xuICBsZXQgbnVtQUdzID0gMDtcbiAgbGV0IGFHUG9zID0gTmFOO1xuICBsZXQgaGFzUHJvY2Vzc2VkQUc7XG4gIGRvIHtcbiAgICBoYXNQcm9jZXNzZWRBRyA9IGZhbHNlO1xuICAgIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICAgIGxldCBudW1Hcm91cHNPcGVuSW5BRyA9IDA7XG4gICAgbGV0IGluQUcgPSBmYWxzZTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgYXRvbWljUGx1Z2luVG9rZW4ubGFzdEluZGV4ID0gTnVtYmVyLmlzTmFOKGFHUG9zKSA/IDAgOiBhR1BvcyArIGVtdWxhdGVkQUdEZWxpbS5sZW5ndGg7XG4gICAgd2hpbGUgKG1hdGNoID0gYXRvbWljUGx1Z2luVG9rZW4uZXhlYyhleHByZXNzaW9uKSkge1xuICAgICAgY29uc3QgezA6IG0sIGluZGV4LCBncm91cHM6IHtjYXB0dXJpbmdTdGFydCwgbm9uY2FwdHVyaW5nU3RhcnR9fSA9IG1hdGNoO1xuICAgICAgaWYgKG0gPT09ICdbJykge1xuICAgICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuXG4gICAgICAgIGlmIChtID09PSBhR0RlbGltICYmICFpbkFHKSB7XG4gICAgICAgICAgYUdQb3MgPSBpbmRleDtcbiAgICAgICAgICBpbkFHID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbkFHICYmIG5vbmNhcHR1cmluZ1N0YXJ0KSB7XG4gICAgICAgICAgbnVtR3JvdXBzT3BlbkluQUcrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJpbmdTdGFydCkge1xuICAgICAgICAgIGlmIChpbkFHKSB7XG4gICAgICAgICAgICBudW1Hcm91cHNPcGVuSW5BRysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1DYXB0dXJlc0JlZm9yZUFHKys7XG4gICAgICAgICAgICBjYXB0dXJlTnVtTWFwLnB1c2gobnVtQ2FwdHVyZXNCZWZvcmVBRyArIG51bUFHcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICcpJyAmJiBpbkFHKSB7XG4gICAgICAgICAgaWYgKCFudW1Hcm91cHNPcGVuSW5BRykge1xuICAgICAgICAgICAgbnVtQUdzKys7XG4gICAgICAgICAgICBjb25zdCBhZGRlZENhcHR1cmVOdW0gPSBudW1DYXB0dXJlc0JlZm9yZUFHICsgbnVtQUdzO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBgZXhwcmVzc2lvbmAgYW5kIHVzZSBgPCQkTj5gIGFzIGEgdGVtcG9yYXJ5IHdyYXBwZXIgZm9yIHRoZSBiYWNrcmVmIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4gYXZvaWQgYmFja3JlZiByZW51bWJlcmluZyBhZnRlcndhcmQuIFdyYXAgdGhlIHdob2xlIHN1YnN0aXR1dGlvbiAoaW5jbHVkaW5nIHRoZVxuICAgICAgICAgICAgLy8gbG9va2FoZWFkIGFuZCBmb2xsb3dpbmcgYmFja3JlZikgaW4gYSBub25jYXB0dXJpbmcgZ3JvdXAgdG8gaGFuZGxlIGZvbGxvd2luZ1xuICAgICAgICAgICAgLy8gcXVhbnRpZmllcnMgYW5kIGxpdGVyYWwgZGlnaXRzXG4gICAgICAgICAgICBleHByZXNzaW9uID0gYCR7ZXhwcmVzc2lvbi5zbGljZSgwLCBhR1Bvcyl9JHtlbXVsYXRlZEFHRGVsaW19JHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNsaWNlKGFHUG9zICsgYUdEZWxpbS5sZW5ndGgsIGluZGV4KVxuICAgICAgICAgICAgICB9KSk8JCQke2FkZGVkQ2FwdHVyZU51bX0+KSR7ZXhwcmVzc2lvbi5zbGljZShpbmRleCArIDEpfWA7XG4gICAgICAgICAgICBoYXNQcm9jZXNzZWRBRyA9IHRydWU7XG4gICAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLnB1c2goYWRkZWRDYXB0dXJlTnVtKTtcbiAgICAgICAgICAgIGluY3JlbWVudElmQXRMZWFzdChoaWRkZW5DYXB0dXJlcywgYWRkZWRDYXB0dXJlTnVtKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlVHJhbnNmZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FwdHVyZVRyYW5zZmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgY2FwdHVyZVRyYW5zZmVycy5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0NhcHR1cmVUcmFuc2ZlcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgdG8gPj0gYWRkZWRDYXB0dXJlTnVtID8gdG8gKyAxIDogdG8sXG4gICAgICAgICAgICAgICAgICBmcm9tLm1hcChmID0+IGYgPj0gYWRkZWRDYXB0dXJlTnVtID8gZiArIDEgOiBmKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXB0dXJlVHJhbnNmZXJzID0gbmV3Q2FwdHVyZVRyYW5zZmVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1Hcm91cHNPcGVuSW5BRy0tO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ10nKSB7XG4gICAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgICAgfVxuICAgIH1cbiAgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGF0b21pYyBncm91cCdzIGNvbnRlbnRzLCBpbiBjYXNlIHRoZSBwcm9jZXNzZWQgZ3JvdXBcbiAgLy8gY29udGFpbnMgYWRkaXRpb25hbCBhdG9taWMgZ3JvdXBzXG4gIH0gd2hpbGUgKGhhc1Byb2Nlc3NlZEFHKTtcblxuICBoaWRkZW5DYXB0dXJlcy5wdXNoKC4uLmFkZGVkSGlkZGVuQ2FwdHVyZXMpO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkanVzdCBudW1iZXJlZCBiYWNrcmVmc1xuICBleHByZXNzaW9uID0gcmVwbGFjZVVuZXNjYXBlZChcbiAgICBleHByZXNzaW9uLFxuICAgIFN0cmluZy5yYXdgXFxcXCg/PGJhY2tyZWZOdW0+WzEtOV1cXGQqKXw8XFwkXFwkKD88d3JhcHBlZEJhY2tyZWZOdW0+XFxkKyk+YCxcbiAgICAoezA6IG0sIGdyb3Vwczoge2JhY2tyZWZOdW0sIHdyYXBwZWRCYWNrcmVmTnVtfX0pID0+IHtcbiAgICAgIGlmIChiYWNrcmVmTnVtKSB7XG4gICAgICAgIGNvbnN0IGJOdW0gPSArYmFja3JlZk51bTtcbiAgICAgICAgaWYgKGJOdW0gPiBjYXB0dXJlTnVtTWFwLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tyZWYgXCIke219XCIgZ3JlYXRlciB0aGFuIG51bWJlciBvZiBjYXB0dXJlc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXFxcXCR7Y2FwdHVyZU51bU1hcFtiTnVtXX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBcXFxcJHt3cmFwcGVkQmFja3JlZk51bX1gO1xuICAgIH0sXG4gICAgQ29udGV4dC5ERUZBVUxUXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBleHByZXNzaW9uLFxuICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgaGlkZGVuQ2FwdHVyZXMsXG4gIH07XG59XG5cbmNvbnN0IGJhc2VRdWFudGlmaWVyID0gU3RyaW5nLnJhd2AoPzpbPyorXXxcXHtcXGQrKD86LFxcZCopP1xcfSlgO1xuLy8gQ29tcGxldGUgdG9rZW5pemVyIGZvciBiYXNlIHN5bnRheDsgZG9lc24ndCAobmVlZCB0bykga25vdyBhYm91dCBjaGFyYWN0ZXItY2xhc3Mtb25seSBzeW50YXhcbmNvbnN0IHBvc3Nlc3NpdmVQbHVnaW5Ub2tlbiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2BcblxcXFwoPzogXFxkK1xuICB8IGNbQS1aYS16XVxuICB8IFtna108W14+XSs+XG4gIHwgW3BQdV1cXHtbXlxcfV0rXFx9XG4gIHwgdVtBLUZhLWZcXGRdezR9XG4gIHwgeFtBLUZhLWZcXGRdezJ9XG4gIClcbnwgXFwoKD86IFxcPyAoPzogWzo9IT5dXG4gIHwgPCg/Ols9IV18W14+XSs+KVxuICB8IFtBLVphLXpcXC1dKzpcbiAgfCBcXChERUZJTkVcXClcbiAgKSk/XG58ICg/PHFCYXNlPiR7YmFzZVF1YW50aWZpZXJ9KSg/PHFNb2Q+Wz8rXT8pKD88aW52YWxpZFE+Wz8qK1xce10/KVxufCBcXFxcPy5cbmAucmVwbGFjZSgvXFxzKy9nLCAnJyksICdnc3UnKTtcblxuLyoqXG5UcmFuc2Zvcm0gcG9zZXNzaXZlIHF1YW50aWZpZXJzIGludG8gYXRvbWljIGdyb3Vwcy4gVGhlIHBvc2Vzc2Vzc2l2ZSBxdWFudGlmaWVycyBhcmU6XG5gPytgLCBgKitgLCBgKytgLCBge059K2AsIGB7Tix9K2AsIGB7TixOfStgLlxuVGhpcyBmb2xsb3dzIEphdmEsIFBDUkUsIFBlcmwsIGFuZCBQeXRob24uXG5Qb3NzZXNzaXZlIHF1YW50aWZpZXJzIGluIE9uaWd1cnVtYSBhbmQgT25pZ21vIGFyZSBvbmx5OiBgPytgLCBgKitgLCBgKytgLlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25cbkByZXR1cm5zIHtpbXBvcnQoJy4vcmVnZXguanMnKS5QbHVnaW5SZXN1bHR9XG4qL1xuZnVuY3Rpb24gcG9zc2Vzc2l2ZShleHByZXNzaW9uKSB7XG4gIGlmICghKG5ldyBSZWdFeHAoYCR7YmFzZVF1YW50aWZpZXJ9XFxcXCtgKS50ZXN0KGV4cHJlc3Npb24pKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuOiBleHByZXNzaW9uLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBvcGVuR3JvdXBJbmRpY2VzID0gW107XG4gIGxldCBsYXN0R3JvdXBJbmRleCA9IG51bGw7XG4gIGxldCBsYXN0Q2hhckNsYXNzSW5kZXggPSBudWxsO1xuICBsZXQgbGFzdFRva2VuID0gJyc7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICBsZXQgbWF0Y2g7XG4gIHBvc3Nlc3NpdmVQbHVnaW5Ub2tlbi5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAobWF0Y2ggPSBwb3NzZXNzaXZlUGx1Z2luVG9rZW4uZXhlYyhleHByZXNzaW9uKSkge1xuICAgIGNvbnN0IHswOiBtLCBpbmRleCwgZ3JvdXBzOiB7cUJhc2UsIHFNb2QsIGludmFsaWRRfX0gPSBtYXRjaDtcbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuICAgICAgICBsYXN0Q2hhckNsYXNzSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ10nKSB7XG4gICAgICBpZiAobnVtQ2hhckNsYXNzZXNPcGVuKSB7XG4gICAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgICAgLy8gVW5tYXRjaGVkIGBdYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYXJDbGFzc0luZGV4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcblxuICAgICAgaWYgKHFNb2QgPT09ICcrJyAmJiBsYXN0VG9rZW4gJiYgIWxhc3RUb2tlbi5zdGFydHNXaXRoKCcoJykpIHtcbiAgICAgICAgLy8gSW52YWxpZCBmb2xsb3dpbmcgcXVhbnRpZmllciB3b3VsZCBiZWNvbWUgdmFsaWQgdmlhIHRoZSB3cmFwcGluZyBncm91cFxuICAgICAgICBpZiAoaW52YWxpZFEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcXVhbnRpZmllciBcIiR7bX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFyc0FkZGVkID0gLTE7IC8vIC0xIGZvciByZW1vdmVkIHRyYWlsaW5nIGArYFxuICAgICAgICAvLyBQb3NzZXNzaXZpemluZyBmaXhlZCByZXBldGl0aW9uIHF1YW50aWZpZXJzIGxpa2UgYHsyfWAgZG9lcyd0IGNoYW5nZSB0aGVpciBiZWhhdmlvciwgc29cbiAgICAgICAgLy8gYXZvaWQgZG9pbmcgc28gKGNvbnZlcnQgdGhlbSB0byBncmVlZHkpXG4gICAgICAgIGlmICgvXlxce1xcZCtcXH0kLy50ZXN0KHFCYXNlKSkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBzcGxpY2VTdHIoZXhwcmVzc2lvbiwgaW5kZXggKyBxQmFzZS5sZW5ndGgsIHFNb2QsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGFzdFRva2VuID09PSAnKScgfHwgbGFzdFRva2VuID09PSAnXScpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGxhc3RUb2tlbiA9PT0gJyknID8gbGFzdEdyb3VwSW5kZXggOiBsYXN0Q2hhckNsYXNzSW5kZXg7XG4gICAgICAgICAgICAvLyBVbm1hdGNoZWQgYClgIHdvdWxkIGJyZWFrIG91dCBvZiB0aGUgd3JhcHBpbmcgZ3JvdXAgYW5kIG1lc3Mgd2l0aCBoYW5kbGluZy5cbiAgICAgICAgICAgIC8vIFVubWF0Y2hlZCBgXWAgd291bGRuJ3QgYmUgYSBwcm9ibGVtLCBidXQgaXQncyB1bm5lY2Vzc2FyeSB0byBoYXZlIGRlZGljYXRlZCBzdXBwb3J0XG4gICAgICAgICAgICAvLyBmb3IgdW5lc2NhcGVkIGBdKytgIHNpbmNlIHRoaXMgd29uJ3Qgd29yayB3aXRoIGZsYWcgdSBvciB2IGFueXdheVxuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdW5tYXRjaGVkIFwiJHtsYXN0VG9rZW59XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBgJHtleHByZXNzaW9uLnNsaWNlKDAsIG5vZGVJbmRleCl9KD8+JHtleHByZXNzaW9uLnNsaWNlKG5vZGVJbmRleCwgaW5kZXgpfSR7cUJhc2V9KSR7ZXhwcmVzc2lvbi5zbGljZShpbmRleCArIG0ubGVuZ3RoKX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gYCR7ZXhwcmVzc2lvbi5zbGljZSgwLCBpbmRleCAtIGxhc3RUb2tlbi5sZW5ndGgpfSg/PiR7bGFzdFRva2VufSR7cUJhc2V9KSR7ZXhwcmVzc2lvbi5zbGljZShpbmRleCArIG0ubGVuZ3RoKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFyc0FkZGVkICs9IDQ7IC8vIGAoPz4pYFxuICAgICAgICB9XG4gICAgICAgIHBvc3Nlc3NpdmVQbHVnaW5Ub2tlbi5sYXN0SW5kZXggKz0gY2hhcnNBZGRlZDtcbiAgICAgIH0gZWxzZSBpZiAobVswXSA9PT0gJygnKSB7XG4gICAgICAgIG9wZW5Hcm91cEluZGljZXMucHVzaChpbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKG0gPT09ICcpJykge1xuICAgICAgICBsYXN0R3JvdXBJbmRleCA9IG9wZW5Hcm91cEluZGljZXMubGVuZ3RoID8gb3Blbkdyb3VwSW5kaWNlcy5wb3AoKSA6IG51bGw7XG4gICAgICB9XG5cbiAgICB9XG4gICAgbGFzdFRva2VuID0gbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogZXhwcmVzc2lvbixcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgYXRvbWljLFxuICBwb3NzZXNzaXZlLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/atomic.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/internals.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/internals.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpSubclass: () => (/* reexport safe */ _subclass_js__WEBPACK_IMPORTED_MODULE_1__.RegExpSubclass),\n/* harmony export */   atomic: () => (/* reexport safe */ _atomic_js__WEBPACK_IMPORTED_MODULE_0__.atomic),\n/* harmony export */   possessive: () => (/* reexport safe */ _atomic_js__WEBPACK_IMPORTED_MODULE_0__.possessive)\n/* harmony export */ });\n/* harmony import */ var _atomic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./atomic.js */ \"(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/atomic.js\");\n/* harmony import */ var _subclass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subclass.js */ \"(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/subclass.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvaW50ZXJuYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvaW50ZXJuYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7YXRvbWljLCBwb3NzZXNzaXZlfSBmcm9tICcuL2F0b21pYy5qcyc7XG5leHBvcnQge1JlZ0V4cFN1YmNsYXNzfSBmcm9tICcuL3N1YmNsYXNzLmpzJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/internals.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/subclass.js":
/*!****************************************************************************!*\
  !*** ../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/subclass.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpSubclass: () => (/* binding */ RegExpSubclass)\n/* harmony export */ });\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but automatically\nadjusts subpattern matches and indices (with flag `d`) to account for captures added as part of\nemulating extended syntax.\n*/\nclass RegExpSubclass extends RegExp {\n  // Avoid `#private` to allow for subclassing\n  /**\n  @private\n  @type {Map<number, {\n    hidden: true;\n  }>}\n  */\n  _captureMap;\n  /**\n  @overload\n  @param {string} expression\n  @param {string} [flags]\n  @param {{\n    hiddenCaptures?: Array<number>;\n  }} [options]\n  */\n  /**\n  @overload\n  @param {RegExpSubclass} expression\n  @param {string} [flags]\n  */\n  constructor(expression, flags, options) {\n    // Argument `options` isn't provided when regexes are copied via `new RegExpSubclass(regexp)`,\n    // including as part of the internal handling of string methods `matchAll` and `split`\n    if (expression instanceof RegExp) {\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      super(expression, flags);\n      if (expression instanceof RegExpSubclass) {\n        this._captureMap = expression._captureMap;\n      } else {\n        this._captureMap = new Map();\n      }\n    } else {\n      super(expression, flags);\n      const hiddenCaptures = options?.hiddenCaptures ?? [];\n      this._captureMap = createCaptureMap(hiddenCaptures);\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = super.exec(str);\n    if (!match || !this._captureMap.size) {\n      return match;\n    }\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (!this._captureMap.get(i)?.hidden) {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n}\n\n/**\nBuild the capturing group map, with hidden captures marked to indicate their submatches shouldn't\nappear in match results.\n@param {Array<number>} hiddenCaptures\n@returns {Map<number, {\n  hidden: true;\n}>}\n*/\nfunction createCaptureMap(hiddenCaptures) {\n  const captureMap = new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true,\n    });\n  }\n  return captureMap;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvc3ViY2xhc3MuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZTtBQUN2QixVQUFVO0FBQ1Y7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFJRSIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFua2ltL05lc3Rvci9tZWRmZXRjaC5qcy9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXhANi4wLjEvbm9kZV9tb2R1bGVzL3JlZ2V4L3NyYy9zdWJjbGFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbldvcmtzIHRoZSBzYW1lIGFzIEphdmFTY3JpcHQncyBuYXRpdmUgYFJlZ0V4cGAgY29uc3RydWN0b3IgaW4gYWxsIGNvbnRleHRzLCBidXQgYXV0b21hdGljYWxseVxuYWRqdXN0cyBzdWJwYXR0ZXJuIG1hdGNoZXMgYW5kIGluZGljZXMgKHdpdGggZmxhZyBgZGApIHRvIGFjY291bnQgZm9yIGNhcHR1cmVzIGFkZGVkIGFzIHBhcnQgb2ZcbmVtdWxhdGluZyBleHRlbmRlZCBzeW50YXguXG4qL1xuY2xhc3MgUmVnRXhwU3ViY2xhc3MgZXh0ZW5kcyBSZWdFeHAge1xuICAvLyBBdm9pZCBgI3ByaXZhdGVgIHRvIGFsbG93IGZvciBzdWJjbGFzc2luZ1xuICAvKipcbiAgQHByaXZhdGVcbiAgQHR5cGUge01hcDxudW1iZXIsIHtcbiAgICBoaWRkZW46IHRydWU7XG4gIH0+fVxuICAqL1xuICBfY2FwdHVyZU1hcDtcbiAgLyoqXG4gIEBvdmVybG9hZFxuICBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblxuICBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICBAcGFyYW0ge3tcbiAgICBoaWRkZW5DYXB0dXJlcz86IEFycmF5PG51bWJlcj47XG4gIH19IFtvcHRpb25zXVxuICAqL1xuICAvKipcbiAgQG92ZXJsb2FkXG4gIEBwYXJhbSB7UmVnRXhwU3ViY2xhc3N9IGV4cHJlc3Npb25cbiAgQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgKi9cbiAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICAvLyBBcmd1bWVudCBgb3B0aW9uc2AgaXNuJ3QgcHJvdmlkZWQgd2hlbiByZWdleGVzIGFyZSBjb3BpZWQgdmlhIGBuZXcgUmVnRXhwU3ViY2xhc3MocmVnZXhwKWAsXG4gICAgLy8gaW5jbHVkaW5nIGFzIHBhcnQgb2YgdGhlIGludGVybmFsIGhhbmRsaW5nIG9mIHN0cmluZyBtZXRob2RzIGBtYXRjaEFsbGAgYW5kIGBzcGxpdGBcbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcHJvdmlkZSBvcHRpb25zIHdoZW4gY29weWluZyBhIHJlZ2V4cCcpO1xuICAgICAgfVxuICAgICAgc3VwZXIoZXhwcmVzc2lvbiwgZmxhZ3MpO1xuICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBSZWdFeHBTdWJjbGFzcykge1xuICAgICAgICB0aGlzLl9jYXB0dXJlTWFwID0gZXhwcmVzc2lvbi5fY2FwdHVyZU1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhcHR1cmVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyKGV4cHJlc3Npb24sIGZsYWdzKTtcbiAgICAgIGNvbnN0IGhpZGRlbkNhcHR1cmVzID0gb3B0aW9ucz8uaGlkZGVuQ2FwdHVyZXMgPz8gW107XG4gICAgICB0aGlzLl9jYXB0dXJlTWFwID0gY3JlYXRlQ2FwdHVyZU1hcChoaWRkZW5DYXB0dXJlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICBDYWxsZWQgaW50ZXJuYWxseSBieSBhbGwgU3RyaW5nL1JlZ0V4cCBtZXRob2RzIHRoYXQgdXNlIHJlZ2V4ZXMuXG4gIEBvdmVycmlkZVxuICBAcGFyYW0ge3N0cmluZ30gc3RyXG4gIEByZXR1cm5zIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfVxuICAqL1xuICBleGVjKHN0cikge1xuICAgIGNvbnN0IG1hdGNoID0gc3VwZXIuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2ggfHwgIXRoaXMuX2NhcHR1cmVNYXAuc2l6ZSkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaENvcHkgPSBbLi4ubWF0Y2hdO1xuICAgIC8vIEVtcHR5IGFsbCBidXQgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBhcnJheSB3aGlsZSBwcmVzZXJ2aW5nIGl0cyBvdGhlciBwcm9wZXJ0aWVzXG4gICAgbWF0Y2gubGVuZ3RoID0gMTtcbiAgICBsZXQgaW5kaWNlc0NvcHk7XG4gICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgaW5kaWNlc0NvcHkgPSBbLi4ubWF0Y2guaW5kaWNlc107XG4gICAgICBtYXRjaC5pbmRpY2VzLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0Y2hDb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2NhcHR1cmVNYXAuZ2V0KGkpPy5oaWRkZW4pIHtcbiAgICAgICAgbWF0Y2gucHVzaChtYXRjaENvcHlbaV0pO1xuICAgICAgICBpZiAodGhpcy5oYXNJbmRpY2VzKSB7XG4gICAgICAgICAgbWF0Y2guaW5kaWNlcy5wdXNoKGluZGljZXNDb3B5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cbn1cblxuLyoqXG5CdWlsZCB0aGUgY2FwdHVyaW5nIGdyb3VwIG1hcCwgd2l0aCBoaWRkZW4gY2FwdHVyZXMgbWFya2VkIHRvIGluZGljYXRlIHRoZWlyIHN1Ym1hdGNoZXMgc2hvdWxkbid0XG5hcHBlYXIgaW4gbWF0Y2ggcmVzdWx0cy5cbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaGlkZGVuQ2FwdHVyZXNcbkByZXR1cm5zIHtNYXA8bnVtYmVyLCB7XG4gIGhpZGRlbjogdHJ1ZTtcbn0+fVxuKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVNYXAoaGlkZGVuQ2FwdHVyZXMpIHtcbiAgY29uc3QgY2FwdHVyZU1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBudW0gb2YgaGlkZGVuQ2FwdHVyZXMpIHtcbiAgICBjYXB0dXJlTWFwLnNldChudW0sIHtcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FwdHVyZU1hcDtcbn1cblxuZXhwb3J0IHtcbiAgUmVnRXhwU3ViY2xhc3MsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/subclass.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/utils-internals.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/utils-internals.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   incrementIfAtLeast: () => (/* binding */ incrementIfAtLeast),\n/* harmony export */   noncapturingDelim: () => (/* binding */ noncapturingDelim),\n/* harmony export */   spliceStr: () => (/* binding */ spliceStr)\n/* harmony export */ });\n// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDYuMC4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvdXRpbHMtaW50ZXJuYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGVBQWU7QUFDdkIsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQU1FIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA2LjAuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL3V0aWxzLWludGVybmFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXBhcmF0aW5nIHNvbWUgdXRpbHMgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZyBvZiB0aGUgYC4vaW50ZXJuYWxzYCBleHBvcnRcblxuY29uc3Qgbm9uY2FwdHVyaW5nRGVsaW0gPSBTdHJpbmcucmF3YFxcKFxcPyg/Ols6PSE+QS1aYS16XFwtXXw8Wz0hXXxcXChERUZJTkVcXCkpYDtcblxuLyoqXG5VcGRhdGVzIHRoZSBhcnJheSBpbiBwbGFjZSBieSBpbmNyZW1lbnRpbmcgZWFjaCB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRocmVzaG9sZC5cbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyXG5AcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gaW5jcmVtZW50SWZBdExlYXN0KGFyciwgdGhyZXNob2xkKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGFycltpXSsrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBzdHJcbkBwYXJhbSB7bnVtYmVyfSBwb3NcbkBwYXJhbSB7c3RyaW5nfSBvbGRWYWx1ZVxuQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIHNwbGljZVN0cihzdHIsIHBvcywgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgcG9zKSArIG5ld1ZhbHVlICsgc3RyLnNsaWNlKHBvcyArIG9sZFZhbHVlLmxlbmd0aCk7XG59XG5cbmV4cG9ydCB7XG4gIGluY3JlbWVudElmQXRMZWFzdCxcbiAgbm9uY2FwdHVyaW5nRGVsaW0sXG4gIHNwbGljZVN0cixcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/utils-internals.js\n");

/***/ })

};
;