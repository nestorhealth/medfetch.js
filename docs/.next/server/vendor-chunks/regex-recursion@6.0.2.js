"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regex-recursion@6.0.2";
exports.ids = ["vendor-chunks/regex-recursion@6.0.2"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursion: () => (/* binding */ recursion)\n/* harmony export */ });\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex-utilities */ \"(rsc)/../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCaptureDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst captureDelim = r`${namedCaptureDelim}|(?<unnamed>\\()(?!\\?)`;\nconst token = new RegExp(r`${namedCaptureDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n\n/**\n@param {string} pattern\n@param {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n  mode?: 'plugin' | 'external';\n}} [data]\n@returns {{\n  pattern: string;\n  captureTransfers: Map<number, Array<number>>;\n  hiddenCaptures: Array<number>;\n}}\n*/\nfunction recursion(pattern, data) {\n  const {hiddenCaptures, mode} = {\n    hiddenCaptures: [],\n    mode: 'plugin',\n    ...data,\n  };\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with `Context.DEFAULT`\n  if (!(new RegExp(recursiveToken, 'su').test(pattern))) {\n    return {\n      pattern,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n  if (mode === 'plugin' && (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\(\\?\\(DEFINE\\)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n\n  const addedHiddenCaptures = [];\n  const hasNumberedBackref = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\\\[1-9]`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCapturesPassed = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(pattern))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with global recursion`\n          );\n        }\n        const left = pattern.slice(0, match.index);\n        const right = pattern.slice(token.lastIndex);\n        if ((0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(right, recursiveToken, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        const reps = +rDepth - 1;\n        pattern = makeRecursive(\n          left,\n          right,\n          reps,\n          false,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          left,\n          reps,\n          addedHiddenCaptures.length,\n          0,\n          numCapturesPassed\n        );\n        // No need to parse further\n        break;\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"${\n            mode === 'external' ? gRNameOrNum : r`\\g<${gRNameOrNum}&R=${gRDepth}>`\n          }\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.getGroupContents)(pattern, startPos);\n        if (\n          hasNumberedBackref &&\n          (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(groupContents, r`${namedCaptureDelim}|\\((?!\\?)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)\n        ) {\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with recursion of capturing groups`\n          );\n        }\n        const groupContentsLeft = pattern.slice(startPos, match.index);\n        const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);\n        const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;\n        const reps = +gRDepth - 1;\n        const expansion = makeRecursive(\n          groupContentsLeft,\n          groupContentsRight,\n          reps,\n          true,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          groupContentsLeft,\n          reps,\n          addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion,\n          numAddedHiddenCapturesPreExpansion,\n          numCapturesPassed\n        );\n        const pre = pattern.slice(0, startPos);\n        const post = pattern.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        pattern = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCapturesPassed++;\n        groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCapturesPassed,\n          name: captureName,\n        });\n      } else if (m[0] === '(') {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCapturesPassed++;\n          groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCapturesPassed} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  return {\n    pattern,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} left\n@param {string} right\n@param {number} reps\n@param {boolean} isSubpattern\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction makeRecursive(\n  left,\n  right,\n  reps,\n  isSubpattern,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const namesInRecursed = new Set();\n  // Can skip this work if not needed\n  if (isSubpattern) {\n    (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left + right, namedCaptureDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  }\n  const rest = [\n    reps,\n    isSubpattern ? namesInRecursed : null,\n    hiddenCaptures,\n    addedHiddenCaptures,\n    numCapturesPassed,\n  ];\n  // Depth 2: 'left(?:left(?:)right)right'\n  // Depth 3: 'left(?:left(?:left(?:)right)right)right'\n  // Empty group in the middle separates tokens and absorbs a following quantifier if present\n  return `${left}${\n    repeatWithDepth(`(?:${left}`, 'forward', ...rest)\n  }(?:)${\n    repeatWithDepth(`${right})`, 'backward', ...rest)\n  }${right}`;\n}\n\n/**\n@param {string} pattern\n@param {'forward' | 'backward'} direction\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction repeatWithDepth(\n  pattern,\n  direction,\n  reps,\n  namesInRecursed,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const startNum = 2;\n  const getDepthNum = i => direction === 'forward' ? (i + startNum) : (reps - i + startNum - 1);\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const depthNum = getDepthNum(i);\n    result += (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.replaceUnescaped)(\n      pattern,\n      r`${captureDelim}|\\\\k<(?<backref>[^>]+)>`,\n      ({0: m, groups: {captureName, unnamed, backref}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        const suffix = `_$${depthNum}`;\n        if (unnamed || captureName) {\n          const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;\n          addedHiddenCaptures.push(addedCaptureNum);\n          incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n          return unnamed ? m : `(?<${captureName}${suffix}>`;\n        }\n        return r`\\k<${backref}${suffix}>`;\n      },\n      regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT\n    );\n  }\n  return result;\n}\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {Map<number, Array<number>>} captureTransfers\n@param {string} left\n@param {number} reps\n@param {number} numCapturesAddedInExpansion\n@param {number} numAddedHiddenCapturesPreExpansion\n@param {number} numCapturesPassed\n@returns {Map<number, Array<number>>}\n*/\nfunction mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {\n  if (captureTransfers.size && numCapturesAddedInExpansion) {\n    let numCapturesInLeft = 0;\n    (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left, captureDelim, () => numCapturesInLeft++, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n    // Is 0 for global recursion\n    const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;\n    const newCaptureTransfers = new Map();\n    captureTransfers.forEach((from, to) => {\n      const numCapturesInRight = (numCapturesAddedInExpansion - (numCapturesInLeft * reps)) / reps;\n      const numCapturesAddedInLeft = numCapturesInLeft * reps;\n      const newTo = to > (recursionDelimCaptureNum + numCapturesInLeft) ? to + numCapturesAddedInExpansion : to;\n      const newFrom = [];\n      for (const f of from) {\n        // Before the recursed subpattern\n        if (f <= recursionDelimCaptureNum) {\n          newFrom.push(f);\n        // After the recursed subpattern\n        } else if (f > (recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight)) {\n          newFrom.push(f + numCapturesAddedInExpansion);\n        // Within the recursed subpattern, on the left of the recursion token\n        } else if (f <= (recursionDelimCaptureNum + numCapturesInLeft)) {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + (numCapturesInLeft * i));\n          }\n        // Within the recursed subpattern, on the right of the recursion token\n        } else {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + numCapturesAddedInLeft + (numCapturesInRight * i));\n          }\n        }\n      }\n      newCaptureTransfers.set(newTo, newFrom);\n    });\n    return newCaptureTransfers;\n  }\n  return captureTransfers;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4LXJlY3Vyc2lvbkA2LjAuMi9ub2RlX21vZHVsZXMvcmVnZXgtcmVjdXJzaW9uL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0Rzs7QUFFNUc7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsa0JBQWtCLEdBQUcsZUFBZTtBQUNqRTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFZLDZCQUE2QixvREFBTztBQUMzRTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDZEQUFZLHNCQUFzQixvREFBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLDRDQUE0QztBQUN0RTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUF3RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQVksd0JBQXdCLG9EQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWSxLQUFLLFFBQVE7QUFDaEYsV0FBVztBQUNYO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQWdCO0FBQzlDO0FBQ0E7QUFDQSxVQUFVLDZEQUFZLG9CQUFvQixrQkFBa0IsWUFBWSxvREFBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLFVBQVUsRUFBRSxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0IsSUFBSTtBQUN4RSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0EsK0RBQStELE9BQU8sSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsUUFBUSxTQUFTO0FBQ2pCLFFBQVEsZUFBZTtBQUN2QixRQUFRLGVBQWU7QUFDdkIsUUFBUSxRQUFRO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWdCLG9DQUFvQyxTQUFTLGFBQWE7QUFDOUU7QUFDQSxLQUFLLEVBQUUsb0RBQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLDBCQUEwQixLQUFLO0FBQy9CLEdBQUc7QUFDSCx1QkFBdUIsTUFBTTtBQUM3QixHQUFHLEVBQUUsTUFBTTtBQUNYOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsd0JBQXdCO0FBQ2hDLFFBQVEsUUFBUTtBQUNoQixRQUFRLG9CQUFvQjtBQUM1QixRQUFRLGVBQWU7QUFDdkIsUUFBUSxlQUFlO0FBQ3ZCLFFBQVEsUUFBUTtBQUNoQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLGNBQWMsaUVBQWdCO0FBQzlCO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFFBQVEsZUFBZSwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLEVBQUUsT0FBTztBQUMxRDtBQUNBLHNCQUFzQixRQUFRLEVBQUUsT0FBTztBQUN2QyxPQUFPO0FBQ1AsTUFBTSxvREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGVBQWU7QUFDdkIsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDRCQUE0QjtBQUNwQyxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWdCLGdEQUFnRCxvREFBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUlFIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW5raW0vTmVzdG9yL21lZGZldGNoLmpzL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleC1yZWN1cnNpb25ANi4wLjIvbm9kZV9tb2R1bGVzL3JlZ2V4LXJlY3Vyc2lvbi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb250ZXh0LCBmb3JFYWNoVW5lc2NhcGVkLCBnZXRHcm91cENvbnRlbnRzLCBoYXNVbmVzY2FwZWQsIHJlcGxhY2VVbmVzY2FwZWR9IGZyb20gJ3JlZ2V4LXV0aWxpdGllcyc7XG5cbmNvbnN0IHIgPSBTdHJpbmcucmF3O1xuY29uc3QgZ1JUb2tlbiA9IHJgXFxcXGc8KD88Z1JOYW1lT3JOdW0+W14+Jl0rKSZSPSg/PGdSRGVwdGg+W14+XSspPmA7XG5jb25zdCByZWN1cnNpdmVUb2tlbiA9IHJgXFwoXFw/Uj0oPzxyRGVwdGg+W15cXCldKylcXCl8JHtnUlRva2VufWA7XG5jb25zdCBuYW1lZENhcHR1cmVEZWxpbSA9IHJgXFwoXFw/PCg/IVs9IV0pKD88Y2FwdHVyZU5hbWU+W14+XSspPmA7XG5jb25zdCBjYXB0dXJlRGVsaW0gPSByYCR7bmFtZWRDYXB0dXJlRGVsaW19fCg/PHVubmFtZWQ+XFwoKSg/IVxcPylgO1xuY29uc3QgdG9rZW4gPSBuZXcgUmVnRXhwKHJgJHtuYW1lZENhcHR1cmVEZWxpbX18JHtyZWN1cnNpdmVUb2tlbn18XFwoXFw/fFxcXFw/LmAsICdnc3UnKTtcbmNvbnN0IG92ZXJsYXBwaW5nUmVjdXJzaW9uTXNnID0gJ0Nhbm5vdCB1c2UgbXVsdGlwbGUgb3ZlcmxhcHBpbmcgcmVjdXJzaW9ucyc7XG5cbi8qKlxuQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbkBwYXJhbSB7e1xuICBmbGFncz86IHN0cmluZztcbiAgY2FwdHVyZVRyYW5zZmVycz86IE1hcDxudW1iZXIsIEFycmF5PG51bWJlcj4+O1xuICBoaWRkZW5DYXB0dXJlcz86IEFycmF5PG51bWJlcj47XG4gIG1vZGU/OiAncGx1Z2luJyB8ICdleHRlcm5hbCc7XG59fSBbZGF0YV1cbkByZXR1cm5zIHt7XG4gIHBhdHRlcm46IHN0cmluZztcbiAgY2FwdHVyZVRyYW5zZmVyczogTWFwPG51bWJlciwgQXJyYXk8bnVtYmVyPj47XG4gIGhpZGRlbkNhcHR1cmVzOiBBcnJheTxudW1iZXI+O1xufX1cbiovXG5mdW5jdGlvbiByZWN1cnNpb24ocGF0dGVybiwgZGF0YSkge1xuICBjb25zdCB7aGlkZGVuQ2FwdHVyZXMsIG1vZGV9ID0ge1xuICAgIGhpZGRlbkNhcHR1cmVzOiBbXSxcbiAgICBtb2RlOiAncGx1Z2luJyxcbiAgICAuLi5kYXRhLFxuICB9O1xuICAvLyBDYXB0dXJlIHRyYW5zZmVyIGlzIHVzZWQgYnkgPGdpdGh1Yi5jb20vc2xldml0aGFuL29uaWd1cnVtYS10by1lcz5cbiAgbGV0IGNhcHR1cmVUcmFuc2ZlcnMgPSBkYXRhPy5jYXB0dXJlVHJhbnNmZXJzID8/IG5ldyBNYXAoKTtcbiAgLy8gS2VlcCB0aGUgaW5pdGlhbCBmYWlsLWNoZWNrICh3aGljaCBhdm9pZHMgdW5uZWVkZWQgcHJvY2Vzc2luZykgYXMgZmFzdCBhcyBwb3NzaWJsZSBieSB0ZXN0aW5nXG4gIC8vIHdpdGhvdXQgdGhlIGFjY3VyYWN5IGltcHJvdmVtZW50IG9mIHVzaW5nIGBoYXNVbmVzY2FwZWRgIHdpdGggYENvbnRleHQuREVGQVVMVGBcbiAgaWYgKCEobmV3IFJlZ0V4cChyZWN1cnNpdmVUb2tlbiwgJ3N1JykudGVzdChwYXR0ZXJuKSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybixcbiAgICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgICBoaWRkZW5DYXB0dXJlcyxcbiAgICB9O1xuICB9XG4gIGlmIChtb2RlID09PSAncGx1Z2luJyAmJiBoYXNVbmVzY2FwZWQocGF0dGVybiwgcmBcXChcXD9cXChERUZJTkVcXClgLCBDb250ZXh0LkRFRkFVTFQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdERUZJTkUgZ3JvdXBzIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVjdXJzaW9uJyk7XG4gIH1cblxuICBjb25zdCBhZGRlZEhpZGRlbkNhcHR1cmVzID0gW107XG4gIGNvbnN0IGhhc051bWJlcmVkQmFja3JlZiA9IGhhc1VuZXNjYXBlZChwYXR0ZXJuLCByYFxcXFxbMS05XWAsIENvbnRleHQuREVGQVVMVCk7XG4gIGNvbnN0IGdyb3VwQ29udGVudHNTdGFydFBvcyA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgb3Blbkdyb3VwcyA9IFtdO1xuICBsZXQgaGFzUmVjdXJzZWQgPSBmYWxzZTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCBudW1DYXB0dXJlc1Bhc3NlZCA9IDA7XG4gIGxldCBtYXRjaDtcbiAgdG9rZW4ubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKChtYXRjaCA9IHRva2VuLmV4ZWMocGF0dGVybikpKSB7XG4gICAgY29uc3QgezA6IG0sIGdyb3Vwczoge2NhcHR1cmVOYW1lLCByRGVwdGgsIGdSTmFtZU9yTnVtLCBnUkRlcHRofX0gPSBtYXRjaDtcbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcblxuICAgICAgLy8gYCg/Uj1OKWBcbiAgICAgIGlmIChyRGVwdGgpIHtcbiAgICAgICAgYXNzZXJ0TWF4SW5Cb3VuZHMockRlcHRoKTtcbiAgICAgICAgaWYgKGhhc1JlY3Vyc2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG92ZXJsYXBwaW5nUmVjdXJzaW9uTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTnVtYmVyZWRCYWNrcmVmKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWRkIHN1cHBvcnQgZm9yIG51bWJlcmVkIGJhY2tyZWZzIHdpdGggZXh0cmEgZWZmb3J0LCBidXQgaXQncyBwcm9iYWJseSBub3Qgd29ydGhcbiAgICAgICAgICAvLyBpdC4gVG8gdHJpZ2dlciB0aGlzIGVycm9yLCB0aGUgcmVnZXggbXVzdCBpbmNsdWRlIHJlY3Vyc2lvbiBhbmQgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgLy8gLSBBbiBpbnRlcnBvbGF0ZWQgcmVnZXggdGhhdCBjb250YWlucyBhIG51bWJlcmVkIGJhY2tyZWYgKHNpbmNlIG90aGVyIG51bWJlcmVkXG4gICAgICAgICAgLy8gICBiYWNrcmVmcyBhcmUgcHJldmVudGVkIGJ5IGltcGxpY2l0IGZsYWcgbikuXG4gICAgICAgICAgLy8gLSBBIG51bWJlcmVkIGJhY2tyZWYsIHdoZW4gZmxhZyBuIGlzIGV4cGxpY2l0bHkgZGlzYWJsZWQuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IFJlZ2V4KydzIGV4dGVuZGVkIHN5bnRheCAoYXRvbWljIGdyb3VwcyBhbmQgc29tZXRpbWVzIHN1YnJvdXRpbmVzKSBjYW4gYWxzb1xuICAgICAgICAgIC8vIGFkZCBudW1iZXJlZCBiYWNrcmVmcywgYnV0IHRob3NlIHdvcmsgZmluZSBiZWNhdXNlIGV4dGVybmFsIHBsdWdpbnMgbGlrZSB0aGlzIG9uZSBydW5cbiAgICAgICAgICAvLyAqYmVmb3JlKiB0aGUgdHJhbnNmb3JtYXRpb24gb2YgYnVpbHQtaW4gc3ludGF4IGV4dGVuc2lvbnNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAvLyBXaGVuIHVzZWQgaW4gYGV4dGVybmFsYCBtb2RlIGJ5IHRyYW5zcGlsZXJzIG90aGVyIHRoYW4gUmVnZXgrLCBiYWNrcmVmcyBtaWdodCBoYXZlXG4gICAgICAgICAgICAvLyBnb25lIHRocm91Z2ggY29udmVyc2lvbiBmcm9tIG5hbWVkIHRvIG51bWJlcmVkLCBzbyBhdm9pZCBhIG1pc2xlYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGAke21vZGUgPT09ICdleHRlcm5hbCcgPyAnQmFja3JlZnMnIDogJ051bWJlcmVkIGJhY2tyZWZzJ30gY2Fubm90IGJlIHVzZWQgd2l0aCBnbG9iYWwgcmVjdXJzaW9uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdCA9IHBhdHRlcm4uc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCByaWdodCA9IHBhdHRlcm4uc2xpY2UodG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGhhc1VuZXNjYXBlZChyaWdodCwgcmVjdXJzaXZlVG9rZW4sIENvbnRleHQuREVGQVVMVCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcHMgPSArckRlcHRoIC0gMTtcbiAgICAgICAgcGF0dGVybiA9IG1ha2VSZWN1cnNpdmUoXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICByaWdodCxcbiAgICAgICAgICByZXBzLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGhpZGRlbkNhcHR1cmVzLFxuICAgICAgICAgIGFkZGVkSGlkZGVuQ2FwdHVyZXMsXG4gICAgICAgICAgbnVtQ2FwdHVyZXNQYXNzZWRcbiAgICAgICAgKTtcbiAgICAgICAgY2FwdHVyZVRyYW5zZmVycyA9IG1hcENhcHR1cmVUcmFuc2ZlcnMoXG4gICAgICAgICAgY2FwdHVyZVRyYW5zZmVycyxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGgsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHBhcnNlIGZ1cnRoZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBgXFxnPG5hbWUmUj1OPmAsIGBcXGc8bnVtYmVyJlI9Tj5gXG4gICAgICB9IGVsc2UgaWYgKGdSTmFtZU9yTnVtKSB7XG4gICAgICAgIGFzc2VydE1heEluQm91bmRzKGdSRGVwdGgpO1xuICAgICAgICBsZXQgaXNXaXRoaW5SZWZmZWRHcm91cCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGcgb2Ygb3Blbkdyb3Vwcykge1xuICAgICAgICAgIGlmIChnLm5hbWUgPT09IGdSTmFtZU9yTnVtIHx8IGcubnVtID09PSArZ1JOYW1lT3JOdW0pIHtcbiAgICAgICAgICAgIGlzV2l0aGluUmVmZmVkR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGcuaGFzUmVjdXJzZWRXaXRoaW4pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG92ZXJsYXBwaW5nUmVjdXJzaW9uTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzV2l0aGluUmVmZmVkR3JvdXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBSZWN1cnNpdmUgXFxnIGNhbm5vdCBiZSB1c2VkIG91dHNpZGUgdGhlIHJlZmVyZW5jZWQgZ3JvdXAgXCIke1xuICAgICAgICAgICAgbW9kZSA9PT0gJ2V4dGVybmFsJyA/IGdSTmFtZU9yTnVtIDogcmBcXGc8JHtnUk5hbWVPck51bX0mUj0ke2dSRGVwdGh9PmBcbiAgICAgICAgICB9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFBvcyA9IGdyb3VwQ29udGVudHNTdGFydFBvcy5nZXQoZ1JOYW1lT3JOdW0pO1xuICAgICAgICBjb25zdCBncm91cENvbnRlbnRzID0gZ2V0R3JvdXBDb250ZW50cyhwYXR0ZXJuLCBzdGFydFBvcyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBoYXNOdW1iZXJlZEJhY2tyZWYgJiZcbiAgICAgICAgICBoYXNVbmVzY2FwZWQoZ3JvdXBDb250ZW50cywgcmAke25hbWVkQ2FwdHVyZURlbGltfXxcXCgoPyFcXD8pYCwgQ29udGV4dC5ERUZBVUxUKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAvLyBXaGVuIHVzZWQgaW4gYGV4dGVybmFsYCBtb2RlIGJ5IHRyYW5zcGlsZXJzIG90aGVyIHRoYW4gUmVnZXgrLCBiYWNrcmVmcyBtaWdodCBoYXZlXG4gICAgICAgICAgICAvLyBnb25lIHRocm91Z2ggY29udmVyc2lvbiBmcm9tIG5hbWVkIHRvIG51bWJlcmVkLCBzbyBhdm9pZCBhIG1pc2xlYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGAke21vZGUgPT09ICdleHRlcm5hbCcgPyAnQmFja3JlZnMnIDogJ051bWJlcmVkIGJhY2tyZWZzJ30gY2Fubm90IGJlIHVzZWQgd2l0aCByZWN1cnNpb24gb2YgY2FwdHVyaW5nIGdyb3Vwc2BcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGVudHNMZWZ0ID0gcGF0dGVybi5zbGljZShzdGFydFBvcywgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBncm91cENvbnRlbnRzUmlnaHQgPSBncm91cENvbnRlbnRzLnNsaWNlKGdyb3VwQ29udGVudHNMZWZ0Lmxlbmd0aCArIG0ubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbnVtQWRkZWRIaWRkZW5DYXB0dXJlc1ByZUV4cGFuc2lvbiA9IGFkZGVkSGlkZGVuQ2FwdHVyZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXBzID0gK2dSRGVwdGggLSAxO1xuICAgICAgICBjb25zdCBleHBhbnNpb24gPSBtYWtlUmVjdXJzaXZlKFxuICAgICAgICAgIGdyb3VwQ29udGVudHNMZWZ0LFxuICAgICAgICAgIGdyb3VwQ29udGVudHNSaWdodCxcbiAgICAgICAgICByZXBzLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgaGlkZGVuQ2FwdHVyZXMsXG4gICAgICAgICAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICBjYXB0dXJlVHJhbnNmZXJzID0gbWFwQ2FwdHVyZVRyYW5zZmVycyhcbiAgICAgICAgICBjYXB0dXJlVHJhbnNmZXJzLFxuICAgICAgICAgIGdyb3VwQ29udGVudHNMZWZ0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGggLSBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uLFxuICAgICAgICAgIG51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb24sXG4gICAgICAgICAgbnVtQ2FwdHVyZXNQYXNzZWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHJlID0gcGF0dGVybi5zbGljZSgwLCBzdGFydFBvcyk7XG4gICAgICAgIGNvbnN0IHBvc3QgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0UG9zICsgZ3JvdXBDb250ZW50cy5sZW5ndGgpO1xuICAgICAgICAvLyBNb2RpZnkgdGhlIHN0cmluZyB3ZSdyZSBsb29waW5nIG92ZXJcbiAgICAgICAgcGF0dGVybiA9IGAke3ByZX0ke2V4cGFuc2lvbn0ke3Bvc3R9YDtcbiAgICAgICAgLy8gU3RlcCBmb3J3YXJkIGZvciB0aGUgbmV4dCBsb29wIGl0ZXJhdGlvblxuICAgICAgICB0b2tlbi5sYXN0SW5kZXggKz0gZXhwYW5zaW9uLmxlbmd0aCAtIG0ubGVuZ3RoIC0gZ3JvdXBDb250ZW50c0xlZnQubGVuZ3RoIC0gZ3JvdXBDb250ZW50c1JpZ2h0Lmxlbmd0aDtcbiAgICAgICAgb3Blbkdyb3Vwcy5mb3JFYWNoKGcgPT4gZy5oYXNSZWN1cnNlZFdpdGhpbiA9IHRydWUpO1xuICAgICAgICBoYXNSZWN1cnNlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmVOYW1lKSB7XG4gICAgICAgIG51bUNhcHR1cmVzUGFzc2VkKys7XG4gICAgICAgIGdyb3VwQ29udGVudHNTdGFydFBvcy5zZXQoU3RyaW5nKG51bUNhcHR1cmVzUGFzc2VkKSwgdG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgZ3JvdXBDb250ZW50c1N0YXJ0UG9zLnNldChjYXB0dXJlTmFtZSwgdG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgb3Blbkdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICBudW06IG51bUNhcHR1cmVzUGFzc2VkLFxuICAgICAgICAgIG5hbWU6IGNhcHR1cmVOYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobVswXSA9PT0gJygnKSB7XG4gICAgICAgIGNvbnN0IGlzVW5uYW1lZENhcHR1cmUgPSBtID09PSAnKCc7XG4gICAgICAgIGlmIChpc1VubmFtZWRDYXB0dXJlKSB7XG4gICAgICAgICAgbnVtQ2FwdHVyZXNQYXNzZWQrKztcbiAgICAgICAgICBncm91cENvbnRlbnRzU3RhcnRQb3Muc2V0KFN0cmluZyhudW1DYXB0dXJlc1Bhc3NlZCksIHRva2VuLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgb3Blbkdyb3Vwcy5wdXNoKGlzVW5uYW1lZENhcHR1cmUgPyB7bnVtOiBudW1DYXB0dXJlc1Bhc3NlZH0gOiB7fSk7XG4gICAgICB9IGVsc2UgaWYgKG0gPT09ICcpJykge1xuICAgICAgICBvcGVuR3JvdXBzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChtID09PSAnXScpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgfVxuXG4gIGhpZGRlbkNhcHR1cmVzLnB1c2goLi4uYWRkZWRIaWRkZW5DYXB0dXJlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuLFxuICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgaGlkZGVuQ2FwdHVyZXMsXG4gIH07XG59XG5cbi8qKlxuQHBhcmFtIHtzdHJpbmd9IG1heFxuKi9cbmZ1bmN0aW9uIGFzc2VydE1heEluQm91bmRzKG1heCkge1xuICBjb25zdCBlcnJNc2cgPSBgTWF4IGRlcHRoIG11c3QgYmUgaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDEwMDsgdXNlZCAke21heH1gO1xuICBpZiAoIS9eWzEtOV1cXGQqJC8udGVzdChtYXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gIH1cbiAgbWF4ID0gK21heDtcbiAgaWYgKG1heCA8IDIgfHwgbWF4ID4gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gIH1cbn1cblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gbGVmdFxuQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG5AcGFyYW0ge251bWJlcn0gcmVwc1xuQHBhcmFtIHtib29sZWFufSBpc1N1YnBhdHRlcm5cbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaGlkZGVuQ2FwdHVyZXNcbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYWRkZWRIaWRkZW5DYXB0dXJlc1xuQHBhcmFtIHtudW1iZXJ9IG51bUNhcHR1cmVzUGFzc2VkXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIG1ha2VSZWN1cnNpdmUoXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICByZXBzLFxuICBpc1N1YnBhdHRlcm4sXG4gIGhpZGRlbkNhcHR1cmVzLFxuICBhZGRlZEhpZGRlbkNhcHR1cmVzLFxuICBudW1DYXB0dXJlc1Bhc3NlZFxuKSB7XG4gIGNvbnN0IG5hbWVzSW5SZWN1cnNlZCA9IG5ldyBTZXQoKTtcbiAgLy8gQ2FuIHNraXAgdGhpcyB3b3JrIGlmIG5vdCBuZWVkZWRcbiAgaWYgKGlzU3VicGF0dGVybikge1xuICAgIGZvckVhY2hVbmVzY2FwZWQobGVmdCArIHJpZ2h0LCBuYW1lZENhcHR1cmVEZWxpbSwgKHtncm91cHM6IHtjYXB0dXJlTmFtZX19KSA9PiB7XG4gICAgICBuYW1lc0luUmVjdXJzZWQuYWRkKGNhcHR1cmVOYW1lKTtcbiAgICB9LCBDb250ZXh0LkRFRkFVTFQpO1xuICB9XG4gIGNvbnN0IHJlc3QgPSBbXG4gICAgcmVwcyxcbiAgICBpc1N1YnBhdHRlcm4gPyBuYW1lc0luUmVjdXJzZWQgOiBudWxsLFxuICAgIGhpZGRlbkNhcHR1cmVzLFxuICAgIGFkZGVkSGlkZGVuQ2FwdHVyZXMsXG4gICAgbnVtQ2FwdHVyZXNQYXNzZWQsXG4gIF07XG4gIC8vIERlcHRoIDI6ICdsZWZ0KD86bGVmdCg/OilyaWdodClyaWdodCdcbiAgLy8gRGVwdGggMzogJ2xlZnQoPzpsZWZ0KD86bGVmdCg/OilyaWdodClyaWdodClyaWdodCdcbiAgLy8gRW1wdHkgZ3JvdXAgaW4gdGhlIG1pZGRsZSBzZXBhcmF0ZXMgdG9rZW5zIGFuZCBhYnNvcmJzIGEgZm9sbG93aW5nIHF1YW50aWZpZXIgaWYgcHJlc2VudFxuICByZXR1cm4gYCR7bGVmdH0ke1xuICAgIHJlcGVhdFdpdGhEZXB0aChgKD86JHtsZWZ0fWAsICdmb3J3YXJkJywgLi4ucmVzdClcbiAgfSg/Oikke1xuICAgIHJlcGVhdFdpdGhEZXB0aChgJHtyaWdodH0pYCwgJ2JhY2t3YXJkJywgLi4ucmVzdClcbiAgfSR7cmlnaHR9YDtcbn1cblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuQHBhcmFtIHsnZm9yd2FyZCcgfCAnYmFja3dhcmQnfSBkaXJlY3Rpb25cbkBwYXJhbSB7bnVtYmVyfSByZXBzXG5AcGFyYW0ge1NldDxzdHJpbmc+IHwgbnVsbH0gbmFtZXNJblJlY3Vyc2VkXG5AcGFyYW0ge0FycmF5PG51bWJlcj59IGhpZGRlbkNhcHR1cmVzXG5AcGFyYW0ge0FycmF5PG51bWJlcj59IGFkZGVkSGlkZGVuQ2FwdHVyZXNcbkBwYXJhbSB7bnVtYmVyfSBudW1DYXB0dXJlc1Bhc3NlZFxuQHJldHVybnMge3N0cmluZ31cbiovXG5mdW5jdGlvbiByZXBlYXRXaXRoRGVwdGgoXG4gIHBhdHRlcm4sXG4gIGRpcmVjdGlvbixcbiAgcmVwcyxcbiAgbmFtZXNJblJlY3Vyc2VkLFxuICBoaWRkZW5DYXB0dXJlcyxcbiAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgbnVtQ2FwdHVyZXNQYXNzZWRcbikge1xuICBjb25zdCBzdGFydE51bSA9IDI7XG4gIGNvbnN0IGdldERlcHRoTnVtID0gaSA9PiBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IChpICsgc3RhcnROdW0pIDogKHJlcHMgLSBpICsgc3RhcnROdW0gLSAxKTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcHM7IGkrKykge1xuICAgIGNvbnN0IGRlcHRoTnVtID0gZ2V0RGVwdGhOdW0oaSk7XG4gICAgcmVzdWx0ICs9IHJlcGxhY2VVbmVzY2FwZWQoXG4gICAgICBwYXR0ZXJuLFxuICAgICAgcmAke2NhcHR1cmVEZWxpbX18XFxcXGs8KD88YmFja3JlZj5bXj5dKyk+YCxcbiAgICAgICh7MDogbSwgZ3JvdXBzOiB7Y2FwdHVyZU5hbWUsIHVubmFtZWQsIGJhY2tyZWZ9fSkgPT4ge1xuICAgICAgICBpZiAoYmFja3JlZiAmJiBuYW1lc0luUmVjdXJzZWQgJiYgIW5hbWVzSW5SZWN1cnNlZC5oYXMoYmFja3JlZikpIHtcbiAgICAgICAgICAvLyBEb24ndCBhbHRlciBiYWNrcmVmcyB0byBncm91cHMgb3V0c2lkZSB0aGUgcmVjdXJzZWQgc3VicGF0dGVyblxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGBfJCR7ZGVwdGhOdW19YDtcbiAgICAgICAgaWYgKHVubmFtZWQgfHwgY2FwdHVyZU5hbWUpIHtcbiAgICAgICAgICBjb25zdCBhZGRlZENhcHR1cmVOdW0gPSBudW1DYXB0dXJlc1Bhc3NlZCArIGFkZGVkSGlkZGVuQ2FwdHVyZXMubGVuZ3RoICsgMTtcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLnB1c2goYWRkZWRDYXB0dXJlTnVtKTtcbiAgICAgICAgICBpbmNyZW1lbnRJZkF0TGVhc3QoaGlkZGVuQ2FwdHVyZXMsIGFkZGVkQ2FwdHVyZU51bSk7XG4gICAgICAgICAgcmV0dXJuIHVubmFtZWQgPyBtIDogYCg/PCR7Y2FwdHVyZU5hbWV9JHtzdWZmaXh9PmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJgXFxrPCR7YmFja3JlZn0ke3N1ZmZpeH0+YDtcbiAgICAgIH0sXG4gICAgICBDb250ZXh0LkRFRkFVTFRcbiAgICApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuVXBkYXRlcyB0aGUgYXJyYXkgaW4gcGxhY2UgYnkgaW5jcmVtZW50aW5nIGVhY2ggdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0aHJlc2hvbGQuXG5AcGFyYW0ge0FycmF5PG51bWJlcj59IGFyclxuQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIGluY3JlbWVudElmQXRMZWFzdChhcnIsIHRocmVzaG9sZCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0gPj0gdGhyZXNob2xkKSB7XG4gICAgICBhcnJbaV0rKztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG5AcGFyYW0ge01hcDxudW1iZXIsIEFycmF5PG51bWJlcj4+fSBjYXB0dXJlVHJhbnNmZXJzXG5AcGFyYW0ge3N0cmluZ30gbGVmdFxuQHBhcmFtIHtudW1iZXJ9IHJlcHNcbkBwYXJhbSB7bnVtYmVyfSBudW1DYXB0dXJlc0FkZGVkSW5FeHBhbnNpb25cbkBwYXJhbSB7bnVtYmVyfSBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uXG5AcGFyYW0ge251bWJlcn0gbnVtQ2FwdHVyZXNQYXNzZWRcbkByZXR1cm5zIHtNYXA8bnVtYmVyLCBBcnJheTxudW1iZXI+Pn1cbiovXG5mdW5jdGlvbiBtYXBDYXB0dXJlVHJhbnNmZXJzKGNhcHR1cmVUcmFuc2ZlcnMsIGxlZnQsIHJlcHMsIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiwgbnVtQWRkZWRIaWRkZW5DYXB0dXJlc1ByZUV4cGFuc2lvbiwgbnVtQ2FwdHVyZXNQYXNzZWQpIHtcbiAgaWYgKGNhcHR1cmVUcmFuc2ZlcnMuc2l6ZSAmJiBudW1DYXB0dXJlc0FkZGVkSW5FeHBhbnNpb24pIHtcbiAgICBsZXQgbnVtQ2FwdHVyZXNJbkxlZnQgPSAwO1xuICAgIGZvckVhY2hVbmVzY2FwZWQobGVmdCwgY2FwdHVyZURlbGltLCAoKSA9PiBudW1DYXB0dXJlc0luTGVmdCsrLCBDb250ZXh0LkRFRkFVTFQpO1xuICAgIC8vIElzIDAgZm9yIGdsb2JhbCByZWN1cnNpb25cbiAgICBjb25zdCByZWN1cnNpb25EZWxpbUNhcHR1cmVOdW0gPSBudW1DYXB0dXJlc1Bhc3NlZCAtIG51bUNhcHR1cmVzSW5MZWZ0ICsgbnVtQWRkZWRIaWRkZW5DYXB0dXJlc1ByZUV4cGFuc2lvbjtcbiAgICBjb25zdCBuZXdDYXB0dXJlVHJhbnNmZXJzID0gbmV3IE1hcCgpO1xuICAgIGNhcHR1cmVUcmFuc2ZlcnMuZm9yRWFjaCgoZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IG51bUNhcHR1cmVzSW5SaWdodCA9IChudW1DYXB0dXJlc0FkZGVkSW5FeHBhbnNpb24gLSAobnVtQ2FwdHVyZXNJbkxlZnQgKiByZXBzKSkgLyByZXBzO1xuICAgICAgY29uc3QgbnVtQ2FwdHVyZXNBZGRlZEluTGVmdCA9IG51bUNhcHR1cmVzSW5MZWZ0ICogcmVwcztcbiAgICAgIGNvbnN0IG5ld1RvID0gdG8gPiAocmVjdXJzaW9uRGVsaW1DYXB0dXJlTnVtICsgbnVtQ2FwdHVyZXNJbkxlZnQpID8gdG8gKyBudW1DYXB0dXJlc0FkZGVkSW5FeHBhbnNpb24gOiB0bztcbiAgICAgIGNvbnN0IG5ld0Zyb20gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiBmcm9tKSB7XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgcmVjdXJzZWQgc3VicGF0dGVyblxuICAgICAgICBpZiAoZiA8PSByZWN1cnNpb25EZWxpbUNhcHR1cmVOdW0pIHtcbiAgICAgICAgICBuZXdGcm9tLnB1c2goZik7XG4gICAgICAgIC8vIEFmdGVyIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuXG4gICAgICAgIH0gZWxzZSBpZiAoZiA+IChyZWN1cnNpb25EZWxpbUNhcHR1cmVOdW0gKyBudW1DYXB0dXJlc0luTGVmdCArIG51bUNhcHR1cmVzSW5SaWdodCkpIHtcbiAgICAgICAgICBuZXdGcm9tLnB1c2goZiArIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbik7XG4gICAgICAgIC8vIFdpdGhpbiB0aGUgcmVjdXJzZWQgc3VicGF0dGVybiwgb24gdGhlIGxlZnQgb2YgdGhlIHJlY3Vyc2lvbiB0b2tlblxuICAgICAgICB9IGVsc2UgaWYgKGYgPD0gKHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSArIG51bUNhcHR1cmVzSW5MZWZ0KSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJlcHM7IGkrKykge1xuICAgICAgICAgICAgbmV3RnJvbS5wdXNoKGYgKyAobnVtQ2FwdHVyZXNJbkxlZnQgKiBpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBXaXRoaW4gdGhlIHJlY3Vyc2VkIHN1YnBhdHRlcm4sIG9uIHRoZSByaWdodCBvZiB0aGUgcmVjdXJzaW9uIHRva2VuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcmVwczsgaSsrKSB7XG4gICAgICAgICAgICBuZXdGcm9tLnB1c2goZiArIG51bUNhcHR1cmVzQWRkZWRJbkxlZnQgKyAobnVtQ2FwdHVyZXNJblJpZ2h0ICogaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3Q2FwdHVyZVRyYW5zZmVycy5zZXQobmV3VG8sIG5ld0Zyb20pO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdDYXB0dXJlVHJhbnNmZXJzO1xuICB9XG4gIHJldHVybiBjYXB0dXJlVHJhbnNmZXJzO1xufVxuXG5leHBvcnQge1xuICByZWN1cnNpb24sXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\n");

/***/ })

};
;