"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+core@2.5.0";
exports.ids = ["vendor-chunks/@shikijs+core@2.5.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs":
/*!*******************************************************************************************!*\
  !*** ../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontStyle: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle),\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError),\n/* harmony export */   StackElementMetadata: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata),\n/* harmony export */   addClassToHast: () => (/* binding */ addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* binding */ applyColorReplacements),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createCssVariablesTheme: () => (/* binding */ createCssVariablesTheme),\n/* harmony export */   createHighlighterCore: () => (/* binding */ createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* binding */ createHighlighterCoreSync),\n/* harmony export */   createJavaScriptRegexEngine: () => (/* binding */ createJavaScriptRegexEngine),\n/* harmony export */   createOnigurumaEngine: () => (/* binding */ createOnigurumaEngine),\n/* harmony export */   createPositionConverter: () => (/* binding */ createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* binding */ createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* binding */ createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* binding */ createSingletonShorthands),\n/* harmony export */   createWasmOnigEngine: () => (/* binding */ createWasmOnigEngine),\n/* harmony export */   createdBundledHighlighter: () => (/* binding */ createdBundledHighlighter),\n/* harmony export */   defaultJavaScriptRegexConstructor: () => (/* binding */ defaultJavaScriptRegexConstructor),\n/* harmony export */   enableDeprecationWarnings: () => (/* reexport safe */ _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   flatTokenVariants: () => (/* binding */ flatTokenVariants),\n/* harmony export */   getHighlighterCore: () => (/* binding */ getHighlighterCore),\n/* harmony export */   getShikiInternal: () => (/* binding */ getShikiInternal),\n/* harmony export */   getSingletonHighlighterCore: () => (/* binding */ getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* binding */ getTokenStyleObject),\n/* harmony export */   guessEmbeddedLanguages: () => (/* binding */ guessEmbeddedLanguages),\n/* harmony export */   hastToHtml: () => (/* reexport safe */ hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml),\n/* harmony export */   isNoneTheme: () => (/* binding */ isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* binding */ isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* binding */ isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* binding */ isSpecialTheme),\n/* harmony export */   loadWasm: () => (/* binding */ loadWasm),\n/* harmony export */   makeSingletonHighlighter: () => (/* binding */ makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* binding */ makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* binding */ normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* binding */ normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* binding */ resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitToken: () => (/* binding */ splitToken),\n/* harmony export */   splitTokens: () => (/* binding */ splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* binding */ stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* binding */ tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* binding */ tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* binding */ tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* binding */ transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* reexport safe */ _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)\n/* harmony export */ });\n/* harmony import */ var _shikijs_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/types */ \"(rsc)/../node_modules/.pnpm/@shikijs+types@2.5.0/node_modules/@shikijs/types/dist/index.mjs\");\n/* harmony import */ var _shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shikijs/engine-oniguruma */ \"(rsc)/../node_modules/.pnpm/@shikijs+engine-oniguruma@2.5.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs\");\n/* harmony import */ var _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/core.5hv0Law9.mjs */ \"(rsc)/../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs\");\n/* harmony import */ var _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shikijs/vscode-textmate */ \"(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\");\n/* harmony import */ var hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-html */ \"(rsc)/../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/index.js\");\n/* harmony import */ var _shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shikijs/engine-javascript */ \"(rsc)/../node_modules/.pnpm/@shikijs+engine-javascript@2.5.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs\");\n\n\n\n\n\n\n\n\n\n\n\nfunction createOnigurumaEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction createWasmOnigEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction loadWasm(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `loadWasm` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.loadWasm)(options);\n}\n\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\n\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\n\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction guessEmbeddedLanguages(code, _lang, highlighter) {\n  const langs = /* @__PURE__ */ new Set();\n  for (const match of code.matchAll(/lang=[\"']([\\w-]+)[\"']/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/(?:```|~~~)([\\w-]+)/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/\\\\begin\\{([\\w-]+)\\}/g)) {\n    langs.add(match[1]);\n  }\n  if (!highlighter)\n    return Array.from(langs);\n  const bundle = highlighter.getBundledLanguages();\n  return Array.from(langs).filter((l) => l && bundle[l]);\n}\n\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nfunction flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor) {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor) {\n        mergedStyles[key] = value;\n      } else {\n        const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n        const varKey = cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n        mergedStyles[varKey] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline)\n      styles[\"text-decoration\"] = \"underline\";\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  /**\n   * @deprecated use `getScopes` instead\n   */\n  get scopes() {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"GrammarState.scopes is deprecated, use GrammarState.getScopes() instead\");\n    return getScopes(this._stacks[this.theme]);\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.getScopes()\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === void 0)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          if (p.character < 0 || p.character > line.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            offset: converter.posToIndex(p.line, p.character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;\n      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarStart && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  return [\n    ...options.transformers || [],\n    ...builtInTransformers\n  ];\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  8: \"hidden\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B\", position);\n  if (nextEscape !== -1) {\n    if (value[nextEscape + 1] === \"[\") {\n      const nextClose = value.indexOf(\"m\", nextEscape);\n      if (nextClose !== -1) {\n        return {\n          sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n          startPosition: nextEscape,\n          position: nextClose + 1\n        };\n      }\n    }\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence) {\n  const colorMode = sequence.shift();\n  if (colorMode === \"2\") {\n    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));\n    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))\n      return;\n    return {\n      type: \"rgb\",\n      rgb\n    };\n  } else if (colorMode === \"5\") {\n    const index = sequence.shift();\n    if (index) {\n      return { type: \"table\", index: Number(index) };\n    }\n  }\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  while (sequence.length > 0) {\n    const code = sequence.shift();\n    if (!code)\n      continue;\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n        if (decoration === \"dim\") {\n          commands.push({\n            type: \"resetDecoration\",\n            value: \"bold\"\n          });\n        }\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt === 53) {\n      commands.push({\n        type: \"setDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt === 55) {\n      commands.push({\n        type: \"resetDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : void 0;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: void 0,\n      grammarContextCode: void 0\n    }\n  ).stateStack : _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[_shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : void 0;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? void 0 : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      if (typeof token.htmlStyle === \"string\")\n        (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`htmlStyle` as a string is deprecated. Use an object instead.\");\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isUnderline = token.fontStyle && token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      const couldMerge = !isUnderline;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\n\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = (0,hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml)(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nclass Registry extends _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Registry {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options) {\n  if (options.loadWasm) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.\");\n  }\n  if (!options.engine) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options.loadWasm || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.getDefaultWasmLoader)())\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    themes,\n    langs,\n    engine\n  });\n}\nfunction getShikiInternal(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getShikiInternal` is deprecated. Use `createShikiInternal` instead.\");\n  return createShikiInternal(options);\n}\n\nasync function createHighlighterCore(options) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\nfunction getHighlighterCore(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getHighlighterCore` is deprecated. Use `createHighlighterCore` or `getSingletonHighlighterCore` instead.\");\n  return createHighlighterCore(options);\n}\n\nfunction createdBundledHighlighter(arg1, arg2, arg3) {\n  let bundledLanguages;\n  let bundledThemes;\n  let engine;\n  if (arg2) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`createdBundledHighlighter` signature with `bundledLanguages` and `bundledThemes` is deprecated. Use the options object signature instead.\");\n    bundledLanguages = arg1;\n    bundledThemes = arg2;\n    engine = () => createOnigurumaEngine(arg3);\n  } else {\n    const options = arg1;\n    bundledLanguages = options.langs;\n    bundledThemes = options.themes;\n    engine = options.engine;\n  }\n  async function createHighlighter(options) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options.engine ?? engine(),\n      ...options,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      },\n      getBundledLanguages() {\n        return bundledLanguages;\n      },\n      getBundledThemes() {\n        return bundledThemes;\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter, config) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  async function get(code, options) {\n    const shiki = await getSingletonHighlighter({\n      langs: [options.lang],\n      themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n    });\n    const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);\n    if (langs) {\n      await shiki.loadLanguage(...langs);\n    }\n    return shiki;\n  }\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createJavaScriptRegexEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createJavaScriptRegexEngine` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.createJavaScriptRegexEngine)(options);\n}\nfunction defaultJavaScriptRegexConstructor(pattern) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `defaultJavaScriptRegexConstructor` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.defaultJavaScriptRegexConstructor)(pattern);\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMi41LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDN0I7QUFDNEc7QUFDMUU7QUFDVztBQUN1QztBQUNoQjtBQUN4RDtBQUNjO0FBQzJIOztBQUVwTDtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxnRkFBdUI7QUFDaEM7QUFDQTtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxnRkFBdUI7QUFDaEM7QUFDQTtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxtRUFBVTtBQUNuQjs7QUFFQTtBQUNBLHNEQUFzRCxJQUFJO0FBQzFEO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVtNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMi41LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hpa2lFcnJvciBhcyBTaGlraUVycm9yJDEgfSBmcm9tICdAc2hpa2lqcy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICdAc2hpa2lqcy90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVPbmlndXJ1bWFFbmdpbmUgYXMgY3JlYXRlT25pZ3VydW1hRW5naW5lJDEsIGxvYWRXYXNtIGFzIGxvYWRXYXNtJDEsIGdldERlZmF1bHRXYXNtTG9hZGVyIH0gZnJvbSAnQHNoaWtpanMvZW5naW5lLW9uaWd1cnVtYSc7XG5pbXBvcnQgeyB3IGFzIHdhcm5EZXByZWNhdGVkIH0gZnJvbSAnLi9zaGFyZWQvY29yZS41aHYwTGF3OS5tanMnO1xuZXhwb3J0IHsgZSBhcyBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzIH0gZnJvbSAnLi9zaGFyZWQvY29yZS41aHYwTGF3OS5tanMnO1xuaW1wb3J0IHsgRm9udFN0eWxlLCBJTklUSUFMLCBFbmNvZGVkVG9rZW5NZXRhZGF0YSwgUmVnaXN0cnkgYXMgUmVnaXN0cnkkMSwgVGhlbWUgfSBmcm9tICdAc2hpa2lqcy92c2NvZGUtdGV4dG1hdGUnO1xuZXhwb3J0IHsgRm9udFN0eWxlLCBFbmNvZGVkVG9rZW5NZXRhZGF0YSBhcyBTdGFja0VsZW1lbnRNZXRhZGF0YSB9IGZyb20gJ0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZSc7XG5pbXBvcnQgeyB0b0h0bWwgfSBmcm9tICdoYXN0LXV0aWwtdG8taHRtbCc7XG5leHBvcnQgeyB0b0h0bWwgYXMgaGFzdFRvSHRtbCB9IGZyb20gJ2hhc3QtdXRpbC10by1odG1sJztcbmltcG9ydCB7IGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSBhcyBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmUkMSwgZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yIGFzIGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvciQxIH0gZnJvbSAnQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHQnO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBmcm9tIGBAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hYCBvciBgc2hpa2kvZW5naW5lL29uaWd1cnVtYWAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlV2FzbU9uaWdFbmdpbmUob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBmcm9tIGBAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hYCBvciBgc2hpa2kvZW5naW5lL29uaWd1cnVtYWAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbG9hZFdhc20ob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgbG9hZFdhc21gIGZyb20gYEBzaGlraWpzL2VuZ2luZS1vbmlndXJ1bWFgIG9yIGBzaGlraS9lbmdpbmUvb25pZ3VydW1hYCBpbnN0ZWFkXCIpO1xuICByZXR1cm4gbG9hZFdhc20kMShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcGxhY2VtZW50cyA9IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHt9IDogeyAuLi50aGVtZS5jb2xvclJlcGxhY2VtZW50cyB9O1xuICBjb25zdCB0aGVtZU5hbWUgPSB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IHRoZW1lLm5hbWU7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnM/LmNvbG9yUmVwbGFjZW1lbnRzIHx8IHt9KSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXBsYWNlbWVudHNba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgaWYgKGtleSA9PT0gdGhlbWVOYW1lKVxuICAgICAgT2JqZWN0LmFzc2lnbihyZXBsYWNlbWVudHMsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVwbGFjZW1lbnRzO1xufVxuZnVuY3Rpb24gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhjb2xvciwgcmVwbGFjZW1lbnRzKSB7XG4gIGlmICghY29sb3IpXG4gICAgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gcmVwbGFjZW1lbnRzPy5bY29sb3I/LnRvTG93ZXJDYXNlKCldIHx8IGNvbG9yO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xufVxuYXN5bmMgZnVuY3Rpb24gbm9ybWFsaXplR2V0dGVyKHApIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcCgpIDogcCkudGhlbigocikgPT4gci5kZWZhdWx0IHx8IHIpO1xufVxuZnVuY3Rpb24gaXNQbGFpbkxhbmcobGFuZykge1xuICByZXR1cm4gIWxhbmcgfHwgW1wicGxhaW50ZXh0XCIsIFwidHh0XCIsIFwidGV4dFwiLCBcInBsYWluXCJdLmluY2x1ZGVzKGxhbmcpO1xufVxuZnVuY3Rpb24gaXNTcGVjaWFsTGFuZyhsYW5nKSB7XG4gIHJldHVybiBsYW5nID09PSBcImFuc2lcIiB8fCBpc1BsYWluTGFuZyhsYW5nKTtcbn1cbmZ1bmN0aW9uIGlzTm9uZVRoZW1lKHRoZW1lKSB7XG4gIHJldHVybiB0aGVtZSA9PT0gXCJub25lXCI7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWxUaGVtZSh0aGVtZSkge1xuICByZXR1cm4gaXNOb25lVGhlbWUodGhlbWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDbGFzc1RvSGFzdChub2RlLCBjbGFzc05hbWUpIHtcbiAgaWYgKCFjbGFzc05hbWUpXG4gICAgcmV0dXJuIG5vZGU7XG4gIG5vZGUucHJvcGVydGllcyB8fD0ge307XG4gIG5vZGUucHJvcGVydGllcy5jbGFzcyB8fD0gW107XG4gIGlmICh0eXBlb2Ygbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID09PSBcInN0cmluZ1wiKVxuICAgIG5vZGUucHJvcGVydGllcy5jbGFzcyA9IG5vZGUucHJvcGVydGllcy5jbGFzcy5zcGxpdCgvXFxzKy9nKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUucHJvcGVydGllcy5jbGFzcykpXG4gICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID0gW107XG4gIGNvbnN0IHRhcmdldHMgPSBBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkgPyBjbGFzc05hbWUgOiBjbGFzc05hbWUuc3BsaXQoL1xccysvZyk7XG4gIGZvciAoY29uc3QgYyBvZiB0YXJnZXRzKSB7XG4gICAgaWYgKGMgJiYgIW5vZGUucHJvcGVydGllcy5jbGFzcy5pbmNsdWRlcyhjKSlcbiAgICAgIG5vZGUucHJvcGVydGllcy5jbGFzcy5wdXNoKGMpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzcGxpdExpbmVzKGNvZGUsIHByZXNlcnZlRW5kaW5nID0gZmFsc2UpIHtcbiAgY29uc3QgcGFydHMgPSBjb2RlLnNwbGl0KC8oXFxyP1xcbikvZyk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBsaW5lID0gcHJlc2VydmVFbmRpbmcgPyBwYXJ0c1tpXSArIChwYXJ0c1tpICsgMV0gfHwgXCJcIikgOiBwYXJ0c1tpXTtcbiAgICBsaW5lcy5wdXNoKFtsaW5lLCBpbmRleF0pO1xuICAgIGluZGV4ICs9IHBhcnRzW2ldLmxlbmd0aDtcbiAgICBpbmRleCArPSBwYXJ0c1tpICsgMV0/Lmxlbmd0aCB8fCAwO1xuICB9XG4gIHJldHVybiBsaW5lcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQ29udmVydGVyKGNvZGUpIHtcbiAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKGNvZGUsIHRydWUpLm1hcCgoW2xpbmVdKSA9PiBsaW5lKTtcbiAgZnVuY3Rpb24gaW5kZXhUb1BvcyhpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gY29kZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IGxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgIGNoYXJhY3RlcjogbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY2hhcmFjdGVyID0gaW5kZXg7XG4gICAgbGV0IGxpbmUgPSAwO1xuICAgIGZvciAoY29uc3QgbGluZVRleHQgb2YgbGluZXMpIHtcbiAgICAgIGlmIChjaGFyYWN0ZXIgPCBsaW5lVGV4dC5sZW5ndGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2hhcmFjdGVyIC09IGxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgIGxpbmUrKztcbiAgICB9XG4gICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyIH07XG4gIH1cbiAgZnVuY3Rpb24gcG9zVG9JbmRleChsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKVxuICAgICAgaW5kZXggKz0gbGluZXNbaV0ubGVuZ3RoO1xuICAgIGluZGV4ICs9IGNoYXJhY3RlcjtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsaW5lcyxcbiAgICBpbmRleFRvUG9zLFxuICAgIHBvc1RvSW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGd1ZXNzRW1iZWRkZWRMYW5ndWFnZXMoY29kZSwgX2xhbmcsIGhpZ2hsaWdodGVyKSB7XG4gIGNvbnN0IGxhbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC9sYW5nPVtcIiddKFtcXHctXSspW1wiJ10vZykpIHtcbiAgICBsYW5ncy5hZGQobWF0Y2hbMV0pO1xuICB9XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgY29kZS5tYXRjaEFsbCgvKD86YGBgfH5+fikoW1xcdy1dKykvZykpIHtcbiAgICBsYW5ncy5hZGQobWF0Y2hbMV0pO1xuICB9XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgY29kZS5tYXRjaEFsbCgvXFxcXGJlZ2luXFx7KFtcXHctXSspXFx9L2cpKSB7XG4gICAgbGFuZ3MuYWRkKG1hdGNoWzFdKTtcbiAgfVxuICBpZiAoIWhpZ2hsaWdodGVyKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGxhbmdzKTtcbiAgY29uc3QgYnVuZGxlID0gaGlnaGxpZ2h0ZXIuZ2V0QnVuZGxlZExhbmd1YWdlcygpO1xuICByZXR1cm4gQXJyYXkuZnJvbShsYW5ncykuZmlsdGVyKChsKSA9PiBsICYmIGJ1bmRsZVtsXSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0VG9rZW4odG9rZW4sIG9mZnNldHMpIHtcbiAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgZm9yIChjb25zdCBvZmZzZXQgb2Ygb2Zmc2V0cykge1xuICAgIGlmIChvZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKGxhc3RPZmZzZXQsIG9mZnNldCksXG4gICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGxhc3RPZmZzZXQgPCB0b2tlbi5jb250ZW50Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIC4uLnRva2VuLFxuICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShsYXN0T2Zmc2V0KSxcbiAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBzcGxpdFRva2Vucyh0b2tlbnMsIGJyZWFrcG9pbnRzKSB7XG4gIGNvbnN0IHNvcnRlZCA9IEFycmF5LmZyb20oYnJlYWtwb2ludHMgaW5zdGFuY2VvZiBTZXQgPyBicmVha3BvaW50cyA6IG5ldyBTZXQoYnJlYWtwb2ludHMpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGlmICghc29ydGVkLmxlbmd0aClcbiAgICByZXR1cm4gdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBjb25zdCBicmVha3BvaW50c0luVG9rZW4gPSBzb3J0ZWQuZmlsdGVyKChpKSA9PiB0b2tlbi5vZmZzZXQgPCBpICYmIGkgPCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5jb250ZW50Lmxlbmd0aCkubWFwKChpKSA9PiBpIC0gdG9rZW4ub2Zmc2V0KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBpZiAoIWJyZWFrcG9pbnRzSW5Ub2tlbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIHJldHVybiBzcGxpdFRva2VuKHRva2VuLCBicmVha3BvaW50c0luVG9rZW4pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRUb2tlblZhcmlhbnRzKG1lcmdlZCwgdmFyaWFudHNPcmRlciwgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvcikge1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICBjb250ZW50OiBtZXJnZWQuY29udGVudCxcbiAgICBleHBsYW5hdGlvbjogbWVyZ2VkLmV4cGxhbmF0aW9uLFxuICAgIG9mZnNldDogbWVyZ2VkLm9mZnNldFxuICB9O1xuICBjb25zdCBzdHlsZXMgPSB2YXJpYW50c09yZGVyLm1hcCgodCkgPT4gZ2V0VG9rZW5TdHlsZU9iamVjdChtZXJnZWQudmFyaWFudHNbdF0pKTtcbiAgY29uc3Qgc3R5bGVLZXlzID0gbmV3IFNldChzdHlsZXMuZmxhdE1hcCgodCkgPT4gT2JqZWN0LmtleXModCkpKTtcbiAgY29uc3QgbWVyZ2VkU3R5bGVzID0ge307XG4gIHN0eWxlcy5mb3JFYWNoKChjdXIsIGlkeCkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHN0eWxlS2V5cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJba2V5XSB8fCBcImluaGVyaXRcIjtcbiAgICAgIGlmIChpZHggPT09IDAgJiYgZGVmYXVsdENvbG9yKSB7XG4gICAgICAgIG1lcmdlZFN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5ID09PSBcImNvbG9yXCIgPyBcIlwiIDoga2V5ID09PSBcImJhY2tncm91bmQtY29sb3JcIiA/IFwiLWJnXCIgOiBgLSR7a2V5fWA7XG4gICAgICAgIGNvbnN0IHZhcktleSA9IGNzc1ZhcmlhYmxlUHJlZml4ICsgdmFyaWFudHNPcmRlcltpZHhdICsgKGtleSA9PT0gXCJjb2xvclwiID8gXCJcIiA6IGtleU5hbWUpO1xuICAgICAgICBtZXJnZWRTdHlsZXNbdmFyS2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRva2VuLmh0bWxTdHlsZSA9IG1lcmdlZFN0eWxlcztcbiAgcmV0dXJuIHRva2VuO1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5TdHlsZU9iamVjdCh0b2tlbikge1xuICBjb25zdCBzdHlsZXMgPSB7fTtcbiAgaWYgKHRva2VuLmNvbG9yKVxuICAgIHN0eWxlcy5jb2xvciA9IHRva2VuLmNvbG9yO1xuICBpZiAodG9rZW4uYmdDb2xvcilcbiAgICBzdHlsZXNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gdG9rZW4uYmdDb2xvcjtcbiAgaWYgKHRva2VuLmZvbnRTdHlsZSkge1xuICAgIGlmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuSXRhbGljKVxuICAgICAgc3R5bGVzW1wiZm9udC1zdHlsZVwiXSA9IFwiaXRhbGljXCI7XG4gICAgaWYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5Cb2xkKVxuICAgICAgc3R5bGVzW1wiZm9udC13ZWlnaHRcIl0gPSBcImJvbGRcIjtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLlVuZGVybGluZSlcbiAgICAgIHN0eWxlc1tcInRleHQtZGVjb3JhdGlvblwiXSA9IFwidW5kZXJsaW5lXCI7XG4gIH1cbiAgcmV0dXJuIHN0eWxlcztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4pIHtcbiAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gdG9rZW47XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh0b2tlbikubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06JHt2YWx1ZX1gKS5qb2luKFwiO1wiKTtcbn1cblxuY29uc3QgX2dyYW1tYXJTdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKGtleXMsIHN0YXRlKSB7XG4gIF9ncmFtbWFyU3RhdGVNYXAuc2V0KGtleXMsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKGtleXMpIHtcbiAgcmV0dXJuIF9ncmFtbWFyU3RhdGVNYXAuZ2V0KGtleXMpO1xufVxuY2xhc3MgR3JhbW1hclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZW1lIHRvIFN0YWNrIG1hcHBpbmdcbiAgICovXG4gIF9zdGFja3MgPSB7fTtcbiAgbGFuZztcbiAgZ2V0IHRoZW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RhY2tzKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVzWzBdO1xuICB9XG4gIGdldCBfc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGlzLnRoZW1lXTtcbiAgfVxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBpbml0aWFsIGdyYW1tYXIgc3RhdGUuXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbChsYW5nLCB0aGVtZXMpIHtcbiAgICByZXR1cm4gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh0b0FycmF5KHRoZW1lcykubWFwKCh0aGVtZSkgPT4gW3RoZW1lLCBJTklUSUFMXSkpLFxuICAgICAgbGFuZ1xuICAgICk7XG4gIH1cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW3N0YWNrc01hcCwgbGFuZ10gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHN0YWNrc01hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3N0YWNrLCBsYW5nLCB0aGVtZV0gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHsgW3RoZW1lXTogc3RhY2sgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJuYWwgc3RhY2sgb2JqZWN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEludGVybmFsU3RhY2sodGhlbWUgPSB0aGlzLnRoZW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGVtZV07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0U2NvcGVzYCBpbnN0ZWFkXG4gICAqL1xuICBnZXQgc2NvcGVzKCkge1xuICAgIHdhcm5EZXByZWNhdGVkKFwiR3JhbW1hclN0YXRlLnNjb3BlcyBpcyBkZXByZWNhdGVkLCB1c2UgR3JhbW1hclN0YXRlLmdldFNjb3BlcygpIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIGdldFNjb3Blcyh0aGlzLl9zdGFja3NbdGhpcy50aGVtZV0pO1xuICB9XG4gIGdldFNjb3Blcyh0aGVtZSA9IHRoaXMudGhlbWUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKHRoaXMuX3N0YWNrc1t0aGVtZV0pO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICB0aGVtZXM6IHRoaXMudGhlbWVzLFxuICAgICAgc2NvcGVzOiB0aGlzLmdldFNjb3BlcygpXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2NvcGVzKHN0YWNrKSB7XG4gIGNvbnN0IHNjb3BlcyA9IFtdO1xuICBjb25zdCB2aXNpdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gcHVzaFNjb3BlKHN0YWNrMikge1xuICAgIGlmICh2aXNpdGVkLmhhcyhzdGFjazIpKVxuICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWQuYWRkKHN0YWNrMik7XG4gICAgY29uc3QgbmFtZSA9IHN0YWNrMj8ubmFtZVNjb3Blc0xpc3Q/LnNjb3BlTmFtZTtcbiAgICBpZiAobmFtZSlcbiAgICAgIHNjb3Blcy5wdXNoKG5hbWUpO1xuICAgIGlmIChzdGFjazIucGFyZW50KVxuICAgICAgcHVzaFNjb3BlKHN0YWNrMi5wYXJlbnQpO1xuICB9XG4gIHB1c2hTY29wZShzdGFjayk7XG4gIHJldHVybiBzY29wZXM7XG59XG5mdW5jdGlvbiBnZXRHcmFtbWFyU3RhY2soc3RhdGUsIHRoZW1lKSB7XG4gIGlmICghKHN0YXRlIGluc3RhbmNlb2YgR3JhbW1hclN0YXRlKSlcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiSW52YWxpZCBncmFtbWFyIHN0YXRlXCIpO1xuICByZXR1cm4gc3RhdGUuZ2V0SW50ZXJuYWxTdGFjayh0aGVtZSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyRGVjb3JhdGlvbnMoKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiBnZXRDb250ZXh0KHNoaWtpKSB7XG4gICAgaWYgKCFtYXAuaGFzKHNoaWtpLm1ldGEpKSB7XG4gICAgICBsZXQgbm9ybWFsaXplUG9zaXRpb24gPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmIChwIDwgMCB8fCBwID4gc2hpa2kuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEludmFsaWQgZGVjb3JhdGlvbiBvZmZzZXQ6ICR7cH0uIENvZGUgbGVuZ3RoOiAke3NoaWtpLnNvdXJjZS5sZW5ndGh9YCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbnZlcnRlci5pbmRleFRvUG9zKHApLFxuICAgICAgICAgICAgb2Zmc2V0OiBwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gY29udmVydGVyLmxpbmVzW3AubGluZV07XG4gICAgICAgICAgaWYgKGxpbmUgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEludmFsaWQgZGVjb3JhdGlvbiBwb3NpdGlvbiAke0pTT04uc3RyaW5naWZ5KHApfS4gTGluZXMgbGVuZ3RoOiAke2NvbnZlcnRlci5saW5lcy5sZW5ndGh9YCk7XG4gICAgICAgICAgaWYgKHAuY2hhcmFjdGVyIDwgMCB8fCBwLmNoYXJhY3RlciA+IGxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIHBvc2l0aW9uICR7SlNPTi5zdHJpbmdpZnkocCl9LiBMaW5lICR7cC5saW5lfSBsZW5ndGg6ICR7bGluZS5sZW5ndGh9YCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICBvZmZzZXQ6IGNvbnZlcnRlci5wb3NUb0luZGV4KHAubGluZSwgcC5jaGFyYWN0ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNyZWF0ZVBvc2l0aW9uQ29udmVydGVyKHNoaWtpLnNvdXJjZSk7XG4gICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IChzaGlraS5vcHRpb25zLmRlY29yYXRpb25zIHx8IFtdKS5tYXAoKGQpID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHN0YXJ0OiBub3JtYWxpemVQb3NpdGlvbihkLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBub3JtYWxpemVQb3NpdGlvbihkLmVuZClcbiAgICAgIH0pKTtcbiAgICAgIHZlcmlmeUludGVyc2VjdGlvbnMoZGVjb3JhdGlvbnMpO1xuICAgICAgbWFwLnNldChzaGlraS5tZXRhLCB7XG4gICAgICAgIGRlY29yYXRpb25zLFxuICAgICAgICBjb252ZXJ0ZXIsXG4gICAgICAgIHNvdXJjZTogc2hpa2kuc291cmNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcC5nZXQoc2hpa2kubWV0YSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcInNoaWtpOmRlY29yYXRpb25zXCIsXG4gICAgdG9rZW5zKHRva2Vucykge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVjb3JhdGlvbnM/Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dCh0aGlzKTtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gY3R4LmRlY29yYXRpb25zLmZsYXRNYXAoKGQpID0+IFtkLnN0YXJ0Lm9mZnNldCwgZC5lbmQub2Zmc2V0XSk7XG4gICAgICBjb25zdCBzcGxpdHRlZCA9IHNwbGl0VG9rZW5zKHRva2VucywgYnJlYWtwb2ludHMpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVkO1xuICAgIH0sXG4gICAgY29kZShjb2RlRWwpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRlY29yYXRpb25zPy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQodGhpcyk7XG4gICAgICBjb25zdCBsaW5lcyA9IEFycmF5LmZyb20oY29kZUVsLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgaS50YWdOYW1lID09PSBcInNwYW5cIik7XG4gICAgICBpZiAobGluZXMubGVuZ3RoICE9PSBjdHguY29udmVydGVyLmxpbmVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgTnVtYmVyIG9mIGxpbmVzIGluIGNvZGUgZWxlbWVudCAoJHtsaW5lcy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBzb3VyY2UgKCR7Y3R4LmNvbnZlcnRlci5saW5lcy5sZW5ndGh9KS4gRmFpbGVkIHRvIGFwcGx5IGRlY29yYXRpb25zLmApO1xuICAgICAgZnVuY3Rpb24gYXBwbHlMaW5lU2VjdGlvbihsaW5lLCBzdGFydCwgZW5kLCBkZWNvcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxpbmVFbCA9IGxpbmVzW2xpbmVdO1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gLTE7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IC0xO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApXG4gICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT09IDApXG4gICAgICAgICAgZW5kSW5kZXggPSAwO1xuICAgICAgICBpZiAoZW5kID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgZW5kSW5kZXggPSBsaW5lRWwuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEgfHwgZW5kSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lRWwuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gc3RyaW5naWZ5KGxpbmVFbC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEgJiYgdGV4dC5sZW5ndGggPT09IHN0YXJ0KVxuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xICYmIHRleHQubGVuZ3RoID09PSBlbmQpXG4gICAgICAgICAgICAgIGVuZEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBGYWlsZWQgdG8gZmluZCBzdGFydCBpbmRleCBmb3IgZGVjb3JhdGlvbiAke0pTT04uc3RyaW5naWZ5KGRlY29yYXRpb24uc3RhcnQpfWApO1xuICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEZhaWxlZCB0byBmaW5kIGVuZCBpbmRleCBmb3IgZGVjb3JhdGlvbiAke0pTT04uc3RyaW5naWZ5KGRlY29yYXRpb24uZW5kKX1gKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBsaW5lRWwuY2hpbGRyZW4uc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAoIWRlY29yYXRpb24uYWx3YXlzV3JhcCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBhcHBseURlY29yYXRpb24obGluZUVsLCBkZWNvcmF0aW9uLCBcImxpbmVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlY29yYXRpb24uYWx3YXlzV3JhcCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJlbGVtZW50XCIpIHtcbiAgICAgICAgICBhcHBseURlY29yYXRpb24oY2hpbGRyZW5bMF0sIGRlY29yYXRpb24sIFwidG9rZW5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhcHBseURlY29yYXRpb24od3JhcHBlciwgZGVjb3JhdGlvbiwgXCJ3cmFwcGVyXCIpO1xuICAgICAgICAgIGxpbmVFbC5jaGlsZHJlbi5zcGxpY2Uoc3RhcnRJbmRleCwgY2hpbGRyZW4ubGVuZ3RoLCB3cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHlMaW5lKGxpbmUsIGRlY29yYXRpb24pIHtcbiAgICAgICAgbGluZXNbbGluZV0gPSBhcHBseURlY29yYXRpb24obGluZXNbbGluZV0sIGRlY29yYXRpb24sIFwibGluZVwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFwcGx5RGVjb3JhdGlvbihlbCwgZGVjb3JhdGlvbiwgdHlwZSkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGVjb3JhdGlvbi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBkZWNvcmF0aW9uLnRyYW5zZm9ybSB8fCAoKGkpID0+IGkpO1xuICAgICAgICBlbC50YWdOYW1lID0gZGVjb3JhdGlvbi50YWdOYW1lIHx8IFwic3BhblwiO1xuICAgICAgICBlbC5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIC4uLmVsLnByb3BlcnRpZXMsXG4gICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICBjbGFzczogZWwucHJvcGVydGllcy5jbGFzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVjb3JhdGlvbi5wcm9wZXJ0aWVzPy5jbGFzcylcbiAgICAgICAgICBhZGRDbGFzc1RvSGFzdChlbCwgZGVjb3JhdGlvbi5wcm9wZXJ0aWVzLmNsYXNzKTtcbiAgICAgICAgZWwgPSB0cmFuc2Zvcm0oZWwsIHR5cGUpIHx8IGVsO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lQXBwbGllcyA9IFtdO1xuICAgICAgY29uc3Qgc29ydGVkID0gY3R4LmRlY29yYXRpb25zLnNvcnQoKGEsIGIpID0+IGIuc3RhcnQub2Zmc2V0IC0gYS5zdGFydC5vZmZzZXQgfHwgYS5lbmQub2Zmc2V0IC0gYi5lbmQub2Zmc2V0KTtcbiAgICAgIGZvciAoY29uc3QgZGVjb3JhdGlvbiBvZiBzb3J0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBkZWNvcmF0aW9uO1xuICAgICAgICBpZiAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUpIHtcbiAgICAgICAgICBhcHBseUxpbmVTZWN0aW9uKHN0YXJ0LmxpbmUsIHN0YXJ0LmNoYXJhY3RlciwgZW5kLmNoYXJhY3RlciwgZGVjb3JhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQubGluZSA8IGVuZC5saW5lKSB7XG4gICAgICAgICAgYXBwbHlMaW5lU2VjdGlvbihzdGFydC5saW5lLCBzdGFydC5jaGFyYWN0ZXIsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgZGVjb3JhdGlvbik7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0LmxpbmUgKyAxOyBpIDwgZW5kLmxpbmU7IGkrKylcbiAgICAgICAgICAgIGxpbmVBcHBsaWVzLnVuc2hpZnQoKCkgPT4gYXBwbHlMaW5lKGksIGRlY29yYXRpb24pKTtcbiAgICAgICAgICBhcHBseUxpbmVTZWN0aW9uKGVuZC5saW5lLCAwLCBlbmQuY2hhcmFjdGVyLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGluZUFwcGxpZXMuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnRlcnNlY3Rpb25zKGl0ZW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmb28gPSBpdGVtc1tpXTtcbiAgICBpZiAoZm9vLnN0YXJ0Lm9mZnNldCA+IGZvby5lbmQub2Zmc2V0KVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIHJhbmdlOiAke0pTT04uc3RyaW5naWZ5KGZvby5zdGFydCl9IC0gJHtKU09OLnN0cmluZ2lmeShmb28uZW5kKX1gKTtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgYmFyID0gaXRlbXNbal07XG4gICAgICBjb25zdCBpc0Zvb0hhc0JhclN0YXJ0ID0gZm9vLnN0YXJ0Lm9mZnNldCA8PSBiYXIuc3RhcnQub2Zmc2V0ICYmIGJhci5zdGFydC5vZmZzZXQgPCBmb28uZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGlzRm9vSGFzQmFyRW5kID0gZm9vLnN0YXJ0Lm9mZnNldCA8IGJhci5lbmQub2Zmc2V0ICYmIGJhci5lbmQub2Zmc2V0IDw9IGZvby5lbmQub2Zmc2V0O1xuICAgICAgY29uc3QgaXNCYXJIYXNGb29TdGFydCA9IGJhci5zdGFydC5vZmZzZXQgPD0gZm9vLnN0YXJ0Lm9mZnNldCAmJiBmb28uc3RhcnQub2Zmc2V0IDwgYmFyLmVuZC5vZmZzZXQ7XG4gICAgICBjb25zdCBpc0Jhckhhc0Zvb0VuZCA9IGJhci5zdGFydC5vZmZzZXQgPCBmb28uZW5kLm9mZnNldCAmJiBmb28uZW5kLm9mZnNldCA8PSBiYXIuZW5kLm9mZnNldDtcbiAgICAgIGlmIChpc0Zvb0hhc0JhclN0YXJ0IHx8IGlzRm9vSGFzQmFyRW5kIHx8IGlzQmFySGFzRm9vU3RhcnQgfHwgaXNCYXJIYXNGb29FbmQpIHtcbiAgICAgICAgaWYgKGlzRm9vSGFzQmFyU3RhcnQgJiYgaXNGb29IYXNCYXJFbmQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpc0Jhckhhc0Zvb1N0YXJ0ICYmIGlzQmFySGFzRm9vRW5kKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBEZWNvcmF0aW9ucyAke0pTT04uc3RyaW5naWZ5KGZvby5zdGFydCl9IGFuZCAke0pTT04uc3RyaW5naWZ5KGJhci5zdGFydCl9IGludGVyc2VjdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShlbCkge1xuICBpZiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIpXG4gICAgcmV0dXJuIGVsLnZhbHVlO1xuICBpZiAoZWwudHlwZSA9PT0gXCJlbGVtZW50XCIpXG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLm1hcChzdHJpbmdpZnkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBcIlwiO1xufVxuXG5jb25zdCBidWlsdEluVHJhbnNmb3JtZXJzID0gW1xuICAvKiBAX19QVVJFX18gKi8gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpXG5dO1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5vcHRpb25zLnRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAuLi5idWlsdEluVHJhbnNmb3JtZXJzXG4gIF07XG59XG5cbi8vIHNyYy9jb2xvcnMudHNcbnZhciBuYW1lZENvbG9ycyA9IFtcbiAgXCJibGFja1wiLFxuICBcInJlZFwiLFxuICBcImdyZWVuXCIsXG4gIFwieWVsbG93XCIsXG4gIFwiYmx1ZVwiLFxuICBcIm1hZ2VudGFcIixcbiAgXCJjeWFuXCIsXG4gIFwid2hpdGVcIixcbiAgXCJicmlnaHRCbGFja1wiLFxuICBcImJyaWdodFJlZFwiLFxuICBcImJyaWdodEdyZWVuXCIsXG4gIFwiYnJpZ2h0WWVsbG93XCIsXG4gIFwiYnJpZ2h0Qmx1ZVwiLFxuICBcImJyaWdodE1hZ2VudGFcIixcbiAgXCJicmlnaHRDeWFuXCIsXG4gIFwiYnJpZ2h0V2hpdGVcIlxuXTtcblxuLy8gc3JjL2RlY29yYXRpb25zLnRzXG52YXIgZGVjb3JhdGlvbnMgPSB7XG4gIDE6IFwiYm9sZFwiLFxuICAyOiBcImRpbVwiLFxuICAzOiBcIml0YWxpY1wiLFxuICA0OiBcInVuZGVybGluZVwiLFxuICA3OiBcInJldmVyc2VcIixcbiAgODogXCJoaWRkZW5cIixcbiAgOTogXCJzdHJpa2V0aHJvdWdoXCJcbn07XG5cbi8vIHNyYy9wYXJzZXIudHNcbmZ1bmN0aW9uIGZpbmRTZXF1ZW5jZSh2YWx1ZSwgcG9zaXRpb24pIHtcbiAgY29uc3QgbmV4dEVzY2FwZSA9IHZhbHVlLmluZGV4T2YoXCJcXHgxQlwiLCBwb3NpdGlvbik7XG4gIGlmIChuZXh0RXNjYXBlICE9PSAtMSkge1xuICAgIGlmICh2YWx1ZVtuZXh0RXNjYXBlICsgMV0gPT09IFwiW1wiKSB7XG4gICAgICBjb25zdCBuZXh0Q2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwibVwiLCBuZXh0RXNjYXBlKTtcbiAgICAgIGlmIChuZXh0Q2xvc2UgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2VxdWVuY2U6IHZhbHVlLnN1YnN0cmluZyhuZXh0RXNjYXBlICsgMiwgbmV4dENsb3NlKS5zcGxpdChcIjtcIiksXG4gICAgICAgICAgc3RhcnRQb3NpdGlvbjogbmV4dEVzY2FwZSxcbiAgICAgICAgICBwb3NpdGlvbjogbmV4dENsb3NlICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiB2YWx1ZS5sZW5ndGhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29sb3Ioc2VxdWVuY2UpIHtcbiAgY29uc3QgY29sb3JNb2RlID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgaWYgKGNvbG9yTW9kZSA9PT0gXCIyXCIpIHtcbiAgICBjb25zdCByZ2IgPSBzZXF1ZW5jZS5zcGxpY2UoMCwgMykubWFwKCh4KSA9PiBOdW1iZXIucGFyc2VJbnQoeCkpO1xuICAgIGlmIChyZ2IubGVuZ3RoICE9PSAzIHx8IHJnYi5zb21lKCh4KSA9PiBOdW1iZXIuaXNOYU4oeCkpKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJnYlwiLFxuICAgICAgcmdiXG4gICAgfTtcbiAgfSBlbHNlIGlmIChjb2xvck1vZGUgPT09IFwiNVwiKSB7XG4gICAgY29uc3QgaW5kZXggPSBzZXF1ZW5jZS5zaGlmdCgpO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YWJsZVwiLCBpbmRleDogTnVtYmVyKGluZGV4KSB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VTZXF1ZW5jZShzZXF1ZW5jZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICB3aGlsZSAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvZGUgPSBzZXF1ZW5jZS5zaGlmdCgpO1xuICAgIGlmICghY29kZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGNvZGVJbnQgPSBOdW1iZXIucGFyc2VJbnQoY29kZSk7XG4gICAgaWYgKE51bWJlci5pc05hTihjb2RlSW50KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChjb2RlSW50ID09PSAwKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHsgdHlwZTogXCJyZXNldEFsbFwiIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSA5KSB7XG4gICAgICBjb25zdCBkZWNvcmF0aW9uID0gZGVjb3JhdGlvbnNbY29kZUludF07XG4gICAgICBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInNldERlY29yYXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogZGVjb3JhdGlvbnNbY29kZUludF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDI5KSB7XG4gICAgICBjb25zdCBkZWNvcmF0aW9uID0gZGVjb3JhdGlvbnNbY29kZUludCAtIDIwXTtcbiAgICAgIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGRlY29yYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWNvcmF0aW9uID09PSBcImRpbVwiKSB7XG4gICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInJlc2V0RGVjb3JhdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IFwiYm9sZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPD0gMzcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEZvcmVncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSAzMF0gfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSAzOCkge1xuICAgICAgY29uc3QgY29sb3IgPSBwYXJzZUNvbG9yKHNlcXVlbmNlKTtcbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInNldEZvcmVncm91bmRDb2xvclwiLFxuICAgICAgICAgIHZhbHVlOiBjb2xvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDM5KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJyZXNldEZvcmVncm91bmRDb2xvclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPD0gNDcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSA0MF0gfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA0OCkge1xuICAgICAgY29uc3QgY29sb3IgPSBwYXJzZUNvbG9yKHNlcXVlbmNlKTtcbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICAgIHZhbHVlOiBjb2xvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDQ5KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJyZXNldEJhY2tncm91bmRDb2xvclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDUzKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBcIm92ZXJsaW5lXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNTUpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInJlc2V0RGVjb3JhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJvdmVybGluZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPj0gOTAgJiYgY29kZUludCA8PSA5Nykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0Rm9yZWdyb3VuZENvbG9yXCIsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6IFwibmFtZWRcIiwgbmFtZTogbmFtZWRDb2xvcnNbY29kZUludCAtIDkwICsgOF0gfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID49IDEwMCAmJiBjb2RlSW50IDw9IDEwNykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6IFwibmFtZWRcIiwgbmFtZTogbmFtZWRDb2xvcnNbY29kZUludCAtIDEwMCArIDhdIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tbWFuZHM7XG59XG5mdW5jdGlvbiBjcmVhdGVBbnNpU2VxdWVuY2VQYXJzZXIoKSB7XG4gIGxldCBmb3JlZ3JvdW5kID0gbnVsbDtcbiAgbGV0IGJhY2tncm91bmQgPSBudWxsO1xuICBsZXQgZGVjb3JhdGlvbnMyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBmaW5kUmVzdWx0ID0gZmluZFNlcXVlbmNlKHZhbHVlLCBwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHRleHQgPSBmaW5kUmVzdWx0LnNlcXVlbmNlID8gdmFsdWUuc3Vic3RyaW5nKHBvc2l0aW9uLCBmaW5kUmVzdWx0LnN0YXJ0UG9zaXRpb24pIDogdmFsdWUuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGJhY2tncm91bmQsXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogbmV3IFNldChkZWNvcmF0aW9uczIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmRSZXN1bHQuc2VxdWVuY2UpIHtcbiAgICAgICAgICBjb25zdCBjb21tYW5kcyA9IHBhcnNlU2VxdWVuY2UoZmluZFJlc3VsdC5zZXF1ZW5jZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBzdHlsZVRva2VuIG9mIGNvbW1hbmRzKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0QWxsXCIpIHtcbiAgICAgICAgICAgICAgZm9yZWdyb3VuZCA9IG51bGw7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgICBkZWNvcmF0aW9uczIuY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0Rm9yZWdyb3VuZENvbG9yXCIpIHtcbiAgICAgICAgICAgICAgZm9yZWdyb3VuZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEJhY2tncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXREZWNvcmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMyLmRlbGV0ZShzdHlsZVRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBzdHlsZVRva2VuIG9mIGNvbW1hbmRzKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInNldEZvcmVncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBzdHlsZVRva2VuLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwic2V0QmFja2dyb3VuZENvbG9yXCIpIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IHN0eWxlVG9rZW4udmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJzZXREZWNvcmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMyLmFkZChzdHlsZVRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gPSBmaW5kUmVzdWx0LnBvc2l0aW9uO1xuICAgICAgfSB3aGlsZSAocG9zaXRpb24gPCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9wYWxldHRlLnRzXG52YXIgZGVmYXVsdE5hbWVkQ29sb3JzTWFwID0ge1xuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIHJlZDogXCIjYmIwMDAwXCIsXG4gIGdyZWVuOiBcIiMwMGJiMDBcIixcbiAgeWVsbG93OiBcIiNiYmJiMDBcIixcbiAgYmx1ZTogXCIjMDAwMGJiXCIsXG4gIG1hZ2VudGE6IFwiI2ZmMDBmZlwiLFxuICBjeWFuOiBcIiMwMGJiYmJcIixcbiAgd2hpdGU6IFwiI2VlZWVlZVwiLFxuICBicmlnaHRCbGFjazogXCIjNTU1NTU1XCIsXG4gIGJyaWdodFJlZDogXCIjZmY1NTU1XCIsXG4gIGJyaWdodEdyZWVuOiBcIiMwMGZmMDBcIixcbiAgYnJpZ2h0WWVsbG93OiBcIiNmZmZmNTVcIixcbiAgYnJpZ2h0Qmx1ZTogXCIjNTU1NWZmXCIsXG4gIGJyaWdodE1hZ2VudGE6IFwiI2ZmNTVmZlwiLFxuICBicmlnaHRDeWFuOiBcIiM1NWZmZmZcIixcbiAgYnJpZ2h0V2hpdGU6IFwiI2ZmZmZmZlwiXG59O1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JQYWxldHRlKG5hbWVkQ29sb3JzTWFwID0gZGVmYXVsdE5hbWVkQ29sb3JzTWFwKSB7XG4gIGZ1bmN0aW9uIG5hbWVkQ29sb3IobmFtZSkge1xuICAgIHJldHVybiBuYW1lZENvbG9yc01hcFtuYW1lXTtcbiAgfVxuICBmdW5jdGlvbiByZ2JDb2xvcihyZ2IpIHtcbiAgICByZXR1cm4gYCMke3JnYi5tYXAoKHgpID0+IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIDI1NSkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIil9YDtcbiAgfVxuICBsZXQgY29sb3JUYWJsZTtcbiAgZnVuY3Rpb24gZ2V0Q29sb3JUYWJsZSgpIHtcbiAgICBpZiAoY29sb3JUYWJsZSkge1xuICAgICAgcmV0dXJuIGNvbG9yVGFibGU7XG4gICAgfVxuICAgIGNvbG9yVGFibGUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVkQ29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2xvclRhYmxlLnB1c2gobmFtZWRDb2xvcihuYW1lZENvbG9yc1tpXSkpO1xuICAgIH1cbiAgICBsZXQgbGV2ZWxzID0gWzAsIDk1LCAxMzUsIDE3NSwgMjE1LCAyNTVdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgNjsgcisrKSB7XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IDY7IGcrKykge1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IDY7IGIrKykge1xuICAgICAgICAgIGNvbG9yVGFibGUucHVzaChyZ2JDb2xvcihbbGV2ZWxzW3JdLCBsZXZlbHNbZ10sIGxldmVsc1tiXV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbGV2ZWwgPSA4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkrKywgbGV2ZWwgKz0gMTApIHtcbiAgICAgIGNvbG9yVGFibGUucHVzaChyZ2JDb2xvcihbbGV2ZWwsIGxldmVsLCBsZXZlbF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yVGFibGU7XG4gIH1cbiAgZnVuY3Rpb24gdGFibGVDb2xvcihpbmRleCkge1xuICAgIHJldHVybiBnZXRDb2xvclRhYmxlKClbaW5kZXhdO1xuICB9XG4gIGZ1bmN0aW9uIHZhbHVlKGNvbG9yKSB7XG4gICAgc3dpdGNoIChjb2xvci50eXBlKSB7XG4gICAgICBjYXNlIFwibmFtZWRcIjpcbiAgICAgICAgcmV0dXJuIG5hbWVkQ29sb3IoY29sb3IubmFtZSk7XG4gICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIHJldHVybiByZ2JDb2xvcihjb2xvci5yZ2IpO1xuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIHJldHVybiB0YWJsZUNvbG9yKGNvbG9yLmluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB0b2tlbml6ZUFuc2lXaXRoVGhlbWUodGhlbWUsIGZpbGVDb250ZW50cywgb3B0aW9ucykge1xuICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0aGVtZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhmaWxlQ29udGVudHMpO1xuICBjb25zdCBjb2xvclBhbGV0dGUgPSBjcmVhdGVDb2xvclBhbGV0dGUoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbmFtZWRDb2xvcnMubWFwKChuYW1lKSA9PiBbXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRoZW1lLmNvbG9ycz8uW2B0ZXJtaW5hbC5hbnNpJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnN1YnN0cmluZygxKX1gXVxuICAgICAgXSlcbiAgICApXG4gICk7XG4gIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFuc2lTZXF1ZW5jZVBhcnNlcigpO1xuICByZXR1cm4gbGluZXMubWFwKFxuICAgIChsaW5lKSA9PiBwYXJzZXIucGFyc2UobGluZVswXSkubWFwKCh0b2tlbikgPT4ge1xuICAgICAgbGV0IGNvbG9yO1xuICAgICAgbGV0IGJnQ29sb3I7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwicmV2ZXJzZVwiKSkge1xuICAgICAgICBjb2xvciA9IHRva2VuLmJhY2tncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uYmFja2dyb3VuZCkgOiB0aGVtZS5iZztcbiAgICAgICAgYmdDb2xvciA9IHRva2VuLmZvcmVncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uZm9yZWdyb3VuZCkgOiB0aGVtZS5mZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yID0gdG9rZW4uZm9yZWdyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5mb3JlZ3JvdW5kKSA6IHRoZW1lLmZnO1xuICAgICAgICBiZ0NvbG9yID0gdG9rZW4uYmFja2dyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5iYWNrZ3JvdW5kKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbG9yID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhjb2xvciwgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgICAgYmdDb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoYmdDb2xvciwgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcImRpbVwiKSlcbiAgICAgICAgY29sb3IgPSBkaW1Db2xvcihjb2xvcik7XG4gICAgICBsZXQgZm9udFN0eWxlID0gRm9udFN0eWxlLk5vbmU7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwiYm9sZFwiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5Cb2xkO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcIml0YWxpY1wiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5JdGFsaWM7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwidW5kZXJsaW5lXCIpKVxuICAgICAgICBmb250U3R5bGUgfD0gRm9udFN0eWxlLlVuZGVybGluZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHRva2VuLnZhbHVlLFxuICAgICAgICBvZmZzZXQ6IGxpbmVbMV0sXG4gICAgICAgIC8vIFRPRE86IG1vcmUgYWNjdXJhdGUgb2Zmc2V0PyBtaWdodCBuZWVkIHRvIGZvcmsgYW5zaS1zZXF1ZW5jZS1wYXJzZXJcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGJnQ29sb3IsXG4gICAgICAgIGZvbnRTdHlsZVxuICAgICAgfTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gZGltQ29sb3IoY29sb3IpIHtcbiAgY29uc3QgaGV4TWF0Y2ggPSBjb2xvci5tYXRjaCgvIyhbMC05YS1mXXszfSkoWzAtOWEtZl17M30pPyhbMC05YS1mXXsyfSk/Lyk7XG4gIGlmIChoZXhNYXRjaCkge1xuICAgIGlmIChoZXhNYXRjaFszXSkge1xuICAgICAgY29uc3QgYWxwaGEgPSBNYXRoLnJvdW5kKE51bWJlci5wYXJzZUludChoZXhNYXRjaFszXSwgMTYpIC8gMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICAgIHJldHVybiBgIyR7aGV4TWF0Y2hbMV19JHtoZXhNYXRjaFsyXX0ke2FscGhhfWA7XG4gICAgfSBlbHNlIGlmIChoZXhNYXRjaFsyXSkge1xuICAgICAgcmV0dXJuIGAjJHtoZXhNYXRjaFsxXX0ke2hleE1hdGNoWzJdfTgwYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAjJHtBcnJheS5mcm9tKGhleE1hdGNoWzFdKS5tYXAoKHgpID0+IGAke3h9JHt4fWApLmpvaW4oXCJcIil9ODBgO1xuICAgIH1cbiAgfVxuICBjb25zdCBjc3NWYXJNYXRjaCA9IGNvbG9yLm1hdGNoKC92YXJcXCgoLS1bXFx3LV0rLWFuc2ktW1xcdy1dKylcXCkvKTtcbiAgaWYgKGNzc1Zhck1hdGNoKVxuICAgIHJldHVybiBgdmFyKCR7Y3NzVmFyTWF0Y2hbMV19LWRpbSlgO1xuICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIGNvZGVUb1Rva2Vuc0Jhc2UoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbGFuZyA9IFwidGV4dFwiLFxuICAgIHRoZW1lOiB0aGVtZU5hbWUgPSBpbnRlcm5hbC5nZXRMb2FkZWRUaGVtZXMoKVswXVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5MYW5nKGxhbmcpIHx8IGlzTm9uZVRoZW1lKHRoZW1lTmFtZSkpXG4gICAgcmV0dXJuIHNwbGl0TGluZXMoY29kZSkubWFwKChsaW5lKSA9PiBbeyBjb250ZW50OiBsaW5lWzBdLCBvZmZzZXQ6IGxpbmVbMV0gfV0pO1xuICBjb25zdCB7IHRoZW1lLCBjb2xvck1hcCB9ID0gaW50ZXJuYWwuc2V0VGhlbWUodGhlbWVOYW1lKTtcbiAgaWYgKGxhbmcgPT09IFwiYW5zaVwiKVxuICAgIHJldHVybiB0b2tlbml6ZUFuc2lXaXRoVGhlbWUodGhlbWUsIGNvZGUsIG9wdGlvbnMpO1xuICBjb25zdCBfZ3JhbW1hciA9IGludGVybmFsLmdldExhbmd1YWdlKGxhbmcpO1xuICBpZiAob3B0aW9ucy5ncmFtbWFyU3RhdGUpIHtcbiAgICBpZiAob3B0aW9ucy5ncmFtbWFyU3RhdGUubGFuZyAhPT0gX2dyYW1tYXIubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgR3JhbW1hciBzdGF0ZSBsYW5ndWFnZSBcIiR7b3B0aW9ucy5ncmFtbWFyU3RhdGUubGFuZ31cIiBkb2VzIG5vdCBtYXRjaCBoaWdobGlnaHQgbGFuZ3VhZ2UgXCIke19ncmFtbWFyLm5hbWV9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmdyYW1tYXJTdGF0ZS50aGVtZXMuaW5jbHVkZXModGhlbWUubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEdyYW1tYXIgc3RhdGUgdGhlbWVzIFwiJHtvcHRpb25zLmdyYW1tYXJTdGF0ZS50aGVtZXN9XCIgZG8gbm90IGNvbnRhaW4gaGlnaGxpZ2h0IHRoZW1lIFwiJHt0aGVtZS5uYW1lfVwiYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBfZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RHcmFtbWFyU3RhdGUoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAoYXJnc1sxXSk7XG4gIH1cbiAgY29uc3QgW2ludGVybmFsLCBjb2RlLCBvcHRpb25zID0ge31dID0gYXJncztcbiAgY29uc3Qge1xuICAgIGxhbmcgPSBcInRleHRcIixcbiAgICB0aGVtZTogdGhlbWVOYW1lID0gaW50ZXJuYWwuZ2V0TG9hZGVkVGhlbWVzKClbMF1cbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChpc1BsYWluTGFuZyhsYW5nKSB8fCBpc05vbmVUaGVtZSh0aGVtZU5hbWUpKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJQbGFpbiBsYW5ndWFnZSBkb2VzIG5vdCBoYXZlIGdyYW1tYXIgc3RhdGVcIik7XG4gIGlmIChsYW5nID09PSBcImFuc2lcIilcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiQU5TSSBsYW5ndWFnZSBkb2VzIG5vdCBoYXZlIGdyYW1tYXIgc3RhdGVcIik7XG4gIGNvbnN0IHsgdGhlbWUsIGNvbG9yTWFwIH0gPSBpbnRlcm5hbC5zZXRUaGVtZSh0aGVtZU5hbWUpO1xuICBjb25zdCBfZ3JhbW1hciA9IGludGVybmFsLmdldExhbmd1YWdlKGxhbmcpO1xuICByZXR1cm4gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgX2dyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykuc3RhdGVTdGFjayxcbiAgICBfZ3JhbW1hci5uYW1lLFxuICAgIHRoZW1lLm5hbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIHRva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKTtcbiAgY29uc3QgZ3JhbW1hclN0YXRlID0gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKS5zdGF0ZVN0YWNrLFxuICAgIGdyYW1tYXIubmFtZSxcbiAgICB0aGVtZS5uYW1lXG4gICk7XG4gIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChyZXN1bHQudG9rZW5zLCBncmFtbWFyU3RhdGUpO1xuICByZXR1cm4gcmVzdWx0LnRva2Vucztcbn1cbmZ1bmN0aW9uIF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29sb3JSZXBsYWNlbWVudHMgPSByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModGhlbWUsIG9wdGlvbnMpO1xuICBjb25zdCB7XG4gICAgdG9rZW5pemVNYXhMaW5lTGVuZ3RoID0gMCxcbiAgICB0b2tlbml6ZVRpbWVMaW1pdCA9IDUwMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKGNvZGUpO1xuICBsZXQgc3RhdGVTdGFjayA9IG9wdGlvbnMuZ3JhbW1hclN0YXRlID8gZ2V0R3JhbW1hclN0YWNrKG9wdGlvbnMuZ3JhbW1hclN0YXRlLCB0aGVtZS5uYW1lKSA/PyBJTklUSUFMIDogb3B0aW9ucy5ncmFtbWFyQ29udGV4dENvZGUgIT0gbnVsbCA/IF90b2tlbml6ZVdpdGhUaGVtZShcbiAgICBvcHRpb25zLmdyYW1tYXJDb250ZXh0Q29kZSxcbiAgICBncmFtbWFyLFxuICAgIHRoZW1lLFxuICAgIGNvbG9yTWFwLFxuICAgIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBncmFtbWFyU3RhdGU6IHZvaWQgMCxcbiAgICAgIGdyYW1tYXJDb250ZXh0Q29kZTogdm9pZCAwXG4gICAgfVxuICApLnN0YXRlU3RhY2sgOiBJTklUSUFMO1xuICBsZXQgYWN0dWFsID0gW107XG4gIGNvbnN0IGZpbmFsID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IFtsaW5lLCBsaW5lT2Zmc2V0XSA9IGxpbmVzW2ldO1xuICAgIGlmIChsaW5lID09PSBcIlwiKSB7XG4gICAgICBhY3R1YWwgPSBbXTtcbiAgICAgIGZpbmFsLnB1c2goW10pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b2tlbml6ZU1heExpbmVMZW5ndGggPiAwICYmIGxpbmUubGVuZ3RoID49IHRva2VuaXplTWF4TGluZUxlbmd0aCkge1xuICAgICAgYWN0dWFsID0gW107XG4gICAgICBmaW5hbC5wdXNoKFt7XG4gICAgICAgIGNvbnRlbnQ6IGxpbmUsXG4gICAgICAgIG9mZnNldDogbGluZU9mZnNldCxcbiAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgIGZvbnRTdHlsZTogMFxuICAgICAgfV0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCByZXN1bHRXaXRoU2NvcGVzO1xuICAgIGxldCB0b2tlbnNXaXRoU2NvcGVzO1xuICAgIGxldCB0b2tlbnNXaXRoU2NvcGVzSW5kZXg7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZUV4cGxhbmF0aW9uKSB7XG4gICAgICByZXN1bHRXaXRoU2NvcGVzID0gZ3JhbW1hci50b2tlbml6ZUxpbmUobGluZSwgc3RhdGVTdGFjaywgdG9rZW5pemVUaW1lTGltaXQpO1xuICAgICAgdG9rZW5zV2l0aFNjb3BlcyA9IHJlc3VsdFdpdGhTY29wZXMudG9rZW5zO1xuICAgICAgdG9rZW5zV2l0aFNjb3Blc0luZGV4ID0gMDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZ3JhbW1hci50b2tlbml6ZUxpbmUyKGxpbmUsIHN0YXRlU3RhY2ssIHRva2VuaXplVGltZUxpbWl0KTtcbiAgICBjb25zdCB0b2tlbnNMZW5ndGggPSByZXN1bHQudG9rZW5zLmxlbmd0aCAvIDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbnNMZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHJlc3VsdC50b2tlbnNbMiAqIGpdO1xuICAgICAgY29uc3QgbmV4dFN0YXJ0SW5kZXggPSBqICsgMSA8IHRva2Vuc0xlbmd0aCA/IHJlc3VsdC50b2tlbnNbMiAqIGogKyAyXSA6IGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IG5leHRTdGFydEluZGV4KVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVzdWx0LnRva2Vuc1syICogaiArIDFdO1xuICAgICAgY29uc3QgY29sb3IgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKFxuICAgICAgICBjb2xvck1hcFtFbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKV0sXG4gICAgICAgIGNvbG9yUmVwbGFjZW1lbnRzXG4gICAgICApO1xuICAgICAgY29uc3QgZm9udFN0eWxlID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9udFN0eWxlKG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICBjb250ZW50OiBsaW5lLnN1YnN0cmluZyhzdGFydEluZGV4LCBuZXh0U3RhcnRJbmRleCksXG4gICAgICAgIG9mZnNldDogbGluZU9mZnNldCArIHN0YXJ0SW5kZXgsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBmb250U3R5bGVcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgICAgY29uc3QgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycyA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24gIT09IFwic2NvcGVOYW1lXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNldHRpbmcgb2YgdGhlbWUuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RvcnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzZXR0aW5nLnNjb3BlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZXR0aW5nLnNjb3BlLnNwbGl0KC8sLykubWFwKChzY29wZSkgPT4gc2NvcGUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNldHRpbmcuc2NvcGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVtZVNldHRpbmdzU2VsZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZyxcbiAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMubWFwKChzZWxlY3RvcikgPT4gc2VsZWN0b3Iuc3BsaXQoLyAvKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbi5leHBsYW5hdGlvbiA9IFtdO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggKyBvZmZzZXQgPCBuZXh0U3RhcnRJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHRva2VuV2l0aFNjb3BlcyA9IHRva2Vuc1dpdGhTY29wZXNbdG9rZW5zV2l0aFNjb3Blc0luZGV4XTtcbiAgICAgICAgICBjb25zdCB0b2tlbldpdGhTY29wZXNUZXh0ID0gbGluZS5zdWJzdHJpbmcoXG4gICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5lbmRJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2V0ICs9IHRva2VuV2l0aFNjb3Blc1RleHQubGVuZ3RoO1xuICAgICAgICAgIHRva2VuLmV4cGxhbmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgY29udGVudDogdG9rZW5XaXRoU2NvcGVzVGV4dCxcbiAgICAgICAgICAgIHNjb3Blczogb3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24gPT09IFwic2NvcGVOYW1lXCIgPyBleHBsYWluVGhlbWVTY29wZXNOYW1lT25seShcbiAgICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLnNjb3Blc1xuICAgICAgICAgICAgKSA6IGV4cGxhaW5UaGVtZVNjb3Blc0Z1bGwoXG4gICAgICAgICAgICAgIHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMsXG4gICAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5zY29wZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b2tlbnNXaXRoU2NvcGVzSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0dWFsLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICBmaW5hbC5wdXNoKGFjdHVhbCk7XG4gICAgYWN0dWFsID0gW107XG4gICAgc3RhdGVTdGFjayA9IHJlc3VsdC5ydWxlU3RhY2s7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IGZpbmFsLFxuICAgIHN0YXRlU3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cGxhaW5UaGVtZVNjb3Blc05hbWVPbmx5KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLm1hcCgoc2NvcGUpID0+ICh7IHNjb3BlTmFtZTogc2NvcGUgfSkpO1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGVzRnVsbCh0aGVtZVNlbGVjdG9ycywgc2NvcGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2NvcGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaV07XG4gICAgcmVzdWx0W2ldID0ge1xuICAgICAgc2NvcGVOYW1lOiBzY29wZSxcbiAgICAgIHRoZW1lTWF0Y2hlczogZXhwbGFpblRoZW1lU2NvcGUodGhlbWVTZWxlY3RvcnMsIHNjb3BlLCBzY29wZXMuc2xpY2UoMCwgaSkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hlc09uZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09PSBzY29wZSB8fCBzY29wZS5zdWJzdHJpbmcoMCwgc2VsZWN0b3IubGVuZ3RoKSA9PT0gc2VsZWN0b3IgJiYgc2NvcGVbc2VsZWN0b3IubGVuZ3RoXSA9PT0gXCIuXCI7XG59XG5mdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9ycywgc2NvcGUsIHBhcmVudFNjb3Blcykge1xuICBpZiAoIW1hdGNoZXNPbmUoc2VsZWN0b3JzW3NlbGVjdG9ycy5sZW5ndGggLSAxXSwgc2NvcGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IHNlbGVjdG9yUGFyZW50SW5kZXggPSBzZWxlY3RvcnMubGVuZ3RoIC0gMjtcbiAgbGV0IHBhcmVudEluZGV4ID0gcGFyZW50U2NvcGVzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChzZWxlY3RvclBhcmVudEluZGV4ID49IDAgJiYgcGFyZW50SW5kZXggPj0gMCkge1xuICAgIGlmIChtYXRjaGVzT25lKHNlbGVjdG9yc1tzZWxlY3RvclBhcmVudEluZGV4XSwgcGFyZW50U2NvcGVzW3BhcmVudEluZGV4XSkpXG4gICAgICBzZWxlY3RvclBhcmVudEluZGV4IC09IDE7XG4gICAgcGFyZW50SW5kZXggLT0gMTtcbiAgfVxuICBpZiAoc2VsZWN0b3JQYXJlbnRJbmRleCA9PT0gLTEpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4cGxhaW5UaGVtZVNjb3BlKHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMsIHNjb3BlLCBwYXJlbnRTY29wZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgeyBzZWxlY3RvcnMsIHNldHRpbmdzIH0gb2YgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycykge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3JQaWVjZXMgb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBpZiAobWF0Y2hlcyhzZWxlY3RvclBpZWNlcywgc2NvcGUsIHBhcmVudFNjb3BlcykpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2V0dGluZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBjb25zdCB0aGVtZXMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLnRoZW1lcykuZmlsdGVyKChpKSA9PiBpWzFdKS5tYXAoKGkpID0+ICh7IGNvbG9yOiBpWzBdLCB0aGVtZTogaVsxXSB9KSk7XG4gIGNvbnN0IHRoZW1lZFRva2VucyA9IHRoZW1lcy5tYXAoKHQpID0+IHtcbiAgICBjb25zdCB0b2tlbnMyID0gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRoZW1lOiB0LnRoZW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0b2tlbnMyKTtcbiAgICBjb25zdCB0aGVtZSA9IHR5cGVvZiB0LnRoZW1lID09PSBcInN0cmluZ1wiID8gdC50aGVtZSA6IHQudGhlbWUubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiB0b2tlbnMyLFxuICAgICAgc3RhdGUsXG4gICAgICB0aGVtZVxuICAgIH07XG4gIH0pO1xuICBjb25zdCB0b2tlbnMgPSBzeW5jVGhlbWVzVG9rZW5pemF0aW9uKFxuICAgIC4uLnRoZW1lZFRva2Vucy5tYXAoKGkpID0+IGkudG9rZW5zKVxuICApO1xuICBjb25zdCBtZXJnZWRUb2tlbnMgPSB0b2tlbnNbMF0ubWFwKFxuICAgIChsaW5lLCBsaW5lSWR4KSA9PiBsaW5lLm1hcCgoX3Rva2VuLCB0b2tlbklkeCkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkVG9rZW4gPSB7XG4gICAgICAgIGNvbnRlbnQ6IF90b2tlbi5jb250ZW50LFxuICAgICAgICB2YXJpYW50czoge30sXG4gICAgICAgIG9mZnNldDogX3Rva2VuLm9mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChcImluY2x1ZGVFeHBsYW5hdGlvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgICAgbWVyZ2VkVG9rZW4uZXhwbGFuYXRpb24gPSBfdG9rZW4uZXhwbGFuYXRpb247XG4gICAgICB9XG4gICAgICB0b2tlbnMuZm9yRWFjaCgodCwgdGhlbWVJZHgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRlbnQ6IF8sXG4gICAgICAgICAgZXhwbGFuYXRpb246IF9fLFxuICAgICAgICAgIG9mZnNldDogX19fLFxuICAgICAgICAgIC4uLnN0eWxlc1xuICAgICAgICB9ID0gdFtsaW5lSWR4XVt0b2tlbklkeF07XG4gICAgICAgIG1lcmdlZFRva2VuLnZhcmlhbnRzW3RoZW1lc1t0aGVtZUlkeF0uY29sb3JdID0gc3R5bGVzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWVyZ2VkVG9rZW47XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgbWVyZ2VkR3JhbW1hclN0YXRlID0gdGhlbWVkVG9rZW5zWzBdLnN0YXRlID8gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICBPYmplY3QuZnJvbUVudHJpZXModGhlbWVkVG9rZW5zLm1hcCgocykgPT4gW3MudGhlbWUsIHMuc3RhdGU/LmdldEludGVybmFsU3RhY2socy50aGVtZSldKSksXG4gICAgdGhlbWVkVG9rZW5zWzBdLnN0YXRlLmxhbmdcbiAgKSA6IHZvaWQgMDtcbiAgaWYgKG1lcmdlZEdyYW1tYXJTdGF0ZSlcbiAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAobWVyZ2VkVG9rZW5zLCBtZXJnZWRHcmFtbWFyU3RhdGUpO1xuICByZXR1cm4gbWVyZ2VkVG9rZW5zO1xufVxuZnVuY3Rpb24gc3luY1RoZW1lc1Rva2VuaXphdGlvbiguLi50aGVtZXMpIHtcbiAgY29uc3Qgb3V0VGhlbWVzID0gdGhlbWVzLm1hcCgoKSA9PiBbXSk7XG4gIGNvbnN0IGNvdW50ID0gdGhlbWVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGVtZXNbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lcyA9IHRoZW1lcy5tYXAoKHQpID0+IHRbaV0pO1xuICAgIGNvbnN0IG91dExpbmVzID0gb3V0VGhlbWVzLm1hcCgoKSA9PiBbXSk7XG4gICAgb3V0VGhlbWVzLmZvckVhY2goKHQsIGkyKSA9PiB0LnB1c2gob3V0TGluZXNbaTJdKSk7XG4gICAgY29uc3QgaW5kZXhlcyA9IGxpbmVzLm1hcCgoKSA9PiAwKTtcbiAgICBjb25zdCBjdXJyZW50ID0gbGluZXMubWFwKChsKSA9PiBsWzBdKTtcbiAgICB3aGlsZSAoY3VycmVudC5ldmVyeSgodCkgPT4gdCkpIHtcbiAgICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWluKC4uLmN1cnJlbnQubWFwKCh0KSA9PiB0LmNvbnRlbnQubGVuZ3RoKSk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGNvdW50OyBuKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBjdXJyZW50W25dO1xuICAgICAgICBpZiAodG9rZW4uY29udGVudC5sZW5ndGggPT09IG1pbkxlbmd0aCkge1xuICAgICAgICAgIG91dExpbmVzW25dLnB1c2godG9rZW4pO1xuICAgICAgICAgIGluZGV4ZXNbbl0gKz0gMTtcbiAgICAgICAgICBjdXJyZW50W25dID0gbGluZXNbbl1baW5kZXhlc1tuXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0TGluZXNbbl0ucHVzaCh7XG4gICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQuc2xpY2UoMCwgbWluTGVuZ3RoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnRbbl0gPSB7XG4gICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQuc2xpY2UobWluTGVuZ3RoKSxcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbWluTGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0VGhlbWVzO1xufVxuXG5mdW5jdGlvbiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMpIHtcbiAgbGV0IGJnO1xuICBsZXQgZmc7XG4gIGxldCB0b2tlbnM7XG4gIGxldCB0aGVtZU5hbWU7XG4gIGxldCByb290U3R5bGU7XG4gIGxldCBncmFtbWFyU3RhdGU7XG4gIGlmIChcInRoZW1lc1wiIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0Q29sb3IgPSBcImxpZ2h0XCIsXG4gICAgICBjc3NWYXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRoZW1lcyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudGhlbWVzKS5maWx0ZXIoKGkpID0+IGlbMV0pLm1hcCgoaSkgPT4gKHsgY29sb3I6IGlbMF0sIHRoZW1lOiBpWzFdIH0pKS5zb3J0KChhLCBiKSA9PiBhLmNvbG9yID09PSBkZWZhdWx0Q29sb3IgPyAtMSA6IGIuY29sb3IgPT09IGRlZmF1bHRDb2xvciA/IDEgOiAwKTtcbiAgICBpZiAodGhlbWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJgdGhlbWVzYCBvcHRpb24gbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgY29uc3QgdGhlbWVUb2tlbnMgPSBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKFxuICAgICAgaW50ZXJuYWwsXG4gICAgICBjb2RlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZ3JhbW1hclN0YXRlID0gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAodGhlbWVUb2tlbnMpO1xuICAgIGlmIChkZWZhdWx0Q29sb3IgJiYgIXRoZW1lcy5maW5kKCh0KSA9PiB0LmNvbG9yID09PSBkZWZhdWx0Q29sb3IpKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgXFxgdGhlbWVzXFxgIG9wdGlvbiBtdXN0IGNvbnRhaW4gdGhlIGRlZmF1bHRDb2xvciBrZXkgXFxgJHtkZWZhdWx0Q29sb3J9XFxgYCk7XG4gICAgY29uc3QgdGhlbWVSZWdzID0gdGhlbWVzLm1hcCgodCkgPT4gaW50ZXJuYWwuZ2V0VGhlbWUodC50aGVtZSkpO1xuICAgIGNvbnN0IHRoZW1lc09yZGVyID0gdGhlbWVzLm1hcCgodCkgPT4gdC5jb2xvcik7XG4gICAgdG9rZW5zID0gdGhlbWVUb2tlbnMubWFwKChsaW5lKSA9PiBsaW5lLm1hcCgodG9rZW4pID0+IGZsYXRUb2tlblZhcmlhbnRzKHRva2VuLCB0aGVtZXNPcmRlciwgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvcikpKTtcbiAgICBpZiAoZ3JhbW1hclN0YXRlKVxuICAgICAgc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKHRva2VucywgZ3JhbW1hclN0YXRlKTtcbiAgICBjb25zdCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzID0gdGhlbWVzLm1hcCgodCkgPT4gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHQudGhlbWUsIG9wdGlvbnMpKTtcbiAgICBmZyA9IHRoZW1lcy5tYXAoKHQsIGlkeCkgPT4gKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IgPyBcIlwiIDogYCR7Y3NzVmFyaWFibGVQcmVmaXggKyB0LmNvbG9yfTpgKSArIChhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tpZHhdLmZnLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzW2lkeF0pIHx8IFwiaW5oZXJpdFwiKSkuam9pbihcIjtcIik7XG4gICAgYmcgPSB0aGVtZXMubWFwKCh0LCBpZHgpID0+IChpZHggPT09IDAgJiYgZGVmYXVsdENvbG9yID8gXCJcIiA6IGAke2Nzc1ZhcmlhYmxlUHJlZml4ICsgdC5jb2xvcn0tYmc6YCkgKyAoYXBwbHlDb2xvclJlcGxhY2VtZW50cyh0aGVtZVJlZ3NbaWR4XS5iZywgdGhlbWVDb2xvclJlcGxhY2VtZW50c1tpZHhdKSB8fCBcImluaGVyaXRcIikpLmpvaW4oXCI7XCIpO1xuICAgIHRoZW1lTmFtZSA9IGBzaGlraS10aGVtZXMgJHt0aGVtZVJlZ3MubWFwKCh0KSA9PiB0Lm5hbWUpLmpvaW4oXCIgXCIpfWA7XG4gICAgcm9vdFN0eWxlID0gZGVmYXVsdENvbG9yID8gdm9pZCAwIDogW2ZnLCBiZ10uam9pbihcIjtcIik7XG4gIH0gZWxzZSBpZiAoXCJ0aGVtZVwiIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyhvcHRpb25zLnRoZW1lLCBvcHRpb25zKTtcbiAgICB0b2tlbnMgPSBjb2RlVG9Ub2tlbnNCYXNlKFxuICAgICAgaW50ZXJuYWwsXG4gICAgICBjb2RlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgX3RoZW1lID0gaW50ZXJuYWwuZ2V0VGhlbWUob3B0aW9ucy50aGVtZSk7XG4gICAgYmcgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKF90aGVtZS5iZywgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgIGZnID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhfdGhlbWUuZmcsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICB0aGVtZU5hbWUgPSBfdGhlbWUubmFtZTtcbiAgICBncmFtbWFyU3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0b2tlbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJJbnZhbGlkIG9wdGlvbnMsIGVpdGhlciBgdGhlbWVgIG9yIGB0aGVtZXNgIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnMsXG4gICAgZmcsXG4gICAgYmcsXG4gICAgdGhlbWVOYW1lLFxuICAgIHJvb3RTdHlsZSxcbiAgICBncmFtbWFyU3RhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucywgdHJhbnNmb3JtZXJDb250ZXh0ID0ge1xuICBtZXRhOiB7fSxcbiAgb3B0aW9ucyxcbiAgY29kZVRvSGFzdDogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKSxcbiAgY29kZVRvVG9rZW5zOiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIF9jb2RlLCBfb3B0aW9ucylcbn0pIHtcbiAgbGV0IGlucHV0ID0gY29kZTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgaW5wdXQgPSB0cmFuc2Zvcm1lci5wcmVwcm9jZXNzPy5jYWxsKHRyYW5zZm9ybWVyQ29udGV4dCwgaW5wdXQsIG9wdGlvbnMpIHx8IGlucHV0O1xuICBsZXQge1xuICAgIHRva2VucyxcbiAgICBmZyxcbiAgICBiZyxcbiAgICB0aGVtZU5hbWUsXG4gICAgcm9vdFN0eWxlLFxuICAgIGdyYW1tYXJTdGF0ZVxuICB9ID0gY29kZVRvVG9rZW5zKGludGVybmFsLCBpbnB1dCwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZVdoaXRlc3BhY2VzID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKG1lcmdlV2hpdGVzcGFjZXMgPT09IHRydWUpXG4gICAgdG9rZW5zID0gbWVyZ2VXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucyk7XG4gIGVsc2UgaWYgKG1lcmdlV2hpdGVzcGFjZXMgPT09IFwibmV2ZXJcIilcbiAgICB0b2tlbnMgPSBzcGxpdFdoaXRlc3BhY2VUb2tlbnModG9rZW5zKTtcbiAgY29uc3QgY29udGV4dFNvdXJjZSA9IHtcbiAgICAuLi50cmFuc2Zvcm1lckNvbnRleHQsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpKVxuICAgIHRva2VucyA9IHRyYW5zZm9ybWVyLnRva2Vucz8uY2FsbChjb250ZXh0U291cmNlLCB0b2tlbnMpIHx8IHRva2VucztcbiAgcmV0dXJuIHRva2Vuc1RvSGFzdChcbiAgICB0b2tlbnMsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGZnLFxuICAgICAgYmcsXG4gICAgICB0aGVtZU5hbWUsXG4gICAgICByb290U3R5bGVcbiAgICB9LFxuICAgIGNvbnRleHRTb3VyY2UsXG4gICAgZ3JhbW1hclN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiB0b2tlbnNUb0hhc3QodG9rZW5zLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQsIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VucykpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCByb290ID0ge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBjb25zdCB7XG4gICAgc3RydWN0dXJlID0gXCJjbGFzc2ljXCIsXG4gICAgdGFiaW5kZXggPSBcIjBcIlxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHByZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJwcmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBjbGFzczogYHNoaWtpICR7b3B0aW9ucy50aGVtZU5hbWUgfHwgXCJcIn1gLFxuICAgICAgc3R5bGU6IG9wdGlvbnMucm9vdFN0eWxlIHx8IGBiYWNrZ3JvdW5kLWNvbG9yOiR7b3B0aW9ucy5iZ307Y29sb3I6JHtvcHRpb25zLmZnfWAsXG4gICAgICAuLi50YWJpbmRleCAhPT0gZmFsc2UgJiYgdGFiaW5kZXggIT0gbnVsbCA/IHtcbiAgICAgICAgdGFiaW5kZXg6IHRhYmluZGV4LnRvU3RyaW5nKClcbiAgICAgIH0gOiB7fSxcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLm1ldGEgfHwge30pXG4gICAgICAgICkuZmlsdGVyKChba2V5XSkgPT4gIWtleS5zdGFydHNXaXRoKFwiX1wiKSlcbiAgICAgIClcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBsZXQgY29kZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IGxpbmVzXG4gIH07XG4gIGNvbnN0IGxpbmVOb2RlcyA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIC4uLnRyYW5zZm9ybWVyQ29udGV4dCxcbiAgICBzdHJ1Y3R1cmUsXG4gICAgYWRkQ2xhc3NUb0hhc3QsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lckNvbnRleHQuc291cmNlO1xuICAgIH0sXG4gICAgZ2V0IHRva2VucygpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSxcbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuICAgIGdldCBwcmUoKSB7XG4gICAgICByZXR1cm4gcHJlTm9kZTtcbiAgICB9LFxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGNvZGVOb2RlO1xuICAgIH0sXG4gICAgZ2V0IGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGxpbmVOb2RlcztcbiAgICB9XG4gIH07XG4gIHRva2Vucy5mb3JFYWNoKChsaW5lLCBpZHgpID0+IHtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBpZiAoc3RydWN0dXJlID09PSBcImlubGluZVwiKVxuICAgICAgICByb290LmNoaWxkcmVuLnB1c2goeyB0eXBlOiBcImVsZW1lbnRcIiwgdGFnTmFtZTogXCJiclwiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgZWxzZSBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIilcbiAgICAgICAgbGluZXMucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCJcXG5cIiB9KTtcbiAgICB9XG4gICAgbGV0IGxpbmVOb2RlID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgIHByb3BlcnRpZXM6IHsgY2xhc3M6IFwibGluZVwiIH0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGxldCBjb2wgPSAwO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbGluZSkge1xuICAgICAgbGV0IHRva2VuTm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLi4udG9rZW4uaHRtbEF0dHJzXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRva2VuLmNvbnRlbnQgfV1cbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHRva2VuLmh0bWxTdHlsZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoXCJgaHRtbFN0eWxlYCBhcyBhIHN0cmluZyBpcyBkZXByZWNhdGVkLiBVc2UgYW4gb2JqZWN0IGluc3RlYWQuXCIpO1xuICAgICAgY29uc3Qgc3R5bGUgPSBzdHJpbmdpZnlUb2tlblN0eWxlKHRva2VuLmh0bWxTdHlsZSB8fCBnZXRUb2tlblN0eWxlT2JqZWN0KHRva2VuKSk7XG4gICAgICBpZiAoc3R5bGUpXG4gICAgICAgIHRva2VuTm9kZS5wcm9wZXJ0aWVzLnN0eWxlID0gc3R5bGU7XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgICAgdG9rZW5Ob2RlID0gdHJhbnNmb3JtZXI/LnNwYW4/LmNhbGwoY29udGV4dCwgdG9rZW5Ob2RlLCBpZHggKyAxLCBjb2wsIGxpbmVOb2RlLCB0b2tlbikgfHwgdG9rZW5Ob2RlO1xuICAgICAgaWYgKHN0cnVjdHVyZSA9PT0gXCJpbmxpbmVcIilcbiAgICAgICAgcm9vdC5jaGlsZHJlbi5wdXNoKHRva2VuTm9kZSk7XG4gICAgICBlbHNlIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKVxuICAgICAgICBsaW5lTm9kZS5jaGlsZHJlbi5wdXNoKHRva2VuTm9kZSk7XG4gICAgICBjb2wgKz0gdG9rZW4uY29udGVudC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKSB7XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgICAgbGluZU5vZGUgPSB0cmFuc2Zvcm1lcj8ubGluZT8uY2FsbChjb250ZXh0LCBsaW5lTm9kZSwgaWR4ICsgMSkgfHwgbGluZU5vZGU7XG4gICAgICBsaW5lTm9kZXMucHVzaChsaW5lTm9kZSk7XG4gICAgICBsaW5lcy5wdXNoKGxpbmVOb2RlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgY29kZU5vZGUgPSB0cmFuc2Zvcm1lcj8uY29kZT8uY2FsbChjb250ZXh0LCBjb2RlTm9kZSkgfHwgY29kZU5vZGU7XG4gICAgcHJlTm9kZS5jaGlsZHJlbi5wdXNoKGNvZGVOb2RlKTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgIHByZU5vZGUgPSB0cmFuc2Zvcm1lcj8ucHJlPy5jYWxsKGNvbnRleHQsIHByZU5vZGUpIHx8IHByZU5vZGU7XG4gICAgcm9vdC5jaGlsZHJlbi5wdXNoKHByZU5vZGUpO1xuICB9XG4gIGxldCByZXN1bHQgPSByb290O1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICByZXN1bHQgPSB0cmFuc2Zvcm1lcj8ucm9vdD8uY2FsbChjb250ZXh0LCByZXN1bHQpIHx8IHJlc3VsdDtcbiAgaWYgKGdyYW1tYXJTdGF0ZSlcbiAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAocmVzdWx0LCBncmFtbWFyU3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWVyZ2VXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIGNvbnN0IG5ld0xpbmUgPSBbXTtcbiAgICBsZXQgY2FycnlPbkNvbnRlbnQgPSBcIlwiO1xuICAgIGxldCBmaXJzdE9mZnNldCA9IDA7XG4gICAgbGluZS5mb3JFYWNoKCh0b2tlbiwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBpc1VuZGVybGluZSA9IHRva2VuLmZvbnRTdHlsZSAmJiB0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lO1xuICAgICAgY29uc3QgY291bGRNZXJnZSA9ICFpc1VuZGVybGluZTtcbiAgICAgIGlmIChjb3VsZE1lcmdlICYmIHRva2VuLmNvbnRlbnQubWF0Y2goL15cXHMrJC8pICYmIGxpbmVbaWR4ICsgMV0pIHtcbiAgICAgICAgaWYgKCFmaXJzdE9mZnNldClcbiAgICAgICAgICBmaXJzdE9mZnNldCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgY2FycnlPbkNvbnRlbnQgKz0gdG9rZW4uY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYXJyeU9uQ29udGVudCkge1xuICAgICAgICAgIGlmIChjb3VsZE1lcmdlKSB7XG4gICAgICAgICAgICBuZXdMaW5lLnB1c2goe1xuICAgICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBmaXJzdE9mZnNldCxcbiAgICAgICAgICAgICAgY29udGVudDogY2FycnlPbkNvbnRlbnQgKyB0b2tlbi5jb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGluZS5wdXNoKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudDogY2FycnlPbkNvbnRlbnQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmaXJzdE9mZnNldFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3RPZmZzZXQgPSAwO1xuICAgICAgICAgIGNhcnJ5T25Db250ZW50ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3BsaXRXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBpZiAodG9rZW4uY29udGVudC5tYXRjaCgvXlxccyskLykpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIGNvbnN0IG1hdGNoID0gdG9rZW4uY29udGVudC5tYXRjaCgvXihcXHMqKSguKj8pKFxccyopJC8pO1xuICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgY29uc3QgWywgbGVhZGluZywgY29udGVudCwgdHJhaWxpbmddID0gbWF0Y2g7XG4gICAgICBpZiAoIWxlYWRpbmcgJiYgIXRyYWlsaW5nKVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICBjb25zdCBleHBhbmRlZCA9IFt7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldCArIGxlYWRpbmcubGVuZ3RoLFxuICAgICAgICBjb250ZW50XG4gICAgICB9XTtcbiAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgIGV4cGFuZGVkLnVuc2hpZnQoe1xuICAgICAgICAgIGNvbnRlbnQ6IGxlYWRpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgZXhwYW5kZWQucHVzaCh7XG4gICAgICAgICAgY29udGVudDogdHJhaWxpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsZWFkaW5nLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29kZVRvSHRtbChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG1ldGE6IHt9LFxuICAgIG9wdGlvbnMsXG4gICAgY29kZVRvSGFzdDogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKSxcbiAgICBjb2RlVG9Ub2tlbnM6IChfY29kZSwgX29wdGlvbnMpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKVxuICB9O1xuICBsZXQgcmVzdWx0ID0gdG9IdG1sKGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMsIGNvbnRleHQpKTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIucG9zdHByb2Nlc3M/LmNhbGwoY29udGV4dCwgcmVzdWx0LCBvcHRpb25zKSB8fCByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfRkcgPSB7IGxpZ2h0OiBcIiMzMzMzMzNcIiwgZGFyazogXCIjYmJiYmJiXCIgfTtcbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcgPSB7IGxpZ2h0OiBcIiNmZmZmZmVcIiwgZGFyazogXCIjMWUxZTFlXCIgfTtcbmNvbnN0IFJFU09MVkVEX0tFWSA9IFwiX19zaGlraV9yZXNvbHZlZFwiO1xuZnVuY3Rpb24gbm9ybWFsaXplVGhlbWUocmF3VGhlbWUpIHtcbiAgaWYgKHJhd1RoZW1lPy5bUkVTT0xWRURfS0VZXSlcbiAgICByZXR1cm4gcmF3VGhlbWU7XG4gIGNvbnN0IHRoZW1lID0ge1xuICAgIC4uLnJhd1RoZW1lXG4gIH07XG4gIGlmICh0aGVtZS50b2tlbkNvbG9ycyAmJiAhdGhlbWUuc2V0dGluZ3MpIHtcbiAgICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnRva2VuQ29sb3JzO1xuICAgIGRlbGV0ZSB0aGVtZS50b2tlbkNvbG9ycztcbiAgfVxuICB0aGVtZS50eXBlIHx8PSBcImRhcmtcIjtcbiAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHMgPSB7IC4uLnRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzIH07XG4gIHRoZW1lLnNldHRpbmdzIHx8PSBbXTtcbiAgbGV0IHsgYmcsIGZnIH0gPSB0aGVtZTtcbiAgaWYgKCFiZyB8fCAhZmcpIHtcbiAgICBjb25zdCBnbG9iYWxTZXR0aW5nID0gdGhlbWUuc2V0dGluZ3MgPyB0aGVtZS5zZXR0aW5ncy5maW5kKChzKSA9PiAhcy5uYW1lICYmICFzLnNjb3BlKSA6IHZvaWQgMDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmZvcmVncm91bmQpXG4gICAgICBmZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmJhY2tncm91bmQpXG4gICAgICBiZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICBpZiAoIWZnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5mb3JlZ3JvdW5kXCJdKVxuICAgICAgZmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuZm9yZWdyb3VuZFwiXTtcbiAgICBpZiAoIWJnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5iYWNrZ3JvdW5kXCJdKVxuICAgICAgYmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuYmFja2dyb3VuZFwiXTtcbiAgICBpZiAoIWZnKVxuICAgICAgZmcgPSB0aGVtZS50eXBlID09PSBcImxpZ2h0XCIgPyBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0ZHLmxpZ2h0IDogVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRy5kYXJrO1xuICAgIGlmICghYmcpXG4gICAgICBiZyA9IHRoZW1lLnR5cGUgPT09IFwibGlnaHRcIiA/IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcubGlnaHQgOiBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0JHLmRhcms7XG4gICAgdGhlbWUuZmcgPSBmZztcbiAgICB0aGVtZS5iZyA9IGJnO1xuICB9XG4gIGlmICghKHRoZW1lLnNldHRpbmdzWzBdICYmIHRoZW1lLnNldHRpbmdzWzBdLnNldHRpbmdzICYmICF0aGVtZS5zZXR0aW5nc1swXS5zY29wZSkpIHtcbiAgICB0aGVtZS5zZXR0aW5ncy51bnNoaWZ0KHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIGZvcmVncm91bmQ6IHRoZW1lLmZnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5iZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCByZXBsYWNlbWVudENvdW50ID0gMDtcbiAgY29uc3QgcmVwbGFjZW1lbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKSB7XG4gICAgaWYgKHJlcGxhY2VtZW50TWFwLmhhcyh2YWx1ZSkpXG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRNYXAuZ2V0KHZhbHVlKTtcbiAgICByZXBsYWNlbWVudENvdW50ICs9IDE7XG4gICAgY29uc3QgaGV4ID0gYCMke3JlcGxhY2VtZW50Q291bnQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgaWYgKHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzPy5bYCMke2hleH1gXSlcbiAgICAgIHJldHVybiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKTtcbiAgICByZXBsYWNlbWVudE1hcC5zZXQodmFsdWUsIGhleCk7XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnNldHRpbmdzLm1hcCgoc2V0dGluZykgPT4ge1xuICAgIGNvbnN0IHJlcGxhY2VGZyA9IHNldHRpbmcuc2V0dGluZ3M/LmZvcmVncm91bmQgJiYgIXNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZC5zdGFydHNXaXRoKFwiI1wiKTtcbiAgICBjb25zdCByZXBsYWNlQmcgPSBzZXR0aW5nLnNldHRpbmdzPy5iYWNrZ3JvdW5kICYmICFzZXR0aW5nLnNldHRpbmdzLmJhY2tncm91bmQuc3RhcnRzV2l0aChcIiNcIik7XG4gICAgaWYgKCFyZXBsYWNlRmcgJiYgIXJlcGxhY2VCZylcbiAgICAgIHJldHVybiBzZXR0aW5nO1xuICAgIGNvbnN0IGNsb25lID0ge1xuICAgICAgLi4uc2V0dGluZyxcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIC4uLnNldHRpbmcuc2V0dGluZ3NcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXBsYWNlRmcpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcihzZXR0aW5nLnNldHRpbmdzLmZvcmVncm91bmQpO1xuICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gc2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgICAgY2xvbmUuc2V0dGluZ3MuZm9yZWdyb3VuZCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICBpZiAocmVwbGFjZUJnKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGdldFJlcGxhY2VtZW50Q29sb3Ioc2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kKTtcbiAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICAgIGNsb25lLnNldHRpbmdzLmJhY2tncm91bmQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9KTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhlbWUuY29sb3JzIHx8IHt9KSkge1xuICAgIGlmIChrZXkgPT09IFwiZWRpdG9yLmZvcmVncm91bmRcIiB8fCBrZXkgPT09IFwiZWRpdG9yLmJhY2tncm91bmRcIiB8fCBrZXkuc3RhcnRzV2l0aChcInRlcm1pbmFsLmFuc2lcIikpIHtcbiAgICAgIGlmICghdGhlbWUuY29sb3JzW2tleV0/LnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcih0aGVtZS5jb2xvcnNba2V5XSk7XG4gICAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHRoZW1lLmNvbG9yc1trZXldO1xuICAgICAgICB0aGVtZS5jb2xvcnNba2V5XSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlbWUsIFJFU09MVkVEX0tFWSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHRoZW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTGFuZ3MobGFuZ3MpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCgoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbGFuZ3MuZmlsdGVyKChsKSA9PiAhaXNTcGVjaWFsTGFuZyhsKSkubWFwKGFzeW5jIChsYW5nKSA9PiBhd2FpdCBub3JtYWxpemVHZXR0ZXIobGFuZykudGhlbigocikgPT4gQXJyYXkuaXNBcnJheShyKSA/IHIgOiBbcl0pKVxuICApKS5mbGF0KCkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVUaGVtZXModGhlbWVzKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdGhlbWVzLm1hcChcbiAgICAgIGFzeW5jICh0aGVtZSkgPT4gaXNTcGVjaWFsVGhlbWUodGhlbWUpID8gbnVsbCA6IG5vcm1hbGl6ZVRoZW1lKGF3YWl0IG5vcm1hbGl6ZUdldHRlcih0aGVtZSkpXG4gICAgKVxuICApO1xuICByZXR1cm4gcmVzb2x2ZWQuZmlsdGVyKChpKSA9PiAhIWkpO1xufVxuXG5jbGFzcyBTaGlraUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTaGlraUVycm9yXCI7XG4gIH1cbn1cblxuY2xhc3MgUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeSQxIHtcbiAgY29uc3RydWN0b3IoX3Jlc29sdmVyLCBfdGhlbWVzLCBfbGFuZ3MsIF9hbGlhcyA9IHt9KSB7XG4gICAgc3VwZXIoX3Jlc29sdmVyKTtcbiAgICB0aGlzLl9yZXNvbHZlciA9IF9yZXNvbHZlcjtcbiAgICB0aGlzLl90aGVtZXMgPSBfdGhlbWVzO1xuICAgIHRoaXMuX2xhbmdzID0gX2xhbmdzO1xuICAgIHRoaXMuX2FsaWFzID0gX2FsaWFzO1xuICAgIHRoaXMuX3RoZW1lcy5tYXAoKHQpID0+IHRoaXMubG9hZFRoZW1lKHQpKTtcbiAgICB0aGlzLmxvYWRMYW5ndWFnZXModGhpcy5fbGFuZ3MpO1xuICB9XG4gIF9yZXNvbHZlZFRoZW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9yZXNvbHZlZEdyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2xhbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfbGFuZ0dyYXBoID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3RleHRtYXRlVGhlbWVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBfbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICBfbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICBnZXRUaGVtZSh0aGVtZSkge1xuICAgIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRUaGVtZXMuZ2V0KHRoZW1lKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5sb2FkVGhlbWUodGhlbWUpO1xuICB9XG4gIGxvYWRUaGVtZSh0aGVtZSkge1xuICAgIGNvbnN0IF90aGVtZSA9IG5vcm1hbGl6ZVRoZW1lKHRoZW1lKTtcbiAgICBpZiAoX3RoZW1lLm5hbWUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVkVGhlbWVzLnNldChfdGhlbWUubmFtZSwgX3RoZW1lKTtcbiAgICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGVtZTtcbiAgfVxuICBnZXRMb2FkZWRUaGVtZXMoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2FkZWRUaGVtZXNDYWNoZSlcbiAgICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gWy4uLnRoaXMuX3Jlc29sdmVkVGhlbWVzLmtleXMoKV07XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlO1xuICB9XG4gIC8vIE92ZXJyaWRlIGFuZCByZS1pbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gY2FjaGUgdGhlIHRleHRtYXRlIHRoZW1lcyBhcyBgVGV4dE1hdGVUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWVgXG4gIC8vIGlzIGV4cGVuc2l2ZS4gVGhlbWVzIGNhbiBzd2l0Y2ggb2Z0ZW4gZXNwZWNpYWxseSBmb3IgZHVhbC10aGVtZSBzdXBwb3J0LlxuICAvL1xuICAvLyBUaGUgcGFyZW50IGNsYXNzIGFsc28gYWNjZXB0cyBgY29sb3JNYXBgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCBidXQgc2luY2Ugd2UgZG9uJ3QgdXNlIHRoYXQsXG4gIC8vIHdlIG9taXQgaGVyZSBzbyBpdCdzIGVhc2llciB0byBjYWNoZSB0aGUgdGhlbWVzLlxuICBzZXRUaGVtZSh0aGVtZSkge1xuICAgIGxldCB0ZXh0bWF0ZVRoZW1lID0gdGhpcy5fdGV4dG1hdGVUaGVtZUNhY2hlLmdldCh0aGVtZSk7XG4gICAgaWYgKCF0ZXh0bWF0ZVRoZW1lKSB7XG4gICAgICB0ZXh0bWF0ZVRoZW1lID0gVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKHRoZW1lKTtcbiAgICAgIHRoaXMuX3RleHRtYXRlVGhlbWVDYWNoZS5zZXQodGhlbWUsIHRleHRtYXRlVGhlbWUpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuc2V0VGhlbWUodGV4dG1hdGVUaGVtZSk7XG4gIH1cbiAgZ2V0R3JhbW1hcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2FsaWFzW25hbWVdKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtuYW1lXSk7XG4gICAgICB3aGlsZSAodGhpcy5fYWxpYXNbbmFtZV0pIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuX2FsaWFzW25hbWVdO1xuICAgICAgICBpZiAocmVzb2x2ZWQuaGFzKG5hbWUpKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBDaXJjdWxhciBhbGlhcyBcXGAke0FycmF5LmZyb20ocmVzb2x2ZWQpLmpvaW4oXCIgLT4gXCIpfSAtPiAke25hbWV9XFxgYCk7XG4gICAgICAgIHJlc29sdmVkLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZ2V0KG5hbWUpO1xuICB9XG4gIGxvYWRMYW5ndWFnZShsYW5nKSB7XG4gICAgaWYgKHRoaXMuZ2V0R3JhbW1hcihsYW5nLm5hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVtYmVkZGVkTGF6aWx5QnkgPSBuZXcgU2V0KFxuICAgICAgWy4uLnRoaXMuX2xhbmdNYXAudmFsdWVzKCldLmZpbHRlcigoaSkgPT4gaS5lbWJlZGRlZExhbmdzTGF6eT8uaW5jbHVkZXMobGFuZy5uYW1lKSlcbiAgICApO1xuICAgIHRoaXMuX3Jlc29sdmVyLmFkZExhbmd1YWdlKGxhbmcpO1xuICAgIGNvbnN0IGdyYW1tYXJDb25maWcgPSB7XG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM6IGxhbmcuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtcIipcIl0sXG4gICAgICB1bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9yczogbGFuZy51bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyB8fCBbXVxuICAgIH07XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5Ll9yYXdHcmFtbWFycy5zZXQobGFuZy5zY29wZU5hbWUsIGxhbmcpO1xuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRHcmFtbWFyV2l0aENvbmZpZ3VyYXRpb24obGFuZy5zY29wZU5hbWUsIDEsIGdyYW1tYXJDb25maWcpO1xuICAgIGcubmFtZSA9IGxhbmcubmFtZTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLnNldChsYW5nLm5hbWUsIGcpO1xuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIGxhbmcuYWxpYXNlcy5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICB0aGlzLl9hbGlhc1thbGlhc10gPSBsYW5nLm5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICAgIGlmIChlbWJlZGRlZExhemlseUJ5LnNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBlbWJlZGRlZExhemlseUJ5KSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZGVsZXRlKGUubmFtZSk7XG4gICAgICAgIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5Py5faW5qZWN0aW9uR3JhbW1hcnM/LmRlbGV0ZShlLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMuX3N5bmNSZWdpc3RyeT8uX2dyYW1tYXJzPy5kZWxldGUoZS5zY29wZU5hbWUpO1xuICAgICAgICB0aGlzLmxvYWRMYW5ndWFnZSh0aGlzLl9sYW5nTWFwLmdldChlLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fbGFuZ01hcC5jbGVhcigpO1xuICAgIHRoaXMuX2xhbmdHcmFwaC5jbGVhcigpO1xuICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gbnVsbDtcbiAgfVxuICBsb2FkTGFuZ3VhZ2VzKGxhbmdzKSB7XG4gICAgZm9yIChjb25zdCBsYW5nIG9mIGxhbmdzKVxuICAgICAgdGhpcy5yZXNvbHZlRW1iZWRkZWRMYW5ndWFnZXMobGFuZyk7XG4gICAgY29uc3QgbGFuZ3NHcmFwaEFycmF5ID0gQXJyYXkuZnJvbSh0aGlzLl9sYW5nR3JhcGguZW50cmllcygpKTtcbiAgICBjb25zdCBtaXNzaW5nTGFuZ3MgPSBsYW5nc0dyYXBoQXJyYXkuZmlsdGVyKChbXywgbGFuZ10pID0+ICFsYW5nKTtcbiAgICBpZiAobWlzc2luZ0xhbmdzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IGxhbmdzR3JhcGhBcnJheS5maWx0ZXIoKFtfLCBsYW5nXSkgPT4gbGFuZyAmJiBsYW5nLmVtYmVkZGVkTGFuZ3M/LnNvbWUoKGwpID0+IG1pc3NpbmdMYW5ncy5tYXAoKFtuYW1lXSkgPT4gbmFtZSkuaW5jbHVkZXMobCkpKS5maWx0ZXIoKGxhbmcpID0+ICFtaXNzaW5nTGFuZ3MuaW5jbHVkZXMobGFuZykpO1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYE1pc3NpbmcgbGFuZ3VhZ2VzICR7bWlzc2luZ0xhbmdzLm1hcCgoW25hbWVdKSA9PiBgXFxgJHtuYW1lfVxcYGApLmpvaW4oXCIsIFwiKX0sIHJlcXVpcmVkIGJ5ICR7ZGVwZW5kZW50cy5tYXAoKFtuYW1lXSkgPT4gYFxcYCR7bmFtZX1cXGBgKS5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW18sIGxhbmddIG9mIGxhbmdzR3JhcGhBcnJheSlcbiAgICAgIHRoaXMuX3Jlc29sdmVyLmFkZExhbmd1YWdlKGxhbmcpO1xuICAgIGZvciAoY29uc3QgW18sIGxhbmddIG9mIGxhbmdzR3JhcGhBcnJheSlcbiAgICAgIHRoaXMubG9hZExhbmd1YWdlKGxhbmcpO1xuICB9XG4gIGdldExvYWRlZExhbmd1YWdlcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlKSB7XG4gICAgICB0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IFtcbiAgICAgICAgLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRoaXMuX3Jlc29sdmVkR3JhbW1hcnMua2V5cygpLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9hbGlhcyldKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlO1xuICB9XG4gIHJlc29sdmVFbWJlZGRlZExhbmd1YWdlcyhsYW5nKSB7XG4gICAgdGhpcy5fbGFuZ01hcC5zZXQobGFuZy5uYW1lLCBsYW5nKTtcbiAgICB0aGlzLl9sYW5nR3JhcGguc2V0KGxhbmcubmFtZSwgbGFuZyk7XG4gICAgaWYgKGxhbmcuZW1iZWRkZWRMYW5ncykge1xuICAgICAgZm9yIChjb25zdCBlbWJlZGRlZExhbmcgb2YgbGFuZy5lbWJlZGRlZExhbmdzKVxuICAgICAgICB0aGlzLl9sYW5nR3JhcGguc2V0KGVtYmVkZGVkTGFuZywgdGhpcy5fbGFuZ01hcC5nZXQoZW1iZWRkZWRMYW5nKSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlc29sdmVyIHtcbiAgX2xhbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Njb3BlVG9MYW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2luamVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfb25pZ0xpYjtcbiAgY29uc3RydWN0b3IoZW5naW5lLCBsYW5ncykge1xuICAgIHRoaXMuX29uaWdMaWIgPSB7XG4gICAgICBjcmVhdGVPbmlnU2Nhbm5lcjogKHBhdHRlcm5zKSA9PiBlbmdpbmUuY3JlYXRlU2Nhbm5lcihwYXR0ZXJucyksXG4gICAgICBjcmVhdGVPbmlnU3RyaW5nOiAocykgPT4gZW5naW5lLmNyZWF0ZVN0cmluZyhzKVxuICAgIH07XG4gICAgbGFuZ3MuZm9yRWFjaCgoaSkgPT4gdGhpcy5hZGRMYW5ndWFnZShpKSk7XG4gIH1cbiAgZ2V0IG9uaWdMaWIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uaWdMaWI7XG4gIH1cbiAgZ2V0TGFuZ1JlZ2lzdHJhdGlvbihsYW5nSWRPckFsaWFzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhbmdzLmdldChsYW5nSWRPckFsaWFzKTtcbiAgfVxuICBsb2FkR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NvcGVUb0xhbmcuZ2V0KHNjb3BlTmFtZSk7XG4gIH1cbiAgYWRkTGFuZ3VhZ2UobCkge1xuICAgIHRoaXMuX2xhbmdzLnNldChsLm5hbWUsIGwpO1xuICAgIGlmIChsLmFsaWFzZXMpIHtcbiAgICAgIGwuYWxpYXNlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhbmdzLnNldChhLCBsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zY29wZVRvTGFuZy5zZXQobC5zY29wZU5hbWUsIGwpO1xuICAgIGlmIChsLmluamVjdFRvKSB7XG4gICAgICBsLmluamVjdFRvLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbmplY3Rpb25zLmdldChpKSlcbiAgICAgICAgICB0aGlzLl9pbmplY3Rpb25zLnNldChpLCBbXSk7XG4gICAgICAgIHRoaXMuX2luamVjdGlvbnMuZ2V0KGkpLnB1c2gobC5zY29wZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEluamVjdGlvbnMoc2NvcGVOYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVQYXJ0cyA9IHNjb3BlTmFtZS5zcGxpdChcIi5cIik7XG4gICAgbGV0IGluamVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzY29wZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJTY29wZU5hbWUgPSBzY29wZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIuXCIpO1xuICAgICAgaW5qZWN0aW9ucyA9IFsuLi5pbmplY3Rpb25zLCAuLi50aGlzLl9pbmplY3Rpb25zLmdldChzdWJTY29wZU5hbWUpIHx8IFtdXTtcbiAgICB9XG4gICAgcmV0dXJuIGluamVjdGlvbnM7XG4gIH1cbn1cblxubGV0IGluc3RhbmNlc0NvdW50ID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jKG9wdGlvbnMpIHtcbiAgaW5zdGFuY2VzQ291bnQgKz0gMTtcbiAgaWYgKG9wdGlvbnMud2FybmluZ3MgIT09IGZhbHNlICYmIGluc3RhbmNlc0NvdW50ID49IDEwICYmIGluc3RhbmNlc0NvdW50ICUgMTAgPT09IDApXG4gICAgY29uc29sZS53YXJuKGBbU2hpa2ldICR7aW5zdGFuY2VzQ291bnR9IGluc3RhbmNlcyBoYXZlIGJlZW4gY3JlYXRlZC4gU2hpa2kgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBhcyBhIHNpbmdsZXRvbiwgY29uc2lkZXIgcmVmYWN0b3JpbmcgeW91ciBjb2RlIHRvIGNhY2hlIHlvdXIgaGlnaGxpZ2h0ZXIgaW5zdGFuY2U7IE9yIGNhbGwgXFxgaGlnaGxpZ2h0ZXIuZGlzcG9zZSgpXFxgIHRvIHJlbGVhc2UgdW51c2VkIGluc3RhbmNlcy5gKTtcbiAgbGV0IGlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgaWYgKCFvcHRpb25zLmVuZ2luZSlcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihcImBlbmdpbmVgIG9wdGlvbiBpcyByZXF1aXJlZCBmb3Igc3luY2hyb25vdXMgbW9kZVwiKTtcbiAgY29uc3QgbGFuZ3MgPSAob3B0aW9ucy5sYW5ncyB8fCBbXSkuZmxhdCgxKTtcbiAgY29uc3QgdGhlbWVzID0gKG9wdGlvbnMudGhlbWVzIHx8IFtdKS5mbGF0KDEpLm1hcChub3JtYWxpemVUaGVtZSk7XG4gIGNvbnN0IHJlc29sdmVyID0gbmV3IFJlc29sdmVyKG9wdGlvbnMuZW5naW5lLCBsYW5ncyk7XG4gIGNvbnN0IF9yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShyZXNvbHZlciwgdGhlbWVzLCBsYW5ncywgb3B0aW9ucy5sYW5nQWxpYXMpO1xuICBsZXQgX2xhc3RUaGVtZTtcbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgY29uc3QgX2xhbmcgPSBfcmVnaXN0cnkuZ2V0R3JhbW1hcih0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5hbWUgOiBuYW1lLm5hbWUpO1xuICAgIGlmICghX2xhbmcpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgTGFuZ3VhZ2UgXFxgJHtuYW1lfVxcYCBub3QgZm91bmQsIHlvdSBtYXkgbmVlZCB0byBsb2FkIGl0IGZpcnN0YCk7XG4gICAgcmV0dXJuIF9sYW5nO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRoZW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJub25lXCIpXG4gICAgICByZXR1cm4geyBiZzogXCJcIiwgZmc6IFwiXCIsIG5hbWU6IFwibm9uZVwiLCBzZXR0aW5nczogW10sIHR5cGU6IFwiZGFya1wiIH07XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCBfdGhlbWUgPSBfcmVnaXN0cnkuZ2V0VGhlbWUobmFtZSk7XG4gICAgaWYgKCFfdGhlbWUpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgVGhlbWUgXFxgJHtuYW1lfVxcYCBub3QgZm91bmQsIHlvdSBtYXkgbmVlZCB0byBsb2FkIGl0IGZpcnN0YCk7XG4gICAgcmV0dXJuIF90aGVtZTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUaGVtZShuYW1lKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKG5hbWUpO1xuICAgIGlmIChfbGFzdFRoZW1lICE9PSBuYW1lKSB7XG4gICAgICBfcmVnaXN0cnkuc2V0VGhlbWUodGhlbWUpO1xuICAgICAgX2xhc3RUaGVtZSA9IG5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yTWFwID0gX3JlZ2lzdHJ5LmdldENvbG9yTWFwKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW1lLFxuICAgICAgY29sb3JNYXBcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldExvYWRlZFRoZW1lcygpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiBfcmVnaXN0cnkuZ2V0TG9hZGVkVGhlbWVzKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9hZGVkTGFuZ3VhZ2VzKCkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIF9yZWdpc3RyeS5nZXRMb2FkZWRMYW5ndWFnZXMoKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2VTeW5jKC4uLmxhbmdzMikge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgX3JlZ2lzdHJ5LmxvYWRMYW5ndWFnZXMobGFuZ3MyLmZsYXQoMSkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZSguLi5sYW5nczIpIHtcbiAgICByZXR1cm4gbG9hZExhbmd1YWdlU3luYyhhd2FpdCByZXNvbHZlTGFuZ3MobGFuZ3MyKSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZFRoZW1lU3luYyguLi50aGVtZXMyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBmb3IgKGNvbnN0IHRoZW1lIG9mIHRoZW1lczIuZmxhdCgxKSkge1xuICAgICAgX3JlZ2lzdHJ5LmxvYWRUaGVtZSh0aGVtZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRUaGVtZSguLi50aGVtZXMyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICByZXR1cm4gbG9hZFRoZW1lU3luYyhhd2FpdCByZXNvbHZlVGhlbWVzKHRoZW1lczIpKTtcbiAgfVxuICBmdW5jdGlvbiBlbnN1cmVOb3REaXNwb3NlZCgpIHtcbiAgICBpZiAoaXNEaXNwb3NlZClcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKFwiU2hpa2kgaW5zdGFuY2UgaGFzIGJlZW4gZGlzcG9zZWRcIik7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAoaXNEaXNwb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBpc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBfcmVnaXN0cnkuZGlzcG9zZSgpO1xuICAgIGluc3RhbmNlc0NvdW50IC09IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzZXRUaGVtZSxcbiAgICBnZXRUaGVtZSxcbiAgICBnZXRMYW5ndWFnZSxcbiAgICBnZXRMb2FkZWRUaGVtZXMsXG4gICAgZ2V0TG9hZGVkTGFuZ3VhZ2VzLFxuICAgIGxvYWRMYW5ndWFnZSxcbiAgICBsb2FkTGFuZ3VhZ2VTeW5jLFxuICAgIGxvYWRUaGVtZSxcbiAgICBsb2FkVGhlbWVTeW5jLFxuICAgIGRpc3Bvc2UsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogZGlzcG9zZVxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTaGlraUludGVybmFsKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubG9hZFdhc20pIHtcbiAgICB3YXJuRGVwcmVjYXRlZChcImBsb2FkV2FzbWAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgZW5naW5lOiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUobG9hZFdhc20pYCBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZW5naW5lKSB7XG4gICAgd2FybkRlcHJlY2F0ZWQoXCJgZW5naW5lYCBvcHRpb24gaXMgcmVxdWlyZWQuIFVzZSBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBvciBgY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lYCB0byBjcmVhdGUgYW4gZW5naW5lLlwiKTtcbiAgfVxuICBjb25zdCBbXG4gICAgdGhlbWVzLFxuICAgIGxhbmdzLFxuICAgIGVuZ2luZVxuICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIHJlc29sdmVUaGVtZXMob3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgIHJlc29sdmVMYW5ncyhvcHRpb25zLmxhbmdzIHx8IFtdKSxcbiAgICBvcHRpb25zLmVuZ2luZSB8fCBjcmVhdGVPbmlndXJ1bWFFbmdpbmUkMShvcHRpb25zLmxvYWRXYXNtIHx8IGdldERlZmF1bHRXYXNtTG9hZGVyKCkpXG4gIF0pO1xuICByZXR1cm4gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGhlbWVzLFxuICAgIGxhbmdzLFxuICAgIGVuZ2luZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNoaWtpSW50ZXJuYWwob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImBnZXRTaGlraUludGVybmFsYCBpcyBkZXByZWNhdGVkLiBVc2UgYGNyZWF0ZVNoaWtpSW50ZXJuYWxgIGluc3RlYWQuXCIpO1xuICByZXR1cm4gY3JlYXRlU2hpa2lJbnRlcm5hbChvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgaW50ZXJuYWwgPSBhd2FpdCBjcmVhdGVTaGlraUludGVybmFsKG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGdldExhc3RHcmFtbWFyU3RhdGU6ICguLi5hcmdzKSA9PiBnZXRMYXN0R3JhbW1hclN0YXRlKGludGVybmFsLCAuLi5hcmdzKSxcbiAgICBjb2RlVG9Ub2tlbnNCYXNlOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2Vuc0Jhc2UoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9Ub2tlbnM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvSGFzdDogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvSHRtbDogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9IdG1sKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgZ2V0QnVuZGxlZExhbmd1YWdlczogKCkgPT4gKHt9KSxcbiAgICBnZXRCdW5kbGVkVGhlbWVzOiAoKSA9PiAoe30pLFxuICAgIC4uLmludGVybmFsLFxuICAgIGdldEludGVybmFsQ29udGV4dDogKCkgPT4gaW50ZXJuYWxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZVN5bmMob3B0aW9ucykge1xuICBjb25zdCBpbnRlcm5hbCA9IGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jKG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGdldExhc3RHcmFtbWFyU3RhdGU6ICguLi5hcmdzKSA9PiBnZXRMYXN0R3JhbW1hclN0YXRlKGludGVybmFsLCAuLi5hcmdzKSxcbiAgICBjb2RlVG9Ub2tlbnNCYXNlOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2Vuc0Jhc2UoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9Ub2tlbnM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvSGFzdDogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvSHRtbDogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9IdG1sKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgZ2V0QnVuZGxlZExhbmd1YWdlczogKCkgPT4gKHt9KSxcbiAgICBnZXRCdW5kbGVkVGhlbWVzOiAoKSA9PiAoe30pLFxuICAgIC4uLmludGVybmFsLFxuICAgIGdldEludGVybmFsQ29udGV4dDogKCkgPT4gaW50ZXJuYWxcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlckNvcmUoY3JlYXRlSGlnaGxpZ2h0ZXIpIHtcbiAgbGV0IF9zaGlraTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlMihvcHRpb25zKSB7XG4gICAgaWYgKCFfc2hpa2kpIHtcbiAgICAgIF9zaGlraSA9IGNyZWF0ZUhpZ2hsaWdodGVyKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdGhlbWVzOiBvcHRpb25zLnRoZW1lcyB8fCBbXSxcbiAgICAgICAgbGFuZ3M6IG9wdGlvbnMubGFuZ3MgfHwgW11cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9zaGlraTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IGF3YWl0IF9zaGlraTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgcy5sb2FkVGhlbWUoLi4ub3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgICAgICBzLmxvYWRMYW5ndWFnZSguLi5vcHRpb25zLmxhbmdzIHx8IFtdKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZTI7XG59XG5jb25zdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZShjcmVhdGVIaWdobGlnaHRlckNvcmUpO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJDb3JlKG9wdGlvbnMpIHtcbiAgd2FybkRlcHJlY2F0ZWQoXCJgZ2V0SGlnaGxpZ2h0ZXJDb3JlYCBpcyBkZXByZWNhdGVkLiBVc2UgYGNyZWF0ZUhpZ2hsaWdodGVyQ29yZWAgb3IgYGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZWAgaW5zdGVhZC5cIik7XG4gIHJldHVybiBjcmVhdGVIaWdobGlnaHRlckNvcmUob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZWRCdW5kbGVkSGlnaGxpZ2h0ZXIoYXJnMSwgYXJnMiwgYXJnMykge1xuICBsZXQgYnVuZGxlZExhbmd1YWdlcztcbiAgbGV0IGJ1bmRsZWRUaGVtZXM7XG4gIGxldCBlbmdpbmU7XG4gIGlmIChhcmcyKSB7XG4gICAgd2FybkRlcHJlY2F0ZWQoXCJgY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlcmAgc2lnbmF0dXJlIHdpdGggYGJ1bmRsZWRMYW5ndWFnZXNgIGFuZCBgYnVuZGxlZFRoZW1lc2AgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBvcHRpb25zIG9iamVjdCBzaWduYXR1cmUgaW5zdGVhZC5cIik7XG4gICAgYnVuZGxlZExhbmd1YWdlcyA9IGFyZzE7XG4gICAgYnVuZGxlZFRoZW1lcyA9IGFyZzI7XG4gICAgZW5naW5lID0gKCkgPT4gY3JlYXRlT25pZ3VydW1hRW5naW5lKGFyZzMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmcxO1xuICAgIGJ1bmRsZWRMYW5ndWFnZXMgPSBvcHRpb25zLmxhbmdzO1xuICAgIGJ1bmRsZWRUaGVtZXMgPSBvcHRpb25zLnRoZW1lcztcbiAgICBlbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRlcihvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUxhbmcobGFuZykge1xuICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpc1NwZWNpYWxMYW5nKGxhbmcpKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYnVuZGxlZExhbmd1YWdlc1tsYW5nXTtcbiAgICAgICAgaWYgKCFidW5kbGUpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgTGFuZ3VhZ2UgXFxgJHtsYW5nfVxcYCBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBidW5kbGUuIFlvdSBtYXkgd2FudCB0byBsb2FkIGl0IGZyb20gZXh0ZXJuYWwgc291cmNlLmApO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVUaGVtZSh0aGVtZSkge1xuICAgICAgaWYgKGlzU3BlY2lhbFRoZW1lKHRoZW1lKSlcbiAgICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBidW5kbGVkVGhlbWVzW3RoZW1lXTtcbiAgICAgICAgaWYgKCFidW5kbGUpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgVGhlbWUgXFxgJHt0aGVtZX1cXGAgaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYnVuZGxlLiBZb3UgbWF5IHdhbnQgdG8gbG9hZCBpdCBmcm9tIGV4dGVybmFsIHNvdXJjZS5gKTtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9XG4gICAgY29uc3QgX3RoZW1lcyA9IChvcHRpb25zLnRoZW1lcyA/PyBbXSkubWFwKChpKSA9PiByZXNvbHZlVGhlbWUoaSkpO1xuICAgIGNvbnN0IGxhbmdzID0gKG9wdGlvbnMubGFuZ3MgPz8gW10pLm1hcCgoaSkgPT4gcmVzb2x2ZUxhbmcoaSkpO1xuICAgIGNvbnN0IGNvcmUgPSBhd2FpdCBjcmVhdGVIaWdobGlnaHRlckNvcmUoe1xuICAgICAgZW5naW5lOiBvcHRpb25zLmVuZ2luZSA/PyBlbmdpbmUoKSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0aGVtZXM6IF90aGVtZXMsXG4gICAgICBsYW5nc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb3JlLFxuICAgICAgbG9hZExhbmd1YWdlKC4uLmxhbmdzMikge1xuICAgICAgICByZXR1cm4gY29yZS5sb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MyLm1hcChyZXNvbHZlTGFuZykpO1xuICAgICAgfSxcbiAgICAgIGxvYWRUaGVtZSguLi50aGVtZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUubG9hZFRoZW1lKC4uLnRoZW1lcy5tYXAocmVzb2x2ZVRoZW1lKSk7XG4gICAgICB9LFxuICAgICAgZ2V0QnVuZGxlZExhbmd1YWdlcygpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZWRMYW5ndWFnZXM7XG4gICAgICB9LFxuICAgICAgZ2V0QnVuZGxlZFRoZW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZWRUaGVtZXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlSGlnaGxpZ2h0ZXI7XG59XG5mdW5jdGlvbiBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXIoY3JlYXRlSGlnaGxpZ2h0ZXIpIHtcbiAgbGV0IF9zaGlraTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFfc2hpa2kpIHtcbiAgICAgIF9zaGlraSA9IGNyZWF0ZUhpZ2hsaWdodGVyKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdGhlbWVzOiBvcHRpb25zLnRoZW1lcyB8fCBbXSxcbiAgICAgICAgbGFuZ3M6IG9wdGlvbnMubGFuZ3MgfHwgW11cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9zaGlraTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IGF3YWl0IF9zaGlraTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgcy5sb2FkVGhlbWUoLi4ub3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgICAgICBzLmxvYWRMYW5ndWFnZSguLi5vcHRpb25zLmxhbmdzIHx8IFtdKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uU2hvcnRoYW5kcyhjcmVhdGVIaWdobGlnaHRlciwgY29uZmlnKSB7XG4gIGNvbnN0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyID0gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyKGNyZWF0ZUhpZ2hsaWdodGVyKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KGNvZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKHtcbiAgICAgIGxhbmdzOiBbb3B0aW9ucy5sYW5nXSxcbiAgICAgIHRoZW1lczogXCJ0aGVtZVwiIGluIG9wdGlvbnMgPyBbb3B0aW9ucy50aGVtZV0gOiBPYmplY3QudmFsdWVzKG9wdGlvbnMudGhlbWVzKVxuICAgIH0pO1xuICAgIGNvbnN0IGxhbmdzID0gYXdhaXQgY29uZmlnPy5ndWVzc0VtYmVkZGVkTGFuZ3VhZ2VzPy4oY29kZSwgb3B0aW9ucy5sYW5nLCBzaGlraSk7XG4gICAgaWYgKGxhbmdzKSB7XG4gICAgICBhd2FpdCBzaGlraS5sb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gc2hpa2k7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIob3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9IdG1sKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb0h0bWwoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9IYXN0KGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb0hhc3QoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9Ub2tlbnMoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zQmFzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9Ub2tlbnNCYXNlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0TGFzdEdyYW1tYXJTdGF0ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKHtcbiAgICAgICAgbGFuZ3M6IFtvcHRpb25zLmxhbmddLFxuICAgICAgICB0aGVtZXM6IFtvcHRpb25zLnRoZW1lXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hpa2kuZ2V0TGFzdEdyYW1tYXJTdGF0ZShjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZShvcHRpb25zKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiaW1wb3J0IGBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmVgIGZyb20gYEBzaGlraWpzL2VuZ2luZS1qYXZhc2NyaXB0YCBvciBgc2hpa2kvZW5naW5lL2phdmFzY3JpcHRgIGluc3RlYWRcIik7XG4gIHJldHVybiBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmUkMShvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiaW1wb3J0IGBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3JgIGZyb20gYEBzaGlraWpzL2VuZ2luZS1qYXZhc2NyaXB0YCBvciBgc2hpa2kvZW5naW5lL2phdmFzY3JpcHRgIGluc3RlYWRcIik7XG4gIHJldHVybiBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IkMShwYXR0ZXJuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3NzVmFyaWFibGVzVGhlbWUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJjc3MtdmFyaWFibGVzXCIsXG4gICAgdmFyaWFibGVQcmVmaXggPSBcIi0tc2hpa2ktXCIsXG4gICAgZm9udFN0eWxlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdmFyaWFibGUgPSAobmFtZTIpID0+IHtcbiAgICBpZiAob3B0aW9ucy52YXJpYWJsZURlZmF1bHRzPy5bbmFtZTJdKVxuICAgICAgcmV0dXJuIGB2YXIoJHt2YXJpYWJsZVByZWZpeH0ke25hbWUyfSwgJHtvcHRpb25zLnZhcmlhYmxlRGVmYXVsdHNbbmFtZTJdfSlgO1xuICAgIHJldHVybiBgdmFyKCR7dmFyaWFibGVQcmVmaXh9JHtuYW1lMn0pYDtcbiAgfTtcbiAgY29uc3QgdGhlbWUgPSB7XG4gICAgbmFtZSxcbiAgICB0eXBlOiBcImRhcmtcIixcbiAgICBjb2xvcnM6IHtcbiAgICAgIFwiZWRpdG9yLmZvcmVncm91bmRcIjogdmFyaWFibGUoXCJmb3JlZ3JvdW5kXCIpLFxuICAgICAgXCJlZGl0b3IuYmFja2dyb3VuZFwiOiB2YXJpYWJsZShcImJhY2tncm91bmRcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCbGFja1wiOiB2YXJpYWJsZShcImFuc2ktYmxhY2tcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lSZWRcIjogdmFyaWFibGUoXCJhbnNpLXJlZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUdyZWVuXCI6IHZhcmlhYmxlKFwiYW5zaS1ncmVlblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaVllbGxvd1wiOiB2YXJpYWJsZShcImFuc2kteWVsbG93XCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQmx1ZVwiOiB2YXJpYWJsZShcImFuc2ktYmx1ZVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaU1hZ2VudGFcIjogdmFyaWFibGUoXCJhbnNpLW1hZ2VudGFcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lDeWFuXCI6IHZhcmlhYmxlKFwiYW5zaS1jeWFuXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpV2hpdGVcIjogdmFyaWFibGUoXCJhbnNpLXdoaXRlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0QmxhY2tcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ibGFja1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFJlZFwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXJlZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodEdyZWVuXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtZ3JlZW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRZZWxsb3dcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC15ZWxsb3dcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRCbHVlXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtYmx1ZVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodE1hZ2VudGFcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1tYWdlbnRhXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0Q3lhblwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LWN5YW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRXaGl0ZVwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXdoaXRlXCIpXG4gICAgfSxcbiAgICB0b2tlbkNvbG9yczogW1xuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwia2V5d29yZC5vcGVyYXRvci5hY2Nlc3NvclwiLFxuICAgICAgICAgIFwibWV0YS5ncm91cC5icmFjZXMucm91bmQuZnVuY3Rpb24uYXJndW1lbnRzXCIsXG4gICAgICAgICAgXCJtZXRhLnRlbXBsYXRlLmV4cHJlc3Npb25cIixcbiAgICAgICAgICBcIm1hcmt1cC5mZW5jZWRfY29kZSBtZXRhLmVtYmVkZGVkLmJsb2NrXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcImZvcmVncm91bmRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFwiZW1waGFzaXNcIixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcInN0cm9uZ1wiLCBcIm1hcmt1cC5oZWFkaW5nLm1hcmtkb3duXCIsIFwibWFya3VwLmJvbGQubWFya2Rvd25cIl0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9udFN0eWxlOiBcImJvbGRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wibWFya3VwLml0YWxpYy5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFwibWV0YS5saW5rLmlubGluZS5tYXJrZG93blwiLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWxpbmtcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcInN0cmluZ1wiLCBcIm1hcmt1cC5mZW5jZWRfY29kZVwiLCBcIm1hcmt1cC5pbmxpbmVcIl0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1zdHJpbmdcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcImNvbW1lbnRcIiwgXCJzdHJpbmcucXVvdGVkLmRvY3N0cmluZy5tdWx0aVwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWNvbW1lbnRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImNvbnN0YW50Lm51bWVyaWNcIixcbiAgICAgICAgICBcImNvbnN0YW50Lmxhbmd1YWdlXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5vdGhlci5wbGFjZWhvbGRlclwiLFxuICAgICAgICAgIFwiY29uc3RhbnQuY2hhcmFjdGVyLmZvcm1hdC5wbGFjZWhvbGRlclwiLFxuICAgICAgICAgIFwidmFyaWFibGUubGFuZ3VhZ2UudGhpc1wiLFxuICAgICAgICAgIFwidmFyaWFibGUub3RoZXIub2JqZWN0XCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5jbGFzc1wiLFxuICAgICAgICAgIFwidmFyaWFibGUub3RoZXIuY29uc3RhbnRcIixcbiAgICAgICAgICBcIm1ldGEucHJvcGVydHktbmFtZVwiLFxuICAgICAgICAgIFwibWV0YS5wcm9wZXJ0eS12YWx1ZVwiLFxuICAgICAgICAgIFwic3VwcG9ydFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1jb25zdGFudFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwia2V5d29yZFwiLFxuICAgICAgICAgIFwic3RvcmFnZS5tb2RpZmllclwiLFxuICAgICAgICAgIFwic3RvcmFnZS50eXBlXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLmNvbnRyb2wuY2xvanVyZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUuZnVuY3Rpb24uY2xvanVyZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUudGFnLnlhbWxcIixcbiAgICAgICAgICBcInN1cHBvcnQuZnVuY3Rpb24ubm9kZVwiLFxuICAgICAgICAgIFwic3VwcG9ydC50eXBlLnByb3BlcnR5LW5hbWUuanNvblwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uc2VwYXJhdG9yLmtleS12YWx1ZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi50ZW1wbGF0ZS1leHByZXNzaW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWtleXdvcmRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFwidmFyaWFibGUucGFyYW1ldGVyLmZ1bmN0aW9uXCIsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1wYXJhbWV0ZXJcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcInN1cHBvcnQuZnVuY3Rpb25cIixcbiAgICAgICAgICBcImVudGl0eS5uYW1lLnR5cGVcIixcbiAgICAgICAgICBcImVudGl0eS5vdGhlci5pbmhlcml0ZWQtY2xhc3NcIixcbiAgICAgICAgICBcIm1ldGEuZnVuY3Rpb24tY2FsbFwiLFxuICAgICAgICAgIFwibWV0YS5pbnN0YW5jZS5jb25zdHJ1Y3RvclwiLFxuICAgICAgICAgIFwiZW50aXR5Lm90aGVyLmF0dHJpYnV0ZS1uYW1lXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS5mdW5jdGlvblwiLFxuICAgICAgICAgIFwiY29uc3RhbnQua2V5d29yZC5jbG9qdXJlXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWZ1bmN0aW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS50YWdcIixcbiAgICAgICAgICBcInN0cmluZy5xdW90ZWRcIixcbiAgICAgICAgICBcInN0cmluZy5yZWdleHBcIixcbiAgICAgICAgICBcInN0cmluZy5pbnRlcnBvbGF0ZWRcIixcbiAgICAgICAgICBcInN0cmluZy50ZW1wbGF0ZVwiLFxuICAgICAgICAgIFwic3RyaW5nLnVucXVvdGVkLnBsYWluLm91dC55YW1sXCIsXG4gICAgICAgICAgXCJrZXl3b3JkLm90aGVyLnRlbXBsYXRlXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZy1leHByZXNzaW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmFyZ3VtZW50c1wiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5kaWN0XCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5zZXBhcmF0b3JcIixcbiAgICAgICAgICBcIm1ldGEuZnVuY3Rpb24tY2FsbC5hcmd1bWVudHNcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tcHVuY3R1YXRpb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gbGlua3NcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcIm1hcmt1cC51bmRlcmxpbmUubGlua1wiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5tZXRhZGF0YS5tYXJrZG93blwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1saW5rXCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIFtDdXN0b21dIE1hcmtkb3duIGxpc3RcbiAgICAgICAgc2NvcGU6IFtcImJlZ2lubmluZy5wdW5jdHVhdGlvbi5kZWZpbml0aW9uLmxpc3QubWFya2Rvd25cIl0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1zdHJpbmdcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gcHVuY3R1YXRpb24gZGVmaW5pdGlvbiBicmFja2V0c1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuYmVnaW4ubWFya2Rvd25cIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uc3RyaW5nLmVuZC5tYXJrZG93blwiLFxuICAgICAgICAgIFwic3RyaW5nLm90aGVyLmxpbmsudGl0bGUubWFya2Rvd25cIixcbiAgICAgICAgICBcInN0cmluZy5vdGhlci5saW5rLmRlc2NyaXB0aW9uLm1hcmtkb3duXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWtleXdvcmRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gRGlmZlxuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmluc2VydGVkXCIsXG4gICAgICAgICAgXCJtZXRhLmRpZmYuaGVhZGVyLnRvLWZpbGVcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uaW5zZXJ0ZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4taW5zZXJ0ZWRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcIm1hcmt1cC5kZWxldGVkXCIsXG4gICAgICAgICAgXCJtZXRhLmRpZmYuaGVhZGVyLmZyb20tZmlsZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5kZWxldGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWRlbGV0ZWRcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcIm1hcmt1cC5jaGFuZ2VkXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmNoYW5nZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tY2hhbmdlZFwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xuICBpZiAoIWZvbnRTdHlsZSkge1xuICAgIHRoZW1lLnRva2VuQ29sb3JzID0gdGhlbWUudG9rZW5Db2xvcnM/Lm1hcCgodG9rZW5Db2xvcikgPT4ge1xuICAgICAgaWYgKHRva2VuQ29sb3Iuc2V0dGluZ3M/LmZvbnRTdHlsZSlcbiAgICAgICAgZGVsZXRlIHRva2VuQ29sb3Iuc2V0dGluZ3MuZm9udFN0eWxlO1xuICAgICAgcmV0dXJuIHRva2VuQ29sb3I7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoZW1lO1xufVxuXG5leHBvcnQgeyBhZGRDbGFzc1RvSGFzdCwgYXBwbHlDb2xvclJlcGxhY2VtZW50cywgY29kZVRvSGFzdCwgY29kZVRvSHRtbCwgY29kZVRvVG9rZW5zLCBjb2RlVG9Ub2tlbnNCYXNlLCBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzLCBjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZSwgY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlLCBjcmVhdGVIaWdobGlnaHRlckNvcmVTeW5jLCBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmUsIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSwgY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIsIGNyZWF0ZVNoaWtpSW50ZXJuYWwsIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jLCBjcmVhdGVTaW5nbGV0b25TaG9ydGhhbmRzLCBjcmVhdGVXYXNtT25pZ0VuZ2luZSwgY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlciwgZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yLCBmbGF0VG9rZW5WYXJpYW50cywgZ2V0SGlnaGxpZ2h0ZXJDb3JlLCBnZXRTaGlraUludGVybmFsLCBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUsIGdldFRva2VuU3R5bGVPYmplY3QsIGd1ZXNzRW1iZWRkZWRMYW5ndWFnZXMsIGlzTm9uZVRoZW1lLCBpc1BsYWluTGFuZywgaXNTcGVjaWFsTGFuZywgaXNTcGVjaWFsVGhlbWUsIGxvYWRXYXNtLCBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXIsIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlckNvcmUsIG5vcm1hbGl6ZUdldHRlciwgbm9ybWFsaXplVGhlbWUsIHJlc29sdmVDb2xvclJlcGxhY2VtZW50cywgc3BsaXRMaW5lcywgc3BsaXRUb2tlbiwgc3BsaXRUb2tlbnMsIHN0cmluZ2lmeVRva2VuU3R5bGUsIHRvQXJyYXksIHRva2VuaXplQW5zaVdpdGhUaGVtZSwgdG9rZW5pemVXaXRoVGhlbWUsIHRva2Vuc1RvSGFzdCwgdHJhbnNmb3JtZXJEZWNvcmF0aW9ucywgd2FybkRlcHJlY2F0ZWQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ enableDeprecationWarnings),\n/* harmony export */   w: () => (/* binding */ warnDeprecated)\n/* harmony export */ });\nlet _emitDeprecation = 3;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n  _emitDeprecation = emitDeprecation;\n  _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n  if (!_emitDeprecation)\n    return;\n  if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation)\n    return;\n  if (_emitError) {\n    throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n  } else {\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMi41LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9zaGFyZWQvY29yZS41aHYwTGF3OS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCxJQUFJO0FBQ0osd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTs7QUFFK0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldGhhbmtpbS9OZXN0b3IvbWVkZmV0Y2guanMvbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMi41LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9zaGFyZWQvY29yZS41aHYwTGF3OS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IF9lbWl0RGVwcmVjYXRpb24gPSAzO1xubGV0IF9lbWl0RXJyb3IgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoZW1pdERlcHJlY2F0aW9uID0gdHJ1ZSwgZW1pdEVycm9yID0gZmFsc2UpIHtcbiAgX2VtaXREZXByZWNhdGlvbiA9IGVtaXREZXByZWNhdGlvbjtcbiAgX2VtaXRFcnJvciA9IGVtaXRFcnJvcjtcbn1cbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkKG1lc3NhZ2UsIHZlcnNpb24gPSAzKSB7XG4gIGlmICghX2VtaXREZXByZWNhdGlvbilcbiAgICByZXR1cm47XG4gIGlmICh0eXBlb2YgX2VtaXREZXByZWNhdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB2ZXJzaW9uID4gX2VtaXREZXByZWNhdGlvbilcbiAgICByZXR1cm47XG4gIGlmIChfZW1pdEVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbU0hJS0kgREVQUkVDQVRFXTogJHttZXNzYWdlfWApO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUudHJhY2UoYFtTSElLSSBERVBSRUNBVEVdOiAke21lc3NhZ2V9YCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZW5hYmxlRGVwcmVjYXRpb25XYXJuaW5ncyBhcyBlLCB3YXJuRGVwcmVjYXRlZCBhcyB3IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs\n");

/***/ })

};
;