{
  "version": 3,
  "sources": ["../../../../../../node_modules/.pnpm/emitter-component@1.1.2/node_modules/emitter-component/index.js", "../../../../../../node_modules/.pnpm/stream@0.0.2/node_modules/stream/index.js", "../../../../../../node_modules/.pnpm/clarinet@0.12.6/node_modules/clarinet/clarinet.js"],
  "sourcesContent": ["\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Emitter = require('emitter');\n\nfunction Stream() {\n  Emitter.call(this);\n}\nStream.prototype = new Emitter();\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (!this.hasListeners('error')) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.off('data', ondata);\n    dest.off('drain', ondrain);\n\n    source.off('end', onend);\n    source.off('close', onclose);\n\n    source.off('error', onerror);\n    dest.off('error', onerror);\n\n    source.off('end', cleanup);\n    source.off('close', cleanup);\n\n    dest.off('end', cleanup);\n    dest.off('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n}\n", ";(function (clarinet) {\n  \"use strict\";\n\n  // non node-js needs to set clarinet debug on root\n  var env =(typeof process === 'object' && process.env)\n    ? process.env\n    : self;\n\n  clarinet.parser            = function (opt) { return new CParser(opt);};\n  clarinet.CParser           = CParser;\n  clarinet.CStream           = CStream;\n  clarinet.createStream      = createStream;\n  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;\n  clarinet.DEBUG             = (env.CDEBUG==='debug');\n  clarinet.INFO              = (env.CDEBUG==='debug' || env.CDEBUG==='info');\n  clarinet.EVENTS            =\n    [ \"value\"\n    , \"string\"\n    , \"key\"\n    , \"openobject\"\n    , \"closeobject\"\n    , \"openarray\"\n    , \"closearray\"\n    , \"error\"\n    , \"end\"\n    , \"ready\"\n    ];\n\n  var buffers     = {\n        textNode: undefined,\n        numberNode: \"\"\n    }\n    , streamWraps = clarinet.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n        })\n    , S           = 0\n    , Stream\n    ;\n\n  clarinet.STATE =\n    { BEGIN                             : S++\n    , VALUE                             : S++ // general stuff\n    , OPEN_OBJECT                       : S++ // {\n    , CLOSE_OBJECT                      : S++ // }\n    , OPEN_ARRAY                        : S++ // [\n    , CLOSE_ARRAY                       : S++ // ]\n    , TEXT_ESCAPE                       : S++ // \\ stuff\n    , STRING                            : S++ // \"\"\n    , BACKSLASH                         : S++\n    , END                               : S++ // No more stack\n    , OPEN_KEY                          : S++ // , \"a\"\n    , CLOSE_KEY                         : S++ // :\n    , TRUE                              : S++ // r\n    , TRUE2                             : S++ // u\n    , TRUE3                             : S++ // e\n    , FALSE                             : S++ // a\n    , FALSE2                            : S++ // l\n    , FALSE3                            : S++ // s\n    , FALSE4                            : S++ // e\n    , NULL                              : S++ // u\n    , NULL2                             : S++ // l\n    , NULL3                             : S++ // l\n    , NUMBER_DECIMAL_POINT              : S++ // .\n    , NUMBER_DIGIT                      : S++ // [0-9]\n    };\n\n  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;\n\n  // switcharoo\n  S = clarinet.STATE;\n\n  const Char = {\n    tab                 : 0x09,     // \\t\n    lineFeed            : 0x0A,     // \\n\n    carriageReturn      : 0x0D,     // \\r\n    space               : 0x20,     // \" \"\n\n    doubleQuote         : 0x22,     // \"\n    plus                : 0x2B,     // +\n    comma               : 0x2C,     // ,\n    minus               : 0x2D,     // -\n    period              : 0x2E,     // .\n\n    _0                  : 0x30,     // 0\n    _9                  : 0x39,     // 9\n\n    colon               : 0x3A,     // :\n\n    E                   : 0x45,     // E\n\n    openBracket         : 0x5B,     // [\n    backslash           : 0x5C,     // \\\n    closeBracket        : 0x5D,     // ]\n\n    a                   : 0x61,     // a\n    b                   : 0x62,     // b\n    e                   : 0x65,     // e \n    f                   : 0x66,     // f\n    l                   : 0x6C,     // l\n    n                   : 0x6E,     // n\n    r                   : 0x72,     // r\n    s                   : 0x73,     // s\n    t                   : 0x74,     // t\n    u                   : 0x75,     // u\n\n    openBrace           : 0x7B,     // {\n    closeBrace          : 0x7D,     // }\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function f () { this[\"__proto__\"] = o; }\n      f.prototype = o;\n      return new f;\n    };\n  }\n\n  if (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function (o) {\n      return o[\"__proto__\"];\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)\n      , maxActual = 0\n      ;\n    for (var buffer in buffers) {\n      var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n      if (len > maxAllowed) {\n        switch (buffer) {\n          case \"text\":\n            closeText(parser);\n          break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \"+ buffer);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)\n                               + parser.position;\n  }\n\n  function clearBuffers (parser) {\n    for (var buffer in buffers) {\n      parser[buffer] = buffers[buffer];\n    }\n  }\n\n  var stringTokenPattern = /[\\\\\"\\n]/g;\n\n  function CParser (opt) {\n    if (!(this instanceof CParser)) return new CParser (opt);\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n    parser.q        = parser.c = parser.p = \"\";\n    parser.opt      = opt || {};\n    parser.closed   = parser.closedRoot = parser.sawRoot = false;\n    parser.tag      = parser.error = null;\n    parser.state    = S.BEGIN;\n    parser.stack    = new Array();\n    // mostly just for error reporting\n    parser.position = parser.column = 0;\n    parser.line     = 1;\n    parser.slashed  = false;\n    parser.unicodeI = 0;\n    parser.unicodeS = null;\n    parser.depth    = 0;\n    emit(parser, \"onready\");\n  }\n\n  CParser.prototype =\n    { end    : function () { end(this); }\n    , write  : write\n    , resume : function () { this.error = null; return this; }\n    , close  : function () { return this.write(null); }\n    };\n\n  try        { Stream = require(\"stream\").Stream; }\n  catch (ex) { Stream = function () {}; }\n\n  function createStream (opt) { return new CStream(opt); }\n\n  function CStream (opt) {\n    if (!(this instanceof CStream)) return new CStream(opt);\n\n    this._parser = new CParser(opt);\n    this.writable = true;\n    this.readable = true;\n\n    //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n    this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n    this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n    this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n    this.string = '';\n\n    var me = this;\n    Stream.apply(me);\n\n    this._parser.onend = function () { me.emit(\"end\"); };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev,\n        { get          : function () { return me._parser[\"on\" + ev]; }\n        , set          : function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\"+ev] = h;\n              return h;\n            }\n            me.on(ev, h);\n          }\n        , enumerable   : true\n        , configurable : false\n        });\n    });\n  }\n\n  CStream.prototype = Object.create(Stream.prototype,\n    { constructor: { value: CStream } });\n\n  CStream.prototype.write = function (data) {\n    data = new Buffer(data);\n    for (var i = 0; i < data.length; i++) {\n      var n = data[i];\n\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n        }\n        this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n\n        // move iterator forward by number of byte read during sequencing\n        i = i + j - 1;\n\n        // pass data to parser and move forward to parse rest of data\n        this._parser.write(this.string);\n        this.emit(\"data\", this.string);\n        continue;\n      }\n\n      // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n      if (this.bytes_remaining === 0 && n >= 128) {\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > data.length) { // if bytes needed to complete char fall outside data length, we have a boundary split\n\n          for (var k = 0; k <= (data.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;\n\n          // immediately return as we need another chunk to sequence the character\n          return true;\n        } else {\n          this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n\n          this._parser.write(this.string);\n          this.emit(\"data\", this.string);\n          continue;\n        }\n      }\n\n      // is there a range of characters that are immediately parsable?\n      for (var p = i; p < data.length; p++) {\n        if (data[p] >= 128) break;\n      }\n      this.string = data.slice(i, p).toString();\n      this._parser.write(this.string);\n      this.emit(\"data\", this.string);\n      i = p - 1;\n\n      // handle any remaining characters using multibyte logic\n      continue;\n    }\n  };\n\n  CStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n    this._parser.end();\n    return true;\n  };\n\n  CStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\"+ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]]\n                 : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  CStream.prototype.destroy = function () {\n    clearBuffers(this._parser);\n    this.emit(\"close\");\n  };\n\n  function emit(parser, event, data) {\n    if(clarinet.INFO) console.log('-- emit', event, data);\n    if (parser[event]) parser[event](data);\n  }\n\n  function emitNode(parser, event, data) {\n    closeValue(parser);\n    emit(parser, event, data);\n  }\n\n  function closeValue(parser, event) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode !== undefined) {\n      emit(parser, (event ? event : \"onvalue\"), parser.textNode);\n    }\n    parser.textNode = undefined;\n  }\n\n  function closeNumber(parser) {\n    if (parser.numberNode)\n      emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n    parser.numberNode = \"\";\n  }\n\n  function textopts (opt, text) {\n    if (text === undefined) {\n      return text;\n    }\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error (parser, er) {\n    closeValue(parser);\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.VALUE || parser.depth !== 0)\n      error(parser, \"Unexpected end\");\n\n    closeValue(parser);\n    parser.c      = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    CParser.call(parser, parser.opt);\n    return parser;\n  }\n\n  function isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n  }\n\n  function write (chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser,\n      \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0, c = chunk.charCodeAt(0), p = parser.p;\n    var lockIncrements = false;\n    if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n    while (c) {\n      p = c;\n      parser.c = c = chunk.charCodeAt(i++);\n      // if chunk doesnt have next, like streaming char by char\n      // this way we need to check if previous is really previous\n      // if not we need to reset to what the parser says is the previous\n      // from buffer\n      if(p !== c ) parser.p = p;\n      else p = parser.p;\n\n      if(!c) break;\n\n      if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);\n      if (!lockIncrements) {\n        parser.position ++;\n        if (c === Char.lineFeed) {\n          parser.line ++;\n          parser.column = 0;\n        } else parser.column ++;\n      } else {\n        lockIncrements = false;\n      }\n      switch (parser.state) {\n\n        case S.BEGIN:\n          if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if (!isWhitespace(c))\n            error(parser, \"Non-whitespace before {[.\");\n        continue;\n\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (isWhitespace(c)) continue;\n          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);\n          else {\n            if(c === Char.closeBrace) {\n              emit(parser, 'onopenobject');\n              this.depth++;\n              emit(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else  parser.stack.push(S.CLOSE_OBJECT);\n          }\n          if(c === Char.doubleQuote) parser.state = S.STRING;\n          else error(parser, \"Malformed object key should start with \\\"\");\n        continue;\n\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (isWhitespace(c)) continue;\n          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';\n          if(c === Char.colon) {\n            if(parser.state === S.CLOSE_OBJECT) {\n              parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser, 'onopenobject');\n               this.depth++;\n            } else closeValue(parser, 'onkey');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBrace) {\n            emitNode(parser, 'oncloseobject');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if(c === Char.comma) {\n            if(parser.state === S.CLOSE_OBJECT)\n              parser.stack.push(S.CLOSE_OBJECT);\n            closeValue(parser);\n            parser.state  = S.OPEN_KEY;\n          } else error(parser, 'Bad object');\n        continue;\n\n        case S.OPEN_ARRAY: // after an array there always a value\n        case S.VALUE:\n          if (isWhitespace(c)) continue;\n          if(parser.state===S.OPEN_ARRAY) {\n            emit(parser, 'onopenarray');\n            this.depth++;\n            parser.state = S.VALUE;\n            if(c === Char.closeBracket) {\n              emit(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else {\n              parser.stack.push(S.CLOSE_ARRAY);\n            }\n          }\n               if(c === Char.doubleQuote) parser.state = S.STRING;\n          else if(c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if(c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if(c === Char.t) parser.state = S.TRUE;\n          else if(c === Char.f) parser.state = S.FALSE;\n          else if(c === Char.n) parser.state = S.NULL;\n          else if(c === Char.minus) { // keep and continue\n            parser.numberNode += \"-\";\n          } else if(Char._0 <= c && c <= Char._9) {\n            parser.numberNode += String.fromCharCode(c);\n            parser.state = S.NUMBER_DIGIT;\n          } else               error(parser, \"Bad value\");\n        continue;\n\n        case S.CLOSE_ARRAY:\n          if(c === Char.comma) {\n            parser.stack.push(S.CLOSE_ARRAY);\n            closeValue(parser, 'onvalue');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBracket) {\n            emitNode(parser, 'onclosearray');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if (isWhitespace(c))\n              continue;\n          else error(parser, 'Bad array');\n        continue;\n\n        case S.STRING:\n          if (parser.textNode === undefined) {\n            parser.textNode = \"\";\n          }\n\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1\n            , slashed = parser.slashed\n            , unicodeI = parser.unicodeI\n            ;\n          STRING_BIGLOOP: while (true) {\n            if (clarinet.DEBUG)\n              console.log(i,c,clarinet.STATE[parser.state]\n                         ,slashed);\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              parser.unicodeS += String.fromCharCode(c);\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === Char.doubleQuote && !slashed) {\n              parser.state = parser.stack.pop() || S.VALUE;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            if (c === Char.backslash && !slashed) {\n              slashed = true;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === Char.n) { parser.textNode += '\\n'; }\n              else if (c === Char.r) { parser.textNode += '\\r'; }\n              else if (c === Char.t) { parser.textNode += '\\t'; }\n              else if (c === Char.f) { parser.textNode += '\\f'; }\n              else if (c === Char.b) { parser.textNode += '\\b'; }\n              else if (c === Char.u) {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                parser.unicodeS = '';\n              } else {\n                parser.textNode += String.fromCharCode(c);\n              }\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (reResult === null) {\n              i = chunk.length+1;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charCodeAt(reResult.index);\n            if (!c) {\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n          }\n          parser.slashed = slashed;\n          parser.unicodeI = unicodeI;\n        continue;\n\n        case S.TRUE:\n          if (c === Char.r) parser.state = S.TRUE2;\n          else error(parser, 'Invalid true started with t'+ c);\n        continue;\n\n        case S.TRUE2:\n          if (c === Char.u) parser.state = S.TRUE3;\n          else error(parser, 'Invalid true started with tr'+ c);\n        continue;\n\n        case S.TRUE3:\n          if(c === Char.e) {\n            emit(parser, \"onvalue\", true);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid true started with tru'+ c);\n        continue;\n\n        case S.FALSE:\n          if (c === Char.a) parser.state = S.FALSE2;\n          else error(parser, 'Invalid false started with f'+ c);\n        continue;\n\n        case S.FALSE2:\n          if (c === Char.l) parser.state = S.FALSE3;\n          else error(parser, 'Invalid false started with fa'+ c);\n        continue;\n\n        case S.FALSE3:\n          if (c === Char.s) parser.state = S.FALSE4;\n          else error(parser, 'Invalid false started with fal'+ c);\n        continue;\n\n        case S.FALSE4:\n          if (c === Char.e) {\n            emit(parser, \"onvalue\", false);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid false started with fals'+ c);\n        continue;\n\n        case S.NULL:\n          if (c === Char.u) parser.state = S.NULL2;\n          else error(parser, 'Invalid null started with n'+ c);\n        continue;\n\n        case S.NULL2:\n          if (c === Char.l) parser.state = S.NULL3;\n          else error(parser, 'Invalid null started with nu'+ c);\n        continue;\n\n        case S.NULL3:\n          if(c === Char.l) {\n            emit(parser, \"onvalue\", null);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid null started with nul'+ c);\n        continue;\n\n        case S.NUMBER_DECIMAL_POINT:\n          if(c === Char.period) {\n            parser.numberNode += \".\";\n            parser.state       = S.NUMBER_DIGIT;\n          } else error(parser, 'Leading zero not followed by .');\n        continue;\n\n        case S.NUMBER_DIGIT:\n          if(Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);\n          else if (c === Char.period) {\n            if(parser.numberNode.indexOf('.')!==-1)\n              error(parser, 'Invalid number has two dots');\n            parser.numberNode += \".\";\n          } else if (c === Char.e || c === Char.E) {\n            if(parser.numberNode.indexOf('e')!==-1 ||\n               parser.numberNode.indexOf('E')!==-1 )\n               error(parser, 'Invalid number has two exponential');\n            parser.numberNode += \"e\";\n          } else if (c === Char.plus || c === Char.minus) {\n            if(!(p === Char.e || p === Char.E))\n              error(parser, 'Invalid symbol in number');\n            parser.numberNode += String.fromCharCode(c);\n          } else {\n            closeNumber(parser);\n            i--; // go back one\n            lockIncrements = true; // do not apply increments for a single cycle\n            parser.state = parser.stack.pop() || S.VALUE;\n          }\n        continue;\n\n        default:\n          error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition)\n      checkBufferLength(parser);\n    return parser;\n  }\n\n})(typeof exports === \"undefined\" ? clarinet = {} : exports);\n"],
  "mappings": "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",
  "names": ["self", "clarinet"]
}
